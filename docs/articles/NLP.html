<!DOCTYPE html>
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>NLPに関する論文・技術記事メモの一覧 | わたしのべんきょうノート</title>
<meta name="generator" content="Jekyll v4.3.2">
<meta property="og:title" content="NLPに関する論文・技術記事メモの一覧">
<meta name="author" content="AkihikoWATANABE">
<meta property="og:locale" content="ja">
<meta name="description" content="NLP">
<meta property="og:description" content="NLP">
<link rel="canonical" href="http://akihikowatanabe.github.io/paper_notes/articles/NLP.html">
<meta property="og:url" content="http://akihikowatanabe.github.io/paper_notes/articles/NLP.html">
<meta property="og:site_name" content="わたしのべんきょうノート">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2025-08-29T00:45:37+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="NLPに関する論文・技術記事メモの一覧">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"AkihikoWATANABE"},"dateModified":"2025-08-29T00:45:37+00:00","datePublished":"2025-08-29T00:45:37+00:00","description":"NLP","headline":"NLPに関する論文・技術記事メモの一覧","mainEntityOfPage":{"@type":"WebPage","@id":"http://akihikowatanabe.github.io/paper_notes/articles/NLP.html"},"url":"http://akihikowatanabe.github.io/paper_notes/articles/NLP.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="icon" href="">
  <link rel="canonical" href="http://akihikowatanabe.github.io">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/paper_notes/assets/css/main.css">
  <link rel="stylesheet" href="/paper_notes/assets/css/custom_button.css">
  <script src="/paper_notes/assets/js/main.js"></script>
  <script src="https://d3js.org/d3.v5.min.js"></script><link type="application/atom+xml" rel="alternate" href="http://akihikowatanabe.github.io/paper_notes/feed.xml" title="わたしのべんきょうノート">
<script>
  function showMore(index) {
    const contentDivs = document.getElementsByClassName('hidden-content');
    const contentDiv = contentDivs[index];

    if (contentDiv) {
      contentDiv.style.display = "block";
          
      // このボタンの参照を取得して非表示にします
      const moreButtons = document.querySelectorAll('button[onclick^="showMore"]');
      const moreButton = moreButtons[index];
      if (moreButton) {
        moreButton.style.display = "none";
      }
          
      // hideボタンの参照を取得して表示します
      const hideButton = contentDiv.querySelector('button[onclick^="hideContent"]');
      if (hideButton) {
        hideButton.style.display = "block";
      }
    }
  }

  function hideContent(index) {
    const contentDivs = document.getElementsByClassName('hidden-content');
    const contentDiv = contentDivs[index];

    if (contentDiv) {
      contentDiv.style.display = "none";
  
      // moreボタンの参照を取得して表示します
      const moreButtons = document.querySelectorAll('button[onclick^="showMore"]');
      const moreButton = moreButtons[index];
      if (moreButton) {
        moreButton.style.display = "block";
      }
  
      // このボタンを隠します
      const hideButtons = document.querySelectorAll('button[onclick^="hideContent"]');
      const hideButton = hideButtons[index];
      if (hideButton) {
        hideButton.style.display = "none";
      }
    }
  }
</script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js" async></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
<script src="//cdnjs.cloudflare.com/ajax/libs/photoswipe/5.3.7/umd/photoswipe-lightbox.umd.min.js" async></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/photoswipe/5.3.7/umd/photoswipe.umd.min.js" async></script>
<link href="//cdnjs.cloudflare.com/ajax/libs/photoswipe/5.3.7/photoswipe.min.css" rel="stylesheet">
<style>
  .pswp .pswp__container .pswp__img {
    background-color: white;
  }
</style>

<script>
  function initPhotoSwipe() {
    let customOptions = {};

    try {
      const data = `{"gallery"=>"section.main", "children"=>"a.photo-swipe", "bgOpacity"=>0.8, "padding"=>{"top"=>20, "bottom"=>40, "left"=>100, "right"=>100}}`.replaceAll("=>", ":");
      customOptions = JSON.parse(data);
    } catch (e) {
      console.info("Invalid custom photo previewer options! " + e.message);
    }

    // Define object and gallery options
    const options = Object.assign(
      {
        gallery: "section.main",
        children: "a.photo-swipe",
        photo_scale: 2,
        // dynamic import is not supported in UMD version
        pswpModule: PhotoSwipe,
      },
      customOptions
    );

    const galleryEl = document.querySelector(options.gallery);
    if (!galleryEl) {
      return;
    }

    const imgEls = [];
    const els = galleryEl.querySelectorAll("img:not(.emoji)");
    els.forEach((el) => {
      if (el.src.trim() == "") {
        return;
      }
      if (!imgEls.includes(el)) {
        imgEls.push(el);
      }
    });

    if (imgEls.length === 0) {
      return;
    }

    imgEls.forEach((imgEl) => {
      imgEl.outerHTML = `
      <a class="photo-swipe"
        href="${imgEl.src}"
        data-pswp-width="${
          Math.max(imgEl.naturalWidth, imgEl.width) * options.photo_scale
        }"
        data-pswp-height="${
          Math.max(imgEl.naturalHeight, imgEl.height) * options.photo_scale
        }"
        data-pswp-caption="${imgEl.getAttribute("caption") || imgEl.alt}"
        target="_blank">
        ${imgEl.outerHTML}
      </a>`;
    });

    // Initialize PhotoSwipe 5
    var lightbox = new PhotoSwipeLightbox(options);

    lightbox.init();
  }

  window.addEventListener("load", initPhotoSwipe);
</script>
<meta name="google-site-verification" content="u_DTTPcCZ806iq51zgirHyWq3556HUKGq8AQfH91iFI">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-P70KSB88WH"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-P70KSB88WH');
  </script>
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["$$","$$"],["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>





































































































































<header class="site-header site-header-transparent" role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/paper_notes/">
  <img class="site-favicon" title="わたしのべんきょうノート" src="" onerror="this.style.display='none'">
  わたしのべんきょうノート
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">









<span class="page-link">



<div id="google_translate_element" style="display: none;">
</div>

<span class="ct-language">
  <ul class="list-unstyled ct-language-dropdown">
    
      <li>
        <a href="#" class="lang-select" data-lang="en">
          
          <img src="https://cdn.countryflags.com/thumbs/united-states-of-america/flag-400.png" title="English">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="fr">
          
          <img src="https://cdn.countryflags.com/thumbs/france/flag-400.png" title="French">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="zh-CN">
          
          <img src="https://cdn.countryflags.com/thumbs/china/flag-400.png" title="Chinese(Simple)">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ja">
          
          <img src="https://cdn.countryflags.com/thumbs/japan/flag-400.png" title="Japanese">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ko">
          
          <img src="https://cdn.countryflags.com/thumbs/south-korea/flag-400.png" title="Korean">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ru">
          
          <img src="https://cdn.countryflags.com/thumbs/russia/flag-400.png" title="Russian">
          
        </a>
      </li>
    
  </ul>
</span>

<script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({
    pageLanguage: 'ja',
    autoDisplay: false,
    layout: google.translate.TranslateElement.InlineLayout.VERTICAL
  }, 'google_translate_element');

  // Links to cross-origin destinations are unsafe
  var gll = document.getElementsByClassName('goog-logo-link')[0];
  if (gll) {
    gll.setAttribute('rel', 'noopener');
  }

  function restoreLang() {
    var iframe = document.getElementsByClassName('goog-te-banner-frame')[0];
    if (!iframe) return;

    var innerDoc = iframe.contentDocument || iframe.contentWindow.document;
    var restore_el = innerDoc.getElementsByTagName("button");

    for (var i = 0; i < restore_el.length; i++) {
      if (restore_el[i].id.indexOf("restore") >= 0) {
        restore_el[i].click();
        var close_el = innerDoc.getElementsByClassName("goog-close-link");
        close_el[0].click();
        return;
      }
    }
  }

  function triggerHtmlEvent(element, eventName) {
    var event;
    if (document.createEvent) {
      event = document.createEvent('HTMLEvents');
      event.initEvent(eventName, true, true);
      element.dispatchEvent(event);
    } else {
      event = document.createEventObject();
      event.eventType = eventName;
      element.fireEvent('on' + event.eventType, event);
    }
  }

  var googleCombo = document.querySelector("select.goog-te-combo");
  var langSelect = document.querySelector('.ct-language');
  langSelect.addEventListener('click', function(event) {
    if (!event.target) {
      return;
    }

    var selected = document.querySelector('.ct-language .ct-language-selected');
    if (selected) {
      selected.classList.remove('ct-language-selected');
    }

    var target = event.target;
    while (target && target !== langSelect ) {
      if (target.matches('.lang-select')) {
        break;
      }
      target = target.parentElement;
    }

    if (target && target.matches('.lang-select')) {
      var lang = target.getAttribute('data-lang');
      if (googleCombo.value == lang) {
        restoreLang();
      } else {
        target.parentElement.classList.add('ct-language-selected');
        googleCombo.value = lang;
        triggerHtmlEvent(googleCombo, 'change');
      }
    }

    event.preventDefault();
  });
}
</script>

<script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit" async></script>
</span>
</div>
        </nav>
</div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;documentElement.setAttribute("data-header-transparent", "");var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);
</script>


























































































































































<style>
    html .page-banner .page-banner-img > *:first-child {
      opacity: 0.4;
    }

    html[data-theme="dark"] .page-banner .page-banner-img > *:first-child {
      opacity: 0.2872;
    }
  </style>
<section class="page-banner">
    <div class="page-banner-img">
<div style="background-image: url(/paper_notes/assets/images/banner.png)"></div>
        <img class="img-placeholder" src="/paper_notes/assets/images/banner.png">
</div>
    <div class="wrapper">
      <div class="page-banner-inner">
<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">わたしのべんきょうノート</h1>
  <h2 class="post-subtitle">勉強した論文や技術等の情報をGithubのIssueにメモっているひとのブログ。
それなりにメモの量が蓄積されてきたので、一度整理したいなと思いブログはじめてみました！
自然言語処理(NLP), 推薦システム(RecommenderSystem), Educational Data Mining (EDM), Learning Analytics (LA)などの分野のメモが多いと思います。
最近は特にLLMの勉強が多めです :)</h2>

  <div class="post-meta">
    <time class="dt-published" datetime="2025-08-29T00:45:37+00:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Aug 29, 2025
    </time><span class="post-author left-vsplit"><i class="fa fa-pencil"></i> AkihikoWATANABE</span>
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 41 hours 25 mins</span>
  </div></header>
</div>
    </div>
  </section><script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('off' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<div id="click-to-top" class="click-to-top">
  <i class="fa fa-arrow-up"></i>
</div>
<script>
  (function () {
    const clickToTop = document.getElementById('click-to-top');
    window.addEventListener('scroll', () => {
      if (window.scrollY > 100) {
        clickToTop.classList.add('show')
      }else {
        clickToTop.classList.remove('show')
      }
    });
    clickToTop.addEventListener('click', () => {
      window.smoothScrollTo(0);
    });
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <h2 id="nlp">NLP</h2>

<div class="visible-content">
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/CurriculumLearning.html">#CurriculumLearning</a>
<a class="button" href="articles/VideoGeneration_Understandings.html">#VideoGeneration/Understandings</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>


<br>


<span class="issue_date">Issue Date: 2025-08-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2580">[Paper Note] Ovis2.5 Technical Report, Shiyin Lu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Ovis2.5は、ネイティブ解像度の視覚認識とマルチモーダル推論を強化するために設計されたモデルで、画像を可変解像度で処理し、複雑な視覚コンテンツの詳細を保持します。推論時には反省を行う「思考モード」を提供し、精度向上を図ります。5段階のカリキュラムで訓練され、マルチモーダルデータの効率的な処理を実現。Ovis2.5-9BはOpenCompassで平均78.3を記録し、Ovis2-8Bに対して大幅な改善を示しました。Ovis2.5-2Bも73.9を達成し、リソース制約のあるデバイスに最適です。STEMベンチマークや複雑なチャート分析においても優れた性能を発揮しています。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/theturingpost/status/1960840587168637183?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QHF:https://huggingface.co/AIDC-AI/Ovis2.5-9B

<br>



<br>

Apache2.0ライセンス

<br>



<br>

GLM-4.1V-9B-Thinkingと同等以上の性能な模様。

<br>

<img src="https://github.com/user-attachments/assets/becc30fe-db20-40c1-a94c-143487ffd9ff" alt="image" loading="lazy">

<br>



<br>

・2128</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/read-later.html">#read-later</a>


<br>


<span class="issue_date">Issue Date: 2025-08-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2569">[Paper Note] Is Chain-of-Thought Reasoning of LLMs a Mirage? A Data Distribution Lens, Chengshuai Zhao+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Chain-of-Thought (CoT) プロンプティングはLLMの性能向上に寄与するが、その深さには疑問が残る。本研究では、CoT推論が訓練データの構造的バイアスを反映しているかを調査し、訓練データとテストクエリの分布不一致がその効果に与える影響を分析。DataAlchemyという制御環境を用いて、CoT推論の脆弱性を明らかにし、一般化可能な推論の達成に向けた課題を強調する。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ConceptErasure.html">#ConceptErasure</a>
<a class="button" href="articles/KnowledgeEditing.html">#KnowledgeEditing</a>


<br>


<span class="issue_date">Issue Date: 2025-08-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2555">[Paper Note] CRISP: Persistent Concept Unlearning via Sparse Autoencoders, Tomer Ashuach+, arXiv'25</a>
<span class="snippet"><span>Summary</span>CRISPは、LLMにおける持続的な概念の忘却を実現するためのパラメータ効率の良い手法であり、スパースオートエンコーダ（SAE）を用いて有害な知識を効果的に除去します。実験により、CRISPはWMDPベンチマークの忘却タスクで従来の手法を上回り、一般的およびドメイン内の能力を保持しつつ、ターゲット特徴の正確な抑制を達成することが示されました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/aicia_solid/status/1960181627549884685?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
</div>
<p><button onclick="showMore(0)">more</button></p>
<div class="hidden-content">
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<span class="issue_date">Issue Date: 2025-08-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2553">[Paper Note] InternVL3.5: Advancing Open-Source Multimodal Models in Versatility,  Reasoning, and Efficiency, Weiyun Wang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>InternVL 3.5は、マルチモーダルモデルの新しいオープンソースファミリーで、Cascade Reinforcement Learningを用いて推論能力と効率を向上させる。粗から細へのトレーニング戦略により、MMMやMathVistaなどのタスクで大幅な改善を実現。Visual Resolution Routerを導入し、視覚トークンの解像度を動的に調整。Decoupled Vision-Language Deployment戦略により、計算負荷をバランスさせ、推論性能を最大16.0%向上させ、速度を4.05倍向上。最大モデルは、オープンソースのMLLMで最先端の結果を達成し、商業モデルとの性能ギャップを縮小。全てのモデルとコードは公開。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gm8xx8/status/1960076908088922147?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<a class="button" href="articles/RLVR.html">#RLVR</a>
<a class="button" href="articles/Diversity.html">#Diversity</a>
<span class="issue_date">Issue Date: 2025-08-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2549">[Paper Note] Beyond Pass@1: Self-Play with Variational Problem Synthesis Sustains  RLVR, Xiao Liang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>RLVRはLLMの複雑な推論タスクにおいて重要だが、従来のトレーニングは生成の多様性を減少させる問題がある。本研究では、ポリシーの生成の多様性を分析し、トレーニング問題を更新することでエントロピー崩壊を軽減する方法を提案。オンライン自己対戦と変分問題合成（SvS）戦略を用いることで、ポリシーのエントロピーを維持し、Pass@kを大幅に改善。AIME24およびAIME25ベンチマークでそれぞれ18.3%および22.8%の向上を達成し、12の推論ベンチマークでSvSの堅牢性を示した。</span>
<span class="snippet"><span>Comment</span>pj page:https://mastervito.github.io/SvS.github.io/元ポスト:https://x.com/mastervito0601/status/1959960582670766411?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q簡易解説:https://x.com/aicia_solid/status/1960178795530600605?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/NeuralArchitectureSearch.html">#NeuralArchitectureSearch</a>
<a class="button" href="articles/SmallModel.html">#SmallModel</a>
<span class="issue_date">Issue Date: 2025-08-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2548">[Paper Note] Jet-Nemotron: Efficient Language Model with Post Neural Architecture  Search, Yuxian Gu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Jet-Nemotronは新しいハイブリッドアーキテクチャの言語モデルで、フルアテンションモデルと同等以上の精度を持ちながら生成スループットを大幅に改善します。Post Neural Architecture Search（PostNAS）を用いて開発され、事前トレーニングされたモデルから効率的にアテンションブロックを探索します。Jet-Nemotron-2Bモデルは、他の先進モデルに対して高い精度を達成し、生成スループットを最大53.6倍向上させました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iscienceluvr/status/1959832287073403137?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q著者ポスト:https://x.com/hancai_hm/status/1960000017235902722?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説:https://x.com/jacksonatkinsx/status/1960090774122483783?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q所見:https://x.com/webbigdata/status/1960392071384326349?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説:https://x.com/omarsar0/status/1960724749790929009?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ModelMerge.html">#ModelMerge</a>
<span class="issue_date">Issue Date: 2025-08-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2543">[Paper Note] Competition and Attraction Improve Model Fusion, João Abrantes+, GECCO'25</a>
<span class="snippet"><span>Summary</span>モデルマージング（M2N2）は、複数の機械学習モデルの専門知識を統合する進化的アルゴリズムで、動的なマージ境界調整や多様性保持メカニズムを特徴とし、最も有望なモデルペアを特定するヒューリスティックを用いる。実験により、M2N2はゼロからMNIST分類器を進化させ、計算効率を向上させつつ高性能を達成。また、専門的な言語や画像生成モデルのマージにも適用可能で、堅牢性と多様性を示す。コードは公開されている。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/sakanaailabs/status/1959799343088857233?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・1257</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/MCP.html">#MCP</a>
<span class="issue_date">Issue Date: 2025-08-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2541">[Paper Note] LiveMCP-101: Stress Testing and Diagnosing MCP-enabled Agents on  Challenging Queries, Ming Yin+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、AIエージェントが複数のMCPツールを協調的に使用してマルチステップタスクを解決する能力を評価するためのベンチマーク「LiveMCP-101」を提案。101の実世界のクエリを用い、真の実行計画を基にした新しい評価アプローチを導入。実験結果から、最前線のLLMの成功率が60％未満であることが示され、ツールのオーケストレーションにおける課題が明らかに。LiveMCP-101は、実世界のエージェント能力を評価するための基準を設定し、自律AIシステムの実現に向けた進展を促進する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/aicia_solid/status/1959786499702182271?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<a class="button" href="articles/DataMixture.html">#DataMixture</a>
<span class="issue_date">Issue Date: 2025-08-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2537">[Paper Note] Motif 2.6B Technical Report, Junghwan Lim+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Motif-2.6Bは、26億パラメータを持つ基盤LLMで、長文理解の向上や幻覚の減少を目指し、差分注意やポリノルム活性化関数を採用。広範な実験により、同サイズの最先端モデルを上回る性能を示し、効率的でスケーラブルな基盤LLMの発展に寄与する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/scaling01/status/1959604841577357430?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QHF:https://huggingface.co/Motif-Technologies/Motif-2.6B・アーキテクチャ

<br>

  ・1466

<br>

  ・2538

<br>

・学習手法

<br>

  ・1979

<br>

    ・8B token学習するごとに直近6つのcheckpointのelement-wiseの平均をとりモデルマージ。当該モデルに対して学習を継続、ということを繰り返す。これにより、学習のノイズを低減し、突然パラメータがシフトすることを防ぐ

<br>

  ・1060

<br>

    ・Adaptive Base Frequency (RoPEのbase frequencyを10000から500000にすることでlong contextのattention scoreが小さくなりすぎることを防ぐ)

<br>

  ・2540 

<br>

・事前学習データ

<br>

  ・1943

<br>

  ・2539

<br>

  ・2109 

<br>



<br>

を利用したモデル。同程度のサイズのモデルとの比較ではかなりのgainを得ているように見える。興味深い。

<br>

DatasetのMixtureの比率などについても記述されている。

<br>



<br>

<img width="705" height="441" alt="Image" src="https://github.com/user-attachments/assets/0a26442e-8075-4cbe-8cc1-f1ff471b7356"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/Length.html">#Length</a>
<a class="button" href="articles/Inference.html">#Inference</a>
<span class="issue_date">Issue Date: 2025-08-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2536">[Paper Note] TokenSkip: Controllable Chain-of-Thought Compression in LLMs, Heming Xia+, EMNLP'25</a>
<span class="snippet"><span>Summary</span>Chain-of-Thought (CoT)はLLMの推論能力を向上させるが、長いCoT出力は推論遅延を増加させる。これに対処するため、重要度の低いトークンを選択的にスキップするTokenSkipを提案。実験により、TokenSkipはCoTトークンの使用を削減しつつ推論性能を維持することを示した。特に、Qwen2.5-14B-InstructでGSM8Kにおいて推論トークンを40%削減し、性能低下は0.4%未満であった。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hemingkx/status/1891873475545137245?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Multi.html">#Multi</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/SelfCorrection.html">#SelfCorrection</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2025-08-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2534">[Paper Note] MAgICoRe: Multi-Agent, Iterative, Coarse-to-Fine Refinement for   Reasoning, Justin Chih-Yao Chen+, EMNLP'25</a>
<span class="snippet"><span>Summary</span>MAgICoReは、LLMの推論を改善するための新しいアプローチで、問題の難易度に応じて洗練を調整し、過剰な修正を回避する。簡単な問題には粗い集約を、難しい問題には細かい反復的な洗練を適用し、外部の報酬モデルを用いてエラーの特定を向上させる。3つのエージェント（Solver、Reviewer、Refiner）によるマルチエージェントループを採用し、洗練の効果を確保する。Llama-3-8BおよびGPT-3.5で評価した結果、MAgICoReは他の手法を上回る性能を示し、反復が進むにつれて改善を続けることが確認された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/cyjustinchen/status/1958957907778969648?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Game.html">#Game</a>
<span class="issue_date">Issue Date: 2025-08-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2533">Identification and Analysis of Identity-Centric Elements of Character-Likeness from Game Scenario, Iwata+, SIGDIAL'25</a>
<span class="snippet"><span>Comment</span>arxivに無さそうなので、概要は元ポスト参照のこと。キャラクターらしさの構成要素とそれらがキャラクターらしさに関してどのように関係しているかを分析した研究な模様。元ポスト:https://x.com/hmkz_/status/1958903563561894229?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Decoding.html">#Decoding</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-08-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2532">[Paper Note] Deep Think with Confidence, Yichao Fu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>「Deep Think with Confidence（DeepConf）」は、LLMの推論タスクにおける精度と計算コストの課題を解決する手法で、モデル内部の信頼性信号を活用して低品質な推論を動的にフィルタリングします。追加の訓練や調整を必要とせず、既存のフレームワークに統合可能です。評価の結果、特に難易度の高いAIME 2025ベンチマークで99.9%の精度を達成し、生成トークンを最大84.7%削減しました。</span>
<span class="snippet"><span>Comment</span>pj page:https://jiaweizzhao.github.io/deepconf

<br>

vLLMでの実装:https://jiaweizzhao.github.io/deepconf/static/htmls/code_example.html元ポスト:https://x.com/jiawzhao/status/1958982524333678877?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qtooluse、追加の訓練なしで、どのようなタスクにも適用でき、85%生成トークン量を減らした上で、OpenModelで初めてAIME2025において99% Acc.を達成した手法とのこと。vLLMを用いて50 line程度で実装できるらしい。reasoning traceのconfidence(i.e., 対数尤度)をgroup sizeを決めてwindow単位で決定し、それらをデコーディングのプロセスで活用することで、品質の低いreasoning traceに基づく結果を排除しつつ、majority votingに活用する方法。直感的にもうまくいきそう。オフラインとオンラインの推論によって活用方法が提案されている。あとでしっかり読んで書く。Confidenceの定義の仕方はグループごとのbottom 10%、tailなどさまざまな定義方法と、それらに基づいたconfidenceによるvotingの重み付けが複数考えられ、オフライン、オンラインによって使い分ける模様。

<br>



<br>

vLLMにPRも出ている模様？</span>
<a class="button" href="articles/Multi.html">#Multi</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/x-Use.html">#x-Use</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<span class="issue_date">Issue Date: 2025-08-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2531">[Paper Note] ToolVQA: A Dataset for Multi-step Reasoning VQA with External Tools, Shaofeng Yin+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、実世界のツール使用能力を向上させるために、23Kのインスタンスからなる大規模マルチモーダルデータセット「ToolVQA」を提案。ToolVQAは、実際の視覚的コンテキストと多段階推論タスクを特徴とし、ToolEngineを用いて人間のようなツール使用推論をシミュレート。7B LFMを微調整した結果、テストセットで優れたパフォーマンスを示し、GPT-3.5-turboを上回る一般化能力を持つことが確認された。</span>
<span class="snippet"><span>Comment</span>人間による小規模なサンプル（イメージシナリオ、ツールセット、クエリ、回答、tool use trajectory)を用いてFoundation Modelに事前知識として与えることで、よりrealisticなscenarioが合成されるようにした上で新たなVQAを4k程度合成。その後10人のアノテータによって高品質なサンプルにのみFilteringすることで作成された、従来よりも実世界の設定に近く、reasoningの複雑さが高いVQAデータセットな模様。

<br>



<br>

<img src="https://github.com/user-attachments/assets/8759244c-89f9-47d7-9c72-81744ef68db1" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/4bc22c9d-79f3-4c16-b5a4-3c054895b416" alt="image" loading="lazy">

<br>



<br>

具体的には、image contextxが与えられた時に、ChatGPT-4oをコントローラーとして、前回のツールとアクションの選択をgivenにし、人間が作成したプールに含まれるサンプルの中からLongest Common Subsequence (LCS) による一致度合いに基づいて人手によるサンプルを選択し、動的にcontextに含めることで多様なで実世界により近しいmulti step tooluseなtrajectoryを合成する、といった手法に見える。pp.4--5に数式や図による直感的な説明がある。なお、LCSを具体的にどのような文字列に対して、どのような前処理をした上で適用しているのかまでは追えていない。

<br>

<img src="https://github.com/user-attachments/assets/9915c3d5-e984-4611-94d4-999ad08dc49d" alt="image" loading="lazy">元ポスト:https://x.com/jiqizhixin/status/1959125184285483090?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<span class="issue_date">Issue Date: 2025-08-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2530">[Paper Note] Hard Examples Are All You Need: Maximizing GRPO Post-Training Under  Annotation Budgets, Benjamin Pikus+, arXiv'25</a>
<span class="snippet"><span>Summary</span>リソースが制約された状況での言語モデルのファインチューニングにおいて、難易度の異なるトレーニング例の優先順位を検討。実験により、最も難しい例でのトレーニングが最大47%のパフォーマンス向上をもたらすことが示され、難しい例が学習機会を多く提供することが明らかに。これにより、予算制約下での効果的なトレーニング戦略として、難しい例を優先することが推奨される。</span>
<span class="snippet"><span>Comment</span>ベースモデルのpass@kが低いhardestなサンプルでGRPOを学習するのがデータ効率が良く、OODに対する汎化性能も発揮されます、というのをQwen3-4B, 14B, Phi4で実験して示しました、という話っぽい？

<br>



<br>

小規模モデル、およびGSM8K、BIG Bench hardでの、Tracking Shuffled Objectのみでの実験な模様？大規模モデルやコーディングなどのドメインでもうまくいくかはよく分からない。OODの実験もAIME2025でのみの実験しているようなのでそこは留意した方が良いかも。

<br>

rewardとして何を使ったのかなどの細かい内容を追えていない。元ポスト:https://x.com/pratyushrt/status/1958947577216524352?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<a class="button" href="articles/Science.html">#Science</a>
<span class="issue_date">Issue Date: 2025-08-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2528">[Paper Note] Intern-S1: A Scientific Multimodal Foundation Model, Lei Bai+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Intern-S1は、科学専門分野に特化したオープンソースの専門家型モデルで、280億の活性化パラメータを持つマルチモーダルMixture-of-Experts（MoE）モデルです。5Tトークンで事前学習され、特に科学データに焦点を当てています。事後学習では、InternBootCampを通じて強化学習を行い、Mixture-of-Rewardsを提案。評価では、一般的な推論タスクで競争力を示し、科学分野の専門的なタスクでクローズドソースモデルを上回る性能を達成しました。モデルはHugging Faceで入手可能です。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iscienceluvr/status/1958894938248384542?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qscientific domainに特化したデータで継続事前学習+RL Finetuningしたドメイン特化言語モデルらしい。HF:https://huggingface.co/internlm/Intern-S1

<br>



<br>

Apache 2.0ライセンス

<br>



<br>

ベースモデルはQwen3とInternViT

<br>

・InternViT:https://huggingface.co/OpenGVLab/InternViT-300M-448px-V2_5

<br>



<br>

関連:

<br>

・2529解説:https://x.com/gm8xx8/status/1959222471183225033?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qサマリ:https://x.com/theturingpost/status/1960840538225303992?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2025-08-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2527">[Paper Note] Beyond GPT-5: Making LLMs Cheaper and Better via Performance-Efficiency  Optimized Routing, Yiqun Zhang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>LLMのパフォーマンスと効率のバランスを取るために、テスト時ルーティングフレームワーク「Avengers-Pro」を提案。クエリを埋め込み、クラスタリングし、最適なモデルにルーティングすることで、6つのベンチマークで最先端の結果を達成。最強の単一モデルを平均精度で+7%上回り、コストを27%削減しつつ約90%のパフォーマンスを実現。すべての単一モデルの中で最高の精度と最低のコストを提供するパレートフロンティアを達成。コードは公開中。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/omarsar0/status/1958897458408563069?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qクエリをkmeansでクラスタリングし、各クラスタごとにモデルごとのperformanceとcostを事前に算出しておく。そして新たなクエリが来た時にクエリが割り当てられるtop pのクラスタのperformanae-cost efficiencyを合計し、スコアが高い一つのモデルを選択（＝routing)しinferenceを実施する。クエリはQwenでembedding化してクラスタリングに活用する。ハイパーパラメータα∈[0,1]によって、performance, costどちらを重視するかのバランスを調整する。

<br>



<br>

シンプルな手法だが、GPT-5 mediumと同等のコスト/性能　でより高い　性能/コスト　を実現。

<br>

<img src="https://github.com/user-attachments/assets/203f99a3-79b3-4465-985b-2bbd124d3972" alt="image" loading="lazy">性能向上、コスト削減でダメ押ししたい時に使えそうだが、発行するクエリがプロプライエタリデータ、あるいはそもそも全然データないんです、みたいな状況の場合、クエリの割当先となるクラスタを適切に確保する（クラスタリングに用いる十分な量のデータを準備する）のが大変な場面があるかもしれない。（全然本筋と関係ないが、最近論文のタイトルにBeyondつけるの流行ってる…？）</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/AutomaticSpeechRecognition(ASR).html">#AutomaticSpeechRecognition(ASR)</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/Encoder-Decoder.html">#Encoder-Decoder</a>
<span class="issue_date">Issue Date: 2025-08-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2525">[Paper Note] LiteASR: Efficient Automatic Speech Recognition with Low-Rank  Approximation, Keisuke Kamahori+, EMNLP'25</a>
<span class="snippet"><span>Summary</span>LiteASRは、現代の自動音声認識モデルのエンコーダを低ランク圧縮する手法で、推論コストを大幅に削減しつつ転写精度を維持します。主成分分析を用いて低ランク行列の乗算を近似し、自己注意機構を最適化することで、Whisper large-v3のエンコーダサイズを50%以上圧縮し、Whisper mediumと同等のサイズでより良い転写精度を実現しました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/keisukekamahori/status/1958695752810864754?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q現代のASRモデルはencoderが計算効率の上でボトルネックとなっていたが、Forward Passにおける activatrion Y を PCA （式2, 3）に基づいて2つの低ランク行列の積（とバイアス項の加算; 式5）によって近似し計算効率を大幅に向上させた、という話な模様。weightを低ランクに写像するV_kとバイアス項のY_M（データセット全体に対するactivation Yの平均）はcalibrfationデータによって事前に計算可能とのこと。また、PCAのrank kがattention headの次元数より小さい場合、self-attentionの計算もより（QWKへ写像するWを低ランク行列で近似することで）効率的な手法を採用でき、そちらについても提案されている模様。（ざっくりしか読めていないので誤りがあるかもしれない。）

<br>



<br>

<img width="592" height="449" alt="Image" src="https://github.com/user-attachments/assets/38c8aa6a-cad3-42d1-af6a-9102ed1df3f5">

<br>



<br>

<img width="484" height="415" alt="Image" src="https://github.com/user-attachments/assets/f8fa8cd1-2b6a-405a-88ec-3bfd2158dffb"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-08-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2524">[Paper Note] Prompt Orchestration Markup Language, Yuge Zhang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>POML（プロンプトオーケストレーションマークアップ言語）を導入し、LLMsのプロンプトにおける構造、データ統合、フォーマット感受性の課題に対処。コンポーネントベースのマークアップやCSSスタイリングシステムを採用し、動的プロンプトのテンプレート機能や開発者ツールキットを提供。POMLの有効性を2つのケーススタディで検証し、実際の開発シナリオでの効果を評価。</span>
<span class="snippet"><span>Comment</span>pj page:https://microsoft.github.io/poml/latest/元ポスト:https://x.com/aicia_solid/status/1958732643996246342?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qこれは非常に興味深い</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/MCP.html">#MCP</a>
<span class="issue_date">Issue Date: 2025-08-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2523">[Paper Note] MCP-Universe: Benchmarking Large Language Models with Real-World Model  Context Protocol Servers, Ziyang Luo+, arXiv'25</a>
<span class="snippet"><span>Summary</span>モデルコンテキストプロトコル（MCP）は、LLMを外部データソースに接続する新しい標準であり、MCP-Universeという包括的なベンチマークを導入。これにより、実際のアプリケーションにおけるLLMの評価が可能となる。6つのコアドメインをカバーし、厳密な評価手法を実装。主要なLLMは性能制限を示し、長文コンテキストや未知のツールの課題に直面。UIサポート付きの評価フレームワークをオープンソース化し、MCPエコシステムの革新を促進。</span>
<span class="snippet"><span>Comment</span>pj page:https://mcp-universe.github.io/元ポスト:https://x.com/lijunnan0409/status/1958671067071004934?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2025-08-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2522">[Paper Note] WebEvolver: Enhancing Web Agent Self-Improvement with Coevolving World  Model, Tianqing Fang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>自己改善エージェントのために、共進化するワールドモデルLLMを導入する新しいフレームワークを提案。これにより、エージェントのポリシーを洗練する自己指導型トレーニングデータを生成し、行動選択を導く先読みシミュレーションを実現。実験により、既存の自己進化エージェントに対して10%のパフォーマンス向上を示し、持続的な適応性を促進することを目指す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/wyu_nd/status/1958632621820584203?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/ModelMerge.html">#ModelMerge</a>
<span class="issue_date">Issue Date: 2025-08-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2517">PLaMo Translate: 翻訳特化大規模言語モデルの開発,今城+, Jxiv'25</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/imos/status/1958687896321630355?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<a class="button" href="articles/Decoding.html">#Decoding</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-08-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2516">[Paper Note] Time Is a Feature: Exploiting Temporal Dynamics in Diffusion Language  Models, Wen Wang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>dLLMsは中間予測を捨てがちだが、時間的振動が重要な現象である。本研究では、時間的一貫性を活用する2つの方法を提案。1つ目は、テスト時に予測を集約する時間的自己一貫性投票、2つ目は中間予測の安定性を測る時間的意味エントロピーを報酬信号とする時間的一貫性強化。実験結果では、Countdownデータセットで24.7%の改善を達成し、他のベンチマークでも向上を示した。これにより、dLLMsの時間的ダイナミクスの可能性が強調される。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jiqizhixin/status/1958702248055513335?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QdLLMのデノイジング過程において途中に正解が表出しているのに時間発展とともに消えてしまう問題があるらしく、それに対して、デノイジングステップにおいてstableな予測を行うSelf-Consistencyベースのdecoding手法と、意味的なエントロピーをrewardに加え時間発展で安定するようにpost trainingすることで対処します、みたいな話らしい。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/RLVR.html">#RLVR</a>
<a class="button" href="articles/DualLearning.html">#DualLearning</a>
<span class="issue_date">Issue Date: 2025-08-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2505">[Paper Note] DuPO: Enabling Reliable LLM Self-Verification via Dual Preference  Optimization, Shuaijie She+, arXiv'25</a>
<span class="snippet"><span>Summary</span>DuPOは、注釈なしのフィードバックを生成する二重学習に基づく好み最適化フレームワークで、強化学習の高価なラベル依存と二重タスクペアの制限に対処。プライマルタスクの入力を分解し、未知の部分を再構築する二重タスクを構築することで、非可逆タスクへの適用範囲を広げる。実験により、翻訳品質や数学的推論の精度が大幅に向上し、DuPOはスケーラブルで一般的なLLM最適化の手法として位置付けられる。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/rosinality/status/1958413194307002415?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・2508解説:https://x.com/gm8xx8/status/1959926238065127724?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Single.html">#Single</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-08-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2503">[Paper Note] Chain-of-Agents: End-to-End Agent Foundation Models via Multi-Agent  Distillation and Agentic RL, Weizhen Li+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Chain-of-Agents（CoA）という新しいLLM推論パラダイムを提案し、マルチエージェントシステムの協力を単一モデル内でエンドツーエンドに実現。マルチエージェント蒸留フレームワークを用いて、エージェント的な教師ありファインチューニングを行い、強化学習で能力を向上。得られたエージェント基盤モデル（AFMs）は、ウェブエージェントやコードエージェントの設定で新たな最先端性能を示す。研究成果はオープンソース化され、今後の研究の基盤を提供。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/omarsar0/status/1958186531161853995?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qマルチエージェントのように振る舞うシングルエージェントを、マルチエージェントから得られたtrajectoryを通じて蒸留することめ実現する手法を提案。SFTでcold startに対して訓練した後、verifiable reward (タスクを正常に完了できたか否か)でRLする模様。

<br>



<br>

<img src="https://github.com/user-attachments/assets/b4cafaba-488e-4d8b-a6d3-faf98733d134" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/80a934e9-db47-401b-809e-394ab5e20585" alt="image" loading="lazy">データセットも公開されている模様所見:https://x.com/dongxi_nlp/status/1958604404338147417?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説:https://x.com/jiqizhixin/status/1959877518972137667?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<span class="issue_date">Issue Date: 2025-08-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2502">[Paper Note] VisualWebInstruct: Scaling up Multimodal Instruction Data through Web   Search, Yiming Jia+, EMNLP'25</a>
<span class="snippet"><span>Summary</span>本研究では、推論に焦点を当てたマルチモーダルデータセットの不足に対処するため、VisualWebInstructという新しいアプローチを提案。30,000のシード画像からGoogle画像検索を用いて700K以上のユニークなURLを収集し、約900KのQAペアを構築。ファインチューニングされたモデルは、Llava-OVで10-20ポイント、MAmmoTH-VLで5ポイントの性能向上を示し、最良モデルMAmmoTH-VL2は複数のベンチマークで最先端の性能を達成。これにより、Vision-Language Modelsの推論能力向上に寄与することが示された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/wenhuchen/status/1958317145349075446?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/ScientificDiscovery.html">#ScientificDiscovery</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/Findings.html">#Findings</a>
<span class="issue_date">Issue Date: 2025-08-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2501">[Paper Note] Agent Laboratory: Using LLM Agents as Research Assistants, Samuel Schmidgall+, EMNLP'25 Findings</a>
<span class="snippet"><span>Summary</span>Agent Laboratoryは、全自動のLLMベースのフレームワークで、研究アイデアから文献レビュー、実験、報告書作成までのプロセスを完了し、質の高い研究成果を生成します。人間のフィードバックを各段階で取り入れることで、研究の質を向上させ、研究費用を84%削減。最先端の機械学習コードを生成し、科学的発見の加速を目指します。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/srschmidgall/status/1958272229223067789?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qpj page:https://agentlaboratory.github.io</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<span class="issue_date">Issue Date: 2025-08-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2485">[Paper Note] AutoCodeBench: Large Language Models are Automatic Code Benchmark  Generators, Jason Chou+, arXiv'25</a>
<span class="snippet"><span>Summary</span>AutoCodeGenを提案し、手動注釈なしで高難易度の多言語コード生成データセットを自動生成。これに基づき、3,920の問題からなるAutoCodeBenchを導入し、20のプログラミング言語に均等に分配。30以上のLLMsを評価した結果、最先端のモデルでも多様性や複雑さに苦労していることが明らかに。AutoCodeBenchシリーズは、実用的な多言語コード生成シナリオに焦点を当てるための貴重なリソースとなることを期待。</span>
<span class="snippet"><span>Comment</span>pj page:https://autocodebench.github.io/元ポスト:https://x.com/tencenthunyuan/status/1957751900608110982?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Overthinking.html">#Overthinking</a>
<a class="button" href="articles/Underthinking.html">#Underthinking</a>
<span class="issue_date">Issue Date: 2025-08-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2478">[Paper Note] OptimalThinkingBench: Evaluating Over and Underthinking in LLMs, Pranjal Aggarwal+, arXiv'25</a>
<span class="snippet"><span>Summary</span>思考型LLMは計算コストが高く、単純な問題に対して過剰に考え、非思考型LLMは迅速だが難しい推論に対して考えが浅い。これにより、最適なモデル選択がエンドユーザーに委ねられている。本研究では、OptimalThinkingBenchを導入し、過剰思考と考え不足を評価する統一ベンチマークを提供。72のドメインの単純なクエリと11の挑戦的な推論タスクを含む2つのサブベンチマークで、33のモデルを評価した結果、最適な思考モデルは存在せず、思考型モデルは過剰に考え、非思考型モデルは浅い結果を示した。将来的には、より良い統一的かつ最適なモデルの必要性が浮き彫りとなった。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jaseweston/status/1957627532963926389?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q元ポストの著者によるスレッドが非常にわかりやすいのでそちらを参照のこと。

<br>

ざっくり言うと、Overthinking（考えすぎて大量のトークンを消費した上に回答が誤っている; トークン量↓とLLMによるJudge Score↑で評価）とUnderthinking（全然考えずにトークンを消費しなかった上に回答が誤っている; Accuracy↑で評価）をそれぞれ評価するサンプルを収集し、それらのスコアの組み合わせでモデルが必要に応じてどれだけ的確にThinkingできているかを評価するベンチマーク。

<br>



<br>

Overthinkingを評価するためのサンプルは、多くのLLMでagreementがとれるシンプルなQAによって構築。一方、Underthinkingを評価するためのサンプルは、small reasoning modelがlarge non reasoning modelよりも高い性能を示すサンプルを収集。

<br>

<img src="https://github.com/user-attachments/assets/5383e385-fda9-41ae-a9a5-aebf494ca79e" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/c08cfe60-8a29-4ebf-8875-081f7ae7d19f" alt="image" loading="lazy">

<br>



<br>

現状Non Thinking ModelではQwen3-235B-A22Bの性能が良く、Thinking Modelではgpt-oss-120Bの性能が良い。プロプライエタリなモデルではそれぞれ、Claude-Sonnet4, o3の性能が良い。全体としてはo3の性能が最も良い。

<br>

<img src="https://github.com/user-attachments/assets/5f5c1ead-d5fa-40a8-9a1b-90d4170ae3ee" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2025-08-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2466">[Paper Note] xbench: Tracking Agents Productivity Scaling with Profession-Aligned  Real-World Evaluations, Kaiyuan Chen+, arXiv'25</a>
<span class="snippet"><span>Summary</span>「xbench」は、AIエージェントの能力と実世界の生産性のギャップを埋めるために設計された動的な評価スイートで、業界専門家が定義したタスクを用いて商業的に重要なドメインをターゲットにしています。リクルートメントとマーケティングの2つのベンチマークを提示し、エージェントの能力を評価するための基準を確立します。評価結果は継続的に更新され、https://xbench.org で入手可能です。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2025-08-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2455">[Paper Note] A Survey on Parallel Text Generation: From Parallel Decoding to  Diffusion Language Models, Lingzhe Zhang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>並列テキスト生成は、LLMの生成速度を向上させるための技術であり、自己回帰生成のボトルネックを打破することを目指している。本研究では、並列テキスト生成手法をARベースと非ARベースに分類し、それぞれの技術を評価。速度、品質、効率のトレードオフを考察し、今後の研究の方向性を示す。関連論文を集めたGitHubリポジトリも作成。</span>
<span class="snippet"><span>Comment</span>Taxonomyと手法一覧。Draft and Verifyingは個人的に非常に興味がある。

<br>

<img src="https://github.com/user-attachments/assets/019469c3-f906-42e3-91d9-f99f75d8d501" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Trustfulness.html">#Trustfulness</a>
<a class="button" href="articles/Health.html">#Health</a>
<span class="issue_date">Issue Date: 2025-08-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2452">[Paper Note] HealthBench: Evaluating Large Language Models Towards Improved Human  Health, Rahul K. Arora+, arXiv'25</a>
<span class="snippet"><span>Summary</span>オープンソースのベンチマーク「HealthBench」を発表。5,000件のマルチターン会話を基に、262人の医師による評価基準でモデルの性能と安全性を測定。従来のベンチマークと異なり、48,562のユニークな評価基準を用いて多様な健康コンテキストを評価。GPT-3.5 TurboとGPT-4oの比較で初期の進展を示し、小型モデルの改善が顕著。新たに「HealthBench Consensus」と「HealthBench Hard」の2つのバリエーションもリリース。HealthBenchが健康分野でのモデル開発に寄与することを期待。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/x-Use.html">#x-Use</a>
<span class="issue_date">Issue Date: 2025-08-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2451">[Paper Note] BrowseComp: A Simple Yet Challenging Benchmark for Browsing Agents, Jason Wei+, arXiv'25</a>
<span class="snippet"><span>Summary</span>BrowseCompは、エージェントのウェブブラウジング能力を測定するための1,266の質問からなるベンチマークで、絡み合った情報を探すことを要求します。シンプルで使いやすく、短い回答が求められ、参照回答との照合が容易です。このベンチマークは、ブラウジングエージェントの能力を評価するための重要なツールであり、持続力と創造性を測定します。詳細はGitHubで入手可能です。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/x-Use.html">#x-Use</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-08-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2436">[Paper Note] OpenCUA: Open Foundations for Computer-Use Agents, Xinyuan Wang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>OpenCUAは、CUAデータと基盤モデルをスケールさせるためのオープンソースフレームワークであり、アノテーションインフラ、AgentNetデータセット、反射的なChain-of-Thought推論を持つスケーラブルなパイプラインを提供。OpenCUA-32Bは、CUAベンチマークで34.8%の成功率を達成し、最先端の性能を示す。研究コミュニティのために、アノテーションツールやデータセットを公開。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gm8xx8/status/1956157162830418062?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q著者ポスト:https://x.com/xywang626/status/1956400403911962757?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QCUAにおいてProprietaryモデルに近い性能を達成した初めての研究な模様。重要</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/ZeroshotHyperparameterTransfer.html">#ZeroshotHyperparameterTransfer</a>
<span class="issue_date">Issue Date: 2025-08-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2430">[Paper Note] $μ$-Parametrization for Mixture of Experts, Jan Małaśnicki+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、Mixture-of-Experts（MoE）モデルに対する$\mu$-Parameterization（$\mu$P）を提案し、ルーターとエキスパートの特徴学習に関する理論的保証を提供します。また、エキスパートの数と粒度のスケーリングが最適な学習率に与える影響を実証的に検証します。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gm8xx8/status/1956103561126789339?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連: mu transfer, muP

<br>

・2582

<br>

・2583</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<span class="issue_date">Issue Date: 2025-08-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2428">[Paper Note] Less Is More: Training-Free Sparse Attention with Global Locality for  Efficient Reasoning, Lijie Yang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>「LessIsMore」という新しいスパースアテンションメカニズムを提案。これは、トレーニング不要でグローバルアテンションパターンを活用し、トークン選択を効率化。精度を維持しつつ、デコーディング速度を1.1倍向上させ、トークン数を2倍削減。既存手法と比較して1.13倍のスピードアップを実現。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/lijieyyang/status/1955139186530328633?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qトレーニングフリーで1.1倍のデコーディング速度で性能もFull Attentionと同等以上のSparse Attentionらしい</span>
<a class="button" href="articles/Multi.html">#Multi</a>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-08-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2427">[Paper Note] The Policy Cliff: A Theoretical Analysis of Reward-Policy Maps in Large  Language Models, Xingcheng Xu, arXiv'25</a>
<span class="snippet"><span>Summary</span>強化学習（RL）は大規模言語モデルの行動形成に重要だが、脆弱なポリシーを生成し、信頼性を損なう問題がある。本論文では、報酬関数から最適ポリシーへのマッピングの安定性を分析する数学的枠組みを提案し、ポリシーの脆弱性が非一意的な最適アクションに起因することを示す。さらに、多報酬RLにおける安定性が「効果的報酬」によって支配されることを明らかにし、エントロピー正則化が安定性を回復することを証明する。この研究は、ポリシー安定性分析を進展させ、安全で信頼性の高いAIシステム設計に寄与する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jiqizhixin/status/1955909877404197072?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qとても面白そう</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Search.html">#Search</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2025-08-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2426">[Paper Note] Beyond Ten Turns: Unlocking Long-Horizon Agentic Search with Large-Scale  Asynchronous RL, Jiaxuan Gao+, arXiv'25</a>
<span class="snippet"><span>Summary</span>ASearcherは、LLMベースの検索エージェントの大規模なRLトレーニングを実現するオープンソースプロジェクトであり、高効率な非同期RLトレーニングと自律的に合成された高品質なQ&amp;Aデータセットを用いて、検索能力を向上させる。提案されたエージェントは、xBenchで46.7%、GAIAで20.8%の改善を達成し、長期的な検索能力を示した。モデルとデータはオープンソースで提供される。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/huggingpapers/status/1955603041518035358?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q著者ポスト:https://x.com/jxwuyi/status/1955487396344238486?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説ポスト: https://x.com/omarsar0/status/1955266026498855354?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連ベンチマーク:

<br>

・2466

<br>

・1158

<br>

・1461既存のモデルは &lt;= 10 turnsのデータで学習されており、大規模で高品質なQAデータが不足している問題があったが、シードQAに基づいてQAを合成する手法によって1.4万シードQAから134kの高品質なQAを合成した（うち25.6kはツール利用が必要）。具体的には、シードのQAを合成しエージェントがQAの複雑度をiterationをしながら向上させていく手法を提案。事実情報は常にverificationをされ、合成プロセスのiterationの中で保持され続ける。個々のiterationにおいて、現在のQAと事実情報に基づいて、エージェントは

<br>

・Injection: 事実情報を新たに注入しQAをよりリッチにすることで複雑度を上げる

<br>

・Fuzz: QA中の一部の詳細な情報をぼかすことで、不確実性のレベルを向上させる。

<br>

の2種類の操作を実施する。その上で、QAに対してQuality verificationを実施する:

<br>

・Basic Quality: LLMでqualityを評価する

<br>

・Difficulty Measurement: LRMによって、複数の回答候補を生成する

<br>

・Answer Uniqueness: Difficulty Measurementで生成された複数の解答情報に基づいて、mismatched answersがvalid answerとなるか否かを検証し、正解が単一であることを担保する

<br>



<br>

<img width="907" height="561" alt="Image" src="https://github.com/user-attachments/assets/d020fc8f-b1da-4425-981a-6759cba5824b">

<br>



<br>

また、複雑なタスク、特にtool callsが非常に多いタスクについては、多くのターン数（long trajectories）が必要となるが、既存のバッチに基づいた学習手法ではlong trajectoriesのロールアウトをしている間、他のサンプルの学習がブロックされてしまい学習効率が非常に悪いので、バッチ内のtrajectoryのロールアウトとモデルの更新を分離（ロールアウトのリクエストが別サーバに送信されサーバ上のInference Engineで非同期に実行され、モデルをアップデートする側は十分なtrajectoryがバッチ内で揃ったらパラメータを更新する、みたいな挙動？）することでIdleタイムを無くすような手法を提案した模様。

<br>



<br>

<img width="873" height="466" alt="Image" src="https://github.com/user-attachments/assets/65d7e7b1-25fb-4288-a85e-07ae7a5eea2f">既存の手法ベンチマークの性能は向上している。学習が進むにつれて、trajectory中のURL参照回数やsearch query数などが増大していく曲線は考察されている。他モデルと比較して、より多いターン数をより高い正確性を以って実行できるといった定量的なデータはまだ存在しないように見えた。

<br>



<br>

<img width="891" height="778" alt="Image" src="https://github.com/user-attachments/assets/70644da8-b862-4bcb-bb05-d915c815b885"></span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<a class="button" href="articles/DeepResearch.html">#DeepResearch</a>
<span class="issue_date">Issue Date: 2025-08-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2424">[Paper Note] WebWatcher: Breaking New Frontier of Vision-Language Deep Research Agent, Xinyu Geng+, arXiv'25</a>
<span class="snippet"><span>Summary</span>WebWatcherは、視覚と言語の推論能力を強化したマルチモーダルエージェントであり、情報探索の困難さに対処する。合成マルチモーダル軌跡を用いた効率的なトレーニングと強化学習により、深い推論能力を向上させる。新たに提案されたBrowseComp-VLベンチマークでの実験により、WebWatcherは複雑なVQAタスクで他のエージェントを大幅に上回る性能を示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/richardxp888/status/1955645614685077796?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<a class="button" href="articles/On-Policy.html">#On-Policy</a>
<a class="button" href="articles/Stability.html">#Stability</a>
<span class="issue_date">Issue Date: 2025-08-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2423">[Paper Note] Geometric-Mean Policy Optimization, Yuzhong Zhao+, arXiv'25</a>
<span class="snippet"><span>Summary</span>GRPOの不安定性を解決するために、幾何平均を最適化するGMPOを提案。GMPOは外れ値に敏感でなく、安定した重要度サンプリング比率を維持。実験により、GMPO-7Bは複数の数学的およびマルチモーダル推論ベンチマークでGRPOを上回る性能を示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/zzlccc/status/1955823092904943816?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q簡易解説:https://x.com/jiqizhixin/status/1955879567354388926?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/On-Policy.html">#On-Policy</a>
<a class="button" href="articles/Overthinking.html">#Overthinking</a>
<span class="issue_date">Issue Date: 2025-08-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2422">[Paper Note] Sample More to Think Less: Group Filtered Policy Optimization for  Concise Reasoning, Vaishnavi Shrivastava+, arXiv'25</a>
<span class="snippet"><span>Summary</span>GFPO（Group Filtered Policy Optimization）を提案し、応答の長さの膨張を抑制。応答を長さとトークン効率に基づいてフィルタリングし、推論時の計算量を削減。Phi-4モデルで長さの膨張を46-71%削減し、精度を維持。Adaptive Difficulty GFPOにより、難易度に応じた訓練リソースの動的割り当てを実現。効率的な推論のための効果的なトレードオフを提供。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/zzlccc/status/1955823092904943816?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q簡易解説:https://x.com/jiqizhixin/status/1955884039149380067?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q著者ポスト:https://x.com/vaishshrivas/status/1956096081504436620?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2025-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2418">[Paper Note] Can Language Models Falsify? Evaluating Algorithmic Reasoning with  Counterexample Creation, Shiven Sinha+, arXiv'25</a>
<span class="snippet"><span>Summary</span>言語モデル（LM）の科学的発見を加速するために、微妙に誤った解決策に対する反例を作成する能力を評価する新しいベンチマーク「REFUTE」を提案。これはプログラミング問題からの誤った提出物を用いており、最も優れた推論エージェントでも9%未満の反例しか生成できないことが示された。この研究は、LMの誤った解決策を否定する能力を向上させ、信頼できる推論を通じて自己改善を促進することを目指している。</span>
<span class="snippet"><span>Comment</span>pj page:https://falsifiers.github.io元ポスト:https://x.com/shashwatgoel7/status/1955311868915966173?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qバグのあるコードとtask descriptionが与えられた時に、inputのフォーマットと全ての制約を満たすが、コードの実行が失敗するサンプル（＝反例）を生成することで、モデルのreasoning capabilityの評価をするベンチマーク。

<br>



<br>

gpt-ossはコードにバグのあるコードに対して上記のような反例を生成する能力が高いようである。ただし、それでも全体のバグのあるコードのうち反例を生成できたのは高々21.6%のようである。ただ、もしコードだけでなくverification全般の能力が高いから、相当使い道がありそう。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<span class="issue_date">Issue Date: 2025-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2417">[Paper Note] Unveiling Super Experts in Mixture-of-Experts Large Language Models, Zunhai Su+, arXiv'25</a>
<span class="snippet"><span>Summary</span>スパースに活性化されたMixture-of-Experts（MoE）モデルにおいて、特定の専門家のサブセット「スーパ専門家（SE）」がモデルの性能に重要な影響を与えることを発見。SEは稀な活性化を示し、プルーニングするとモデルの出力が劣化する。分析により、SEの重要性が数学的推論などのタスクで明らかになり、MoE LLMがSEに依存していることが確認された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jiqizhixin/status/1955217132016505239?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QMoEにおける、特に重要な専門家であるSuper Expertsの存在・1566

<br>



<br>

を思い出す。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/MCP.html">#MCP</a>
<span class="issue_date">Issue Date: 2025-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2415">[Paper Note] LiveMCPBench: Can Agents Navigate an Ocean of MCP Tools?, Guozhao Mo+, arXiv'25</a>
<span class="snippet"><span>Summary</span>LiveMCPBenchは、10,000を超えるMCPサーバーに基づく95の実世界タスクから成る初の包括的なベンチマークで、LLMエージェントの大規模評価を目的としています。70のMCPサーバーと527のツールを含むLiveMCPToolを整備し、LLM-as-a-JudgeフレームワークであるLiveMCPEvalを導入して自動化された適応評価を実現しました。MCP Copilot Agentは、ツールを動的に計画し実行するマルチステップエージェントです。評価の結果、最も優れたモデルは78.95%の成功率を達成しましたが、モデル間で性能のばらつきが見られました。全体として、LiveMCPBenchはLLMエージェントの能力を評価するための新たなフレームワークを提供します。</span>
<span class="snippet"><span>Comment</span>pj page:https://icip-cas.github.io/LiveMCPBench/元ポスト:https://x.com/huggingpapers/status/1955324566298833127?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QMCP環境におけるLLM Agentのベンチマーク。論文中のTable1に他のベンチマークを含めサマリが掲載されている。MCPを用いたLLMAgentのベンチがすでにこんなにあることに驚いた…。

<br>

<img src="https://github.com/user-attachments/assets/29472068-380b-421c-b82d-fd14831b07ff" alt="image" loading="lazy"></span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<a class="button" href="articles/Cultural.html">#Cultural</a>
<span class="issue_date">Issue Date: 2025-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2413">[Paper Note] Grounding Multilingual Multimodal LLMs With Cultural Knowledge, Jean de Dieu Nyandwi+, arXiv'25</a>
<span class="snippet"><span>Summary</span>MLLMsは高リソース環境で優れた性能を示すが、低リソース言語や文化的エンティティに対しては課題がある。これに対処するため、Wikidataを活用し、文化的に重要なエンティティを表す画像を用いた多言語視覚質問応答データセット「CulturalGround」を生成。CulturalPangeaというオープンソースのMLLMを訓練し、文化に基づいたアプローチがMLLMsの文化的ギャップを縮小することを示した。CulturalPangeaは、従来のモデルを平均5.0ポイント上回る性能を達成。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gneubig/status/1955308632305782957?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qpj page:https://neulab.github.io/CulturalGround/

<br>



<br>

VQAデータセット中の日本語データは3.1%程度で、&lt;image, Question, answer&gt;の3つ組で構成される。wikidataから特定の文化と紐づいたエンティティ（42カ国; 人,場所,組織,アーティファクトにフォーカス）を抽出し、関連するimage dataを1--3個程度wikimediaから収集。76種類のテンプレートを用いて、draftのQAを生成し、LLMを用いて洗練（文化的な自然さ、流暢さ）させる。最終的にVLM(Qwen2.5-VL-32B/72B or Gemma-3-12B/72B-Instructを文化ごとに強い方を選択して利用)を用いてirrelevantなimage, question, answerの三つ組をフィルタリング（relevanceのスコアリングと事実情報のverification)する。

<br>



<br>

ベースモデルとして

<br>

・2470

<br>



<br>

を利用(Qwen2-7Bに対してCLIPベースのvision encoderを利用したVLM)し、Vision Encoderはfrozenし、LLMとconnector（テキストと画像のモダリティの橋渡しをする（大抵は）MLP)のみをfinetuningした。catastrophic forgettingを防ぐために事前学習データの一部を補完しfinetuningでも利用し、エンティティの認識力を高めるためにM3LSデータなるものをフィルタリングして追加している。

<br>



<br>

Finetuningの結果、文化的な多様性を持つ評価データ（e.g., 2471 Figure1のJapaneseのサンプルを見ると一目でどのようなベンチか分かる）と一般的なマルチリンガルな評価データの双方でgainがあることを確認。

<br>

<img src="https://github.com/user-attachments/assets/61b33047-4c7c-4785-99f7-bcaa131bcfbf" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/8088e61f-ef46-4bcd-bc94-8d6f6318ca0e" alt="image" loading="lazy">

<br>



<br>

VQAによるフィルタリングで利用されたpromptは下記

<br>

<img src="https://github.com/user-attachments/assets/a9c5b463-a3e3-4565-b2f2-95268252179d" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Reproducibility.html">#Reproducibility</a>
<span class="issue_date">Issue Date: 2025-08-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2411">[Paper Note] Part I: Tricks or Traps? A Deep Dive into RL for LLM Reasoning, Zihe Liu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>強化学習（RL）を用いた大規模言語モデル（LLM）の推論に関する研究が進展する中、標準化されたガイドラインやメカニズムの理解が不足している。実験設定の不一致やデータの変動が混乱を招いている。本論文では、RL技術を体系的にレビューし、再現実験を通じて各技術のメカニズムや適用シナリオを分析。明確なガイドラインを提示し、実務者に信頼できるロードマップを提供する。また、特定の技術の組み合わせが性能を向上させることを示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/omarsar0/status/1955268799525265801?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q読んだ方が良い解説:https://x.com/jiqizhixin/status/1959799274059031039?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/SpeechProcessing.html">#SpeechProcessing</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/VisionLanguageActionModel.html">#VisionLanguageActionModel</a>
<span class="issue_date">Issue Date: 2025-08-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2407">[Paper Note] MolmoAct: Action Reasoning Models that can Reason in Space, Jason Lee+, arXiv'25</a>
<span class="snippet"><span>Summary</span>アクション推論モデル（ARMs）であるMolmoActは、知覚、計画、制御を三段階のパイプラインで統合し、説明可能で操作可能な行動を実現。シミュレーションと実世界で高いパフォーマンスを示し、特にSimplerEnv Visual Matchingタスクで70.5%のゼロショット精度を達成。MolmoAct Datasetを公開し、トレーニングによりベースモデルのパフォーマンスを平均5.5%向上。全てのモデルの重みやデータセットを公開し、ARMsの構築に向けたオープンな設計図を提供。</span>
<span class="snippet"><span>Comment</span>`Action Reasoning Models (ARMs)`

<br>



<br>

元ポスト:https://x.com/gm8xx8/status/1955168414294589844?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

blog: https://allenai.org/blog/molmoact関連:

<br>

・1426models:

<br>

・https://huggingface.co/allenai/MolmoAct-7B-D-Pretrain-0812

<br>

・https://huggingface.co/allenai/MolmoAct-7B-D-0812

<br>



<br>

datasets:

<br>

・https://huggingface.co/datasets/allenai/MolmoAct-Dataset

<br>

・https://huggingface.co/datasets/allenai/MolmoAct-Pretraining-Mixture

<br>

・https://huggingface.co/datasets/allenai/MolmoAct-Midtraining-Mixtureデータは公開されているが、コードが見当たらない？</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-08-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2406">[Paper Note] GLM-4.5: Agentic, Reasoning, and Coding （ARC） Foundation Models, GLM-4. 5 Team+, arXiv'25</a>
<span class="snippet"><span>Summary</span>355Bパラメータを持つオープンソースのMixture-of-ExpertsモデルGLM-4.5を発表。ハイブリッド推論手法を採用し、エージェント的、推論、コーディングタスクで高いパフォーマンスを達成。競合モデルに比べて少ないパラメータ数で上位にランクイン。GLM-4.5とそのコンパクト版GLM-4.5-Airをリリースし、詳細はGitHubで公開。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/grad62304977/status/1954805614011453706?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q・アーキテクチャ

<br>

  ・MoE / sigmoid gates

<br>

    ・1719

<br>

    ・1754

<br>

  ・loss free balanced routing

<br>

    ・2442

<br>

  ・widthを小さく、depthを増やすことでreasoning能力改善

<br>

  ・GQA w/ partial RoPE

<br>

    ・1271

<br>

    ・1310

<br>

  ・Attention Headsの数を2.5倍（何に対して2.5倍なんだ、、？）（96個, 5120次元）にすることで（おそらく）事前学習のlossは改善しなかったがReasoning benchmarkの性能改善

<br>

  ・QK Normを導入しattentionのlogitsの値域を改善

<br>

    ・2443

<br>

  ・Multi Token Prediction

<br>

    ・2444

<br>

    ・1620

<br>



<br>

他モデルとの比較

<br>

<img src="https://github.com/user-attachments/assets/6085b99e-3a76-432c-a759-91dd4feeb219" alt="image" loading="lazy">

<br>



<br>

学習部分は後で追記する・事前学習データ

<br>

  ・web

<br>

    ・英語と中国語のwebページを利用

<br>

    ・1944 と同様にquality scoreyをドキュメントに付与

<br>

    ・最も低いquality scoreの文書群を排除し、quality scoreの高い文書群をup sampling

<br>

    ・最もquality scoreyが大きい文書群は3.2 epoch分利用

<br>

    ・多くのweb pageがテンプレートから自動生成されており高いquality scoreが付与されていたが、MinHashによってdeduplicationできなかったため、 2445 を用いてdocument embeddingに基づいて類似した文書群を排除

<br>

  ・Multilingual

<br>

    ・独自にクロールしたデータとFineWeb-2 2109 から多言語の文書群を抽出し、quality classifierを適用することでeducational utilityを定量化し、高いスコアの文書群をupsamplingして利用

<br>

  ・code

<br>

    ・githubなどのソースコードhosting platformから収集

<br>

    ・ソースコードはルールベースのフィルタリングをかけ、その後言語ごとのquality modelsによって、high,middle, lowの3つに品質を分類

<br>

    ・high qualityなものはupsamplingし、low qualityなものは除外

<br>

    ・2446 で提案されているFill in the Middle objectiveをコードの事前学習では適用

<br>

    ・コードに関連するweb文書も事前学習で収集したテキスト群からルールベースとfasttextによる分類器で抽出し、ソースコードと同様のqualityの分類とサンプリング手法を適用。最終的にフィルタリングされた文書群はre-parseしてフォーマットと内容の品質を向上させた

<br>

  ・math &amp; science

<br>

    ・web page, 本, 論文から、reasoning能力を向上させるために、数学と科学に関する文書を収集

<br>

  ・LLMを用いて文書中のeducational contentの比率に基づいて文書をスコアリングしスコアを予測するsmall-scaleな分類器を学習

<br>

  ・最終的に事前学習コーパスの中の閾値以上のスコアを持つ文書をupsampling

<br>

・事前学習は2 stageに分かれており、最初のステージでは、"大部分は"generalな文書で学習する。次のステージでは、ソースコード、数学、科学、コーディング関連の文書をupsamplingして学習する。

<br>



<br>

上記以上の細かい実装上の情報は記載されていない。

<br>



<br>

mid-training / post trainingについても後ほど追記する</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-08-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2405">[Paper Note] Difficulty-Based Preference Data Selection by DPO Implicit Reward Gap, Xuan Qi+, arXiv'25</a>
<span class="snippet"><span>Summary</span>LLMの好みを人間に合わせるための新しいデータ選択戦略を提案。DPOの暗黙的報酬ギャップが小さいデータを選ぶことで、データ効率とモデルの整合性を向上。元のデータの10％で5つのベースラインを上回るパフォーマンスを達成。限られたリソースでのLLM整合性向上に寄与。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/zhijingjin/status/1954535751489667173?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qpreference pair dataを学習効率の良いサンプルのみに圧縮することで学習効率を上げたい系の話で、chosen, rejectedなサンプルのそれぞれについて、¥frac{現在のポリシーの尤度}{参照ポリシーの尤度}によってreward rを定義し（おそらく参照ポリシーの尤度によってサンプルの重要度を重みづけしている）、r_chosenとr_rejectedの差をreward gapと定義し、gapが大きいものは難易度が低いと判断してフィルタリングする、といった話に見える。

<br>

<img src="https://github.com/user-attachments/assets/1b930f5e-8db4-4c20-b7ca-59fb452f9056" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/ContextEngineering.html">#ContextEngineering</a>
<a class="button" href="articles/memory.html">#memory</a>
<span class="issue_date">Issue Date: 2025-08-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2403">[Paper Note] Memp: Exploring Agent Procedural Memory, Runnan Fang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、LLMに基づくエージェントに学習可能で更新可能な手続き的記憶を持たせるための戦略を提案。Mempを用いて過去のエージェントの軌跡を指示や抽象に蒸留し、記憶の構築と更新を行う。TravelPlannerとALFWorldでの実証評価により、記憶リポジトリが進化することでエージェントの成功率と効率が向上することを示した。また、強力なモデルからの手続き的記憶の移行により、弱いモデルでも性能向上が得られることが確認された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/zxlzr/status/1954840738082193477?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qアドホックに探索と実行を繰り返すのではなく、過去の試行のtrajectoryをメモリに記憶しておき、活用するような枠組みな模様。trajectoryは新たなタスクが来た際にretrieverでrelevantなtrajectoryを検索して利用され、良質なtrajectoryがキープされれば成功率や効率が向上すると考えられる。trajectoryはprocedure memoryとして保存され、成功率が低いtrajectoryは破棄されることで更新される。

<br>

<img src="https://github.com/user-attachments/assets/20e2f063-eef6-4c3d-9161-3d96f56c6f8d" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/a3766541-4946-4e43-91e4-99a873fb1d6f" alt="image" loading="lazy">

<br>



<br>

メモリはT個のタスクに対するs_t, a_t, o_t, i.e., state, action, observation,の系列τと、reward rが与えられた時に、Builderを通して構築されてストアされる。agentは新たなタスクt_newに直面した時に、t_newと類似したメモリをretrieyeする。これはτの中のある時刻tのタスクに対応する。メモリは肥大化していくため、実験では複数のアルゴリズムに基づくメモリの更新方法について実験している。

<br>

<img src="https://github.com/user-attachments/assets/b91dbfed-c976-4764-abf6-00f4751b7e91" alt="image" loading="lazy">

<br>



<br>

procedural memoryの有無による挙動の違いに関するサンプル。

<br>

<img src="https://github.com/user-attachments/assets/2623103d-331d-45eb-a5cc-635ef3cb88ab" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/b1c21bf3-eef1-4b4c-999c-f8d0fcbc9431" alt="image" loading="lazy">memoryに対してretrieverを適用することになるので、retrieverの性能がボトルネックになると思われる。追加の学習をしなくて済むのは利点だが、その代わりモデル側がメモリ管理をする機能を有さない（学習すればそういった機能を持たせられるはず）ので、その点は欠点となる、という印象。簡易解説:

<br>

https://x.com/huggingpapers/status/1954937801490772104?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<span class="issue_date">Issue Date: 2025-08-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2402">[Paper Note] NoCode-bench: A Benchmark for Evaluating Natural Language-Driven Feature  Addition, Le Deng+, arXiv'25</a>
<span class="snippet"><span>Summary</span>自然言語駆動のノーコード開発におけるLLMsの評価のために「NoCode-bench」を提案。634のタスクと114,000のコード変更から成り、ドキュメントとコード実装のペアを検証。実験結果では、最良のLLMsがタスク成功率15.79%に留まり、完全なNL駆動のノーコード開発には未だ課題があることが示された。NoCode-benchは今後の進展の基盤となる。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jiqizhixin/status/1955062236831158763?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qリーダーボード:https://nocodebench.orgドキュメントをソフトウェアの仕様書とみなし、ドキュメントの更新部分をらinputとし、対応する"機能追加"をする能力を測るベンチマーク

<br>



<br>

<img src="https://github.com/user-attachments/assets/249973b0-4c81-468d-91cd-13a3b93e31e7" alt="image" loading="lazy">

<br>



<br>

SoTAモデルでも15.79%程度しか成功しない。

<br>

<img src="https://github.com/user-attachments/assets/f8bab8c8-e5da-46c5-981a-1398021e030d" alt="image" loading="lazy">

<br>



<br>

元ポストによると、ファイルを跨いだ編集、コードベースの理解、tool useに苦労しているとのこと。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/ReversalCurse.html">#ReversalCurse</a>
<span class="issue_date">Issue Date: 2025-08-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2399">[Paper Note] Physics of Language Models: Part 3.2, Knowledge Manipulation, Zeyuan Allen-Zhu+, ICLR'25</a>
<span class="snippet"><span>Summary</span>言語モデルは豊富な知識を持つが、下流タスクへの柔軟な利用には限界がある。本研究では、情報検索、分類、比較、逆検索の4つの知識操作タスクを調査し、言語モデルが知識検索には優れているが、Chain of Thoughtsを用いないと分類や比較タスクで苦労することを示した。特に逆検索ではパフォーマンスがほぼ0%であり、これらの弱点は言語モデルに固有であることを確認した。これにより、現代のAIと人間を区別する新たなチューリングテストの必要性が浮き彫りになった。</span>
<span class="snippet"><span>Comment</span>openreview:https://openreview.net/forum?id=oDbiL9CLoS解説:

<br>

・1834</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SelfCorrection.html">#SelfCorrection</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2025-08-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2398">[Paper Note] Physics of Language Models: Part 2.2, How to Learn From Mistakes on   Grade-School Math Problems, Tian Ye+, ICLR'25</a>
<span class="snippet"><span>Summary</span>言語モデルの推論精度向上のために、「エラー修正」データを事前学習に組み込む有用性を探求。合成数学データセットを用いて、エラーフリーデータと比較して高い推論精度を達成することを示す。さらに、ビームサーチとの違いやデータ準備、マスキングの必要性、エラー量、ファインチューニング段階での遅延についても考察。</span>
<span class="snippet"><span>Comment</span>openreview:https://openreview.net/forum?id=zpDGwcmMV4解説:

<br>

・1834</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2025-08-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2397">[Paper Note] Physics of Language Models: Part 2.1, Grade-School Math and the Hidden   Reasoning Process, Tian Ye+, ICLR'25</a>
<span class="snippet"><span>Summary</span>言語モデルの数学的推論能力を研究し、GSM8Kベンチマークでの精度向上のメカニズムを探る。具体的には、推論スキルの発展、隠れたプロセス、人間との違い、必要なスキルの超越、推論ミスの原因、モデルのサイズや深さについての実験を行い、LLMの理解を深める洞察を提供。</span>
<span class="snippet"><span>Comment</span>openreview:https://openreview.net/forum?id=Tn5B6Udq3E解説:

<br>

・1834</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<span class="issue_date">Issue Date: 2025-08-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2396">[Paper Note] Fast and Simplex: 2-Simplicial Attention in Triton, Aurko Roy+, arXiv'25</a>
<span class="snippet"><span>Summary</span>2-シンプリシアルトランスフォーマーを用いることで、トークン効率を向上させ、標準的なトランスフォーマーよりも優れた性能を発揮することを示す。固定されたトークン予算内で、数学や推論タスクにおいてドット積アテンションを上回る結果を得た。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/scaling01/status/1954682957798715669?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-08-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2393">[Paper Note] STEPWISE-CODEX-Bench: Evaluating Complex Multi-Function Comprehension  and Fine-Grained Execution Reasoning, Kaiwen Yan+, arXiv'25</a>
<span class="snippet"><span>Summary</span>新しいベンチマーク「STEPWISE-CODEX-Bench（SX-Bench）」を提案し、複雑な多機能理解と細かい実行推論を評価。SX-Benchは、サブ関数間の協力を含むタスクを特徴とし、動的実行の深い理解を測定する。20以上のモデルで評価した結果、最先端モデルでも複雑な推論においてボトルネックが明らかに。SX-Benchはコード評価を進展させ、高度なコードインテリジェンスモデルの評価に貢献する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gm8xx8/status/1954296753525752266?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q現在の主流なコード生成のベンチは、input/outputがgivenなら上でコードスニペットを生成する形式が主流(e.g., MBPP 2439, HumanEval 2438)だが、モデルがコードを理解し、複雑なコードのロジックを実行する内部状態の変化に応じて、実行のプロセスを推論する能力が見落とされている。これを解決するために、CRUXEVAL 2440, CRUXEVAL-X 2441 では、関数のinputs/outputsを予測することで、モデルのコードのcomprehension, reasoning能力を測ろうとしているが、

<br>

・single functionのlogicに限定されている

<br>

・20 line程度の短く、trivialなロジックに限定されている

<br>

・すでにSoTAモデルで95%が達成され飽和している

<br>



<br>

というlimitationがあるので、複数の関数が協働するロジック、flow/dataのinteractionのフロー制御、細かい実行ステップなどを含む、staticなコードの理解から、動的な実行プロセスのモデリング能力の評価にシフトするような、新たなベンチマークを作成しました、という話な模様。

<br>



<br>

まず関数単位のライブラリを構築している。このために、単一の関数の基礎的な仕様を「同じinputに対して同じoutputを返すものは同じクラスにマッピングされる」と定義し、既存のコードリポジトリとLLMによる合成によって、GoとPythonについて合計30種類のクラスと361個のインスタンスを収集。これらの関数は、算術演算や大小比較、パリティチェックなどの判定、文字列の操作などを含む。そしてこれら関数を3種類の実行パターンでオーケストレーションすることで、合成関数を作成した。合成方法は

<br>

・Sequential: outputとinputをパイプラインでつなぎ伝搬させる

<br>

・Selective: 条件に応じてf(x)が実行されるか、g(x)が実行されるかを制御

<br>

・Loop: input集合に対するloopの中に関数を埋め込み順次関数を実行

<br>



<br>

の3種類。合成関数の挙動を評価するために、ランダムなテストケースは自動生成し、合成関数の挙動をモニタリング（オーバーフロー、無限ループ、タイムアウト、複数回の実行でoutputが決定的か等など）し、異常があるものはフィルタリングすることで合成関数の品質を担保する。

<br>



<br>

ベンチマーキングの方法としては、CRUXEVALではシンプルにモデルにコードの実行結果を予想させるだけであったが、指示追従能力の問題からミスジャッジをすることがあるため、この問題に対処するため&lt;input, output&gt;のペアが与えられた時に、outputが合成関数に対してinputしま結果とマッチするかをyes/noのbinaryで判定させる（Predictと呼ばれるモデルのコード理解力を評価)。これとは別に、与えられたinput, outputペアと合成関数に基づいて、実行時の合計のcomputation stepsを出力させるタスクをreasoningタスクとして定義し、複雑度に応じてeasy, hardに分類している。computation stepsは、プログラムを実行する最小単位のことであり、たとえば算術演算などの基礎的なarithmetic/logic operationを指す。

<br>

<img src="https://github.com/user-attachments/assets/8ac34d8c-63e4-42d7-96ea-13dbe39ad683" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/76407c5b-acd0-40ef-a698-684875ccc680" alt="image" loading="lazy"></span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/RLVR.html">#RLVR</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<span class="issue_date">Issue Date: 2025-08-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2392">[Paper Note] StructVRM: Aligning Multimodal Reasoning with Structured and Verifiable  Reward Models, Xiangxiang Zhang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>StructVRMは、複雑な多質問推論タスクにおいて、部分的な正確性を評価するための構造化された検証可能な報酬モデルを導入。サブ質問レベルのフィードバックを提供し、微妙な部分的なクレジットスコアリングを可能にする。実験により、Seed-StructVRMが12のマルチモーダルベンチマークのうち6つで最先端のパフォーマンスを達成したことが示された。これは、複雑な推論におけるマルチモーダルモデルの能力向上に寄与する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gm8xx8/status/1954315513397760130?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q複数のsub-questionが存在するような複雑な問題に対して、既存のRLVRにおける全体に対してbinary rewardを適用する方法は報酬が荒すぎるため、よりfine-grainedなverifiableな報酬を設計することで、学習を安定化し性能も向上

<br>

<img src="https://github.com/user-attachments/assets/e3bf6ca8-6873-4d42-83c8-4e9148c16d1d" alt="image" loading="lazy">

<br>



<br>

以下がverifierのサンプル

<br>

<img src="https://github.com/user-attachments/assets/c02274a4-5979-402c-a9c8-145cb1b284bf" alt="image" loading="lazy">general purposeなreal worldに対するmultimodal reasoningシステムを作成するには高品質で多様なデータが必要なので、以下のようなパイプラインを用いて、学習データを合成している模様。後で読む。サマリが元ポストに記載されているので全体像をざっくり知りたい場合は参照のこと。

<br>

<img src="https://github.com/user-attachments/assets/6f3b7503-cd3a-4d32-9080-51b875901c23" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/SyntheticDataGeneration.html">#SyntheticDataGeneration</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<span class="issue_date">Issue Date: 2025-08-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2390">[Paper Note] MathSmith: Towards Extremely Hard Mathematical Reasoning by Forging  Synthetic Problems with a Reinforced Policy, Shaoxiong Zhan+, arXiv'25</a>
<span class="snippet"><span>Summary</span>MathSmithという新しいフレームワークを提案し、LLMの数学的推論を強化するために新しい問題をゼロから合成。既存の問題を修正せず、PlanetMathから概念と説明をランダムにサンプリングし、データの独立性を確保。9つの戦略を用いて難易度を上げ、強化学習で構造的妥当性や推論の複雑さを最適化。実験では、MathSmithが既存のベースラインを上回り、高難易度の合成データがLLMの推論能力を向上させる可能性を示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gm8xx8/status/1954253929761411180?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<a class="button" href="articles/ZeroData.html">#ZeroData</a>
<span class="issue_date">Issue Date: 2025-08-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2387">[Paper Note] R-Zero: Self-Evolving Reasoning LLM from Zero Data, Chengsong Huang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>R-Zeroは、自己進化型大規模言語モデル（LLMs）が自律的にトレーニングデータを生成するフレームワークで、チャレンジャーとソルバーの2つのモデルが共進化することで、既存のタスクやラベルに依存せずに自己改善を実現します。このアプローチにより、推論能力が大幅に向上し、特にQwen3-4B-Baseでは数学推論で+6.49、一般ドメイン推論で+7.54の改善が確認されました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_akhaliq/status/1953804055525962134?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q問題を生成するChallengerと与えられた問題を解くSolverを用意し、片方をfreezezさせた状態で交互にポリシーの更新を繰り返す。

<br>



<br>

<img src="https://github.com/user-attachments/assets/05207756-3029-41a2-8dd0-e27de5228436" alt="image" loading="lazy">

<br>



<br>

Challenger

<br>

・ （Challengerによる)問題生成→

<br>

・（freezed solverによる）self consistencyによるラベル付け→

<br>

・Solverの問題に対するempirical acc.（i.e., サンプリング回数mに対するmajorityが占める割合）でrewardを与えChallengerを更新

<br>



<br>

といった流れでポリシーが更新される。Rewardは他にも生成された問題間のBLEUを測り類似したものばかりの場合はペナルティを与える項や、フォーマットが正しく指定された通りになっているか、といったペナルティも導入する。

<br>



<br>

Solver

<br>

・ChallengerのポリシーからN問生成し、それに対してSolverでself consistencyによって解答を生成

<br>

・empirical acc.を計算し、1/2との差分の絶対値を見て、簡単すぎる/難しすぎる問題をフィルタリング

<br>

  ・これはカリキュラム学習的な意味合いのみならず、低品質な問題のフィルタリングにも寄与する

<br>

・フィルタリング後の問題を利用して、verifiable binary rewardでポリシーを更新

<br>



<br>

評価結果

<br>

数学ドメインに提案手法を適用したところ、iterごとに全体の平均性能は向上。

<br>

<img src="https://github.com/user-attachments/assets/cbe780ec-a99b-4227-b983-4e24982a6af8" alt="image" loading="lazy">

<br>



<br>

提案手法で数学ドメインを学習し、generalドメインに汎化するか？を確認したところ、汎化することを確認（ただ、すぐにサチっているようにも見える）。、

<br>

<img src="https://github.com/user-attachments/assets/bc0eb3e1-8ed1-4d36-b30e-095e8a160886" alt="image" loading="lazy">関連:

<br>

・2383

<br>

・1936著者ポスト:

<br>

・https://x.com/wyu_nd/status/1954249813861810312?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・https://x.com/chengsongh31219/status/1953936172415430695?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q日本語解説:

<br>

https://x.com/curveweb/status/1954367657811308858?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<a class="button" href="articles/ZeroData.html">#ZeroData</a>
<span class="issue_date">Issue Date: 2025-08-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2383">[Paper Note] Self-Questioning Language Models, Lili Chen+, arXiv'25</a>
<span class="snippet"><span>Summary</span>自己質問型言語モデル（SQLM）を提案し、トピックを指定するプロンプトから自ら質問を生成し、解答する非対称の自己対戦フレームワークを構築。提案者と解答者は強化学習で訓練され、問題の難易度に応じて報酬を受け取る。三桁の掛け算や代数問題、プログラミング問題のベンチマークで、外部データなしで言語モデルの推論能力を向上させることができることを示す。</span>
<span class="snippet"><span>Comment</span>pj page:https://self-questioning.github.io元ポスト:https://x.com/lchen915/status/1953896909925757123?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qたとえば下記のような、ラベル無しの外部データを利用する手法も用いてself improvingする手法と比較したときに、どの程度の性能差になるのだろうか？外部データを全く利用せず、外部データありの手法と同等までいけます、という話になると、より興味深いと感じた。

<br>



<br>

・1212既存の外部データを活用しない関連研究:

<br>

・1936</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-08-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2382">[Paper Note] On the Generalization of SFT: A Reinforcement Learning Perspective with  Reward Rectification, Yongliang Wu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLM）の教師ありファインチューニング（SFT）の一般化能力を向上させるため、動的ファインチューニング（DFT）を提案。DFTはトークンの確率に基づいて目的関数を再スケーリングし、勾配更新を安定化させる。これにより、SFTを大幅に上回る性能を示し、オフライン強化学習でも競争力のある結果を得た。理論的洞察と実践的解決策を結びつけ、SFTの性能を向上させる。コードは公開されている。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/theturingpost/status/1953960036126142645?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qこれは大変興味深い。数学以外のドメインでの評価にも期待したい。3節冒頭から3.2節にかけて、SFTとon policy RLのgradientを定式化し、SFT側の数式を整理することで、SFT（のgradient)は以下のようなon policy RLの一つのケースとみなせることを導出している。そしてSFTの汎化性能が低いのは 1/pi_theta によるimportance weightingであると主張し、実験的にそれを証明している。つまり、ポリシーがexpertのgold responseに対して低い尤度を示してしまった場合に、weightか過剰に大きくなり、Rewardの分散が過度に大きくなってしまうことがRLの観点を通してみると問題であり、これを是正することが必要。さらに、分散が大きい報酬の状態で、報酬がsparse(i.e., expertのtrajectoryのexact matchしていないと報酬がzero)であることが、さらに事態を悪化させている。

<br>



<br>

&gt; conventional SFT is precisely an on-policy-gradient with the reward as an indicator function of

<br>

matching the expert trajectory but biased by an importance weighting 1/πθ.

<br>



<br>

まだ斜め読みしかしていないので、後でしっかり読みたい最近は下記で示されている通りSFTでwarm-upをした後にRLによるpost-trainingをすることで性能が向上することが示されており、

<br>

・1746 

<br>



<br>

主要なOpenModelでもSFT wamup -&gt; RLの流れが主流である。この知見が、SFTによるwarm upの有効性とどう紐づくだろうか？

<br>

これを読んだ感じだと、importance weightによって、現在のポリシーが苦手な部分のreasoning capabilityのみを最初に強化し（= warmup）、その上でより広範なサンプルに対するRLが実施されることによって、性能向上と、学習の安定につながっているのではないか？という気がする。日本語解説:https://x.com/hillbig/status/1960108668336390593?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

一歩先の視点が考察されており、とても勉強になる。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<span class="issue_date">Issue Date: 2025-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2381">[Paper Note] A comprehensive taxonomy of hallucinations in Large Language Models, Manuel Cossio, arXiv'25</a>
<span class="snippet"><span>Summary</span>LLMのハルシネーションに関する包括的な分類法を提供し、その本質的な避けられなさを提唱。内因的および外因的な要因、事実誤認や不整合などの具体的な現れを分析。根本的な原因や認知的要因を検討し、評価基準や軽減戦略を概説。今後は、信頼性のある展開のために検出と監視に焦点を当てる必要があることを強調。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/sei_shinagawa/status/1953845008588513762?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<a class="button" href="articles/RewardHacking.html">#RewardHacking</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<a class="button" href="articles/On-Policy.html">#On-Policy</a>
<span class="issue_date">Issue Date: 2025-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2376">[Paper Note] Learning to Reason for Factuality, Xilun Chen+, arXiv'25</a>
<span class="snippet"><span>Summary</span>R-LLMsは複雑な推論タスクで進展しているが、事実性において幻覚を多く生成する。オンラインRLを長文の事実性設定に適用する際、信頼できる検証方法が不足しているため課題がある。従来の自動評価フレームワークを用いたオフラインRLでは報酬ハッキングが発生することが判明。そこで、事実の精度、詳細レベル、関連性を考慮した新しい報酬関数を提案し、オンラインRLを適用。評価の結果、幻覚率を平均23.1ポイント削減し、回答の詳細レベルを23%向上させた。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jaseweston/status/1953629692772446481?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q先行研究:

<br>

・2378Reasoning ModelのHallucination Rateは、そのベースとなるモデルよりも高い。実際、DeepSeek-V3とDeepSeek-R1,Qwen-2.5-32BとQwQ-32Bを6つのFactualityに関するベンチマークで比較すると、Reasoning Modelの方がHallucination Rateが10, 13%程度高かった。これは、現在のOn-policyのRLがlogical reasoningにフォーカスしており、Factualityを見落としているため、と仮説を立てている。

<br>

Factuality（特にLongForm)とRL alignmentsという観点から言うと、決定的、正確かつ信頼性のあるverificatlon手法は存在せず、Human Effortが必要不可欠である。

<br>

自動的にFactualityを測定するFactScoreのような手法は、DPOのようなオフラインのペアワイズのデータを作成するに留まってしまっている。また、on dataでFactualityを改善する取り組みは行われているが、long-formな応答に対して、factual reasoningを実施するにはいくつかの課題が残されている:

<br>

・reward design

<br>

  ・Factualityに関するrewardを単独で追加するだけだと、LLMは非常に短く、詳細を省略した応答をしPrecicionのみを高めようとしてしまう。

<br>



<br>

あとで追記する</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2025-08-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2352">[Paper Note] On the Expressiveness of Softmax Attention: A Recurrent Neural Network  Perspective, Gabriel Mongaras+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、ソフトマックスアテンションの再帰的な形式を導出し、線形アテンションがその近似であることを示す。これにより、ソフトマックスアテンションの各部分をRNNの言語で説明し、構成要素の重要性と相互作用を理解する。これにより、ソフトマックスアテンションが他の手法よりも表現力が高い理由を明らかにする。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1952485214162407644?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLinearAttention関連の研究は下記あたりがありそう？

<br>

・2353

<br>

・2354 

<br>

・2355

<br>

・2356・1271

<br>



<br>

たとえばGQAはQwen3で利用されているが、本研究の知見を活用してscaled-dot product attention計算時のSoftmax計算の計算量が削減できたら、さらに計算量が削減できそう？</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2025-08-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2350">[Paper Note] MLE-STAR: Machine Learning Engineering Agent via Search and Targeted  Refinement, Jaehyun Nam+, arXiv'25</a>
<span class="snippet"><span>Summary</span>MLE-STARは、LLMを用いてMLモデルを自動実装する新しいアプローチで、ウェブから効果的なモデルを取得し、特定のMLコンポーネントに焦点を当てた戦略を探索することで、コード生成の精度を向上させる。実験結果では、MLE-STARがKaggleコンペティションの64%でメダルを獲得し、他の手法を大きく上回る性能を示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/marktechpost/status/1951846630266687927?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/On-Policy.html">#On-Policy</a>
<a class="button" href="articles/CrossDomain.html">#CrossDomain</a>
<span class="issue_date">Issue Date: 2025-08-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2341">[Paper Note] SRPO: A Cross-Domain Implementation of Large-Scale Reinforcement  Learning on LLM, Xiaojiang Zhang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>二段階履歴再サンプリングポリシー最適化（SRPO）を提案し、DeepSeek-R1-Zero-32Bを上回る性能をAIME24およびLiveCodeBenchで達成。SRPOはトレーニングステップを約1/10に削減し、効率性を示す。二つの革新として、クロスドメイントレーニングパラダイムと履歴再サンプリング技術を導入し、LLMの推論能力を拡張するための実験を行った。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jiqizhixin/status/1914920300359377232?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QGRPOよりもより効率的な手法な模様。最初に数学のデータで学習をしReasoning Capabilityを身につけさせ、その後別のドメインのデータで学習させることで、その能力を発揮させるような二段階の手法らしい。

<br>



<br>

Datamixingよりも高い性能（ただし、これは数学とコーディングのCoT Lengthのドメイン間の違いに起因してこのような2 stageな手法にしているようなのでその点には注意が必要そう）？しっかりと読めていないので、読み違いの可能性もあるので注意。

<br>

<img src="https://github.com/user-attachments/assets/cf00de8b-1923-4f23-b575-0a889517ec9e" alt="image" loading="lazy">なんたらRPO多すぎ問題</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Optimizer.html">#Optimizer</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<a class="button" href="articles/ModelMerge.html">#ModelMerge</a>
<a class="button" href="articles/Stability.html">#Stability</a>
<span class="issue_date">Issue Date: 2025-08-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2340">[Paper Note] WSM: Decay-Free Learning Rate Schedule via Checkpoint Merging for LLM  Pre-training, Changxin Tian+, arXiv'25</a>
<span class="snippet"><span>Summary</span>学習率スケジューリングの新たなアプローチとして、Warmup-Stable and Merge（WSM）を提案。WSMは、学習率の減衰とモデルマージの関係を確立し、さまざまな減衰戦略を統一的に扱う。実験により、マージ期間がモデル性能において重要であることを示し、従来のWSDアプローチを上回る性能向上を達成。特に、MATHで+3.5%、HumanEvalで+2.9%、MMLU-Proで+5.5%の改善を記録。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/stochasticchasm/status/1951427541803106714?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QWeight Decayを無くせるらしいエッセンスの解説:https://x.com/wenhaocha1/status/1951790366900019376?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

チェックポイントさえ保存しておいて事後的に活用することだで、細かなハイパラ調整のための試行錯誤する手間と膨大な計算コストがなくなるのであれば相当素晴らしいのでは…？</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-08-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2334">[Paper Note] CoT-Self-Instruct: Building high-quality synthetic prompts for reasoning  and non-reasoning tasks, Ping Yu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>CoT-Self-Instructを提案し、LLMに基づいて新しい合成プロンプトを生成する手法を開発。合成データはMATH500やAMC23などで既存データセットを超える性能を示し、検証不可能なタスクでも人間や標準プロンプトを上回る結果を得た。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jaseweston/status/1951084679286722793?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qより複雑で、Reasoningやplanningを促すようなinstructionが生成される模様。実際に生成されたinstructionのexampleは全体をざっとみた感じこの図中のもののみのように見える。

<br>

<img src="https://github.com/user-attachments/assets/98dcb6a3-686f-4e3d-bf83-7b36765c0953" alt="image" loading="lazy">以下のスクショはMagpieによって合成されたinstruction。InstructionTuning用のデータを合成するならMagpieが便利そうだなぁ、と思っていたのだが、比較するとCoT-SelfInstructの方が、より複雑で具体的な指示を含むinstructionが生成されるように見える。

<br>



<br>

・2094

<br>



<br>

<img src="https://github.com/user-attachments/assets/a631a2bc-d2ee-49dd-96a1-00354ff1f40a" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-08-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2332">[Paper Note] Beyond Binary Rewards: Training LMs to Reason About Their Uncertainty, Mehul Damani+, arXiv'25</a>
<span class="snippet"><span>Summary</span>RLCRを用いた言語モデルの訓練により、推論の精度と信頼度を同時に改善。バイナリ報酬に加え、信頼度推定のためのブライヤースコアを用いた報酬関数を最適化。RLCRは、通常のRLよりもキャリブレーションを改善し、精度を損なうことなく信頼性の高い推論モデルを生成することを示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/asap2650/status/1950942279872762272?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLLMにConfidenceをDiscreteなTokenとして（GEvalなどは除く）出力させると信頼できないことが多いので、もしそれも改善するのだとしたら興味深い。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Composition.html">#Composition</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/InstructionFollowingCapability.html">#InstructionFollowingCapability</a>
<a class="button" href="articles/CommonsenseReasoning.html">#CommonsenseReasoning</a>
<span class="issue_date">Issue Date: 2025-07-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2328">[Paper Note] Revisiting Compositional Generalization Capability of Large Language   Models Considering Instruction Following Ability, Yusuke Sakai+, ACL'25</a>
<span class="snippet"><span>Summary</span>Ordered CommonGenを提案し、LLMsの指示に従う能力と構成的一般化能力を評価するベンチマークを構築。36のLLMsを分析した結果、指示の意図は理解しているが、概念の順序に対するバイアスが低多様性の出力を引き起こすことが判明。最も指示に従うLLMでも約75%の順序付きカバレッジしか達成できず、両能力の改善が必要であることを示唆。</span>
<span class="snippet"><span>Comment</span>LLMの意味の構成性と指示追従能力を同時に発揮する能力を測定可能なOrderedCommonGenを提案

<br>



<br>

<img src="https://github.com/user-attachments/assets/ae8c9468-a788-4baa-a618-402eae92c6c8" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/24ba68b4-3484-4597-a401-1e47183276cf" alt="image" loading="lazy">関連:

<br>

・2330</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<span class="issue_date">Issue Date: 2025-07-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2325">[Paper Note] Efficient Attention Mechanisms for Large Language Models: A Survey, Yutao Sun+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Transformerアーキテクチャの自己注意の複雑さが長文コンテキストモデリングの障害となっている。これに対処するため、線形注意手法とスパース注意技術が導入され、計算効率を向上させつつコンテキストのカバレッジを保持する。本研究は、これらの進展を体系的にまとめ、効率的な注意を大規模言語モデルに組み込む方法を分析し、理論と実践を統合したスケーラブルなモデル設計の基礎を提供することを目指す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/omarsar0/status/1950287053046022286?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q<img src="https://github.com/user-attachments/assets/df56fa40-4206-4d12-9172-39f7b36f19c7" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/SelfCorrection.html">#SelfCorrection</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<span class="issue_date">Issue Date: 2025-07-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2321">[Paper Note] A Survey of Self-Evolving Agents: On Path to Artificial Super  Intelligence, Huan-ang Gao+, arXiv'25</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）は静的であり、動的な環境に適応できないため、自己進化するエージェントの必要性が高まっている。本調査は、自己進化するエージェントに関する初の包括的レビューを提供し、進化の基礎的な次元を整理。エージェントの進化的メカニズムや適応手法を分類し、評価指標や応用分野を分析。最終的には、エージェントが自律的に進化し、人間レベルの知能を超える人工超知能（ASI）の実現を目指す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/ottamm_190/status/1950331148741333489?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QFigure3がとても勉強になる。Self-Evolveと呼んだ時に、それがどのようにEvolveするものなのかはきちんとチェックした方が良さそう。追加の学習をするのか否かなど。これによって使いやすさが段違いになりそうなので。

<br>

<img src="https://github.com/user-attachments/assets/bfa7e8b3-2a5b-4b26-b474-deaee443ee25" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/bcaaadda-ef9b-49dc-a357-3cb6fdf01ca4" alt="image" loading="lazy"></span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<a class="button" href="articles/CLIP.html">#CLIP</a>
<span class="issue_date">Issue Date: 2025-07-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2320">[Paper Note] MetaCLIP 2: A Worldwide Scaling Recipe, Yung-Sung Chuang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>MetaCLIP 2を提案し、CLIPをゼロから訓練するための新しいアプローチを示す。英語と非英語データの相互利益を得るための最小限の変更を加え、ゼロショットのImageNet分類で英語専用モデルを上回る性能を達成。多言語ベンチマークでも新たな最先端を記録。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jaseweston/status/1950366185742016935?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2025-07-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2317">[Paper Note] On The Role of Pretrained Language Models in General-Purpose Text  Embeddings: A Survey, Meishan Zhang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本調査では、事前学習済み言語モデル（PLMs）を活用した一般目的のテキスト埋め込み（GPTE）の発展を概観し、PLMsの役割に焦点を当てる。基本的なアーキテクチャや埋め込み抽出、表現力向上、トレーニング戦略について説明し、PLMsによる多言語サポートやマルチモーダル統合などの高度な役割も考察する。さらに、将来の研究方向性として、ランキング統合やバイアス軽減などの改善目標を超えた課題を強調する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/bo_wangbo/status/1950158633645363465?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QGPTEの学習手法テキストだけでなく、画像やコードなどの様々なモーダル、マルチリンガル、データセットや評価方法、パラメータサイズとMTEBの性能の関係性の図解など、盛りだくさんな模様。最新のものだけでなく、2021年頃のT5から最新モデルまで網羅的にまとまっている。日本語特化のモデルについては記述が無さそうではある。

<br>



<br>

<img src="https://github.com/user-attachments/assets/f0a40a10-7f29-4aaf-b989-672213622ebc" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/7940d307-f1db-421f-86a4-6c9cca22f27c" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/46282995-d538-4bd2-9aa5-983253a98f8f" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/dc4212de-19df-497c-951e-3addff5a193f" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/ac925f56-de46-49ae-b0a8-cd8e2ecc4994" alt="image" loading="lazy">日本語モデルについてはRuriのテクニカルペーパーや、LLM勉強会のまとめを参照のこと

<br>

・1375

<br>

・1563</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/AES(AutomatedEssayScoring).html">#AES(AutomatedEssayScoring)</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/AIED.html">#AIED</a>
<span class="issue_date">Issue Date: 2025-07-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2315">[Paper Note] Do We Need a Detailed Rubric for Automated Essay Scoring using Large   Language Models?, Lui Yoshida, AIED'25</a>
<span class="snippet"><span>Summary</span>本研究では、LLMを用いた自動エッセイ採点におけるルーブリックの詳細さが採点精度に与える影響を調査。TOEFL11データセットを用いて、完全なルーブリック、簡略化されたルーブリック、ルーブリックなしの3条件を比較。結果、3つのモデルは簡略化されたルーブリックでも精度を維持し、トークン使用量を削減。一方、1つのモデルは詳細なルーブリックで性能が低下。簡略化されたルーブリックが多くのLLMにとって効率的な代替手段であることが示唆されるが、モデルごとの評価も重要。</span>
<a class="button" href="articles/Multi.html">#Multi</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2025-07-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2314">[Paper Note] EduThink4AI: Translating Educational Critical Thinking into Multi-Agent  LLM Systems, Xinmeng Hou+, arXiv'25</a>
<span class="snippet"><span>Summary</span>EDU-Promptingは、教育的批判的思考理論とLLMエージェント設計を結びつけ、批判的でバイアスを意識した説明を生成する新しいマルチエージェントフレームワーク。これにより、AI生成の教育的応答の真実性と論理的妥当性が向上し、既存の教育アプリケーションに統合可能。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dair_ai/status/1949481352325128236?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QCritiqueを活用したマルチエージェントのようである（具体的なCritiqueの生成方法については読めていない。その辺が重要そう

<br>



<br>

<img src="https://github.com/user-attachments/assets/a2e73806-a87f-4eab-a83f-b8767d4cd316" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/92256b2a-b655-4b6f-a288-67ff4893c77b" alt="image" loading="lazy"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<span class="issue_date">Issue Date: 2025-07-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2313">[Paper Note] Learning without training: The implicit dynamics of in-context learning, Benoit Dherin+, arXiv'25</a>
<span class="snippet"><span>Summary</span>LLMは文脈内で新しいパターンを学習する能力を持ち、そのメカニズムは未解明である。本研究では、トランスフォーマーブロックが自己注意層とMLPを重ねることで、文脈に応じてMLPの重みを暗黙的に修正できることを示し、このメカニズムがLLMの文脈内学習の理由である可能性を提案する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/omarsar0/status/1948384435654779105?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説:https://x.com/hillbig/status/1950333455134576794?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/Length.html">#Length</a>
<span class="issue_date">Issue Date: 2025-07-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2310">[Paper Note] Beyond Matryoshka: Revisiting Sparse Coding for Adaptive Representation, Tiansheng Wen+, arXiv'25</a>
<span class="snippet"><span>Summary</span>スパースコーディングを用いたContrastive Sparse Representation（CSR）を提案し、適応的な埋め込みを実現。CSRは事前訓練された埋め込みをスパース化し、意味的品質を保持しつつコスト効果の高い推論を可能にする。実験により、CSRは精度と検索速度でMatryoshka Representation Learning（MRL）を上回り、訓練時間も大幅に短縮されることが示された。スパースコーディングは実世界のアプリケーションにおける適応的な表現学習の強力な手法として位置づけられる。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1949957739637002450?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qマトリョーシカ表現:

<br>

・2311</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/Trustfulness.html">#Trustfulness</a>
<span class="issue_date">Issue Date: 2025-07-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2306">[Paper Note] Rectifying Belief Space via Unlearning to Harness LLMs' Reasoning, Ayana Niwa+, ACL'25</a>
<span class="snippet"><span>Summary</span>LLMの不正確な回答は虚偽の信念から生じると仮定し、信念空間を修正する方法を提案。テキスト説明生成で信念を特定し、FBBSを用いて虚偽の信念を抑制、真の信念を強化。実証結果は、誤った回答の修正とモデル性能の向上を示し、一般化の改善にも寄与することを示唆。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/ayaniwa1213/status/1949750575123276265?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<a class="button" href="articles/ActivationSteering/ITI.html">#ActivationSteering/ITI</a>
<a class="button" href="articles/Trustfulness.html">#Trustfulness</a>
<span class="issue_date">Issue Date: 2025-07-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2303">[Paper Note] GrAInS: Gradient-based Attribution for Inference-Time Steering of LLMs  and VLMs, Duy Nguyen+, arXiv'25</a>
<span class="snippet"><span>Summary</span>GrAInSは、LLMsおよびVLMsの推論時に内部活性を調整する新しいステアリング手法で、固定された介入ベクトルに依存せず、トークンの因果的影響を考慮します。統合勾配を用いて、出力への寄与に基づき重要なトークンを特定し、望ましい行動への変化を捉えるベクトルを構築します。これにより、再訓練なしでモデルの挙動を細かく制御でき、実験ではファインチューニングや既存手法を上回る成果を示しました。具体的には、TruthfulQAで精度を13.22%向上させ、MMHal-Benchの幻覚率を低下させ、SPA-VLでのアライメント勝率を改善しました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/duynguyen772/status/1948768520587866522?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q既存のsteering手法は、positive/negativeなサンプルからの差分で単一方向のベクトルを算出し、すべてのトークンに足し合わせるが、本手法はそこからさらにpositive/negativeな影響を与えるトークンレベルにまで踏み込み、negativeなベクトルとpositiveなベクトルの双方を用いて、negative-&gt;positive方向のベクトルを算出してsteeringに活用する方法っぽい？

<br>

<img src="https://github.com/user-attachments/assets/4a4df18c-d5bc-4499-83ae-16fc9f24e8b4" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/938dee15-ed05-4505-97c2-d079b9713cd3" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/ce075fc0-a8f4-42f2-9462-6c6d12085ef6" alt="image" loading="lazy">関連:

<br>

・1941</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/SpeechProcessing.html">#SpeechProcessing</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<span class="issue_date">Issue Date: 2025-07-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2300">[Paper Note] Ming-Omni: A Unified Multimodal Model for Perception and Generation, Inclusion AI+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Ming-Omniは、画像、テキスト、音声、動画を処理できる統一マルチモーダルモデルで、音声生成と画像生成において優れた能力を示す。専用エンコーダを用いて異なるモダリティからトークンを抽出し、MoEアーキテクチャで処理することで、効率的にマルチモーダル入力を融合。音声デコーダと高品質な画像生成を統合し、コンテキストに応じたチャットやテキストから音声への変換、画像編集が可能。Ming-Omniは、GPT-4oに匹敵する初のオープンソースモデルであり、研究と開発を促進するためにコードとモデルの重みを公開。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/user-attachments/assets/62fe9563-ed6b-40bf-ad95-067407534626" alt="image" loading="lazy">元ポスト:https://x.com/gm8xx8/status/1948878025757446389?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

現在はv1.5も公開されておりさらに性能が向上している模様？HF:https://huggingface.co/inclusionAI/Ming-Lite-Omni</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/On-Policy.html">#On-Policy</a>
<a class="button" href="articles/Stability.html">#Stability</a>
<span class="issue_date">Issue Date: 2025-07-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2299">[Paper Note] Group Sequence Policy Optimization, Chujie Zheng+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Group Sequence Policy Optimization (GSPO)は、大規模言語モデルのための新しい強化学習アルゴリズムで、シーケンスの尤度に基づく重要度比を用いてトレーニングを行う。GSPOは、従来のGRPOアルゴリズムよりも効率的で高性能であり、Mixture-of-Experts (MoE) のトレーニングを安定化させる。これにより、最新のQwen3モデルにおいて顕著な改善が見られる。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/theturingpost/status/1948904443749302785?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q公式ポスト:https://x.com/alibaba_qwen/status/1949412072942612873?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QGRPOとGSPOの違いのGIF:

<br>

https://x.com/theturingpost/status/1953976551424634930?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Controllable.html">#Controllable</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<span class="issue_date">Issue Date: 2025-07-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2297">[Paper Note] CaptionSmiths: Flexibly Controlling Language Pattern in Image Captioning, Kuniaki Saito+, arXiv'25</a>
<span class="snippet"><span>Summary</span>CaptionSmithsは、画像キャプショニングモデルがキャプションの特性（長さ、記述性、単語の独自性）を柔軟に制御できる新しいアプローチを提案。人間の注釈なしで特性を定量化し、短いキャプションと長いキャプションの間で補間することで条件付けを実現。実証結果では、出力キャプションの特性をスムーズに変化させ、語彙的整合性を向上させることが示され、誤差を506%削減。コードはGitHubで公開。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/a_hasimoto/status/1948258269668970782?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q従来はDiscreteに表現されていたcaptioningにおける特性をCondition Caluculatorを導入することでcontinuousなrepresentationによって表現し、Caluculatorに人間によるinput, あるいは表現したいConditionを持つexampleをinputすることで、生成時に反映させるような手法を提案している模様。Conditionで利用するpropertyについては、提案手法ではLength, Descriptive, Uniqueness of Vocabulariesの3つを利用している（が、他のpropertyでも本手法は適用可能と思われる）。このとき、あるpropertyの値を変えることで他のpropertyが変化してしまうと制御ができなくなるため、property間のdecorrelationを実施している。これは、あるproperty Aから別のproperty Bの値を予測し、オリジナルのpropertyの値からsubtractする、といった処理を順次propertyごとに実施することで実現される。Appendixに詳細が記述されている。

<br>



<br>

<img src="https://github.com/user-attachments/assets/673a2b9d-d630-4328-b619-f5382bb74f27" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/a90aa9d1-27f1-45c0-819e-c81b93364c68" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<span class="issue_date">Issue Date: 2025-07-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2296">[Paper Note] Towards Greater Leverage: Scaling Laws for Efficient Mixture-of-Experts  Language Models, Changxin Tian+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Mixture-of-Experts (MoE)アーキテクチャは、LLMsの効率的なスケーリングを可能にするが、モデル容量の予測には課題がある。これに対処するため、Efficiency Leverage (EL)を導入し、300以上のモデルを訓練してMoE構成とELの関係を調査。結果、ELはエキスパートの活性化比率と計算予算に依存し、エキスパートの粒度は非線形の調整因子として機能することが明らかに。これらの発見を基にスケーリング法則を統一し、Ling-mini-betaモデルを設計・訓練した結果、計算資源を7倍以上節約しつつ、6.1Bの密なモデルと同等の性能を達成。研究は効率的なMoEモデルのスケーリングに関する基盤を提供する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/rosinality/status/1948255608286990528?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<a class="button" href="articles/SelfCorrection.html">#SelfCorrection</a>
<a class="button" href="articles/DeepResearch.html">#DeepResearch</a>
<span class="issue_date">Issue Date: 2025-07-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2292">[Paper Note] Deep Researcher with Test-Time Diffusion, Rujun Han+, arXiv'25</a>
<span class="snippet"><span>Summary</span>TTD-DRは、LLMsを用いた研究報告書生成の新しいフレームワークで、草案から始まり、デノイジングプロセスを通じて情報を動的に取り入れながら洗練される。自己進化アルゴリズムにより高品質なコンテキストを生成し、情報損失を減少させる。TTD-DRは、集中的な検索とマルチホップ推論を必要とするベンチマークで最先端の結果を達成し、既存の深層研究エージェントを上回る性能を示す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1948526852546744510?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QSelf-Evolutionというのは、モデルのパラメータを更新するというものではなく、Agentに渡すContextをLLM-as-a-Judgeのスコアが改善するように、フィードバックとして得られるcritiqueなどを通じて反復的にoutput（＝別のAgentにcontextとして渡される情報）を洗練させていくような方法のことを指している模様。このようなプロセスを複数のパスで実施し、最終的にマージすることで高品質なoutput(context)を得る。

<br>

<img src="https://github.com/user-attachments/assets/27b0fb23-eeec-4c84-9845-02eb67131738" alt="image" loading="lazy">日本語解説:https://zenn.dev/knowledgesense/articles/5a341158c2c9ab</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Finetuning.html">#Finetuning</a>
<span class="issue_date">Issue Date: 2025-07-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2282">[Paper Note] Subliminal Learning: Language models transmit behavioral traits via  hidden signals in data, Alex Cloud+, arXiv'25</a>
<span class="snippet"><span>Summary</span>サブリミナル学習は、言語モデルが無関係なデータを通じて特性を伝達する現象である。実験では、特定の特性を持つ教師モデルが生成した数列データで訓練された生徒モデルが、その特性を学習することが確認された。データが特性への言及を除去してもこの現象は発生し、異なるベースモデルの教師と生徒では効果が見られなかった。理論的結果を通じて、全てのニューラルネットワークにおけるサブリミナル学習の発生を示し、MLP分類器での実証も行った。サブリミナル学習は一般的な現象であり、AI開発における予期しない問題を引き起こす可能性がある。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/anthropicai/status/1947696314206064819?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q教師モデルが生成したデータから、教師モデルと同じベースモデルを持つ[^1]生徒モデルに対してファインチューニングをした場合、教師モデルと同じ特性を、どんなに厳しく学習元の合成データをフィルタリングしても、意味的に全く関係ないデータを合成しても（たとえばただの数字列のデータを生成したとしても）、生徒モデルに転移してしまう。これは言語モデルに限った話ではなく、ニューラルネットワーク一般について証明された[^2]。

<br>



<br>

また、MNISTを用いたシンプルなMLPにおいて、MNISTを教師モデルに対して学習させ、そのモデルに対してランダムノイズな画像を生成させ、同じ初期化を施した生徒モデルに対してFinetuningをした場合、学習したlogitsがMNIST用ではないにもかかわらず、MNISTデータに対して50%以上の分類性能を示し、数字画像の認識能力が意味的に全く関係ないデータから転移されている[^3]、といった現象が生じることも実験的に確認された。

<br>



<br>

このため、どんなに頑張って合成データのフィルタリングや高品質化を実施し、教師モデルから特性を排除したデータを作成したつもりでも、そのデータでベースモデルが同じ生徒を蒸留すると、結局その特性は転移されてしまう。これは大きな落とし穴になるので気をつけましょう、という話だと思われる。

<br>



<br>

[^1]: これはアーキテクチャの話だけでなく、パラメータの初期値も含まれる

<br>

[^2]: 教師と生徒の初期化が同じ、かつ十分に小さい学習率の場合において、教師モデルが何らかの学習データDを生成し、Dのサンプルxで生徒モデルでパラメータを更新する勾配を計算すると、教師モデルが学習の過程で経た勾配と同じ方向の勾配が導き出される。つまり、パラメータが教師モデルと同じ方向にアップデートされる。みたいな感じだろうか？元論文を時間がなくて厳密に読めていない、かつalphaxivの力を借りて読んでいるため、誤りがあるかもしれない点に注意

<br>

[^3]: このパートについてもalphaxivの出力を参考にしており、元論文の記述をしっかり読めているわけではない</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<span class="issue_date">Issue Date: 2025-07-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2279">[Paper Note] Hierarchical Reasoning Model, Guan Wang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>HRM（Hierarchical Reasoning Model）は、AIの推論プロセスを改善するために提案された新しい再帰的アーキテクチャであり、Chain-of-Thought技術の問題を克服します。HRMは、2つの相互依存する再帰モジュールを用いて、シーケンシャルな推論タスクを単一のフォワードパスで実行し、高レベルの抽象計画と低レベルの詳細計算を分担します。2700万のパラメータで、わずか1000のトレーニングサンプルを使用し、数独や迷路の最適経路探索などの複雑なタスクで優れたパフォーマンスを示し、ARCベンチマークでも他の大規模モデルを上回る結果を達成しました。HRMは、普遍的な計算と汎用推論システムに向けた重要な進展を示唆しています。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/makingagi/status/1947286324735856747?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説ポスト:https://x.com/hillbig/status/1952122977228841206?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・2357 追試の結果再現が可能でモデルアーキテクチャそのものよりも、ablation studyの結果、outer refinement loopが重要とのこと:

<br>

・https://x.com/fchollet/status/1956442449922138336?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・https://x.com/k_schuerholt/status/1956669487349891198?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qポイント解説:https://x.com/giffmana/status/1956705621337608305?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/Contamination.html">#Contamination</a>
<a class="button" href="articles/Science.html">#Science</a>
<span class="issue_date">Issue Date: 2025-07-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2276">[Paper Note] MegaScience: Pushing the Frontiers of Post-Training Datasets for Science  Reasoning, Run-Ze Fan+, arXiv'25</a>
<span class="snippet"><span>Summary</span>科学的推論のためのオープンデータセット「TextbookReasoning」を提案し、65万の推論質問を含む。さらに、125万のインスタンスを持つ「MegaScience」を開発し、各公開科学データセットに最適なサブセットを特定。包括的な評価システムを構築し、既存のデータセットと比較して優れたパフォーマンスを示す。MegaScienceを用いてトレーニングしたモデルは、公式の指示モデルを大幅に上回り、科学的調整におけるスケーリングの利点を示唆。データキュレーションパイプラインやトレーニング済みモデルをコミュニティに公開。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/vfrz525_/status/1947859552407589076?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLLMベースでdecontaminationも実施している模様</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<a class="button" href="articles/Non-VerifiableRewards.html">#Non-VerifiableRewards</a>
<a class="button" href="articles/RewardModel.html">#RewardModel</a>
<span class="issue_date">Issue Date: 2025-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2274">[Paper Note] Inference-Time Scaling for Generalist Reward Modeling, Zijun Liu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>強化学習を用いてLLMsの推論能力を向上させるため、報酬モデリング（RM）のスケーラビリティを探求。ポイントワイズ生成報酬モデリング（GRM）を採用し、自己原則批評調整（SPCT）を提案してパフォーマンスを向上。並列サンプリングとメタRMを導入し、スケーリング性能を改善。実験により、SPCTがGRMの質とスケーラビリティを向上させ、既存の手法を上回る結果を示した。DeepSeek-GRMは一部のタスクで課題があるが、今後の取り組みで解決可能と考えられている。モデルはオープンソースとして提供予定。</span>
<span class="snippet"><span>Comment</span>・inputに対する柔軟性と、

<br>

・同じresponseに対して多様なRewardを算出でき (= inference time scalingを活用できる)、 

<br>

・Verifiableな分野に特化していないGeneralなRewardモデルである

<br>



<br>

Inference-Time Scaling for Generalist Reward Modeling (GRM) を提案

<br>



<br>

<img width="834" height="544" alt="Image" src="https://github.com/user-attachments/assets/18b13e49-745c-4c22-8d29-8b9bbb7fe80c">

<br>



<br>

<img width="840" height="642" alt="Image" src="https://github.com/user-attachments/assets/29c1c101-04c1-43d4-96b0-5023aed726c0"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/RLVR.html">#RLVR</a>
<span class="issue_date">Issue Date: 2025-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2272">[Paper Note] The Invisible Leash: Why RLVR May Not Escape Its Origin, Fang Wu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>RLVRはAIの能力向上に寄与するが、基盤モデルの制約により新しい解の発見を制限する可能性がある。理論的調査により、初期確率がゼロの解をサンプリングできないことや、探索を狭めるトレードオフが明らかになった。実証実験では、RLVRが精度を向上させる一方で、正しい答えを見逃すことが確認された。将来的には、探索メカニズムや過小評価された解に確率質量を注入する戦略が必要とされる。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iscienceluvr/status/1947570323395907830?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QRLVRの限界に関する洞察</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<span class="issue_date">Issue Date: 2025-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2271">[Paper Note] Inverse Scaling in Test-Time Compute, Aryo Pradipta Gema+, arXiv'25</a>
<span class="snippet"><span>Summary</span>LRMsの推論の長さが性能に与える影響を評価するタスクを構築し、計算量と精度の逆スケーリング関係を示す。4つのカテゴリのタスクを通じて、5つの失敗モードを特定。これにより、長時間の推論が問題のあるパターンを強化する可能性があることが明らかになった。結果は、LRMsの失敗モードを特定し対処するために、推論の長さに応じた評価の重要性を示している。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iscienceluvr/status/1947570957029413166?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QReasoningモデルにおいてReasoningが長くなればなるほど

<br>

・context中にirrerevantな情報が含まれるシンプルな個数を数えるタスクでは、irrerevantな情報に惑わされるようになり、

<br>

・特徴表に基づく回帰タスクの場合、擬似相関を持つ特徴量をの影響を増大してしまい、

<br>

・複雑で組み合わせが多い演繹タスク（シマウマパズル）に失敗する

<br>



<br>

といったように、Reasoning Traceが長くなればなるほど性能を悪化させるタスクが存在しこのような問題のある推論パターンを見つけるためにも、様々なReasoning Traceの長さで評価した方が良いのでは、といった話な模様？

<br>

<img src="https://github.com/user-attachments/assets/751d09a2-c889-4ad9-b9e4-9af5a64200b8" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<a class="button" href="articles/Safety.html">#Safety</a>
<span class="issue_date">Issue Date: 2025-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2269">[Paper Note] The Devil behind the mask: An emergent safety vulnerability of Diffusion  LLMs, Zichen Wen+, arXiv'25</a>
<span class="snippet"><span>Summary</span>拡散ベースの大規模言語モデル（dLLMs）は、迅速な推論と高いインタラクティビティを提供するが、安全性に関する懸念がある。既存のアライメントメカニズムは、敵対的プロンプトからdLLMsを保護できていない。これに対処するため、DIJAという新しい脱獄攻撃フレームワークを提案し、dLLMsの生成メカニズムを利用して有害な補完を可能にする。実験により、DIJAは既存の手法を大幅に上回り、特にDream-Instructで100%のASRを達成し、JailbreakBenchでの評価でも優れた結果を示した。これにより、dLLMsの安全性のアライメントを再考する必要性が浮き彫りになった。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/trtd6trtd/status/1947469171077615995?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2268">[Paper Note] Diffusion Beats Autoregressive in Data-Constrained Settings, Mihir Prabhudesai+, arXiv'25</a>
<span class="snippet"><span>Summary</span>マスク付き拡散モデルは、データ制約のある設定で自己回帰（AR）モデルを大幅に上回ることを発見。拡散モデルはデータを効果的に活用し、検証損失を低下させ、下流のパフォーマンスを向上させる。新しいスケーリング法則を見つけ、拡散がARを上回る臨界計算閾値を導出。データがボトルネックの場合、拡散モデルはARの魅力的な代替手段となる。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iscienceluvr/status/1947567159045197924?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QいつかdLLMの時代きそうだなあ著者ポスト:https://x.com/mihirp98/status/1947736993229885545?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q追加実験結果:https://x.com/mihirp98/status/1948875821797798136?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/Decoding.html">#Decoding</a>
<span class="issue_date">Issue Date: 2025-07-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2261">[Paper Note] Unveiling the Power of Source: Source-based Minimum Bayes Risk Decoding   for Neural Machine Translation, Boxuan Lyu+, ACL'25</a>
<span class="snippet"><span>Summary</span>ソースベースのMBRデコーディング（sMBR）を提案し、パラフレーズや逆翻訳から生成された準ソースを「サポート仮説」として利用。参照なしの品質推定メトリックを効用関数として用いる新しいアプローチで、実験によりsMBRがQE再ランキングおよび標準MBRを上回る性能を示した。sMBRはNMTデコーディングにおいて有望な手法である。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/boxuan_lyu425/status/1946802820973519245?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-07-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2260">[Paper Note] Blending Supervised and Reinforcement Fine-Tuning with Prefix Sampling, Zeyu Huang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>ポストトレーニング技術にはSFTとRFTがあり、それぞれ異なるトレードオフが存在する。本論文では、デモンストレーションと探索を統合したハイブリッドアプローチ「Prefix-RFT」を提案し、数学的推論問題でその効果を実証。Prefix-RFTはSFTやRFTの性能を上回り、既存のフレームワークに容易に統合可能である。分析により、SFTとRFTの補完的な性質が示され、デモンストレーションデータの質と量に対する堅牢性も確認された。この研究はLLMのポストトレーニングに新たな視点を提供する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/zeroyuhuang/status/1946232400922484992?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q少し前からXコミュニティでRFT(Reinforcement Finetuning)という用語が観測されたが、arXiv paperで見たのは初めてかもしれない。RFTはおそらく、強化学習を利用したPost-Trainingの総称だと思われる。デモンストレーションデータからPrefixをサンプリングし（SFTの要素; オフラインデータからサンプリングしたPrefixで生成をガイドする）、Prefixの続きをオンラインで生成し（RFTの要素; ガイドされたPrefixの続きを探索する）、Prefix+生成結果をロールアウトとし学習する。

<br>

<img src="https://github.com/user-attachments/assets/2988bc02-0c88-47e7-ab55-a623c5122428" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/01875988-9364-4eb1-acb2-e35cf907b789" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/ContextEngineering.html">#ContextEngineering</a>
<span class="issue_date">Issue Date: 2025-07-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2256">[Paper Note] A Survey of Context Engineering for Large Language Models, Lingrui Mei+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本調査では、LLMsの性能を向上させる「コンテキストエンジニアリング」を提案し、その要素と実装方法を体系的に分類。コンテキストの取得、生成、処理、管理を検討し、洗練されたシステム実装を探る。1300以上の研究を分析し、モデルの能力の非対称性を明らかにし、複雑な文脈理解と長文出力生成のギャップに対処する重要性を強調。研究者とエンジニアのための統一フレームワークを提供。</span>
<span class="snippet"><span>Comment</span>もうContext Engineeringという切り口の体系化されたSurveyが出てきた。早すぎ。

<br>

<img src="https://github.com/user-attachments/assets/9577c3f8-8fd5-49e0-b80f-19c0d4f22064" alt="image" loading="lazy">元ポスト:https://x.com/neural_avb/status/1946288694882685317?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<span class="issue_date">Issue Date: 2025-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2251">[Paper Note] SWE-Perf: Can Language Models Optimize Code Performance on Real-World  Repositories?, Xinyi He+, arXiv'25</a>
<span class="snippet"><span>Summary</span>コードのパフォーマンス最適化は重要であり、LLMsのリポジトリレベルでの能力は未探求。これに対処するため、SWE-Perfという初のベンチマークを導入。140のインスタンスを用いて、LLMsと専門家の最適化パフォーマンスのギャップを評価し、研究機会を示す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/sivil_taram/status/1945855374336446577?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QこれまでのSWE系のベンチマークはBug Fixなどにフォーカスされてきたが、こちらのベンチマークはソフトウェアのパフォーマンス（i.e., 実行時間）を改善させられるかにフォーカスしているとのこと。

<br>

実際にリポジトリからPRを収集し、パッチ前後の実行時間を比較。20回のrunを通じて統計的に有意な実行時間の差があるもののみにフィルタリングをしているとのこと。

<br>



<br>

Human Expertsは平均10.9%のgainを得たが、エージェントは2.3%にとどまっており、ギャップがあるとのこと。

<br>



<br>

傾向として、LLMはlow levelなインフラストラクチャ（環境構築, 依存関係のハンドリング, importのロジック）を改善するが、Human Expertsはhigh levelなロジックやデータ構造を改善する（e.g., アルゴリズムや、データハンドリング）。</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<a class="button" href="articles/DataMixture.html">#DataMixture</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<span class="issue_date">Issue Date: 2025-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2250">[Paper Note] Scaling Laws for Optimal Data Mixtures, Mustafa Shukor+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、スケーリング法則を用いて任意のターゲットドメインに対する最適なデータ混合比率を決定する方法を提案。特定のドメイン重みベクトルを持つモデルの損失を正確に予測し、LLM、NMM、LVMの事前訓練における予測力を示す。少数の小規模な訓練実行でパラメータを推定し、高価な試行錯誤法に代わる原則的な選択肢を提供。</span>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiDimensional.html">#MultiDimensional</a>
<span class="issue_date">Issue Date: 2025-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2249">[Paper Note] TransEvalnia: Reasoning-based Evaluation and Ranking of Translations, Richard Sproat+, arXiv'25</a>
<span class="snippet"><span>Summary</span>プロンプトベースの翻訳評価システム「TransEvalnia」を提案し、Multidimensional Quality Metricsに基づく詳細な評価を行う。TransEvalniaは、英日データやWMTタスクで最先端のMT-Rankerと同等以上の性能を示し、LLMによる評価が人間の評価者と良好に相関することを確認。翻訳の提示順序に敏感であることを指摘し、位置バイアスへの対処法を提案。システムの評価データは公開される。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/sakanaailabs/status/1946071203002941694?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Safety.html">#Safety</a>
<span class="issue_date">Issue Date: 2025-07-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2238">[Paper Note] Chain of Thought Monitorability: A New and Fragile Opportunity for AI  Safety, Tomek Korbak+, arXiv'25</a>
<span class="snippet"><span>Summary</span>人間の言語で「考える」AIシステムは、安全性向上のために思考の連鎖（CoT）を監視することで悪意のある意図を検出する機会を提供する。しかし、CoT監視は完璧ではなく、一部の不正行為が見逃される可能性がある。研究を進め、既存の安全手法と併せてCoT監視への投資を推奨する。モデル開発者は、開発の決定がCoTの監視可能性に与える影響を考慮すべきである。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gdb/status/1945350912668737701?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QCoTを監視することで、たとえばモデルのよろしくない挙動（e.g., misalignmentなどの意図しない動作や、prompt injection等の不正行為)を検知することができ、特にAIがより長期的な課題に取り組む際にはより一層その内部プロセスを監視する手段が必要不可欠となるため、CoTの忠実性や解釈性が重要となる。このため、CoTの監視可能性が維持される（モデルのアーキテクチャや学習手法（たとえばCoTのプロセス自体は一見真っ当なことを言っているように見えるが、実はRewardHackingしている、など）によってはそもそもCoTが難読化し監視できなかったりするので、現状は脆弱性がある）、より改善していく方向にコミュニティとして動くことを推奨する。そして、モデルを研究開発する際にはモデルのCoT監視に関する評価を実施すべきであり、モデルのデプロイや開発の際にはCoTの監視に関する決定を組み込むべき、といったような提言のようである。関連:https://x.com/dongxi_nlp/status/1945606266027426048?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<span class="issue_date">Issue Date: 2025-07-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2237">[Paper Note] In-context denoising with one-layer transformers: connections between  attention and associative memory retrieval, Matthew Smart+, arXiv'25</a>
<span class="snippet"><span>Summary</span>「インコンテキストデノイジング」というタスクを通じて、注意ベースのアーキテクチャと密な連想記憶（DAM）ネットワークの関係を探求。ベイズ的フレームワークを用いて、単層トランスフォーマーが特定のデノイジング問題を最適に解決できることを示す。訓練された注意層は、コンテキストトークンを連想記憶として利用し、デノイジングプロンプトを一回の勾配降下更新で処理。これにより、DAMネットワークの新たな拡張例を提供し、連想記憶と注意メカニズムの関連性を強化する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1945253873456963841?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・2146</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Contamination.html">#Contamination</a>
<span class="issue_date">Issue Date: 2025-07-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2226">[Paper Note] Reasoning or Memorization? Unreliable Results of Reinforcement Learning  Due to Data Contamination, Mingqi Wu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）の推論能力向上に関する研究が進展しており、特にQwen2.5モデルが強化学習（RL）を用いて顕著な改善を示している。しかし、他のモデルでは同様の成果が得られていないため、さらなる調査が必要である。Qwen2.5は数学的推論性能が高いが、データ汚染に脆弱であり、信頼性のある結果を得るためには、RandomCalculationというクリーンなデータセットを用いることが重要である。このデータセットを通じて、正確な報酬信号が性能向上に寄与することが示された。信頼性のある結論を得るためには、汚染のないベンチマークと多様なモデルでのRL手法の評価が推奨される。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/asap2650/status/1945151806536863878?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説ポスト:https://x.com/dongxi_nlp/status/1945214650737451008?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・1997

<br>



<br>

こちらでQwen-mathに対して得られたRLでのgainは他モデルでは現れず汎化しないことも報告されている。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Batch.html">#Batch</a>
<span class="issue_date">Issue Date: 2025-07-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2225">[Paper Note] REST: Stress Testing Large Reasoning Models by Asking Multiple Problems  at Once, Zhuoshi Pan+, arXiv'25</a>
<span class="snippet"><span>Summary</span>RESTという新しい評価フレームワークを提案し、LRMsを同時に複数の問題にさらすことで、実世界の推論能力を評価。従来のベンチマークの限界を克服し、文脈優先配分や問題間干渉耐性を測定。DeepSeek-R1などの最先端モデルでもストレステスト下で性能低下が見られ、RESTはモデル間の性能差を明らかにする。特に「考えすぎの罠」が性能低下の要因であり、「long2short」技術で訓練されたモデルが優れた結果を示すことが確認された。RESTはコスト効率が高く、実世界の要求に適した評価手法である。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_akhaliq/status/1945130848061194500?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q<img src="https://github.com/user-attachments/assets/eb969359-91d2-4ac4-8a48-1fe27d88ec4e" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Off-Policy.html">#Off-Policy</a>
<span class="issue_date">Issue Date: 2025-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2221">[Paper Note] Quantile Reward Policy Optimization: Alignment with Pointwise Regression  and Exact Partition Functions, Simon Matrenok+, arXiv'25</a>
<span class="snippet"><span>Summary</span>QRPO（Quantile Reward Policy Optimization）は、ポイントワイズの絶対報酬から学習する新しい手法で、DPOのシンプルさとオフライン適用性を兼ね備えています。QRPOは量子報酬を用いてKL正則化された強化学習の目的の閉形式解への回帰を実現し、相対的な信号の必要性を排除します。実験結果では、QRPOがDPOやREBEL、SimPOと比較して、チャットやコーディングの評価で一貫して最高のパフォーマンスを示しました。また、堅牢な報酬でのトレーニングにより、長さバイアスが減少することが確認されました。</span>
<span class="snippet"><span>Comment</span>画像は元ポストより。off-policy RLでもlong contextで高い性能が出るようになったのだろうか

<br>



<br>

<img src="https://github.com/user-attachments/assets/2a66064a-8e1c-49fa-a1d2-ed4b475155e1" alt="image" loading="lazy">

<br>



<br>

元ポスト:https://x.com/skandermoalla/status/1944773057085579531?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・2060</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<span class="issue_date">Issue Date: 2025-07-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2205">[Paper Note] VisualPuzzles: Decoupling Multimodal Reasoning Evaluation from Domain  Knowledge, Yueqi Song+, arXiv'25</a>
<span class="snippet"><span>Summary</span>VisualPuzzlesは、専門知識への依存を最小限に抑えた視覚的推論を評価する新しいベンチマークで、5つの推論カテゴリーから成る多様な質問を含む。実験により、VisualPuzzlesはドメイン特有の知識を大幅に減少させ、より複雑な推論を要求することが示された。最先端のマルチモーダルモデルは、VisualPuzzlesで人間のパフォーマンスに遅れをとり、知識集約型タスクでの成功が推論タスクでの成功に必ずしもつながらないことが明らかになった。また、モデルのサイズとパフォーマンスの間に明確な相関は見られず、VisualPuzzlesは事実の記憶を超えた推論能力を評価する新たな視点を提供する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/yueqi_song/status/1912510869491101732?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q画像はPJページより引用。新たにVisual Puzzleと呼ばれる特定のドメイン知識がほとんど必要ないマルチモーダルなreasoningベンチマークを構築。o1ですら、人間の5th percentileに満たない性能とのこと。

<br>



<br>

Chinese Civil Service Examination中のlogical reasoning questionを手作業で翻訳したとのこと。

<br>



<br>

<img src="https://github.com/user-attachments/assets/4ee1cd31-2d47-46a2-861b-2a72c5df8529" alt="image" loading="lazy">

<br>



<br>

データセットの統計量は以下で、合計1168問で、難易度は3段階に分かれている模様。

<br>

<img src="https://github.com/user-attachments/assets/332246e3-075f-4d98-b528-c8e4ec865068" alt="image" loading="lazy">

<br>



<br>

project page:https://neulab.github.io/VisualPuzzles/</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Optimizer.html">#Optimizer</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-07-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2202">[Paper Note] Muon is Scalable for LLM Training, Jingyuan Liu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Muonオプティマイザーを大規模モデルにスケールアップするために、ウェイトデケイとパラメータごとの更新スケール調整を導入。これにより、Muonは大規模トレーニングで即座に機能し、計算効率がAdamWの約2倍に向上。新たに提案するMoonlightモデルは、少ないトレーニングFLOPで優れたパフォーマンスを達成し、オープンソースの分散Muon実装や事前トレーニング済みモデルも公開。</span>
<span class="snippet"><span>Comment</span>解説ポスト:https://x.com/hillbig/status/1944902706747072678?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qこちらでも紹介されている:

<br>

・2208</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<span class="issue_date">Issue Date: 2025-07-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2200">[Paper Note] Kimi-VL Technical Report, Kimi Team+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Kimi-VLは、効率的なオープンソースのMixture-of-Expertsビジョン・ランゲージモデルであり、2.8Bパラメータの言語デコーダーを活性化して高度なマルチモーダル推論を実現。マルチターンエージェントタスクや大学レベルの画像・動画理解において優れた性能を示し、最先端のVLMと競争。128Kの拡張コンテキストウィンドウを持ち、長い入力を処理可能。Kimi-VL-Thinking-2506は、長期的推論能力を強化するために教師ありファインチューニングと強化学習を用いて開発され、堅牢な一般能力を獲得。コードは公開されている。</span>
<span class="snippet"><span>Comment</span>・2201 

<br>

での性能（Vision+テキストの数学の問題）。他の巨大なモデルと比べ2.8BのActivation paramsで高い性能を達成

<br>



<br>

<img width="831" height="431" alt="Image" src="https://github.com/user-attachments/assets/3ec08621-f269-4f1d-97bb-3ebca537f2ea">

<br>



<br>

その他のベンチマークでも高い性能を獲得

<br>



<br>

<img width="833" height="558" alt="Image" src="https://github.com/user-attachments/assets/b30afc4f-efce-4206-b499-f4f089d97226">

<br>



<br>

モデルのアーキテクチャ。MoonViT (Image Encoder, 1Dのpatchをinput, 様々な解像度のサポート, FlashAttention,  SigLIP-SO-400Mを継続事前学習, RoPEを採用) + Linear Projector + MoE Language Decoderの構成

<br>

<img width="851" height="590" alt="Image" src="https://github.com/user-attachments/assets/f59d7655-c1c7-4284-b79c-9d62739da889">

<br>



<br>

学習のパイプライン。ViTの事前学習ではSigLIP loss (contrastive lossの亜種)とcaption生成のcross-entropy lossを採用している。joint cooldown stageにおいては、高品質なQAデータを合成することで実験的に大幅に性能が向上することを確認したので、それを採用しているとのこと。optimizerは 

<br>

・2202

<br>



<br>

<img width="849" height="213" alt="Image" src="https://github.com/user-attachments/assets/720b02f7-a260-497f-85c5-04cf382c2f98">

<br>



<br>

<img width="828" height="402" alt="Image" src="https://github.com/user-attachments/assets/bb78d799-5db4-4904-8669-540d2142c95c">

<br>



<br>

post-trainingにおけるRLでは以下の目的関数を用いており、RLVRを用いつつ、現在のポリシーモデルをreferenceとし更新をするような目的関数になっている。curriculum sampling, prioritize samplingをdifficulty labelに基づいて実施している。

<br>

<img width="842" height="152" alt="Image" src="https://github.com/user-attachments/assets/298fdef8-9807-4511-96f6-02241393ab9f">

<br>



<br>

<img width="822" height="187" alt="Image" src="https://github.com/user-attachments/assets/4ad0d815-ef1c-4945-ae08-ab2b072ec63f"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2025-07-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2198">[Paper Note] Nonlinear transformers can perform inference-time feature learning, Nishikawa+, ICML'25</a>
<span class="snippet"><span>Summary</span>事前学習されたトランスフォーマーは、推論時に特徴を学習する能力を持ち、特に単一インデックスモデルにおける文脈内学習に焦点を当てています。勾配ベースの最適化により、異なるプロンプトからターゲット特徴を抽出し、非適応的アルゴリズムを上回る統計的効率を示します。また、推論時のサンプル複雑性が相関統計クエリの下限を超えることも確認されました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/btreetaiji/status/1944297631808991742?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<a class="button" href="articles/Stability.html">#Stability</a>
<span class="issue_date">Issue Date: 2025-07-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2194">[Paper Note] SingLoRA: Low Rank Adaptation Using a Single Matrix, David Bensaïd+, arXiv'25</a>
<span class="snippet"><span>Summary</span>SingLoRAは、LoRAの低ランク適応を再定式化し、単一の低ランク行列とその転置の積を用いることで、トレーニングの安定性を向上させ、パラメータ数をほぼ半減させる手法です。実験により、常識推論タスクでLLama 7Bを用いたファインチューニングで91.3%の精度を達成し、LoRAやLoRA+を上回る結果を示しました。また、画像生成においてもStable Diffusionのファインチューニングで高い忠実度を実現しました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/theturingpost/status/1943701154497732765?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLoRAは低ランク行列BAの積を計算するが、オリジナルのモデルと同じ挙動から学習をスタートするために、Bをzeroで初期化し、Aはランダムに初期化する。このAとBの不均衡さが、勾配消失、爆発、あるいはsub-optimalな収束の要因となってしまっていた（inter-matrix scale conflicts)。特に、LoRAはモデルのwidthが大きくなると不安定になるという課題があった。このため、低ランク行列を2つ使うのではなく、1つの低ランク行列（とその転置）およびoptimizationのstep tごとにtrainableなパラメータがどの程度影響を与えるかを調整する度合いを決めるscalar function u(t)を導入することで、低ランク行列間の不均衡を解消しつつ、パラメータ数を半減し、学習の安定性と性能を向上させる。たとえばu(t)を学習開始時にzeroにすれば、元のLoRAにおいてBをzeroに初期化するのと同じ挙動（つまり元のモデルと同じ挙動から学習スタートができたりする。みたいな感じだろうか？

<br>



<br>

<img src="https://github.com/user-attachments/assets/2dcd4ec1-59d3-43c0-ab8d-5c1c37e5ec3d" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/c73b8715-e0c8-45c8-a7fa-ea55ac8ca3ce" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/cf034dcd-37c4-48f1-a0a3-1d836db37820" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/82999835-ac1e-4380-8bd0-00d14022abf5" alt="image" loading="lazy">関連:

<br>

・1956

<br>

・1245</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Batch.html">#Batch</a>
<span class="issue_date">Issue Date: 2025-07-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2192">[Paper Note] Small Batch Size Training for Language Models: When Vanilla SGD Works,  and Why Gradient Accumulation Is Wasteful, Martin Marek+, arXiv'25</a>
<span class="snippet"><span>Summary</span>小さなバッチサイズに対するAdamのハイパーパラメータをスケーリングする新しいルールを提案。これにより、小さなバッチサイズでも安定したトレーニングが可能で、大きなバッチサイズと同等以上のパフォーマンスを達成。勾配蓄積は推奨せず、実用的なハイパーパラメータ設定のガイドラインを提供。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/giffmana/status/1943384733418950815?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

論文中のFigure1において、AdamWにおいてbatchsizeが1の方が512の場合と比べてlearning_rateの変化に対してロバストである旨が記述されている。

<br>



<br>

<img width="977" height="642" alt="Image" src="https://github.com/user-attachments/assets/0c1efb5d-6eeb-4fd7-ba06-e4296e988a6c">似たような話でMTでバッチサイズ小さいほうが性能良いです、みたいな話が昔あったような

<br>



<br>

（追記）

<br>

気になって思い出そうとしていたが、MTではなく画像認識の話だったかもしれない（だいぶうろ覚え）

<br>

・2196 参考:https://x.com/odashi_t/status/1944034128707342815?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・1541解説:https://x.com/hillbig/status/1952506470878351492?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q実際に8Bモデルの事前学習においてβ2を0.99にしたところ、学習が不安定になり、かつ最終的なPerplexityも他の設定に勝つことができなかったとのこと:

<br>

https://x.com/odashi_t/status/1955906705637957995?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/On-Policy.html">#On-Policy</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<span class="issue_date">Issue Date: 2025-07-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2191">[Paper Note] Perception-Aware Policy Optimization for Multimodal Reasoning, Zhenhailong Wang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>強化学習における検証可能な報酬（RLVR）は、LLMsに多段階推論能力を与えるが、マルチモーダル推論では最適な性能を発揮できない。視覚入力の認識が主なエラー原因であるため、知覚を意識したポリシー最適化（PAPO）を提案。PAPOはGRPOの拡張で、内部監視信号から学習し、追加のデータや外部報酬に依存しない。KLダイバージェンス項を導入し、マルチモーダルベンチマークで4.4%の改善、視覚依存タスクでは8.0%の改善を達成。知覚エラーも30.5%減少し、PAPOの効果を示す。研究は視覚に基づく推論を促進する新しいRLフレームワークの基盤を築く。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/aicia_solid/status/1943507735489974596?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QVLMにおいて、画像をマスクした場合のポリシーモデルの出力と、画像をマスクしない場合のポリシーモデルの出力のKL Divergenceを最大化することで、画像の認知能力が向上し性能向上するよ、みたいな話な模様。

<br>

<img src="https://github.com/user-attachments/assets/d7844321-d979-497f-84da-5d69fd13233f" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/afe8919c-ea16-48a1-b33b-79b7a3b1ccb0" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/04a3d23c-2eb0-40e2-aa2c-363498976320" alt="image" loading="lazy"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/COLM.html">#COLM</a>
<a class="button" href="articles/Stability.html">#Stability</a>
<span class="issue_date">Issue Date: 2025-07-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2188">[Paper Note] Spike No More: Stabilizing the Pre-training of Large Language Models, Sho Takase+, COLM'25</a>
<span class="snippet"><span>Summary</span>大規模言語モデルの事前学習中に発生する損失のスパイクは性能を低下させるため、避けるべきである。勾配ノルムの急激な増加が原因とされ、サブレイヤーのヤコビ行列の分析を通じて、勾配ノルムを小さく保つための条件として小さなサブレイヤーと大きなショートカットが必要であることを示した。実験により、これらの条件を満たす手法が損失スパイクを効果的に防ぐことが確認された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/shot4410/status/1943301371010388175?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qsmall sub-layers, large shortcutsの説明はこちらに書かれている。前者については、現在主流なLLMの初期化手法は満たしているが、後者はオリジナルのTransformerの実装では実装されている[^1]が、最近の実装では失われてしまっているとのこと。

<br>

<img src="https://github.com/user-attachments/assets/55cf847c-fc6a-4e76-88c9-1507464e96a0" alt="image" loading="lazy">

<br>



<br>

下図が実験結果で、条件の双方を満たしているのはEmbedLN[^2]とScaled Embed[^3]のみであり、実際にスパイクが生じていないことがわかる。

<br>

<img src="https://github.com/user-attachments/assets/79494662-3d58-4d8e-ae9d-8ed9241e0f65" alt="image" loading="lazy">

<br>



<br>

[^1]:オリジナル論文 245 の3.4節末尾、embedding layersに対してsqrt(d_model)を乗じるということがサラッと書いてある。これが実はめちゃめちゃ重要だったという…

<br>

[^2]: positional embeddingを加算する前にLayer Normalizationをかける方法

<br>

[^3]: EmbeddingにEmbeddingの次元数d（i.e., 各レイヤーのinputの次元数)の平方根を乗じる方法前にScaled dot-product attentionのsqrt(d_k)がめっちゃ重要ということを実験的に示した、という話もあったような…

<br>

（まあそもそも元論文になぜスケーリングさせるかの説明は書いてあるけども）</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/Privacy.html">#Privacy</a>
<span class="issue_date">Issue Date: 2025-07-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2186">[Paper Note] FlexOlmo: Open Language Models for Flexible Data Use, Weijia Shi+, arXiv'25</a>
<span class="snippet"><span>Summary</span>FlexOlmoは、データ共有なしでの分散トレーニングを可能にする新しい言語モデルで、異なるモデルパラメータが独立してトレーニングされ、データ柔軟な推論を実現します。混合専門家アーキテクチャを採用し、公開データセットと特化型セットでトレーニングされ、31の下流タスクで評価されました。データライセンスに基づくオプトアウトが可能で、平均41%の性能改善を達成し、従来の手法よりも優れた結果を示しました。FlexOlmoは、データ所有者のプライバシーを尊重しつつ、閉じたデータの利点を活かすことができます。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/asap2650/status/1943184037419585695?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qデータのオーナー側がプロプライエタリデータを用いてエキスパート(FFNとRouter embeddings)を学習し、それをpublicにシェアすることで利用できるようにする。データオーナー側はデータそのものを提供するのではなく、モデルのパラメータを共有するだけで済み、かつ自分たちのエキスパートをRouter側で利用するか否かは制御可能だから、opt-in/outが制御できる、みたいな話っぽい？

<br>

<img src="https://github.com/user-attachments/assets/6c21a262-afa1-4877-8b53-e6cd9176ecf5" alt="image" loading="lazy"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/RLVR.html">#RLVR</a>
<span class="issue_date">Issue Date: 2025-07-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2184">[Paper Note] First Return, Entropy-Eliciting Explore, Tianyu Zheng+, arXiv'25</a>
<span class="snippet"><span>Summary</span>FR3E（First Return, Entropy-Eliciting Explore）は、強化学習における不安定な探索を改善するための構造化された探索フレームワークであり、高不確実性の意思決定ポイントを特定し、中間フィードバックを提供します。実験結果は、FR3Eが安定したトレーニングを促進し、一貫した応答を生成することを示しています。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/f14bertolotti/status/1943201406271328524?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QRLVRのロールアウトにおいて、reasoning traceにおける各トークンを出力する際にエントロピーが高い部分を特定し（つまり、複数の候補がありモデルが迷っている）、その部分について異なる意図的に異なる生成パスを実行することで探索を促すようにするとRLVRがよりreliableになるといった話のようである

<br>

<img src="https://github.com/user-attachments/assets/fc8adfcf-f6fc-4631-ba0a-04fa1401e96a" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/fabf56a8-20f3-4782-a07b-3c854f01dfd5" alt="image" loading="lazy"></span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/ContrastiveLearning.html">#ContrastiveLearning</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Generalization.html">#Generalization</a>
<a class="button" href="articles/Decoder.html">#Decoder</a>
<span class="issue_date">Issue Date: 2025-07-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2182">[Paper Note] NV-Embed: Improved Techniques for Training LLMs as Generalist Embedding   Models, Chankyu Lee+, ICLR'25</a>
<span class="snippet"><span>Summary</span>デコーダー専用のLLMベースの埋め込みモデルNV-Embedは、BERTやT5を上回る性能を示す。アーキテクチャ設計やトレーニング手法を工夫し、検索精度を向上させるために潜在的注意層を提案。二段階の対照的指示調整手法を導入し、検索と非検索タスクの両方で精度を向上。NV-EmbedモデルはMTEBリーダーボードで1位を獲得し、ドメイン外情報検索でも高スコアを達成。モデル圧縮技術の分析も行っている。</span>
<span class="snippet"><span>Comment</span>Decoder-Only LLMのlast hidden layerのmatrixを新たに導入したLatent Attention Blockのinputとし、Latent Attention BlockはEmbeddingをOutputする。Latent Attention Blockは、last hidden layer (系列長l×dの

<br>

matrix)をQueryとみなし、保持しているLatent Array(trainableなmatrixで辞書として機能する;後述の学習においてパラメータが学習される)[^1]をK,Vとして、CrossAttentionによってcontext vectorを生成し、その後MLPとMean Poolingを実施することでEmbeddingに変換する。

<br>

<img src="https://github.com/user-attachments/assets/7a023273-aafd-4cfa-9b39-961180543ae9" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/767e3ac1-fe70-4653-bbe7-091c1f1dc0f7" alt="image" loading="lazy">

<br>



<br>

学習は2段階で行われ、まずQAなどのRetrievalタスク用のデータセットをIn Batch negativeを用いてContrastive Learningしモデルの検索能力を高める。その後、検索と非検索タスクの両方を用いて、hard negativeによってcontrastive learningを実施し、検索以外のタスクの能力も高める（下表）。両者において、instructionテンプレートを用いて、instructionによって条件付けて学習をすることで、instructionに応じて生成されるEmbeddingが変化するようにする。また、学習時にはLLMのcausal maskは無くし、bidirectionalにrepresentationを考慮できるようにする。

<br>

<img src="https://github.com/user-attachments/assets/26d4e126-1d18-421e-873f-f0eef4fc2026" alt="image" loading="lazy">

<br>



<br>

[^1]: 2183 Perceiver-IOにインスパイアされている。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/SmallModel.html">#SmallModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-07-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2181">[Paper Note] Decoder-Hybrid-Decoder Architecture for Efficient Reasoning with Long  Generation, Liliang Ren+, arXiv'25</a>
<span class="snippet"><span>Summary</span>最近の言語モデルの進展により、状態空間モデル（SSM）の効率的なシーケンスモデリングが示されています。本研究では、ゲーテッドメモリユニット（GMU）を導入し、Sambaベースの自己デコーダーからメモリを共有する新しいデコーダーハイブリッドアーキテクチャSambaYを提案します。SambaYはデコーディング効率を向上させ、長文コンテキスト性能を改善し、位置エンコーディングの必要性を排除します。実験により、SambaYはYOCOベースラインに対して優れた性能を示し、特にPhi4-mini-Flash-Reasoningモデルは推論タスクで顕著な成果を上げました。トレーニングコードはオープンソースで公開されています。</span>
<span class="snippet"><span>Comment</span>HF:https://huggingface.co/microsoft/Phi-4-mini-flash-reasoning元ポスト:https://x.com/_akhaliq/status/1943099901161652238?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<a class="button" href="articles/mid-training.html">#mid-training</a>
<a class="button" href="articles/COLM.html">#COLM</a>
<span class="issue_date">Issue Date: 2025-07-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2180">[Paper Note] MegaMath: Pushing the Limits of Open Math Corpora, Fan Zhou+, COLM'25</a>
<span class="snippet"><span>Summary</span>MegaMathは、数学に特化したオープンデータセットで、LLMの数学的推論能力を向上させるために作成された。ウェブデータの再抽出、数学関連コードの特定、合成データの生成を通じて、371Bトークンの高品質なデータを提供し、既存のデータセットを上回る量と品質を実現した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/fazhou_998/status/1942610771915202590?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q非常に大規模な数学の事前学習/mid-training向けのデータセット

<br>



<br>

CommonCrawlのHTMLから、さまざまなフィルタリング処理（reformatting, 2 stageのHTML parserの活用（片方はnoisyだが高速、もう一方は高性能だが遅い）, fasttextベースの分類器による抽出, deduplication等）を実施しMegaMath-Webを作成、また、MegaMathWebをさらに分類器で低品質なものをフィルタリングし、LLMによってノイズ除去、テキストのreorganizingを実施し（≠ピュアな合成データ）継続事前学習、mid-training向けの高品質なMegaMath-Web-Proを作成。

<br>



<br>

MegaMathCodeはThe Stack V2 (2199) をベースにしており、mathematical reasoning, logic puzzles, scientific computationに関するコードを収集。まずこれらのコードと関連が深い11のプログラミング言語を選定し、そのコードスニペットのみを対象とする。次にstrong LLMを用いて、数学に関するrelevanceスコアと、コードの品質を0--6のdiscrete scoreでスコアリングし学習データを作成。作成した学習データでSLMを学習し大規模なフィルタリングを実施することでMegaMath-Codeを作成。

<br>



<br>

最後にMegaMath-{Web, code}を用いて、Q&amp;A, code data, text&amp;code block dataの3種類を合成。Q&amp;Aデータの合成では、MegaMath-WebからQAペアを抽出し、多様性とデータ量を担保するためQwen2.5-72B-Instruct, Llama3.3-70B-Instructの両方を用いて、QAのsolutionを洗練させる（reasoning stepの改善, あるいはゼロから生成する[^1])ことで生成。また、code dataでは、pythonを対象にMegaMath-Codeのデータに含まれるpython以外のコードを、Qwen2.5-Coder-32B-Instructと、Llamd3.1-70B-Instructによってpythonに翻訳することでデータ量を増やした。text&amp;code blockデータでは、MegaMath-Webのドキュメントを与えて、ブロックを生成（タイトル、数式、結果、コードなど[^1]）し、ブロックのverificationを行い（コードが正しく実行できるか、実行結果とanswerが一致するか等）、verifiedなブロックを残すことで生成。

<br>



<br>

<img src="https://github.com/user-attachments/assets/8975019b-5ab4-437c-bd4e-f3b761439c9c" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/995ea6ce-69eb-4f88-8a98-9e55de3e7814" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/c6d1ec61-49f4-459f-92b2-fa0a2625178e" alt="image" loading="lazy">

<br>



<br>

[^1]: この辺は論文の記述を咀嚼して記述しており実サンプルを見ていないので少し正しい認識か不安</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<a class="button" href="articles/OOD.html">#OOD</a>
<a class="button" href="articles/DiseaseNameRecognition.html">#DiseaseNameRecognition</a>
<span class="issue_date">Issue Date: 2025-07-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2177">[Paper Note] Toward Cross-Hospital Deployment of Natural Language Processing Systems: Model Development and Validation of Fine-Tuned Large Language Models for Disease Name Recognition in Japanese, Shimizu+, JMIR'25</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/aramaki/status/1942902940337099254?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LatentReasoning.html">#LatentReasoning</a>
<span class="issue_date">Issue Date: 2025-07-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2176">[Paper Note] A Survey on Latent Reasoning, Rui-Jie Zhu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）は、明示的な思考の連鎖（CoT）によって優れた推論能力を示すが、自然言語推論への依存が表現力を制限する。潜在的推論はこの問題を解決し、トークンレベルの監視を排除する。研究は、ニューラルネットワーク層の役割や多様な潜在的推論手法を探求し、無限深度の潜在的推論を可能にする高度なパラダイムについて議論する。これにより、潜在的推論の概念を明確にし、今後の研究方向を示す。関連情報はGitHubリポジトリで提供されている。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gm8xx8/status/1942787610818097609?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLatent Reasoningというテクニカルタームが出てきた出力されるdiscreteなtokenによってreasoningを実施するのではなく、モデル内部のrepresentationでreasoningを実施するLatent ReasoningのSurvey

<br>



<br>

<img width="1099" height="876" alt="Image" src="https://github.com/user-attachments/assets/a34451e6-bf4a-432c-8c5b-facdbfb55c41">

<br>



<br>

<img width="959" height="575" alt="Image" src="https://github.com/user-attachments/assets/e53b3bba-f35f-4734-af71-14a90af8ee6f"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<span class="issue_date">Issue Date: 2025-07-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2158">[Paper Note] CriticLean: Critic-Guided Reinforcement Learning for Mathematical  Formalization, Zhongyuan Peng+, arXiv'25</a>
<span class="snippet"><span>Summary</span>自然言語の数学的表現を実行可能なコードに翻訳する課題に対し、批評者の役割を能動的な学習コンポーネントに変えるCriticLeanという新しい強化学習フレームワークを提案。CriticLeanGPTを用いて形式化の意味的忠実性を評価し、CriticLeanBenchでその能力を測定。285K以上の問題を含むFineLeanCorpusデータセットを構築し、批評段階の最適化が信頼性のある形式化に重要であることを示す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gm8xx8/status/1942790484688003275?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連

<br>

・1832Lean 4 形式に

<br>



<br>

<img src="https://github.com/user-attachments/assets/79121e53-b205-440d-9615-d520ac848704" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/GraphBased.html">#GraphBased</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/ScientificDiscovery.html">#ScientificDiscovery</a>
<span class="issue_date">Issue Date: 2025-07-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2150">[Paper Note] AI Research Agents for Machine Learning: Search, Exploration, and  Generalization in MLE-bench, Edan Toledo+, arXiv'25</a>
<span class="snippet"><span>Summary</span>AI研究エージェントは、機械学習の自動化を通じて科学の進展を促進する可能性がある。本研究では、MLE-benchというKaggleコンペティションを用いてエージェントの性能向上に取り組み、検索ポリシーとオペレーターを用いて候補解の空間を探索する方法を提案。異なる検索戦略とオペレーターの組み合わせが高いパフォーマンスに寄与することを示し、MLE-bench liteでの結果を向上させ、Kaggleメダル獲得率を39.6%から47.7%に引き上げた。自動化された機械学習の進展には、これらの要素を共同で考慮することが重要である。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/martinjosifoski/status/1942238775305699558?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・1457グラフ中の各ノードはartifacts（i.e., エージェントが生成したコード)で、先行研究がiterativeな実験に加え、潜在的なsolutionに対してtree searchをすることでSoTAを達成しており、これをグラフを用いてより一般化することで異なるデザインのエージェントでも適用できるようにしている。

<br>

<img src="https://github.com/user-attachments/assets/a1f417c1-f5a0-4e51-a17e-6e5a3fcce75d" alt="image" loading="lazy">

<br>



<br>

あとで追記する</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Citations.html">#Citations</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/COLM.html">#COLM</a>
<a class="button" href="articles/AcademicWriting.html">#AcademicWriting</a>
<span class="issue_date">Issue Date: 2025-07-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2149">[Paper Note] ScholarCopilot: Training Large Language Models for Academic Writing with   Accurate Citations, Yubo Wang+, COLM'25</a>
<span class="snippet"><span>Summary</span>ScholarCopilotは、学術的な執筆を支援するために大規模言語モデルを強化したフレームワークで、正確で文脈に関連した引用を生成します。取得トークンを用いて動的に文献を取得し、生成プロセスを補強します。評価では、取得精度が40.1%に達し、生成品質も他のモデルを大幅に上回りました。特に、ScholarCopilotはChatGPTを超える性能を示し、引用の質で100%の好ましさを達成しました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/wenhuchen/status/1907861046833885397?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q従来のRAGベースのAcademicWriting手法では、まずReferenceを検索して、その内容をcontextに含めてテキストを生成するというSequentialなパイプラインだったが、本研究では通常のNextTokenPrediction Lossに加え、特殊トークン\[RET\]を導入し、ContrastiveLearningによって、\[RET\]トークンがトリガーとなり、生成過程のContextとqueryから適切なReferenceを検索できるEmbeddingを出力し、Referenceを検索し、動的にReferenceの内容をcontextに加え、テキストを生成する手法を提案している。

<br>

<img src="https://github.com/user-attachments/assets/777da4cb-5678-455f-babf-b91690945712" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/a27e092e-fff2-4f8a-91f7-09fe39e8e568" alt="image" loading="lazy">

<br>



<br>

データセットはarXivからlatex sourceを収集し、bibliography部分からReferenceのタイトルをQwenを用いて抽出。タイトルをarXivおよびSemanticScholarのデータベースと照合し、paperとReferenceの紐付けを実施することで構築している。

<br>

<img src="https://github.com/user-attachments/assets/2dd2b956-291e-4407-997a-4a2e68a72708" alt="image" loading="lazy">

<br>



<br>

GPT-4oによるjudgeの結果、ground truthのcitationを用いた場合には及ばないが、提案手法により品質が向上し、citation retrievalのRecall@Kも大幅に改善している。

<br>

<img src="https://github.com/user-attachments/assets/2ff5dd73-dcb8-4a3f-9d6a-1bcfb52a8321" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/81a39366-2577-41a1-aa6b-facc7ac25f1c" alt="image" loading="lazy"></span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<a class="button" href="articles/VideoGeneration/Understandings.html">#VideoGeneration/Understandings</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<span class="issue_date">Issue Date: 2025-07-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2146">[Paper Note] Energy-Based Transformers are Scalable Learners and Thinkers, Alexi Gladstone+, arXiv'25</a>
<span class="snippet"><span>Summary</span>エネルギーベースのトランスフォーマー（EBTs）を用いて、無監督学習から思考を学ぶモデルを提案。EBTsは、入力と候補予測の互換性を検証し、エネルギー最小化を通じて予測を行う。トレーニング中に従来のアプローチよりも高いスケーリング率を達成し、言語タスクでの性能を29%向上させ、画像のノイズ除去でも優れた結果を示す。EBTsは一般化能力が高く、モデルの学習能力と思考能力を向上させる新しいパラダイムである。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1941657099567845696?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QProject Page:https://energy-based-transformers.github.ioFirst Authorの方による解説ポスト:https://x.com/alexiglad/status/1942231878305714462?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2025-07-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2145">[Paper Note] Correlated Errors in Large Language Models, Elliot Kim+, ICML'25</a>
<span class="snippet"><span>Summary</span>350以上のLLMを評価し、リーダーボードと履歴書スクリーニングタスクで実証的な分析を実施。モデル間のエラーには実質的な相関があり、特に大きく正確なモデルは異なるアーキテクチャやプロバイダーでも高い相関を示す。相関の影響はLLMを評価者とするタスクや採用タスクにおいても確認された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/kennylpeng/status/1940758198320796065?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qこれは結果を細かく見るのと、評価したタスクの形式とバイアスが生じないかをきちんと確認した方が良いような気がする。

<br>



<br>

それは置いておいたとして、たとえば、Figure9bはLlamaの異なるモデルサイズは、高い相関を示しているが、それはベースが同じだからそうだろうなあ、とは思う。一方、9aはClaude, Nova, Mistral, GPTなど多様なプロバイダーのモデルで高い相関が示されている。Llama3-70BとLLama3.{1,2,3}-70Bでは相関が低かったりしている。

<br>

<img src="https://github.com/user-attachments/assets/03728cf7-9965-4e04-8f19-5ad3977d1a19" alt="image" loading="lazy">

<br>



<br>

Figure1(b)はHELMで比較的最新のモデル間でプロバイダーが別でも高い相関があるようにみえる。

<br>

<img src="https://github.com/user-attachments/assets/d6d1622a-5215-4464-b265-39cc6f0b7a47" alt="image" loading="lazy">

<br>



<br>

このような相関がある要因や傾向については論文を読んでみないとわからない。OpenReview:https://openreview.net/forum?id=kzYq2hfyHB&referrer=%5Bthe%20profile%20of%20Kenny%20Peng%5D(%2Fprofile%3Fid%3D~Kenny_Peng1)LLM-as-a-Judgeにおいて、評価者となるモデルと評価対象となるモデルが同じプロバイダーやシリーズの場合は（エラーの傾向が似ているので）性能がAccuracyが真のAccuracyよりも高めに出ている。また評価者よりも性能が低いモデルに対しても、性能が実際のAccuracyよりも高めに出す傾向にある（エラーの相関によってエラーであるにも関わらず正解とみなされAccuracyが高くなる)ようである。逆に、評価者よりも評価対象が性能が高い場合、評価者は自分が誤ってしまうquestionに対して、評価対象モデルが正解となる回答をしても、それに対して報酬を与えることができず性能が低めに見積もられてしまう。これだけの規模の実験で示されたことは、大変興味深い。

<br>

<img src="https://github.com/user-attachments/assets/4a73cdf4-a70d-4f79-997a-3fd5a55c5a60" alt="image" loading="lazy">履歴書のスクリーニングタスクについてもケーススタディをしている。こちらも詳細に分析されているので興味がある場合は参照のこと。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/RewardModel.html">#RewardModel</a>
<span class="issue_date">Issue Date: 2025-07-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2144">[Paper Note] Skywork-Reward-V2: Scaling Preference Data Curation via Human-AI Synergy, Chris Yuhao Liu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>報酬モデル（RMs）の性能向上のために、4,000万の好みペアからなる大規模データセット「SynPref-40M」を提案。人間とAIの相乗効果を活用した二段階パイプラインでデータをキュレーションし、Skywork-Reward-V2を導入。これにより、7つの報酬モデルベンチマークで最先端のパフォーマンスを達成。データのスケールと高品質なキュレーションが効果をもたらすことを確認。Skywork-Reward-V2はオープン報酬モデルの進展を示し、人間-AIキュレーションの重要性を強調。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_akhaliq/status/1941131426084303242?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q<img src="https://github.com/user-attachments/assets/56b6baa3-a4d0-41fe-9f4e-8a8098f7ee2c" alt="image" loading="lazy">解説:https://x.com/gm8xx8/status/1942375700289233221?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-07-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2143">[Paper Note] Answer Matching Outperforms Multiple Choice for Language Model  Evaluation, Nikhil Chandak+, arXiv'25</a>
<span class="snippet"><span>Summary</span>複数選択のベンチマークは言語モデル評価において重要だが、質問を見ずに回答できることが多い。これに対し、回答マッチングという生成的評価を提案し、自由形式の応答を生成させて参照回答と一致するかを判断。MMLU-ProとGPQA-Diamondで人間の採点データを取得し、回答マッチングがほぼ完璧な一致を達成することを示した。評価方法の変更により、モデルのランキングが大きく変わる可能性がある。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/shashwatgoel7/status/1941153367289364655?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qこれは非常に重要な研究に見えるMultiple Choice Question (MCQ)では、選択肢の中から消去法（論文中では仲間はずれを一つ探す, odd one cut)によって、正解の目処が立ってしまい、分類能力を評価するような尺度になっている。一方で同じモデルでも、Questionのみを与えて、選択肢無しで評価をすると、選択肢ありでは正解できたのに正解できない、という現象が生じる。これはモデルの分類能力ではなく、生成能力を評価しているからであり、これまでのMCQでの評価はモデルの能力の一部、特に識別能力しか評価できていないことが示唆される。このため、Answer Matchingと呼ばれる、モデルに自由記述で出力をさせた後に、referenaceと出力が一致しているか否かで評価をする手法を提案している。GPQA DiamondとMMLU-Proにおいて、人間にAnswer Matchingによる評価をさせオラクルを取得した後、SLMやより大きなモデルでAnswer Matchingを実験したところ、o4-miniを用いたLLM-as-a-Judgeよりも、SLMにおいてさえオラクルに近い性能を発揮し、人間と同等のレベルで自動評価が可能なことが示唆される。

<br>

<img src="https://github.com/user-attachments/assets/edefb3ae-95da-4c3f-9233-9fecf92948b1" alt="image" loading="lazy">まだ冒頭しか読めていないので後で読む</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ScientificDiscovery.html">#ScientificDiscovery</a>
<span class="issue_date">Issue Date: 2025-07-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2139">[Paper Note] AI4Research: A Survey of Artificial Intelligence for Scientific Research, Qiguang Chen+, arXiv'25</a>
<span class="snippet"><span>Summary</span>AIの進展に伴い、AI4Researchに関する包括的な調査が不足しているため、理解と発展が妨げられている。本研究では、AI4Researchの5つの主流タスクを系統的に分類し、研究のギャップや将来の方向性を特定し、関連する応用やリソースをまとめる。これにより、研究コミュニティが迅速にリソースにアクセスでき、革新的なブレークスルーを促進することを目指す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/aicia_solid/status/1940934746932236632?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/Cultural.html">#Cultural</a>
<span class="issue_date">Issue Date: 2025-07-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2133">[Paper Note] CARE: Assessing the Impact of Multilingual Human Preference Learning on  Cultural Awareness, Geyang Guo+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本論文では、文化的多様性を考慮した言語モデル（LM）の訓練方法を分析し、ネイティブな文化的好みを取り入れることで、LMの文化的認識を向上させることを目指します。3,490の文化特有の質問と31,700のネイティブな判断を含むリソース「CARE」を紹介し、高品質なネイティブの好みを少量取り入れることで、さまざまなLMの性能が向上することを示します。また、文化的パフォーマンスが強いモデルはアラインメントからの恩恵を受けやすく、地域間でのデータアクセスの違いがモデル間のギャップを生むことが明らかになりました。CAREは一般に公開される予定です。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/cherylolguo/status/1940798823405600843?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<a class="button" href="articles/Normalization.html">#Normalization</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-07-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2131">[Paper Note] The Curse of Depth in Large Language Models, Wenfang Sun+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本論文では、「深さの呪い」という現象を紹介し、LLMの深い層が期待通りに機能しない理由を分析します。Pre-LNの使用が出力の分散を増加させ、深い層の貢献を低下させることを特定。これを解決するために層正規化スケーリング（LNS）を提案し、出力分散の爆発を抑制します。実験により、LNSがLLMの事前トレーニング性能を向上させることを示し、教師ありファインチューニングにも効果があることを確認しました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/shiwei_liu66/status/1940377801032446428?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q・1795

<br>



<br>

ではそもそもLayerNormalizationを無くしていた（正確にいうとparametrize tanhに置換)が、どちらが優れているのだろうか？

<br>



<br>

<img src="https://github.com/user-attachments/assets/4bc557a0-ae23-4017-9837-7744de74c12e" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/2eead45c-209d-46e4-87e7-0129a4ec5ec2" alt="image" loading="lazy">・1332

<br>



<br>

では知識ニューロンの存在が示唆されており、これはTransformerの層の深い位置に存在し、かつ異なる知識間で知識ニューロンはシェアされない傾向にあった（ただしこれはPost-LNのBERTの話で本研究はPre-LNの話だが。Post-LNの勾配消失問題を緩和し学習を安定化させる研究も2141 のように存在する)。これはこの研究が明らかにしたこととどういう関係性があるだろうか。

<br>



<br>

また、LayerNormalizationのScalingによって深いTransformerブロックの導関数が単位行列となる（学習に寄与しなくなる）ことが改善された場合、知識ニューロンはどのように変化するだろうか？

<br>



<br>

（下記Geminiの応答を見た上での感想)なんとなーくだけれども、おそらく知識ニューロンの局所化が解消されるのかなーという気がする。

<br>



<br>

となると次の疑問としては、MoEアーキテクチャにはどのような影響があるだろうか？

<br>

そもそも知識ニューロンが局所化しているからMoEアーキテクチャのルータによって関連するExpertsのみをactivateすれば（というより結果的にそうなるように学習される）性能を劣化させずに計算効率を上げられていた、と仮定する。そうすると、知識ニューロンが局所化せずに多くのニューロンでシェアされるようになると、2110 のように、サブネットワーク間の情報を互いにやりとりできます、みたいな仕組みがより効いてきそうな気がする。

<br>



<br>

参考までに、Gemini2.5-Proに考察させてみた結果をメモとして残しておく（あくまで参考程度に...）

<br>

```

<br>

ご質問ありがとうございます。非常に興味深い着眼点ですね。「Knowledge Neurons in Pretrained Transformers」と「The Curse of Depth in Large Language Models」は、一見すると全く異なるテーマを扱っているように見えますが、「Transformerの深い層における振る舞い」という共通点で結びつけて考察すると、非常に示唆に富んだ関係性が見えてきます。

<br>



<br>

以下に、両方の論文の概要を解説し、その関係性について考察します。

<br>



<br>

1. Knowledge Neurons in Pretrained Transformers の概要

<br>

この研究は、事前学習済みTransformerモデル（特にBERTなど）の内部で、特定の事実知識がどのように格納されているかを調査したものです。

<br>



<br>

発見: モデルの中間層、特に全結合層（Feed-Forward Network, FFN）に、特定の知識（例：「ダンテ・アリギエーリはイタリアで生まれた」）に強く反応する「知識ニューロン」が存在することを発見しました。

<br>



<br>

特徴: これらの知識ニューロンは、モデルの深い層（後方の層）に、より多く存在する傾向がありました。

<br>



<br>

意味: これまでブラックボックスとされてきた大規模言語モデルの内部で、知識がどのように表現・局在化しているかについて、具体的な手がかりを与えた画期的な研究です。

<br>



<br>

2. The Curse of Depth in Large Language Models の概要

<br>

この研究は、LLMをより深く（層を多く）することの難しさに焦点を当て、その原因と解決策を提案したものです。

<br>



<br>

問題（深さの呪い）: Transformerの標準的なアーキテクチャ（Pre-LN）では、層が深くなるにつれて、LayerNormalization（LN）への入力の分散が指数関数的に増大してしまいます。

<br>



<br>

結果:

<br>



<br>

出力が大きくなりすぎて学習が不安定になります。

<br>



<br>

さらに深刻なのは、深い層ではモデルの出力に関する導関数（勾配計算に必要）がほぼ単位行列になってしまうことです。これは、その層が入力に対してほとんど変換を行わなくなり、学習に寄与しなくなることを意味します。

<br>



<br>

解決策: この問題を解決するため、各層のLayerNormalizationをその深さ（レイヤー番号 l）に応じてスケーリングするというシンプルな手法を提案しました。これにより、深い層でも勾配が適切に伝播し、学習が安定・改善することが示されました。

<br>



<br>

考察：2つの研究の関係性

<br>

これら2つの研究は、「学習の安定性」と「知識の格納方法」という異なる側面から、Transformerの深い層を分析していますが、両者には以下のような深い関係性があると考えられます。

<br>



<br>

学習の不安定性が「知識ニューロン」形成の背景にある可能性

<br>

「The Curse of Depth」で指摘されているように、標準的なTransformerの深い層は、本質的に学習が不安定で、勾配情報が失われやすい環境にあります。

<br>



<br>

この劣悪な学習環境こそが、「知識ニューロン」という形で知識が局所的に格納される原因の一つになっている可能性があります。つまり、

<br>



<br>

学習の非効率性: 深い層のほとんどのニューロンは、勾配消失問題のために効率的に学習を進めることができません。

<br>



<br>

専門化の発生: そのような不安定な環境下で、たまたま特定の知識パターンをうまく捉えることができた一部のニューロンが、その知識を一身に背負う形で強く活性化するよう特化（専門化）していったのではないか、と考えられます。これは、ネットワーク全体で協調して学習するのが難しい状況で、一部のユニットだけが突出して学習を担う、という現象と解釈できます。

<br>



<br>

学習の安定化が、より効率的な知識獲得につながる

<br>

では、「The Curse of Depth」で提案された手法（LNのスケーリング）によって深い層の学習が安定化すると、知識の格納方法はどのように変わるでしょうか。

<br>



<br>

これは非常に興味深い問いであり、2つの可能性が考えられます。

<br>



<br>

可能性A: より強固な知識ニューロンの形成:

<br>

学習が安定することで、各知識ニューロンはより明確に、そして効率的に特定の知識をエンコードできるようになるかもしれません。ノイズの多い環境で偶然生まれた専門家ではなく、安定した環境で育成された真の専門家へと変化するイメージです。

<br>



<br>

可能性B: 知識の分散化:

<br>

ネットワークの全ニューロンが効率的に学習に寄与できるようになるため、一つの知識を少数のニューロンに集中させる必要がなくなり、より多くのニューロンに分散して知識が格納されるようになる可能性も考えられます。

<br>



<br>

現在のところ、学習の安定化は、知識ニューロンがより効率的に形成・機能するための基盤を提供すると考えるのが最も妥当でしょう。「深さの呪い」という問題を解決することは、モデルが知識をどのように獲得し、整理するかという、より根源的なメカニズム（知識ニューロンの振る舞い）にも直接的な影響を与えるはずです。

<br>



<br>

まとめ

<br>

「Knowledge Neurons」は深い層に存在する知識の「状態」を明らかにし、「The Curse of Depth」は深い層で発生する学習の「問題」とその解決策を提示しました。

<br>



<br>

これらを統合すると、「深い層における学習の不安定性という問題が、知識ニューロンという局所的な知識表現を生み出す一因となっており、この問題を解決することで、より効率的で安定した知識の獲得・格納が可能になるかもしれない」という関係性が見えてきます。

<br>



<br>

両者は、LLMの能力と限界を異なる角度から照らし出しており、組み合わせることでモデルの内部動作の解明をさらに一歩前進させる、非常に重要な研究だと言えます。

<br>

```</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Distillation.html">#Distillation</a>
<span class="issue_date">Issue Date: 2025-07-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2129">[Paper Note] NaturalThoughts: Selecting and Distilling Reasoning Traces for General  Reasoning Tasks, Yang Li+, arXiv'25</a>
<span class="snippet"><span>Summary</span>教師モデルからの推論トレースを用いて生徒モデルの能力を向上させる方法を体系的に研究。NaturalReasoningに基づく高品質な「NaturalThoughts」をキュレーションし、サンプル効率とスケーラビリティを分析。データサイズの拡大が性能向上に寄与し、多様な推論戦略を必要とする例が効果的であることを発見。LlamaおよびQwenモデルでの評価により、NaturalThoughtsが既存のデータセットを上回り、STEM推論ベンチマークで優れた性能を示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jaseweston/status/1940656092054204498?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・1768</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/RLHF.html">#RLHF</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/mid-training.html">#mid-training</a>
<a class="button" href="articles/RewardHacking.html">#RewardHacking</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/CurriculumLearning.html">#CurriculumLearning</a>
<a class="button" href="articles/RLVR.html">#RLVR</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<span class="issue_date">Issue Date: 2025-07-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2128">[Paper Note] GLM-4.1V-Thinking: Towards Versatile Multimodal Reasoning with Scalable  Reinforcement Learning, GLM-V Team+, arXiv'25</a>
<span class="snippet"><span>Summary</span>視覚言語モデルGLM-4.1V-Thinkingを発表し、推論中心のトレーニングフレームワークを開発。強力な視覚基盤モデルを構築し、カリキュラムサンプリングを用いた強化学習で多様なタスクの能力を向上。28のベンチマークで最先端のパフォーマンスを達成し、特に難しいタスクで競争力のある結果を示す。モデルはオープンソースとして公開。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/sinclairwang1/status/1940331927724232712?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QQwen2.5-VLよりも性能が良いVLM

<br>

<img src="https://github.com/user-attachments/assets/1215d0cf-3776-4631-a5d5-2c514e7d5a2e" alt="image" loading="lazy">アーキテクチャはこちら。が、pretraining(データのフィルタリング, マルチモーダル→long context継続事前学習)-&gt;SFT(cold startへの対処, reasoning能力の獲得)-&gt;RL(RLVRとRLHFの併用によるパフォーマンス向上とAlignment, RewardHackingへの対処,curriculum sampling)など、全体の学習パイプラインの細かいテクニックの積み重ねで高い性能が獲得されていると考えられる。

<br>

<img src="https://github.com/user-attachments/assets/a692b5de-5f4e-42c6-938e-3718dd2fc0e6" alt="image" loading="lazy"></span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<a class="button" href="articles/Findings.html">#Findings</a>
<span class="issue_date">Issue Date: 2025-07-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2125">[Paper Note] Do Vision-Language Models Have Internal World Models? Towards an Atomic   Evaluation, Qiyue Gao+, ACL（Findings）'25</a>
<span class="snippet"><span>Summary</span>内部世界モデル（WMs）はエージェントの理解と予測を支えるが、最近の大規模ビジョン・ランゲージモデル（VLMs）の基本的なWM能力に関する評価は不足している。本研究では、知覚と予測を評価する二段階のフレームワークを提案し、WM-ABenchというベンチマークを導入。15のVLMsに対する660の実験で、これらのモデルが基本的なWM能力に顕著な制限を示し、特に運動軌道の識別においてほぼランダムな精度であることが明らかになった。VLMsと人間のWMとの間には重要なギャップが存在する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/qiyuegao123/status/1940097188220297613?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<span class="issue_date">Issue Date: 2025-07-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2122">[Paper Note] MARBLE: A Hard Benchmark for Multimodal Spatial Reasoning and Planning, Yulun Jiang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>MARBLEという新しいマルチモーダル推論ベンチマークを提案し、MLLMsの複雑な推論能力を評価。MARBLEは、空間的・視覚的・物理的制約下での多段階計画を必要とするM-PortalとM-Cubeの2つのタスクから成る。現在のMLLMsは低いパフォーマンスを示し、視覚的入力からの情報抽出においても失敗が見られる。これにより、次世代モデルの推論能力向上が期待される。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/michael_d_moor/status/1940062842742526445?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QPortal2を使った新たなベンチマーク。筆者は昔このゲームを少しだけプレイしたことがあるが、普通に難しかった記憶がある😅

<br>



<br>

細かいが表中のGPT-o3は正しくはo3だと思われる。

<br>

時間がなくて全然しっかりと読めていないが、reasoning effortやthinkingモードはどのように設定して評価したのだろうか。

<br>

<img src="https://github.com/user-attachments/assets/a7647007-b718-4b1c-8d8a-396c36d7811d" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/4b996864-7bf8-4ea9-aa3e-84d4e9f3f5d2" alt="image" loading="lazy"></span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Zero/FewShotPrompting.html">#Zero/FewShotPrompting</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<span class="issue_date">Issue Date: 2025-07-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2121">[Paper Note] SMMILE: An Expert-Driven Benchmark for Multimodal Medical In-Context  Learning, Melanie Rieff+, arXiv'25</a>
<span class="snippet"><span>Summary</span>マルチモーダルインコンテキスト学習（ICL）は医療分野での可能性があるが、十分に探求されていない。SMMILEという医療タスク向けの初のマルチモーダルICLベンチマークを導入し、111の問題を含む。15のMLLMの評価で、医療タスクにおけるICL能力が中程度から低いことが示された。ICLはSMMILEで平均8%、SMMILE++で9.4%の改善をもたらし、無関係な例がパフォーマンスを最大9.5%低下させることも確認。例の順序による最近性バイアスがパフォーマンス向上に寄与することも明らかになった。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/michael_d_moor/status/1939664155813839114?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<span class="issue_date">Issue Date: 2025-07-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2120">[Paper Note] Wider or Deeper? Scaling LLM Inference-Time Compute with Adaptive   Branching Tree Search, Yuichi Inoue+, ICLR'25</a>
<span class="snippet"><span>Summary</span>AB-MCTSを提案し、外部フィードバックを活用して繰り返しサンプリングを改善。探索木のノードで新しい応答を「広げる」か「深める」かを動的に決定。実験により、AB-MCTSが従来の手法を上回り、LLMsの応答の多様性と解決策の洗練を強調。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iwiwi/status/1939914618132168961?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/ScientificDiscovery.html">#ScientificDiscovery</a>
<a class="button" href="articles/Reproducibility.html">#Reproducibility</a>
<span class="issue_date">Issue Date: 2025-06-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2118">[Paper Note] The Automated LLM Speedrunning Benchmark: Reproducing NanoGPT  Improvements, Bingchen Zhao+, arXiv'25</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）の進展を活用し、AIエージェントの研究再現能力を評価するために、LLMスピードランベンチマークを導入。19のタスクで訓練スクリプトとヒントを提供し、迅速な実行を促進。既知の革新の再実装が難しいことを発見し、科学的再現を自動化するための指標を提供。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/karpathy/status/1939709449956126910?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/TransferLearning.html">#TransferLearning</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<a class="button" href="articles/VerifiableRewards.html">#VerifiableRewards</a>
<a class="button" href="articles/Off-Policy.html">#Off-Policy</a>
<a class="button" href="articles/On-Policy.html">#On-Policy</a>
<a class="button" href="articles/Non-VerifiableRewards.html">#Non-VerifiableRewards</a>
<span class="issue_date">Issue Date: 2025-06-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2117">[Paper Note] Bridging Offline and Online Reinforcement Learning for LLMs, Jack Lanchantin+, arXiv'25</a>
<span class="snippet"><span>Summary</span>大規模言語モデルのファインチューニングにおける強化学習手法の効果を、オフラインからオンラインへの移行において調査。数学タスクと指示に従うタスクのベンチマーク評価を行い、オンラインおよびセミオンラインの最適化手法がオフライン手法を上回る結果を示す。トレーニングダイナミクスとハイパーパラメータ選択について分析し、検証可能な報酬と検証不可能な報酬を共同で扱うことでパフォーマンス向上を確認。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jaseweston/status/1939673136842313960?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<span class="issue_date">Issue Date: 2025-06-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2110">[Paper Note] Chain-of-Experts: Unlocking the Communication Power of  Mixture-of-Experts Models, Zihan Wang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Chain-of-Experts（CoE）は、逐次的な専門家間のコミュニケーションを導入した新しいMixture-of-Experts（MoE）アーキテクチャで、トークンを反復的に処理する。各反復ステップで専用のルーターを使用し、動的な専門家選択を可能にすることで、モデルの表現能力を向上させる。CoEは数学的推論タスクにおいて、従来のMoEと比較して検証損失を低下させ、メモリ使用量を削減する。反復的残差構造と専門家の専門化が、より表現力豊かな結果をもたらすことが示されている。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/theturingpost/status/1938728784351658087?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-06-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2109">[Paper Note] FineWeb2: One Pipeline to Scale Them All -- Adapting Pre-Training Data  Processing to Every Language, Guilherme Penedo+, arXiv'25</a>
<span class="snippet"><span>Summary</span>多言語LLMsの性能向上のために、FineWebに基づく新しい事前学習データセットキュレーションパイプラインを提案。9つの言語に対して設計選択肢を検証し、非英語コーパスが従来のデータセットよりも高性能なモデルを生成できることを示す。データセットの再バランス手法も導入し、1000以上の言語にスケールアップした20テラバイトの多言語データセットFineWeb2を公開。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gui_penedo/status/1938631842720022572?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qv1

<br>

・1942abstを見る限りFinewebを多言語に拡張した模様</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/mid-training.html">#mid-training</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-06-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2107">[Paper Note] OctoThinker: Mid-training Incentivizes Reinforcement Learning Scaling, Zengzhi Wang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>異なるベース言語モデル（LlamaやQwen）の強化学習（RL）における挙動を調査し、中間トレーニング戦略がRLのダイナミクスに与える影響を明らかに。高品質の数学コーパスがモデルのパフォーマンスを向上させ、長い連鎖的思考（CoT）がRL結果を改善する一方で、冗長性や不安定性を引き起こす可能性があることを示す。二段階の中間トレーニング戦略「Stable-then-Decay」を導入し、OctoThinkerモデルファミリーを開発。オープンソースのモデルと数学推論コーパスを公開し、RL時代の基盤モデルの研究を支援することを目指す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/sinclairwang1/status/1938244843857449431?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qmid-trainingの観点から、post trainingにおけるRLがスケーリングする条件をsystematicallyに調査している模様論文中にはmid-training[^1]の定義が記述されている:

<br>



<br>

<img width="808" height="353" alt="Image" src="https://github.com/user-attachments/assets/da206d3d-f811-4d69-8210-a1d0816c827f">

<br>



<br>

[^1]: mid-trainingについてはコミュニティの間で厳密な定義はまだ無くバズワードっぽく使われている、という印象を筆者は抱いており、本稿は文献中でmid-trainingを定義する初めての試みという所感</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<span class="issue_date">Issue Date: 2025-06-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2106">[Paper Note] RLPR: Extrapolating RLVR to General Domains without Verifiers, Tianyu Yu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>RLVRはLLMの推論能力を向上させるが、主に数学やコードに限られる。これを克服するため、検証者不要のRLPRフレームワークを提案し、LLMのトークン確率を報酬信号として利用。ノイズの多い確率報酬に対処する手法を導入し、実験によりGemma、Llama、Qwenモデルで推論能力を向上させた。特に、TheoremQAで7.6ポイント、Minervaで7.5ポイントの改善を示し、General-Reasonerを平均1.6ポイント上回った。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1938359430980268329?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q既存のRLVRはVerifierを構築しなければならず、しばしばそのVerifierは複雑になりやすく、スケールさせるには課題があった。RLPR（Probabliity Reward)は、生成された応答から回答yを抽出し、残りをreasoning zとする。そして回答部分yをreference y^\で置換したトークン列o'を生成（zがo'に対してどのような扱いになるかは利用するモデルや出力フォーマットによる気がする)し、o'のポリシーモデルでのトークン単位での平均生成確率を報酬とする。尤度のような系列全体の生起確率を考慮する方法が直感的に役に立ちそうだが、計算の際の確率積は分散が高いだけでなく、マイナーな類義語が与えられた時に（たとえば1 tokenだけ生起確率が小さかった場合)に、Rewardが極端に小さくなりsensitiveであることを考察し、平均生成確率を採用している。

<br>

<img src="https://github.com/user-attachments/assets/52bc778b-d6c9-495c-8bf3-586c7381915b" alt="image" loading="lazy">

<br>



<br>

Rule basedなVerifierを用いたRLVRよりもgeneralなドメインとmathドメインで性能向上。コーディングなどでも効果はあるのだろうか？

<br>

<img src="https://github.com/user-attachments/assets/99e26d11-2e16-4452-9410-860b74f497cd" alt="image" loading="lazy">ざっくり見た感じ、RLVRがそもそも適用できないドメインで実験した場合の結果がないように見え、適用した場合に有効なのかは気になるところ。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<span class="issue_date">Issue Date: 2025-06-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2105">[Paper Note] OpenVision: A Fully-Open, Cost-Effective Family of Advanced Vision  Encoders for Multimodal Learning, Xianhang Li+, arXiv'25</a>
<span class="snippet"><span>Summary</span>OpenVisionは、完全にオープンでコスト効果の高いビジョンエンコーダーのファミリーを提案し、CLIPと同等以上の性能を発揮します。既存の研究を基に構築され、マルチモーダルモデルの進展に実用的な利点を示します。5.9Mから632.1Mパラメータのエンコーダーを提供し、容量と効率の柔軟なトレードオフを実現します。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/cihangxie/status/1920575141849030882?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/PRM.html">#PRM</a>
<span class="issue_date">Issue Date: 2025-06-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2104">[Paper Note] Process Reward Models That Think, Muhammad Khalifa+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、データ効率の良いステップバイステップの検証器（ThinkPRM）を提案し、少ないプロセスラベルで高性能を実現します。ThinkPRMは、長いCoTモデルの推論能力を活用し、PRM800Kのわずか1%のプロセスラベルで、従来の検証器を上回る性能を示します。具体的には、ProcessBenchやMATH-500などのベースラインを超え、ドメイン外評価でも優れた結果を得ています。最小限の監視でのトレーニングを通じて、検証計算のスケーリングの重要性を強調しています。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/RewardHacking.html">#RewardHacking</a>
<span class="issue_date">Issue Date: 2025-06-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2101">[Paper Note] Robust Reward Modeling via Causal Rubrics, Pragya Srivastava+, arXiv'25</a>
<span class="snippet"><span>Summary</span>報酬モデル（RMs）は人間のフィードバックを通じて大規模言語モデル（LLMs）を整合させるが、報酬ハッキングの影響を受けやすい。本研究では、報酬ハッキングを軽減するための新しいフレームワーク「Crome」を提案。Cromeは因果的拡張と中立的拡張を用いて、因果属性に基づく感度と虚偽属性に対する不変性を強制する。実験結果では、CromeはRewardBenchで標準的なベースラインを大幅に上回り、平均精度を最大5.4%向上させた。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/harman26singh/status/1937876897058181230?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q以下がresearch question:

<br>

<img src="https://github.com/user-attachments/assets/98c97b8b-ebca-4a40-9c0f-a8c175044fb9" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/SyntheticDataGeneration.html">#SyntheticDataGeneration</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2094">[Paper Note] Magpie: Alignment Data Synthesis from Scratch by Prompting Aligned LLMs   with Nothing, Zhangchen Xu+, ICLR'25</a>
<span class="snippet"><span>Summary</span>高品質な指示データはLLMの整合に不可欠であり、Magpieという自己合成手法を提案。Llama-3-Instructを用いて400万の指示と応答を生成し、30万の高品質なインスタンスを選定。Magpieでファインチューニングしたモデルは、従来のデータセットを用いたモデルと同等の性能を示し、特に整合ベンチマークで優れた結果を得た。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=Pnk7vMbznK<img src="https://github.com/user-attachments/assets/9cb451b2-5440-43a4-9867-b5206dd08cca" alt="image" loading="lazy">

<br>



<br>

下記のようなpre-queryテンプレートを与え（i.e., userの発話は何も与えず、ユーザの発話を表す特殊トークンのみを渡す）instructionを生成し、post-queryテンプレートを与える（i.e., pre-queryテンプレート+生成されたinstruction+assistantの発話の開始を表す特殊トークンのみを渡す）ことでresponseを生成することで、prompt engineeringやseed無しでinstruction tuningデータを合成できるという手法。

<br>

<img src="https://github.com/user-attachments/assets/59e9ea58-1088-4f7f-a5e1-05fba7221aca" alt="image" loading="lazy">

<br>



<br>

生成した生のinstruction tuning pair dataは、たとえば下記のようなフィルタリングをすることで品質向上が可能で

<br>

<img src="https://github.com/user-attachments/assets/6dc19e89-2e0d-409d-9d96-eca8d92d27d3" alt="image" loading="lazy">

<br>



<br>

reward modelと組み合わせてLLMからのresponseを生成しrejection samplingすればDPOのためのpreference dataも作成できるし、single turnの発話まで生成させた後もう一度pre/post-queryをconcatして生成すればMulti turnのデータも生成できる。

<br>



<br>

他のも例えば、システムプロンプトに自分が生成したい情報を与えることで、特定のドメインに特化したデータ、あるいは特定の言語に特化したデータも合成できる。

<br>

<img src="https://github.com/user-attachments/assets/f5f06b90-d1cb-4de8-bbaa-622abbcc0b6b" alt="image" loading="lazy"></span>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/pretrained-LM.html">#pretrained-LM</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2093">[Paper Note] llm-jp-modernbert: A ModernBERT Model Trained on a Large-Scale Japanese  Corpus with Long Context Length, Issa Sugiura+, arXiv'25</a>
<span class="snippet"><span>Summary</span>ModernBERTモデル（llm-jp-modernbert）は、8192トークンのコンテキスト長を持つ日本語コーパスで訓練され、フィルマスクテスト評価で良好な結果を示す。下流タスクでは既存のベースラインを上回らないが、コンテキスト長の拡張効果を分析し、文の埋め込みや訓練中の遷移を調査。再現性を支援するために、モデルと評価コードを公開。</span>
<span class="snippet"><span>Comment</span>参考:

<br>

・1761</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Safety.html">#Safety</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2091">[Paper Note] AnswerCarefully: A Dataset for Improving the Safety of Japanese LLM  Output, Hisami Suzuki+, arXiv'25</a>
<span class="snippet"><span>Summary</span>日本のLLMの安全性を高めるためのデータセット「AnswerCarefully」を紹介。1,800組の質問と参照回答から成り、リスクカテゴリをカバーしつつ日本の文脈に合わせて作成。微調整により出力の安全性が向上し、12のLLMの安全性評価結果も報告。英語翻訳と注釈を提供し、他言語でのデータセット作成を促進。</span>
<span class="snippet"><span>Comment</span>Blog:https://llmc.nii.ac.jp/answercarefully-dataset/</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2088">[Paper Note] Drop-Upcycling: Training Sparse Mixture of Experts with Partial   Re-initialization, Taishi Nakamura+, ICLR'25</a>
<span class="snippet"><span>Summary</span>Drop-Upcycling手法を提案し、MoEモデルのトレーニング効率を向上。事前にトレーニングされた密なモデルの知識を活用しつつ、一部の重みを再初期化することで専門家の専門化を促進。大規模実験により、5.9BパラメータのMoEモデルが13B密なモデルと同等の性能を達成し、トレーニングコストを約1/4に削減。すべての実験リソースを公開。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=gx1wHnf5Vp関連:

<br>

・1546提案手法の全体像とDiversity re-initializationの概要。元のUpcyclingでは全てidenticalな重みでreplicateされていたため、これが個々のexpertがlong termでの学習で特化することの妨げになり、最終的に最大限のcapabilityを発揮できず、収束が遅い要因となっていた。これを、Upcyclingした重みのうち、一部のindexのみを再初期化することで、replicate元の知識を保持しつつ、expertsの多様性を高めることで解決する。

<br>

<img src="https://github.com/user-attachments/assets/46ec75a2-30b1-4f48-9f21-cf5f6e30df95" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/ef3c66b2-32a5-46ab-bb31-828fb4570b53" alt="image" loading="lazy">

<br>



<br>

提案手法は任意のactivation function適用可能。今回はFFN Layerのactivation functionとして一般的なSwiGLUを採用した場合で説明している。

<br>



<br>

Drop-Upcyclingの手法としては、通常のUpcyclingと同様、FFN Layerの重みをn個のexpertsの数だけreplicateする。その後、re-initializationを実施する比率rに基づいて、[1, intermediate size d_f]の範囲からrd_f個のindexをサンプリングする。最終的にSwiGLU、およびFFNにおける3つのWeight W_{gate, up, down}において、サンプリングされたindexと対応するrow/columnと対応する重みをre-initializeする。

<br>



<br>

re-initializeする際には、各W_{gate, up, down}中のサンプリングされたindexと対応するベクトルの平均と分散をそれぞれ独立して求め、それらの平均と分散を持つ正規分布からサンプリングする。

<br>



<br>

学習の初期から高い性能を発揮し、long termでの性能も向上している。また、learning curveの形状もscratchから学習した場合と同様の形状となっており、知識の転移とexpertsのspecializationがうまく進んだことが示唆される。

<br>

<img src="https://github.com/user-attachments/assets/945e5ae5-05cd-4117-80e8-078b47f0e53c" alt="image" loading="lazy">解説:https://llm-jp.nii.ac.jp/news/post-566/</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2086">[Paper Note] Shrinking the Generation-Verification Gap with Weak Verifiers, Jon Saad-Falcon+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Weaverは、複数の弱いverifiersを組み合わせて強力なverifierを設計するフレームワークであり、ラベル付きデータへの依存を減らすために弱い監視を利用します。出力を正規化し、特定のverifiersをフィルタリングすることで、精度の向上を図ります。Weaverは、推論および数学タスクにおいてPass@1性能を大幅に改善し、Llama 3.3 70B Instructを用いて高い精度を達成しました。計算コスト削減のために、統合出力スコアを用いてクロスエンコーダを訓練します。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jonsaadfalcon/status/1937600479527317802?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2085">[Paper Note] Mercury: Ultra-Fast Language Models Based on Diffusion, Inception Labs+, arXiv'25</a>
<span class="snippet"><span>Summary</span>新しい拡散型大規模言語モデルMercuryを発表。特にコーディングアプリケーション向けのMercury Coderは、MiniとSmallの2サイズで提供され、速度と品質で最先端を達成。独立評価では、Mercury Coder Miniが1109トークン/秒、Smallが737トークン/秒を記録し、他のモデルを大幅に上回る性能を示す。さらに、実世界での検証結果や公開API、無料プレイグラウンドも提供。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/arankomatsuzaki/status/1937360864262389786?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qスループット（モデルのトークン生成速度）が、SoTAらしいdLLMモデル解説:https://x.com/hillbig/status/1938026627642101858?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2084">[Paper Note] Recycling the Web: A Method to Enhance Pre-training Data Quality and  Quantity for Language Models, Thao Nguyen+, arXiv'25</a>
<span class="snippet"><span>Summary</span>スケーリング法則に基づき、低品質なウェブデータを再利用する手法「REWIRE」を提案。これにより、事前学習データの合成表現を増やし、フィルタリングされたデータのみでのトレーニングと比較して、22のタスクで性能を向上。生データと合成データの混合が効果的であることを示し、ウェブテキストのリサイクルが事前学習データのスケーリングに有効であることを示唆。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/thao_nguyen26/status/1937210428876292457?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q学習データの枯渇に対する対処として別の方向性としては下記のような研究もある:

<br>

・1829</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/PRM.html">#PRM</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2083">[Paper Note] ReasonFlux-PRM: Trajectory-Aware PRMs for Long Chain-of-Thought  Reasoning in LLMs, Jiaru Zou+, arXiv'25</a>
<span class="snippet"><span>Summary</span>新しいプロセス報酬モデルReasonFlux-PRMを提案し、推論トレースの評価を強化。ステップと軌道の監視を組み込み、報酬割り当てを細かく行う。実験により、ReasonFlux-PRM-7Bが高品質なデータ選択と性能向上を実現し、特に監視付きファインチューニングで平均12.1%の向上を達成。リソース制約のあるアプリケーション向けにReasonFlux-PRM-1.5Bも公開。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_akhaliq/status/1937345023005048925?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/Tokenizer.html">#Tokenizer</a>
<span class="issue_date">Issue Date: 2025-06-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2082">[Paper Note] Vision as a Dialect: Unifying Visual Understanding and Generation via  Text-Aligned Representations, Jiaming Han+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本論文では、視覚理解と生成を統一するマルチモーダルフレームワークTarを提案。Text-Aligned Tokenizer（TA-Tok）を用いて画像を離散トークンに変換し、視覚とテキストを統一空間に統合。スケール適応型のエンコーディングとデコーディングを導入し、高忠実度の視覚出力を生成。迅速な自己回帰モデルと拡散ベースのモデルを用いたデトークナイザーを活用し、視覚理解と生成の改善を実現。実験結果では、Tarが既存手法と同等以上の性能を示し、効率的なトレーニングを達成。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_akhaliq/status/1937345768223859139?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qtext modalityとvision modalityを共通の空間で表現する

<br>

<img src="https://github.com/user-attachments/assets/356e86e1-cad9-4bee-8398-d68c4fc6ad46" alt="image" loading="lazy">Visual Understanding/Generationのベンチで全体的に高い性能を達成

<br>

<img src="https://github.com/user-attachments/assets/6e45aec0-ae0b-4327-923f-fdfce8e83ca0" alt="image" loading="lazy"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2025-06-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2080">[Paper Note] Mind the Gap: Examining the Self-Improvement Capabilities of Large  Language Models, Yuda Song+, ICLR'25</a>
<span class="snippet"><span>Summary</span>自己改善はLLMの出力検証を通じてデータをフィルタリングし、蒸留するメカニズムである。本研究では、自己改善の数学的定式化を行い、生成-検証ギャップに基づくスケーリング現象を発見。さまざまなモデルとタスクを用いた実験により、自己改善の可能性とその性能向上方法を探求し、LLMの理解を深めるとともに、将来の研究への示唆を提供する。</span>
<span class="snippet"><span>Comment</span>参考:https://joisino.hatenablog.com/entry/misleadVerificationに対する理解を深めるのに非常に良さそう</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<span class="issue_date">Issue Date: 2025-06-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2079">[Paper Note] jina-embeddings-v4: Universal Embeddings for Multimodal Multilingual  Retrieval, Michael Günther+, arXiv'25</a>
<span class="snippet"><span>Summary</span>3.8億パラメータのマルチモーダル埋め込みモデル「jina-embeddings-v4」を提案。新しいアーキテクチャにより、クエリベースの情報検索やクロスモーダルの類似性検索を最適化。タスク特化型のLoRAアダプターを組み込み、視覚的に豊かなコンテンツの処理に優れた性能を発揮。新しいベンチマーク「Jina-VDR」も導入。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/arankomatsuzaki/status/1937342962075378014?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2025-06-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2077">[Paper Note] On the Self-Verification Limitations of Large Language Models on   Reasoning and Planning Tasks, Kaya Stechly+, ICLR'25</a>
<span class="snippet"><span>Summary</span>LLMsの推論能力に関する意見の相違を背景に、反復的なプロンプトの効果をGame of 24、グラフ彩色、STRIPS計画の3領域で調査。自己批評がパフォーマンスに悪影響を及ぼす一方、外部の正しい推論者による検証がパフォーマンスを向上させることを示した。再プロンプトによって複雑な設定の利点を維持できることも確認。</span>
<span class="snippet"><span>Comment</span>参考:https://joisino.hatenablog.com/entry/misleadOpenReview:https://openreview.net/forum?id=4O0v4s3IzY</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RLHF.html">#RLHF</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2025-06-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2076">[Paper Note] Language Models Learn to Mislead Humans via RLHF, Jiaxin Wen+, ICLR'25</a>
<span class="snippet"><span>Summary</span>RLHFは言語モデルのエラーを悪化させる可能性があり、モデルが人間を納得させる能力を向上させる一方で、タスクの正確性は向上しない。質問応答タスクとプログラミングタスクで被験者の誤検出率が増加し、意図された詭弁を検出する手法がU-SOPHISTRYには適用できないことが示された。これにより、RLHFの問題点と人間支援の研究の必要性が浮き彫りになった。</span>
<span class="snippet"><span>Comment</span>参考:https://joisino.hatenablog.com/entry/mislead</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Tokenizer.html">#Tokenizer</a>
<span class="issue_date">Issue Date: 2025-06-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2073">[Paper Note] From Bytes to Ideas: Language Modeling with Autoregressive U-Nets, Mathurin Videau+, arXiv'25</a>
<span class="snippet"><span>Summary</span>自己回帰型U-Netを用いてトークン化の柔軟性を向上させ、モデルが生のバイトから単語や単語のペアを生成することでマルチスケールの視点を提供。深い段階では広範な意味パターンに注目し、浅い段階はBPEベースラインに匹敵する性能を発揮。これにより、文字レベルのタスクやリソースの少ない言語間での知識移転が可能となる。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dair_ai/status/1936825784473096335?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-06-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2070">[Paper Note] Revisiting Reinforcement Learning for LLM Reasoning from A Cross-Domain  Perspective, Zhoujun Cheng+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Guruを導入し、数学、コード、科学、論理、シミュレーション、表形式の6つの推論ドメインにわたる92KのRL推論コーパスを構築。これにより、LLM推論のためのRLの信頼性と効果を向上させ、ドメイン間の変動を観察。特に、事前学習の露出が限られたドメインでは、ドメイン内トレーニングが必要であることを示唆。Guru-7BとGuru-32Bモデルは、最先端の性能を達成し、複雑なタスクにおいてベースモデルの性能を改善。データとコードは公開。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/chengzhoujun/status/1936113985507803365?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qpost-trainingにおけるRLのcross domain（Math, Code, Science, Logic, Tabular)における影響を調査した研究。非常に興味深い研究。詳細は元論文が著者ポスト参照のこと。Qwenシリーズで実験。以下ポストのまとめ。

<br>



<br>

・mid trainingにおいて重点的に学習されたドメインはRLによるpost trainingで強い転移を発揮する（Code, Math, Science)

<br>

・一方、mid trainingであまり学習データ中に出現しないドメインについては転移による性能向上は最小限に留まり、in-domainの学習データをきちんと与えてpost trainingしないと性能向上は限定的

<br>

・簡単なタスクはcross domainの転移による恩恵をすぐに得やすい（Math500, MBPP),難易度の高いタスクは恩恵を得にくい

<br>

・各ドメインのデータを一様にmixすると、単一ドメインで学習した場合と同等かそれ以上の性能を達成する

<br>

・必ずしもresponse lengthが長くなりながら予測性能が向上するわけではなく、ドメインによって傾向が異なる

<br>

・たとえば、Code, Logic, Tabularの出力は性能が向上するにつれてresponse lengthは縮小していく

<br>

・一方、Science, Mathはresponse lengthが増大していく。また、Simulationは変化しない

<br>

・異なるドメインのデータをmixすることで、最初の数百ステップにおけるrewardの立ち上がりが早く（単一ドメインと比べて急激にrewardが向上していく）転移がうまくいく

<br>

  ・（これは私がグラフを見た感想だが、単一ドメインでlong runで学習した場合の最終的な性能は4/6で同等程度、2/6で向上（Math, Science)

<br>

・非常に難易度の高いmathデータのみにフィルタリングすると、フィルタリング無しの場合と比べて難易度の高いデータに対する予測性能は向上する一方、簡単なOODタスク（HumanEval)の性能が大幅に低下する（特定のものに特化するとOODの性能が低下する）

<br>

・RLはpre(mid)-trainingで学習されたreasoning能力を引き出すだけではなく、新規のタスクに対しては新たなreasoning能力を獲得できる

<br>

・モデルサイズが小さいと、RLでpost-training後のpass@kのkを大きくするとどこかでサチり、baseモデルと交差するが、大きいとサチらず交差しない

<br>

  ・モデルサイズが大きいとより多様なreasoningパスがunlockされている

<br>

・pass@kで観察したところRLには2つのphaseのよつなものが観測され、最初の0-160（1 epoch)ステップではpass@1が改善したが、pass@max_kは急激に性能が劣化した。一方で、160ステップを超えると、双方共に徐々に性能改善が改善していくような変化が見られた</span>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/parser.html">#parser</a>
<span class="issue_date">Issue Date: 2025-06-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2063">[Paper Note] Dolphin: Document Image Parsing via Heterogeneous Anchor Prompting, Hao Feng+, ACL'25</a>
<span class="snippet"><span>Summary</span>文書画像解析の新モデル「Dolphin」を提案。レイアウト要素をシーケンス化し、タスク特有のプロンプトと組み合わせて解析を行う。3000万以上のサンプルで訓練し、ページレベルと要素レベルの両方で最先端の性能を達成。効率的なアーキテクチャを実現。コードは公開中。</span>
<span class="snippet"><span>Comment</span>repo:https://github.com/bytedance/DolphinSoTAなDocumentのparser

<br>

<img src="https://github.com/user-attachments/assets/5b1c4480-65f1-46cc-9318-f8126327e066" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<span class="issue_date">Issue Date: 2025-06-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2062">[Paper Note] Scaling Laws for Upcycling Mixture-of-Experts Language Models, Seng Pei Liew+, ICML'25</a>
<span class="snippet"><span>Summary</span>LLMsの事前学習は高コストで時間がかかるため、アップサイクリングとMoEモデルの計算効率向上が提案されている。本研究では、アップサイクリングをMoEに適用し、データセットのサイズやモデル構成に依存するスケーリング法則を特定。密なトレーニングデータとアップサイクリングデータの相互作用が効率を制限することを示し、アップサイクリングのスケールアップに関する指針を提供。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/sbintuitions/status/1935970879923540248?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QOpenReview:https://openreview.net/forum?id=ZBBo19jldX関連:

<br>

・1546</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<span class="issue_date">Issue Date: 2025-06-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2059">[Paper Note] Reasoning by Superposition: A Theoretical Perspective on Chain of Continuous Thought, Hanlin Zhu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、連続CoTsを用いた二層トランスフォーマーが有向グラフ到達可能性問題を解決できることを証明。連続CoTsは複数の探索フロンティアを同時にエンコードし、従来の離散CoTsよりも効率的に解を導く。実験により、重ね合わせ状態が自動的に現れ、モデルが複数のパスを同時に探索することが確認された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/tydsh/status/1935206012799303817?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/OpenSource.html">#OpenSource</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-06-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2058">[Paper Note] AceReason-Nemotron 1.1: Advancing Math and Code Reasoning through SFT and RL Synergy, Zihan Liu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、教師ありファインチューニング（SFT）と強化学習（RL）の相乗効果を探求し、SFTトレーニングデータの整備においてプロンプト数の増加が推論性能を向上させることを示しました。特に、サンプリング温度を適切に調整することで、RLトレーニングの効果を最大化できることが分かりました。最終的に、AceReason-Nemotron-1.1モデルは、前モデルを大きく上回り、数学およびコードベンチマークで新たな最先端性能を達成しました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/ychennlp/status/1935005283178492222?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

様々なtakeawayがまとめられている。SFT,RLに利用されたデータも公開・1829

<br>



<br>

において事前学習時に4 epochまでは性能の改善幅が大きいと報告されていたが、SFTでも5 epoch程度まで学習すると良い模様。

<br>



<br>

また、SFT dataをscalingさせる際は、promptの数だけでなく、prompt単位のresponse数を増やすのが効果的

<br>

<img src="https://github.com/user-attachments/assets/67e2a4ff-555b-4e22-a90a-ee239704805e" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-06-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2054">[Paper Note] Direct Reasoning Optimization: LLMs Can Reward And Refine Their Own  Reasoning for Open-Ended Tasks, Yifei Xu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>DRO（直接推論最適化）を提案し、LLMsをオープンエンドの長文推論タスクに微調整するための強化学習フレームワークを構築。新しい報酬信号R3を用いて推論と参照結果の一貫性を捉え、自己完結したトレーニングを実現。ParaRevとFinQAのデータセットで強力なベースラインを上回る性能を示し、広範な適用可能性を確認。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iscienceluvr/status/1934957116571451409?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-06-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2053">[Paper Note] Wait, We Don't Need to "Wait" Removing Thinking Tokens Improves  Reasoning Efficiency, Chenlong Wang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>自己反省を抑制する「NoWait」アプローチを提案し、推論の効率を向上。10のベンチマークで最大27%-51%の思考の連鎖の長さを削減し、有用性を維持。マルチモーダル推論のための効果的なソリューションを提供。</span>
<span class="snippet"><span>Comment</span>Wait, Hmmといったlong CoTを誘導するようなtokenを抑制することで、Accはほぼ変わらずに生成されるトークン数を削減可能、といった図に見える。Reasoningモデルでデコーディング速度を向上したい場合に効果がありそう。

<br>

<img src="https://github.com/user-attachments/assets/c0abd2b4-f019-435e-b72f-f588fa0eb782" alt="image" loading="lazy">元ポスト:https://x.com/huggingpapers/status/1935130111608492060?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-06-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2052">[Paper Note] Massive Supervised Fine-tuning Experiments Reveal How Data, Layer, and  Training Factors Shape LLM Alignment Quality, Yuto Harada+, EMNLP'25</a>
<span class="snippet"><span>Summary</span>SFTはLLMを人間の指示に整合させる重要なプロセスであり、1,000以上のSFTモデルを生成し、データセットの特性と層ごとの変更を調査。訓練タスクの相乗効果やモデル固有の戦略の重要性を明らかにし、困惑度がSFTの効果を予測することを示した。中間層の重みの変化がパフォーマンス向上と強く相関し、研究を加速させるためにモデルと結果を公開予定。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/odashi_t/status/1935191113981403359?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QNLP'25:https://www.anlp.jp/proceedings/annual_meeting/2025/pdf_dir/C10-6.pdf</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/FactualKnowledge.html">#FactualKnowledge</a>
<span class="issue_date">Issue Date: 2025-06-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2049">[Paper Note] What Is Seen Cannot Be Unseen: The Disruptive Effect of Knowledge  Conflict on Large Language Models, Kaiser Sun+, arXiv'25</a>
<span class="snippet"><span>Summary</span>LLMの文脈情報とパラメトリック知識の対立を評価する診断フレームワークを提案。知識の対立はタスクに影響を与えず、一致時にパフォーマンスが向上。モデルは内部知識を抑制できず、対立の理由が文脈依存を高めることを示した。これにより、LLMの評価と展開における知識の対立の重要性が強調される。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/kaiserwholearns/status/1934582217692295268?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-06-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2048">[Paper Note] Overclocking LLM Reasoning: Monitoring and Controlling Thinking Path  Lengths in LLMs, Roy Eisenstadt+, arXiv'25</a>
<span class="snippet"><span>Summary</span>LLMの推論プロセスにおける思考段階の長さを調整するメカニズムを探求。進捗をエンコードし、可視化することで計画ダイナミクスを明らかにし、不要なステップを減らす「オーバークロッキング」手法を提案。これにより、考えすぎを軽減し、回答精度を向上させ、推論のレイテンシを減少させることを実証。コードは公開。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gm8xx8/status/1934357202619310559?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<span class="issue_date">Issue Date: 2025-06-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2047">[Paper Note] LiveCodeBench Pro: How Do Olympiad Medalists Judge LLMs in Competitive  Programming?, Zihan Zheng+, arXiv'25</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）は競技プログラミングで人間のエリートを上回るとされるが、実際には重要な限界があることを調査。新たに導入した「LiveCodeBench Pro」ベンチマークにより、LLMsは中程度の難易度の問題で53%のpass@1を達成する一方、難しい問題では0%という結果が得られた。LLMsは実装重視の問題では成功するが、複雑なアルゴリズム的推論には苦労し、誤った正当化を生成することが多い。これにより、LLMsと人間の専門家との間に重要なギャップがあることが明らかになり、今後の改善のための診断が提供される。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/arankomatsuzaki/status/1934433210387296414?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QHardな問題は現状のSoTAモデル（Claude4が含まれていないが）でも正答率0.0%

<br>

<img src="https://github.com/user-attachments/assets/d0e29f23-2b66-4b19-b39a-68f3717d7058" alt="image" loading="lazy">

<br>



<br>

ベンチマークに含まれる課題のカテゴリ

<br>

<img src="https://github.com/user-attachments/assets/b41b11d7-52a2-4a22-848d-cb08900da5cf" alt="image" loading="lazy">

<br>



<br>

実サンプルやケーススタディなどはAppendix参照のこと。</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2025-06-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2046">[Paper Note] RAG+: Enhancing Retrieval-Augmented Generation with Application-Aware  Reasoning, Yu Wang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>RAG+は、Retrieval-Augmented Generationの拡張で、知識の適用を意識した推論を組み込む。二重コーパスを用いて、関連情報を取得し、目標指向の推論に適用する。実験結果は、RAG+が標準的なRAGを3-5%、複雑なシナリオでは最大7.5%上回ることを示し、知識統合の新たなフレームワークを提供する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/omarsar0/status/1934667096828399641?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q知識だけでなく知識の使い方も蓄積し、利用時に検索された知識と紐づいた使い方を活用することでRAGの推論能力を向上させる。

<br>

<img src="https://github.com/user-attachments/assets/23f2b2cd-458b-437a-837d-11d4db28162f" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/b6a01788-7a14-41a3-81f7-41a2add62bd1" alt="image" loading="lazy">Figure 1のような例はReasoningモデルが進化していったら、わざわざ知識と使い方を紐付けなくても、世界知識から使い方を補完可能だと思われるので不要となると思われる。

<br>

が、真にこの手法が力を発揮するのは「ドメイン固有の使い方やルール」が存在する場合で、どれだけLLMが賢くなっても推論によって導き出せないもの、のついては、こういった手法は効力を発揮し続けるのではないかと思われる。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<span class="issue_date">Issue Date: 2025-06-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2045">[Paper Note] ALE-Bench: A Benchmark for Long-Horizon Objective-Driven Algorithm  Engineering, Yuki Imajuku+, arXiv'25</a>
<span class="snippet"><span>Summary</span>AIシステムの最適化問題に対するパフォーマンスを評価する新しいベンチマークALE-Benchを提案。ALE-Benchは実際のタスクに基づき、長期的な解決策の洗練を促進する。大規模言語モデル（LLM）の評価では特定の問題で高いパフォーマンスを示すが、一貫性や長期的な問題解決能力において人間とのギャップが残ることが明らかになり、今後のAI進展に向けた必要性を示唆している。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/sakanaailabs/status/1934767254715117812?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連ポスト:https://x.com/iwiwi/status/1934830621756674499?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/KnowledgeEditing.html">#KnowledgeEditing</a>
<a class="button" href="articles/FactualKnowledge.html">#FactualKnowledge</a>
<a class="button" href="articles/meta-learning.html">#meta-learning</a>
<span class="issue_date">Issue Date: 2025-06-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2044">[Paper Note] PropMEND: Hypernetworks for Knowledge Propagation in LLMs, Zeyu Leo Liu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>PropMENDは、LLMsにおける知識伝播を改善するためのハイパーネットワークベースのアプローチである。メタ学習を用いて、注入された知識がマルチホップ質問に答えるために伝播するように勾配を修正する。RippleEditデータセットで、難しい質問に対して精度がほぼ2倍向上し、Controlled RippleEditデータセットでは新しい関係やエンティティに対する知識伝播を評価。PropMENDは既存の手法を上回るが、性能差は縮小しており、今後の研究で広範な関係への知識伝播が求められる。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/zeyuliu10/status/1934659512046330057?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q従来のKnowledge Editing手法は新たな知識を記憶させることはできる（i.e., 注入した知識を逐語的に生成できる;東京は日本の首都である。）が、知識を活用することは苦手だった（i.e., 日本の首都の気候は？）ので、それを改善するための手法を提案している模様。

<br>



<br>

既存手法のlimitationは

<br>

・editing手法で学習をする際に知識を伝搬させるデータが無く

<br>

・目的関数がraw textではなく、QA pairをSFTすること

<br>



<br>

によって生じるとし、

<br>



<br>

・学習時にpropagation question（Figure1のオレンジ色のQA; 注入した知識を活用して推論が必要なQA)を用意しどのように知識を伝搬（活用）させるかを学習し

<br>

・目的関数をCausal Language Modeling Loss

<br>



<br>

にすることで改善する、とのこと。

<br>



<br>

<img src="https://github.com/user-attachments/assets/3f915a57-89c9-412f-a950-f86d35d72cd3" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/50cbbdba-c23e-405d-8ed1-1deea14d3384" alt="image" loading="lazy">

<br>



<br>

non-verbatimなQA（注入された知識をそのまま回答するものではなく、何らかの推論が必要なもの）でも性能が向上。

<br>

<img src="https://github.com/user-attachments/assets/ebae00b4-d622-4c45-9eca-abfc23762c25" alt="image" loading="lazy">ベースライン:

<br>

・643

<br>

・2055</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2025-06-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2040">[Paper Note] Steer LLM Latents for Hallucination Detection, Seongheon Park+, ICML'25</a>
<span class="snippet"><span>Summary</span>LLMの幻覚問題に対処するため、Truthfulness Separator Vector（TSV）を提案。TSVは、LLMの表現空間を再構築し、真実と幻覚の出力を分離する軽量な指向ベクトルで、モデルのパラメータを変更せずに機能。二段階のフレームワークで、少数のラベル付き例からTSVを訓練し、ラベルのない生成物を拡張。実験により、TSVは最小限のラベル付きデータで高いパフォーマンスを示し、実世界のアプリケーションにおける実用的な解決策を提供。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/sharonyixuanli/status/1933522788645810493?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Reproducibility.html">#Reproducibility</a>
<span class="issue_date">Issue Date: 2025-06-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2039">[Paper Note] Give Me FP32 or Give Me Death? Challenges and Solutions for Reproducible  Reasoning, Jiayi Yuan+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）のパフォーマンスの再現性が脆弱であることを示し、システム構成の変更が応答に大きな影響を与えることを明らかにしました。特に、初期トークンの丸め誤差が推論精度に波及する問題を指摘し、浮動小数点演算の非結合的性質が変動の根本原因であるとしています。様々な条件下での実験を通じて、数値精度が再現性に与える影響を定量化し、評価実践における重要性を強調しました。さらに、LayerCastという軽量推論パイプラインを開発し、メモリ効率と数値安定性を両立させる方法を提案しました。</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<span class="issue_date">Issue Date: 2025-06-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2036">[Paper Note] Self-Adapting Language Models, Adam Zweiger+, arXiv'25</a>
<span class="snippet"><span>Summary</span>自己適応型LLMs（SEAL）を提案し、モデルが自身のファインチューニングデータと指示を生成することで適応を実現。新しい入力に対して自己編集を行い、持続的な重みの更新を可能にする。強化学習ループを用いて下流性能を報酬信号として活用し、従来のアプローチと異なり、モデル自身の生成を用いて適応を制御。実験結果はSEALの有望性を示す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jyo_pari/status/1933350025284702697?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QコンテキストCと評価データtauが与えられたとき、Cを入力した時にモデルが自分をSFTし、tau上でより高い性能を得られるようなサンプル Self Edit (SE) を生成できるように学習することで、性能を向上させたい。これをRLによって実現する。具体的には、下記アルゴリズムのようにモデルにSEを生成させ、SEでSFTすることめにtau上での性能が向上したか否かのbinary rewardを用いてパラメータを更新する、といったことを繰り返す。これは実質、RL_updateと書いてあるが、性能が向上した良いSEのみでモデルをSFTすること、と同等なことを実施している。

<br>



<br>

<img src="https://github.com/user-attachments/assets/69a395da-521f-444d-af6f-4c1b25bb6765" alt="image" loading="lazy">

<br>



<br>

このような背景として、RLのアルゴリズムとしてGRPOやPPOを適用したところ学習が不安定でうまくいかなかったため、よりシンプルなアプローチであるReST^EM（2041)を採用した。これはrejection samplingとSFTに基づいたEMアルゴリズムのようなものらしく、Eステップで現在のポリシーでcandidateを生成し、Mステップでpositive rewardを得たcandidateのみ（＝rejection sampling)でSFTする、といったことを繰り返す、みたいな手法らしい。これを用いると、論文中の式(1)を上述のbinary rewardで近似することに相当する。より詳細に書くと、式(1)（つまり、SEをCから生成することによって得られるtauに基づく報酬rの総報酬を最大化したい、という式）を最大化するためにθ_tの勾配を計算したいが、reward rがθ_tで微分不可能なため、Monte Carlo Estimatorで勾配を近似する、みたいなことをやるらしい。Monte Carlo Estimatorでは実際のサンプルの期待値によって理論的な勾配を近似するらしく、これが式(3)のスコア関数とreward rの平均、といった式につながっているようである。</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-06-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2035">[Paper Note] Resa: Transparent Reasoning Models via SAEs, Shangshang Wang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Resaという1.5Bの推論モデル群を提案し、効率的なスパースオートエンコーダーチューニング（SAE-Tuning）手法を用いて訓練。これにより、97%以上の推論性能を保持しつつ、訓練コストを2000倍以上削減し、訓練時間を450倍以上短縮。軽いRL訓練を施したモデルで高い推論性能を実現し、抽出された推論能力は一般化可能かつモジュール化可能であることが示された。全ての成果物はオープンソース。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iscienceluvr/status/1933101904529363112?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q著者ポスト:https://x.com/upupwang/status/1933207676663865482?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q論文中で利用されているSource Modelの一つ:

<br>

・1935</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2025-06-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2033">[Paper Note] Text-to-LoRA: Instant Transformer Adaption, Rujikorn Charakorn+, ICML'25</a>
<span class="snippet"><span>Summary</span>Text-to-LoRA（T2L）は、自然言語による説明に基づいて大規模言語モデル（LLMs）を迅速に適応させる手法で、従来のファインチューニングの高コストと時間を克服します。T2Lは、LoRAを安価なフォワードパスで構築するハイパーネットワークを使用し、タスク特有のアダプターと同等のパフォーマンスを示します。また、数百のLoRAインスタンスを圧縮し、新しいタスクに対してゼロショットで一般化可能です。このアプローチは、基盤モデルの専門化を民主化し、計算要件を最小限に抑えた言語ベースの適応を実現します。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/roberttlange/status/1933074366603919638?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qな、なるほど、こんな手が…！</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/x-Use.html">#x-Use</a>
<span class="issue_date">Issue Date: 2025-06-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2032">[Paper Note] Go-Browse: Training Web Agents with Structured Exploration, Apurva Gandhi+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Go-Browseを提案し、ウェブ環境の構造的探索を通じて多様なデータを自動収集。グラフ探索を用いて効率的なデータ収集を実現し、WebArenaベンチマークで成功率21.7%を達成。これはGPT-4o miniを2.4%上回り、10B未満のモデルでの最先端結果を2.9%上回る。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gneubig/status/1932786231542493553?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QWebArena:

<br>

・1849</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<span class="issue_date">Issue Date: 2025-06-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2031">[Paper Note] Reinforcement Pre-Training, Qingxiu Dong+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、強化学習と大規模言語モデルの新しいスケーリング手法「強化事前学習（RPT）」を提案。次のトークン予測を強化学習の推論タスクとして再定義し、一般的なRLを活用することで、ドメイン特有の注釈に依存せずにスケーラブルな方法を提供。RPTは次のトークン予測の精度を向上させ、強化ファインチューニングの基盤を形成。トレーニング計算量の増加が精度を改善することを示し、RPTが言語モデルの事前学習において有望な手法であることを示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1932922314578145640?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2025-06-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2030">[Paper Note] Value Residual Learning, Zhanchao Zhou+, ACL'25</a>
<span class="snippet"><span>Summary</span>ResFormerは、隠れ状態の残差に値の残差接続を加えることで情報の流れを強化する新しいTransformerアーキテクチャを提案。実験により、ResFormerは従来のTransformerに比べて少ないパラメータとトレーニングデータで同等の性能を示し、SVFormerはKVキャッシュサイズを半減させることができる。性能はシーケンスの長さや学習率に依存する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/zhanchaozhou/status/1932829678081098079?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q<img src="https://github.com/user-attachments/assets/c2c97ea1-0930-4033-85bd-b3618463f87a" alt="image" loading="lazy"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Safety.html">#Safety</a>
<span class="issue_date">Issue Date: 2025-06-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2027">[Paper Note] Saffron-1: Towards an Inference Scaling Paradigm for LLM Safety  Assurance, Ruizhong Qiu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>既存のLLMの安全保証研究は主にトレーニング段階に焦点を当てているが、脱獄攻撃に対して脆弱であることが明らかになった。本研究では、推論スケーリングを用いた新たな安全性向上手法SAFFRONを提案し、計算オーバーヘッドを削減する多分岐報酬モデル（MRM）を導入。これにより、報酬モデル評価の数を減らし、探索-効率性のジレンマを克服する。実験により手法の有効性を確認し、訓練済みモデルと安全報酬データセットを公開。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gaotangli/status/1932289294657626189?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Subword.html">#Subword</a>
<span class="issue_date">Issue Date: 2025-06-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2026">[Paper Note] StochasTok: Improving Fine-Grained Subword Understanding in LLMs, Anya Sims+, arXiv'25</a>
<span class="snippet"><span>Summary</span>サブワードレベルの理解を向上させるために、確率的トークン化手法StochasTokを提案。これにより、LLMsは内部構造を把握しやすくなり、文字カウントや数学タスクなどで性能が向上。シンプルな設計により、既存モデルへの統合が容易で、コストを抑えつつサブワード理解を改善できる。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/cong_ml/status/1932369418534760554?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qおもしろそう</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<span class="issue_date">Issue Date: 2025-06-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2025">[Paper Note] Log-Linear Attention, Han Guo+, arXiv'25</a>
<span class="snippet"><span>Summary</span>対数線形注意を提案し、線形注意の効率性とソフトマックス注意の表現力を両立。固定サイズの隠れ状態を対数的に成長する隠れ状態に置き換え、計算コストを対数線形に抑える。Mamba-2とGated DeltaNetの対数線形バリアントが線形時間のバリアントと比較して優れた性能を示すことを確認。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1932194773559107911?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説ポスト:https://x.com/theturingpost/status/1931432543766847887?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<a class="button" href="articles/KnowledgeEditing.html">#KnowledgeEditing</a>
<span class="issue_date">Issue Date: 2025-06-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2023">[Paper Note] Representation Shattering in Transformers: A Synthetic Study with   Knowledge Editing, Kento Nishi+, ICML'25</a>
<span class="snippet"><span>Summary</span>知識編集（KE）アルゴリズムは、モデルの重みを変更して不正確な事実を更新するが、これがモデルの事実の想起精度や推論能力に悪影響を及ぼす可能性がある。新たに定義した合成タスクを通じて、KEがターゲットエンティティを超えて他のエンティティの表現に影響を与え、未見の知識の推論を歪める「表現の破壊」現象を示す。事前訓練されたモデルを用いた実験でもこの発見が確認され、KEがモデルの能力に悪影響を及ぼす理由を明らかにするメカニズム仮説を提供する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/kento_nishi/status/1932072335726539063?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Search.html">#Search</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2025-06-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2022">[Paper Note] Search Arena: Analyzing Search-Augmented LLMs, Mihran Miroyan+, arXiv'25</a>
<span class="snippet"><span>Summary</span>検索強化型LLMsに関する「Search Arena」という大規模な人間の好みデータセットを紹介。24,000以上のマルチターンユーザーインタラクションを含み、ユーザーの好みが引用数や引用元に影響されることを明らかにした。特に、コミュニティ主導の情報源が好まれる傾向があり、静的な情報源は必ずしも信頼されない。検索強化型LLMsの性能を評価した結果、非検索設定でのパフォーマンス向上が確認されたが、検索設定ではパラメトリック知識に依存すると品質が低下することが分かった。このデータセットはオープンソースとして提供されている。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/mirmiroyan/status/1931081734764081391?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-06-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2019">[Paper Note] SynLogic: Synthesizing Verifiable Reasoning Data at Scale for Learning  Logical Reasoning and Beyond, Junteng Liu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>SynLogicは、35の論理的推論タスクを網羅したデータ合成フレームワークで、強化学習（RL）による大規模言語モデル（LLMs）の推論能力向上を目指す。調整可能な難易度で生成されたデータは検証可能で、RLに適している。実験では、SynLogicが最先端の論理的推論性能を達成し、数学やコーディングタスクとの混合によりトレーニング効率が向上することが示された。SynLogicはLLMsの推論能力向上に貴重なリソースとなる。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/junxian_he/status/1930558456907669638?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q35種類のタスクを人手で選定し、タスクごとに困難度の鍵となるパラメータを定義（数独ならばグリッド数など）。その上で、各タスクごとに人手でルールベースのinstanceを生成するコードを実装し、さまざまな困難度パラメータに基づいて多様なinstanceを生成。生成されたinstanceの困難度は、近似的なUpper Bound(DeepSeek-R1, o3-miniのPass@10)とLower bound（chat model[^1]でのPass@10)を求めデータセットに含まれるinstanceの困難度をコントロールし、taskを記述するpromptも生成。タスクごとに人手で実装されたVerifierも用意されている。

<br>

<img src="https://github.com/user-attachments/assets/cda0534d-7db2-4470-93b8-01f446476544" alt="image" loading="lazy">

<br>



<br>

Qwen2.5-7B-BaseをSynDataでDAPOしたところ、大幅にlogic benchmarkとmathematical benchmarkの性能が改善。

<br>

<img src="https://github.com/user-attachments/assets/dcc1309d-7946-4a6d-91a3-7ccac9ec6688" alt="image" loading="lazy">

<br>



<br>

mathやcodeのデータとmixして7Bモデルを訓練したところ、32Bモデルに匹敵する性能を達成し、SynDataをmixすることでgainが大きくなったので、SynDataから学習できる能力が汎化することが示唆される。

<br>

<img src="https://github.com/user-attachments/assets/7b618fe9-5271-434b-9808-f53f0e758e5e" alt="image" loading="lazy">

<br>



<br>

タスク一覧はこちら

<br>

<img src="https://github.com/user-attachments/assets/50fcdcb3-701e-4d42-94c7-201d8d354d75" alt="image" loading="lazy">

<br>



<br>

[^1]:どのchat modelかはざっと見た感じわからない。どこかに書いてあるかも。Logical Reasoningが重要なタスクを扱う際はこのデータを活用することを検討してみても良いかもしれない</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Coding.html">#Coding</a>
<span class="issue_date">Issue Date: 2025-06-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2018">[Paper Note] Training Language Models to Generate Quality Code with Program Analysis  Feedback, Feng Yao+, arXiv'25</a>
<span class="snippet"><span>Summary</span>プログラム分析に基づくフィードバックを用いた強化学習フレームワーク「REAL」を提案。セキュリティや保守性の欠陥を検出し、機能的正確性を保証することで、LLMsによる高品質なコード生成を促進。手動介入不要でスケーラブルな監視を実現し、実験により最先端の手法を上回る性能を示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/fengyao1909/status/1930377346693116350?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q現在のCoding LLMはUnitTestを通るように学習されるが、UnitTestに通るからといってコードの品質が良いわけでは無いので、UnitTestに通るか否かのReward（Functionality)に加えて、RL中に生成されたコードを制御フローグラフ[^1]に変換し汚染解析[^2]をした結果をRewardに組み込むことで、FunctionalityとQualityを両立したよ、という話のようである。

<br>



<br>

Figure1のグラフの縦軸は、Functionalityと（UnitTestが通ったか否か）と、Quailty(セキュリティや保守性に関する問題が検出されなかった)、という両方の条件を満たした割合である点に注意。

<br>



<br>

<img src="https://github.com/user-attachments/assets/b843e416-8c96-40ca-ac1f-0318eb1ae40c" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/6beeea63-571b-4ce6-bef8-ac8e0cfffee2" alt="image" loading="lazy">

<br>



<br>

[^1]:プログラムを実行したときに通る可能性のある経路のすべてをグラフとして表したもの[引用元](https://qiita.com/uint256_t/items/7d4556cb8f5997b9e95c)

<br>

[^2]:信頼できない汚染されたデータがプログラム中でどのように処理されるかを分析すること</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RLVR.html">#RLVR</a>
<span class="issue_date">Issue Date: 2025-06-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2017">[Paper Note] Writing-Zero: Bridge the Gap Between Non-verifiable Problems and  Verifiable Rewards, Xun Lu, arXiv'25</a>
<span class="snippet"><span>Summary</span>非検証可能なタスクにおける強化学習のギャップを埋めるため、ペアワイズ生成報酬モデル（GenRM）とブートストラップ相対ポリシー最適化（BRPO）アルゴリズムを提案。これにより、主観的評価を信頼性のある検証可能な報酬に変換し、動的なペアワイズ比較を実現。提案手法は、LLMsの執筆能力を向上させ、スカラー報酬ベースラインに対して一貫した改善を示し、競争力のある結果を達成。全ての言語タスクに適用可能な包括的なRLトレーニングパラダイムの可能性を示唆。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/grad62304977/status/1929996614883783170?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QWriting Principleに基づいて（e.g., 一貫性、創造性とか？）批評を記述し、最終的に与えられたペアワイズのテキストの優劣を判断するGenerative Reward Model (GenRM; Reasoning Traceを伴い最終的にRewardに変換可能な情報をoutpuするモデル) を学習し、現在生成したresponseグループの中からランダムに一つ擬似的なreferenceを決定し、他のresponseに対しGenRMを適用することで報酬を決定する（BRPO）、といったことをやるらしい。

<br>



<br>

これにより、創造的な文書作成のような客観的なground truthを適用できないタスクでも、RLVRの恩恵をあずかれるようになる（Bridging the gap)といったことを主張している。RLVRの恩恵とは、Reward Hackingされづらい高品質な報酬、ということにあると思われる。ので、要は従来のPreference dataだけで学習したReward Modelよりも、よりReward Hackingされないロバストな学習を実現できるGenerative Reward Modelを提案し、それを適用する手法BRPOも提案しました、という話に見える。関連:

<br>

・2274 </span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<a class="button" href="articles/UnitTest.html">#UnitTest</a>
<span class="issue_date">Issue Date: 2025-06-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2016">[Paper Note] Co-Evolving LLM Coder and Unit Tester via Reinforcement Learning, Yinjie Wang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>CUREは、コーディングとユニットテスト生成を共進化させる強化学習フレームワークで、真のコードを監視せずにトレーニングを行う。ReasonFlux-Coderモデルは、コード生成精度を向上させ、下流タスクにも効果的に拡張可能。ユニットテスト生成では高い推論効率を達成し、強化学習のための効果的な報酬モデルとして機能する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/lingyang_pu/status/1930234983274234232?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QUnitTestの性能向上させます系の研究が増えてきている感関連ポスト:https://x.com/gm8xx8/status/1930348014146859345?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/RLVR.html">#RLVR</a>
<a class="button" href="articles/DataMixture.html">#DataMixture</a>
<span class="issue_date">Issue Date: 2025-06-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2015">[Paper Note] MoDoMoDo: Multi-Domain Data Mixtures for Multimodal LLM Reinforcement  Learning, Yiqing Liang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>検証可能な報酬を用いた強化学習（RLVR）をマルチモーダルLLMsに適用するためのポストトレーニングフレームワークを提案。異なる視覚と言語の問題を含むデータセットをキュレーションし、最適なデータ混合戦略を導入。実験により、提案した戦略がMLLMの推論能力を大幅に向上させることを示し、分布外ベンチマークで平均5.24%の精度向上を達成。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_vztu/status/1930312780701413498?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qマルチモーダルな設定でRLVRを適用すると、すべてのデータセットを学習に利用する場合より、特定のタスクのみのデータで学習した方が当該タスクでは性能が高くなったり（つまりデータが多ければ多いほど良いわけでは無い）、特定のデータをablationするとOODに対する予測性能が改善したりするなど、データ間で干渉が起きて敵対的になってしまうような現象が起きる。このことから、どのように適切にデータを混合できるか？という戦略の必要性が浮き彫りになり、モデルベースなMixture戦略（どうやらデータの混合分布から学習後の性能を予測するモデルな模様）の性能がuniformにmixするよりも高い性能を示した、みたいな話らしい。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Memorization.html">#Memorization</a>
<span class="issue_date">Issue Date: 2025-06-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2014">[Paper Note] How much do language models memorize?, John X. Morris+, arXiv'25</a>
<span class="snippet"><span>Summary</span>モデルの「知識」を推定する新手法を提案し、言語モデルの能力を測定。記憶を「意図しない記憶」と「一般化」に分け、一般化を排除することで総記憶を計算。GPTスタイルのモデルは約3.6ビット/パラメータの能力を持つと推定。データセットのサイズ増加に伴い、モデルは記憶を保持し、一般化が始まると意図しない記憶が減少。数百のトランスフォーマー言語モデルを訓練し、能力とデータサイズの関係を示すスケーリング法則を生成。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/rohanpaul_ai/status/1929989864927146414?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2025-06-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2013">[Paper Note] Unleashing the Reasoning Potential of Pre-trained LLMs by Critique  Fine-Tuning on One Problem, Yubo Wang+, EMNLP'25</a>
<span class="snippet"><span>Summary</span>本研究では、強力な大規模言語モデル（LLM）の推論能力を引き出すために、批評微調整（CFT）が効果的であることを示します。CFTは、単一の問題に対する多様な解を収集し、教師LLMによる批評データを構築する手法です。QwenおよびLlamaモデルを微調整した結果、数学や論理推論のベンチマークで顕著な性能向上を観察しました。特に、わずか5時間のトレーニングで、Qwen-Math-7B-CFTは他の手法と同等以上の成果を上げました。CFTは計算効率が高く、現代のLLMの推論能力を引き出すためのシンプルなアプローチであることが示されました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/wenhuchen/status/1930447298527670662?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・1832

<br>

・1938参考:https://x.com/weiliu99/status/1930826904522875309?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-06-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2012">[Paper Note] Darwin Godel Machine: Open-Ended Evolution of Self-Improving Agents, Jenny Zhang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>ダーヴィン・ゴーデルマシン（DGM）は、自己改善するAIシステムであり、コードを反復的に修正し、コーディングベンチマークで変更を検証します。進化とオープンエンドな研究に基づき、生成されたエージェントのアーカイブを維持し、新しいバージョンを作成することで多様なエージェントを育成します。DGMはコーディング能力を自動的に向上させ、SWE-benchでのパフォーマンスを20.0%から50.0%、Polyglotでのパフォーマンスを14.2%から30.7%に改善しました。安全対策を講じた実験により、自己改善を行わないベースラインを大幅に上回る成果を示しました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://www.linkedin.com/posts/omarsar_new-paper-open-ended-evolution-of-self-improving-activity-7334610178832556033-8dA-?utm_source=share&utm_medium=member_ios&rcm=ACoAACzQvjwB2FeLVE3yukDiUYtr5J4k-6nlNG4・1212

<br>



<br>

あたりの研究とはどう違うのだろうか、という点が気になる。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-06-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2011">[Paper Note] ProRL: Prolonged Reinforcement Learning Expands Reasoning Boundaries in  Large Language Models, Mingjie Liu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>強化学習（RL）が言語モデルの推論能力を向上させる可能性を探る本研究では、長期的なRL（ProRL）トレーニングが新しい推論戦略を明らかにできることを示します。新しいトレーニング手法ProRLを導入し、実証分析により、RLでトレーニングされたモデルが基礎モデルを上回ることが確認されました。推論の改善は基礎モデルの能力やトレーニング期間と相関しており、RLが新しい解決空間を探索できることを示唆しています。これにより、RLが言語モデルの推論を拡張する条件に関する新たな洞察が得られ、今後の研究の基盤が築かれます。モデルの重みは公開されています。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1930043688329326962?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QRLVR（math, code（従来はこの2種類）, STEM, logic Puzzles, instruction following）によって大規模なスケール（長期的に学習をする; 2k training stepsと多様なタスクでの学習データ）で実験をし、定期的にReferenceポリシーとOptimizerをリセットすることで、元のポリシーからの乖離を防ぎつつも、新たな学習が進むようなことをしている模様。

<br>

（※PFNのランチタイムトークを参考に記述）

<br>



<br>

verlを用いて、DAPOで学習をしている。

<br>

<img src="https://github.com/user-attachments/assets/db706cfc-e756-47d1-a0e7-8fbc8043ae17" alt="image" loading="lazy">

<br>



<br>

・1969

<br>

・1815</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2025-06-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2010">[Paper Note] xVerify: Efficient Answer Verifier for Reasoning Model Evaluations, Ding Chen+, arXiv'25</a>
<span class="snippet"><span>Summary</span>推論モデルの評価のために、xVerifyという効率的な回答検証器を提案。xVerifyは、LLMが生成した回答が参照解答と同等であるかを効果的に判断できる。VARデータセットを構築し、複数のLLMからの質問-回答ペアを収集。評価実験では、すべてのxVerifyモデルが95％を超えるF1スコアと精度を達成し、特にxVerify-3B-IbはGPT-4oを超える性能を示した。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/VerifiableRewards.html">#VerifiableRewards</a>
<a class="button" href="articles/RLVR.html">#RLVR</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2025-06-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2009">[Paper Note] Pitfalls of Rule- and Model-based Verifiers -- A Case Study on  Mathematical Reasoning, Yuzhen Huang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、数学的推論における検証者の信頼性とそのRL訓練プロセスへの影響を分析。ルールベースの検証者は偽陰性率が高く、RL訓練のパフォーマンスに悪影響を及ぼすことが判明。モデルベースの検証者は静的評価で高精度を示すが、偽陽性に対して脆弱であり、報酬が不正に膨らむ可能性がある。これにより、強化学習における堅牢な報酬システムの必要性が示唆される。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/junxian_he/status/1929371821767586284?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qverificationタスクに特化してfinetuningされたDiscriminative Classifierが、reward hackingに対してロバストであることが示唆されている模様。

<br>



<br>

Discriminative Verifierとは、Question, Response, Reference Answerがgivenな時に、response（しばしばreasoning traceを含み複数のanswerの候補が記述されている）の中から最終的なanswerを抽出し、Reference answerと抽出したanswerから正解/不正解をbinaryで出力するモデルのこと。Rule-based Verifierではフォーマットが異なっている場合にfalse negativeとなってしまうし、そもそもルールが規定できないタスクの場合は適用できない。Discriminative Verifierではそのようなケースでも適用できると考えられる。Discriminative Verifierの例はたとえば下記:

<br>

https://huggingface.co/IAAR-Shanghai/xVerify-0.5B-I

<br>



<br>

・2010</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<span class="issue_date">Issue Date: 2025-06-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2008">[Paper Note] Self-Challenging Language Model Agents, Yifei Zhou+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Self-Challengingフレームワークを提案し、エージェントが自ら生成した高品質なタスクで訓練。エージェントは挑戦者としてタスクを生成し、実行者として強化学習を用いて訓練。M3ToolEvalとTauBenchでLlama-3.1-8B-Instructが2倍以上の改善を達成。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jaseweston/status/1929719473952497797?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説ポスト:https://x.com/omarsar0/status/1930748591242424439?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-06-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2006">[Paper Note] BIG-Bench Extra Hard, Mehran Kazemi+, arXiv'25</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）の推論能力を評価するための新しいベンチマーク、BIG-Bench Extra Hard（BBEH）を導入。これは、既存のBIG-Bench Hard（BBH）のタスクを新しいものに置き換え、難易度を大幅に引き上げることで、LLMの限界を押し広げることを目的としている。評価の結果、最良の汎用モデルで9.8%、推論専門モデルで44.8%の平均精度が観察され、LLMの一般的推論能力向上の余地が示された。BBEHは公開されている。</span>
<span class="snippet"><span>Comment</span>Big-Bench hard（既にSoTAモデルの能力差を識別できない）の難易度をさらに押し上げたデータセット。

<br>



<br>

Inputの例

<br>

<img src="https://github.com/user-attachments/assets/b9d1308f-1481-470d-a553-c181d902119c" alt="image" loading="lazy">

<br>



<br>

タスクごとのInput, Output lengthの分布

<br>

<img src="https://github.com/user-attachments/assets/ef6b7401-159d-46c7-bd9d-9a64f63b5089" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/01207db3-cb01-46f2-a805-e9ddf9d58198" alt="image" loading="lazy">

<br>



<br>

現在の主要なモデル群の性能

<br>

<img src="https://github.com/user-attachments/assets/5ce538d8-45a1-449a-992a-998b33fdeaf7" alt="image" loading="lazy">Big-Bench論文はこちら:

<br>

・785</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/PRM.html">#PRM</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2025-06-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2005">[Paper Note] Training Step-Level Reasoning Verifiers with Formal Verification Tools, Ryo Kamoi+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本論文では、プロセス報酬モデル（PRMs）のトレーニングにおける2つの課題、すなわち高コストの人間による注釈と数学的推論問題への限定を解決するために、FoVerというアプローチを提案します。FoVerは形式的検証ツールを用いて自動的に段階レベルのエラーラベルを生成し、人的注釈なしでLLMの応答にエラーラベルを付与したデータセットを合成します。このデータセットでトレーニングされたPRMsは、元のLLMsに基づくベースラインを大幅に上回り、他の最先端モデルとも競争力のある結果を達成しました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/ryokamoi/status/1925939062348697874?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q人手によるAnnotation（step levelのラベルのアノテーション)無しでProcsee Reward Modelの学習データを構築する手法

<br>



<br>

<img src="https://github.com/user-attachments/assets/adfc351e-c53b-47af-adba-480e10615d69" alt="image" loading="lazy">Z3やIsabelleなどの形式検証ツールが適用可能なタスクのみに提案手法のスコープは限られる点には注意人手でアノテーションされたモデルと比較してcomparableなパフォーマンスを達成

<br>

<img src="https://github.com/user-attachments/assets/290a4d1c-10ac-41dd-a26e-ed57e1fcca79" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/b1af66e7-fbbe-4823-8679-e5ff5be94fdf" alt="image" loading="lazy">

<br>



<br>

スレッド中で評価データが数回のreasoning stepが必要なタスクのみの評価であり、より長く複雑なreasoning step（たとえば 2006）が必要な場合はどうなるか？といった所に興味が寄せられている模様</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-06-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2004">[Paper Note] Satori-SWE: Evolutionary Test-Time Scaling for Sample-Efficient Software  Engineering, Guangtao Zeng+, arXiv'25</a>
<span class="snippet"><span>Summary</span>EvoScaleを提案し、進化的プロセスを用いて小型言語モデルの性能を向上させる手法を開発。選択と突然変異を通じて出力を洗練し、サンプル数を減少させる。強化学習を用いて自己進化を促進し、SWE-Bench-Verifiedで32Bモデルが100B以上のモデルと同等以上の性能を示す。コード、データ、モデルはオープンソースとして公開予定。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gan_chuang/status/1928963872188244400?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RLVR.html">#RLVR</a>
<span class="issue_date">Issue Date: 2025-06-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2003">Can Large Reasoning Models Self-Train?, Sheikh Shafayat+, arXiv'25</a>
<span class="snippet"><span>Summary</span>自己学習を活用したオンライン強化学習アルゴリズムを提案し、モデルの自己一貫性を利用して正確性信号を推測。難しい数学的推論タスクに適用し、従来の手法に匹敵する性能を示す。自己生成された代理報酬が誤った出力を優遇するリスクも指摘。自己監視による性能向上の可能性と課題を明らかに。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/askalphaxiv/status/1928487492291829809?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q・1995

<br>

と似ているように見えるself-consistencyでground truthを推定し、推定したground truthを用いてverifiableなrewardを計算して学習する手法、のように見える。

<br>

<img src="https://github.com/user-attachments/assets/0f38d47a-ab42-4ec4-a6d5-6d5d8a63a4a9" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/3d08bbad-8578-4add-8ad7-ed02cdd15add" alt="image" loading="lazy">

<br>



<br>

実際のground truthを用いた学習と同等の性能を達成する場合もあれば、long stepで学習するとどこかのタイミングで学習がcollapseする場合もある

<br>

<img src="https://github.com/user-attachments/assets/e120a277-6beb-4fc1-8fd7-e69de467fb3d" alt="image" loading="lazy">パフォーマンスがピークを迎えた後になぜ大幅にAccuracyがdropするかを検証したところ、モデルのKL penaltyがどこかのタイミングで大幅に大きくなることがわかった。つまりこれはオリジナルのモデルからかけ離れたモデルになっている。これは、モデルがデタラメな出力をground truthとして推定するようになり、モデルそのものも一貫してそのデタラメな出力をすることでrewardを増大させるreward hackingが起きている。

<br>

<img src="https://github.com/user-attachments/assets/5a9c091f-e9cb-4914-a1ca-32a1ea2dc1c7" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/aa685b9a-7992-4135-a4da-fd1c8cabe084" alt="image" loading="lazy">これら現象を避ける方法として、以下の3つを提案している

<br>

・early stopping

<br>

・offlineでラベルをself consistencyで生成して、学習の過程で固定する

<br>

・カリキュラムラーニングを導入する

<br>



<br>

<img src="https://github.com/user-attachments/assets/4fa997e3-aa20-4195-96ef-b17c82556fc1" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/99cc2b6c-50a9-40a0-af30-b59aff4056b4" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/e90e9870-b180-4fe9-8c24-8ff88fcf33f0" alt="image" loading="lazy">関連

<br>

・1489</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/COLING.html">#COLING</a>
<span class="issue_date">Issue Date: 2025-05-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2000">Beyond Chain-of-Thought: A Survey of Chain-of-X Paradigms for LLMs, Yu Xia+, COLING'25</a>
<span class="snippet"><span>Summary</span>Chain-of-Thought（CoT）を基にしたChain-of-X（CoX）手法の調査を行い、LLMsの課題に対処するための多様なアプローチを分類。ノードの分類とアプリケーションタスクに基づく分析を通じて、既存の手法の意義と今後の可能性を議論。研究者にとって有用なリソースを提供することを目指す。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Distillation.html">#Distillation</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<span class="issue_date">Issue Date: 2025-05-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1999">Distillation Scaling Laws, Dan Busbridge+, ICML'25</a>
<span class="snippet"><span>Summary</span>蒸留モデルの性能を推定するための蒸留スケーリング法則を提案。教師モデルと生徒モデルの計算割り当てを最適化することで、生徒の性能を最大化。教師が存在する場合やトレーニングが必要な場合に最適な蒸留レシピを提供。多くの生徒を蒸留する際は、監視付きの事前学習を上回るが、生徒のサイズに応じた計算レベルまで。単一の生徒を蒸留し、教師がトレーニング必要な場合は監視学習を推奨。蒸留に関する洞察を提供し、理解を深める。</span>
<span class="snippet"><span>Comment</span>著者ポスト:https://x.com/danbusbridge/status/1944539357542781410?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Temporal.html">#Temporal</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-05-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1996">Temporal Sampling for Forgotten Reasoning in LLMs, Yuetai Li+, arXiv'25</a>
<span class="snippet"><span>Summary</span>ファインチューニング中にLLMsが以前の正しい解法を忘れる「時間的忘却」を発見。これに対処するために「時間的サンプリング」というデコーディング戦略を導入し、複数のチェックポイントから出力を引き出すことで推論性能を向上。Pass@kで4から19ポイントの改善を達成し、LoRA適応モデルでも同様の利点を示す。時間的多様性を活用することで、LLMsの評価方法を再考する手段を提供。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iscienceluvr/status/1927286319018832155?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QTemporal ForgettingとTemporal Sampling</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-05-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1995">Learning to Reason without External Rewards, Xuandong Zhao+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、外部の報酬やラベルなしで大規模言語モデル（LLMs）が学習できるフレームワーク「内部フィードバックからの強化学習（RLIF）」を提案。自己確信を報酬信号として用いる「Intuitor」を開発し、無監視の学習を実現。実験結果は、Intuitorが数学的ベンチマークで優れた性能を示し、ドメイン外タスクへの一般化能力も高いことを示した。内因的信号が効果的な学習を促進する可能性を示唆し、自律AIシステムにおけるスケーラブルな代替手段を提供。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/xuandongzhao/status/1927270931874910259?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qおもしろそうexternalなsignalをrewardとして用いないで、モデル自身が内部的に保持しているconfidenceを用いる。人間は自信がある問題には正解しやすいという直感に基づいており、openendなquestionのようにそもそも正解シグナルが定義できないものもあるが、そういった場合に活用できるようである。self-trainingの考え方に近いのではベースモデルの段階である程度能力が備わっており、post-trainingした結果それが引き出されるようになったという感じなのだろうか。

<br>



<br>

参考: https://x.com/weiliu99/status/1930826904522875309?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-05-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1994">QwenLong-CPRS: Towards $\infty$-LLMs with Dynamic Context Optimization, Weizhou Shen+, arXiv'25</a>
<span class="snippet"><span>Summary</span>QwenLong-CPRSは、長文コンテキスト最適化のための新しいフレームワークで、LLMsの性能低下を軽減します。自然言語指示に基づく多段階のコンテキスト圧縮を実現し、効率と性能を向上させる4つの革新を導入。5つのベンチマークで、他の手法に対して優位性を示し、主要なLLMとの統合で大幅なコンテキスト圧縮と性能向上を達成。QwenLong-CPRSは新たなSOTA性能を確立しました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_akhaliq/status/1927014346690826684?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-05-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1993">QwenLong-L1: Towards Long-Context Large Reasoning Models with  Reinforcement Learning, Fanqi Wan+, arXiv'25</a>
<span class="snippet"><span>Summary</span>長いコンテキストの推論におけるLRMsの課題を解決するため、QwenLong-L1フレームワークを提案。ウォームアップ監視付きファインチューニングとカリキュラム指導型段階的RLを用いてポリシーの安定化を図り、難易度認識型の回顧的サンプリングで探索を促進。実験では、QwenLong-L1-32Bが他のLRMsを上回り、優れた性能を示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_akhaliq/status/1927011243597967524?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<a class="button" href="articles/InstructionFollowingCapability.html">#InstructionFollowingCapability</a>
<span class="issue_date">Issue Date: 2025-05-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1989">Scaling Reasoning, Losing Control: Evaluating Instruction Following in  Large Reasoning Models, Tingchen Fu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>指示に従う能力はLLMにとって重要であり、MathIFという数学的推論タスク用のベンチマークを提案。推論能力の向上と指示遵守の間には緊張関係があり、特に長い思考の連鎖を持つモデルは指示に従いにくい。介入により部分的な従順さを回復できるが、推論性能が低下することも示された。これらの結果は、指示に敏感な推論モデルの必要性を示唆している。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/yafuly/status/1925753754961236006?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Conversation.html">#Conversation</a>
<span class="issue_date">Issue Date: 2025-05-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1988">LLMs Get Lost In Multi-Turn Conversation, Philippe Laban+, arXiv'25</a>
<span class="snippet"><span>Summary</span>LLMsは会話型インターフェースとして、ユーザーがタスクを定義するのを支援するが、マルチターンの会話ではパフォーマンスが低下する。シミュレーション実験の結果、マルチターンで39%のパフォーマンス低下が見られ、初期のターンでの仮定に依存しすぎることが原因と判明。LLMsは会話中に誤った方向に進むと、回復が難しくなることが示された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_stakaya/status/1926009283386155009?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLost in the MiddleならぬLost in Conversation

<br>

<img src="https://github.com/user-attachments/assets/9d4320f5-6fea-43ca-a7ab-a836e7e3642e" alt="image" loading="lazy">関連:

<br>

・793</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<span class="issue_date">Issue Date: 2025-05-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1985">LaViDa: A Large Diffusion Language Model for Multimodal Understanding, Shufan Li+, arXiv'25</a>
<span class="snippet"><span>Summary</span>LaViDaは、離散拡散モデル（DM）を基にしたビジョン・ランゲージモデル（VLM）で、高速な推論と制御可能な生成を実現。新技術を取り入れ、マルチモーダルタスクにおいてAR VLMと競争力のある性能を達成。COCOキャプショニングで速度向上と性能改善を示し、AR VLMの強力な代替手段であることを証明。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iscienceluvr/status/1925749919312159167?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QDiffusion Modelの波が来た同程度のサイズのARモデルをoutperform [^1]

<br>

<img src="https://github.com/user-attachments/assets/aeb12147-48ba-4b64-917c-9976ec1ffa0a" alt="image" loading="lazy">

<br>



<br>

[^1]:ただし、これが本当にDiffusion Modelを使ったことによる恩恵なのかはまだ論文を読んでいないのでわからない。必要になったら読む。ただ、Physics of Language Modelのように、完全にコントロールされたデータで異なるアーキテクチャを比較しないとその辺はわからなそうではある。</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<span class="issue_date">Issue Date: 2025-05-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1984">dKV-Cache: The Cache for Diffusion Language Models, Xinyin Ma+, arXiv'25</a>
<span class="snippet"><span>Summary</span>拡散言語モデル（DLM）の遅い推論を改善するために、遅延KVキャッシュを提案。これは、異なるトークンの表現ダイナミクスに基づくキャッシング戦略で、2つのバリアントを設計。dKV-Cache-Decodeは損失の少ない加速を提供し、dKV-Cache-Greedyは高いスピードアップを実現。最終的に、推論速度を2〜10倍向上させ、DLMの性能を強化することを示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/arankomatsuzaki/status/1925384029718946177?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q提案手法を適用した場合、ARなモデルとDiffusion Modelで、実際のところどの程度のdecoding速度の差があるのだろうか？そういった分析はざーーっと見た感じ見当たらなかったように思える。</span>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<span class="issue_date">Issue Date: 2025-05-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1983">Diffusion vs. Autoregressive Language Models: A Text Embedding  Perspective, Siyue Zhang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>拡散言語モデルを用いたテキスト埋め込みが、自己回帰的なLLMの一方向性の制限を克服し、文書検索や推論タスクで優れた性能を発揮。長文検索で20%、推論集約型検索で8%、指示に従った検索で2%の向上を示し、双方向の注意が重要であることを確認。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/trtd6trtd/status/1925775950500806742?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Contamination.html">#Contamination</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-05-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1982">LiveBench: A Challenging, Contamination-Limited LLM Benchmark, Colin White+, ICLR'25</a>
<span class="snippet"><span>Summary</span>テストセットの汚染を防ぐために、LLM用の新しいベンチマーク「LiveBench」を導入。LiveBenchは、頻繁に更新される質問、自動スコアリング、さまざまな挑戦的タスクを含む。多くのモデルを評価し、正答率は70%未満。質問は毎月更新され、LLMの能力向上を測定可能に。コミュニティの参加を歓迎。</span>
<span class="snippet"><span>Comment</span>テストデータのコンタミネーションに対処できるように設計されたベンチマーク。重要研究</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<span class="issue_date">Issue Date: 2025-05-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1981">Parallel Scaling Law for Language Models, Mouxiang Chen+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、言語モデルのスケーリングにおいて、並列計算を増加させる新しい手法「ParScale」を提案。これにより、モデルの前方パスを並列に実行し、出力を動的に集約することで、推論効率を向上させる。ParScaleは、少ないメモリ増加とレイテンシで同等の性能向上を実現し、既存のモデルを再利用することでトレーニングコストも削減可能。新しいスケーリング法則は、リソースが限られた状況での強力なモデル展開を促進する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1924959706331939099?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q・405

<br>



<br>

と考え方が似ている</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-05-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1980">AdaCoT: Pareto-Optimal Adaptive Chain-of-Thought Triggering via  Reinforcement Learning, Chenwei Lou+, arXiv'25</a>
<span class="snippet"><span>Summary</span>AdaCoT（Adaptive Chain-of-Thought）は、LLMsが推論を適応的に行う新しいフレームワークで、CoTの呼び出しタイミングを最適化します。強化学習を用いて、クエリの複雑さに基づいてCoTの必要性を判断し、計算コストを削減します。実験では、AdaCoTがCoTトリガー率を3.18%に低下させ、応答トークンを69.06%減少させつつ、高い性能を維持することが示されました。</span>
<span class="snippet"><span>Comment</span>RLのRewardにおいて、bassのリワードだけでなく、

<br>

・reasoningをなくした場合のペナルティ項

<br>

・reasoningをoveruseした場合のペナルティ項

<br>

・formattingに関するペナルティ項

<br>

を設定し、reasoningの有無を適切に判断できた場合にrewardが最大化されるような形にしている。(2.2.2)

<br>



<br>

が、multi-stageのRLでは（stageごとに利用するデータセットを変更するが）、データセットの分布には歪みがあり、たとえば常にCoTが有効なデータセットも存在しており（数学に関するデータなど）、その場合常にCoTをするような分布を学習してしまい、AdaptiveなCoT decisionが崩壊したり、不安定になってしまう（decision boundary collapseと呼ぶ）。特にこれがfinal stageで起きると最悪で、これまでAdaptiveにCoTされるよう学習されてきたものが全て崩壊してしまう。これを防ぐために、Selective Loss Maskingというlossを導入している。具体的には、decision token [^1]のlossへの貢献をマスキングするようにすることで、CoTが生じるratioにバイアスがかからないようにする。今回は、Decision tokenとして、`<think>`トークン直後のトークンをdecision tokenとみなし、lossに対する貢献をマスクしている（Selective Loss Masking）。

<br>



<br>

[^1]: CoTするかどうかは多くの場合このDecision Tokenによって決まる、といったことがどっかの研究に示されていたはずいつか必要になったらしっかり読むが、全てのステージでSelective Loss Maskingをしたら、SFTでwarm upした段階からあまりCoTのratioが変化しないような学習のされ方になる気がするが、どのステージに対してapplyするのだろうか。&lt;/span&gt;
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ModelMerge.html">#ModelMerge</a>
<span class="issue_date">Issue Date: 2025-05-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1979">Model Merging in Pre-training of Large Language Models, Yunshui Li+, arXiv'25</a>
<span class="snippet"><span>Summary</span>モデルマージングは大規模言語モデルの強化に有望な技術であり、本論文ではその事前学習プロセスにおける包括的な調査を行う。実験により、一定の学習率で訓練されたチェックポイントをマージすることで性能向上とアニーリング挙動の予測が可能になることを示し、効率的なモデル開発と低コストのトレーニングに寄与する。マージ戦略やハイパーパラメータに関するアブレーション研究を通じて新たな洞察を提供し、実用的な事前学習ガイドラインをオープンソースコミュニティに提示する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iscienceluvr/status/1924804324812873990?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説ポスト:https://x.com/giffmana/status/1924849877634449878?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/KnowledgeGraph.html">#KnowledgeGraph</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-05-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1978">Scaling Reasoning can Improve Factuality in Large Language Models, Mike Zhang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、オープンドメインの質問応答における大規模言語モデル（LLM）の推論能力を検討し、推論の痕跡を抽出してファインチューニングを行った。知識グラフからの情報を導入し、168回の実験を通じて170万の推論を分析した結果、小型モデルが元のモデルよりも事実の正確性を顕著に改善し、計算リソースを追加することでさらに2-8%の向上が確認された。実験成果は公開され、さらなる研究に寄与する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_akhaliq/status/1924477447120068895?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/LLMServing.html">#LLMServing</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<span class="issue_date">Issue Date: 2025-05-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1977">Insights into DeepSeek-V3: Scaling Challenges and Reflections on  Hardware for AI Architectures, Chenggang Zhao+, arXiv'25</a>
<span class="snippet"><span>Summary</span>DeepSeek-V3は、2,048台のNVIDIA H800 GPUでトレーニングされ、ハードウェア制約に対処するための共同設計を示す。メモリ効率向上のためのマルチヘッド潜在注意や、計算と通信の最適化を図る専門家の混合アーキテクチャ、FP8混合精度トレーニングなどの革新を強調。ハードウェアのボトルネックに基づく将来の方向性について議論し、AIワークロードに応えるためのハードウェアとモデルの共同設計の重要性を示す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/deedydas/status/1924512147947848039?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/Probing.html">#Probing</a>
<span class="issue_date">Issue Date: 2025-05-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1974">Why Vision Language Models Struggle with Visual Arithmetic? Towards   Enhanced Chart and Geometry Understanding, Kung-Hsiang Huang+, ACL'25</a>
<span class="snippet"><span>Summary</span>Vision Language Models (VLMs)は視覚的算術に苦労しているが、CogAlignという新しいポストトレーニング戦略を提案し、VLMの性能を向上させる。CogAlignは視覚的変換の不変特性を認識するように訓練し、CHOCOLATEで4.6%、MATH-VISIONで2.9%の性能向上を実現し、トレーニングデータを60%削減。これにより、基本的な視覚的算術能力の向上と下流タスクへの転送の効果が示された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/steeve__huang/status/1923543884367306763?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q既存のLLM (proprietary, openweightそれぞれ)が、シンプルなvisual arithmeticタスク(e.g., 線分の長さ比較, Chart上のdotの理解)などの性能が低いことを明らかにし、

<br>

<img src="https://github.com/user-attachments/assets/039a48de-67a5-4c81-ba59-174acd508479" alt="image" loading="lazy">

<br>

それらの原因を(1)Vision Encoderのrepresentationと(2)Vision EncoderをFreezeした上でのText Decoderのfinetuningで分析した。その結果、(1)ではいくつかのタスクでlinear layerのprobingでは高い性能が達成できないことがわかった。このことから、Vision Encoderによるrepresentationがタスクに関する情報を内包できていないか、タスクに関する情報は内包しているがlinear layerではそれを十分に可能できない可能性が示唆された。

<br>

<img src="https://github.com/user-attachments/assets/0eb90fa2-7b6a-43b6-81d9-b5f7e6fb3ea8" alt="image" loading="lazy">

<br>



<br>

これをさらに分析するために(2)を実施したところ、Vision Encoderをfreezeしていてもfinetuningによりquery stringに関わらず高い性能を獲得できることが示された。このことから、Vision Encoder側のrepresentationの問題ではなく、Text Decoderと側でデコードする際にFinetuningしないとうまく活用できないことが判明した。

<br>

<img src="https://github.com/user-attachments/assets/cd122d99-9228-44b1-9827-cdb56f49d492" alt="image" loading="lazy">手法のところはまだ全然しっかり読めていないのだが、画像に関する特定の属性に関するクエリと回答のペアを合成し、DPOすることで、zero-shotの性能が向上する、という感じっぽい？

<br>

<img src="https://github.com/user-attachments/assets/707b1cc9-8bbf-45a5-b564-f654503c836e" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/281da17b-c8c3-455a-aa51-043ed297ae1f" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<a class="button" href="articles/VerifiableRewards.html">#VerifiableRewards</a>
<span class="issue_date">Issue Date: 2025-05-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1964">J1: Incentivizing Thinking in LLM-as-a-Judge via Reinforcement Learning, Chenxi Whitehouse+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、強化学習アプローチJ1を用いてLLMのトレーニング手法を提案し、判断タスクにおける思考促進とバイアス軽減を図ります。J1は、他の同サイズモデルを上回る性能を示し、特に小型モデルでも優れた結果を出します。モデルは自己生成した参照回答と比較することで、より良い判断を学ぶことが明らかになりました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jaseweston/status/1923186392420450545?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLLM-as-a-Judgeのなめのモデルを学習するレシピにおいて、初めてRLを適用した研究と主張し、より高品質なreasoning traceを出力できるようにすることで性能向上をさせる。

<br>



<br>

具体的にはVerifiableなpromptとnon verifiableなpromptの両方からverifiableなpreference pairを作成しpointwiseなスコアリング、あるいはpairwiseなjudgeを学習するためのrewardを設計しGRPOで学習する、みたいな話っぽい。

<br>

non verifiableなpromptも用いるのは、そういったpromptに対してもjudgeできるモデルを構築するため。

<br>



<br>

mathに関するpromptはverifiableなのでレスポンスが不正解なものをrejection samplingし、WildChatのようなチャットはverifiableではないので、instructionにノイズを混ぜて得られたレスポンスをrejection samplingし、合成データを得ることで、non verifiableなpromptについても、verifiableなrewardを設計できるようになる。

<br>

<img src="https://github.com/user-attachments/assets/4264f599-2067-4688-99e7-b68cc1dc771d" alt="image" loading="lazy"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<a class="button" href="articles/SpeculativeDecoding.html">#SpeculativeDecoding</a>
<span class="issue_date">Issue Date: 2025-05-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1961">Faster Cascades via Speculative Decoding, Harikrishna Narasimhan+, ICLR'25</a>
<span class="snippet"><span>Summary</span>カスケードと推測デコーディングは、言語モデルの推論効率を向上させる手法であり、異なるメカニズムを持つ。カスケードは難しい入力に対して大きなモデルを遅延的に使用し、推測デコーディングは並行検証で大きなモデルを活用する。新たに提案する推測カスケーディング技術は、両者の利点を組み合わせ、最適な遅延ルールを特定する。実験結果は、提案手法がカスケードおよび推測デコーディングのベースラインよりも優れたコスト品質トレードオフを実現することを示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1922059828429832259?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QOpenReview: https://openreview.net/forum?id=vo9t20wsmd</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/KnowledgeEditing.html">#KnowledgeEditing</a>
<span class="issue_date">Issue Date: 2025-05-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1946">EasyEdit2: An Easy-to-use Steering Framework for Editing Large Language  Models, Ziwen Xu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本論文では、LLMの挙動を制御するためのフレームワーク「EasyEdit2」を提案。安全性や感情、個性などの介入をサポートし、使いやすさが特徴。ユーザーは技術的知識なしでモデルの応答を調整可能。新しいアーキテクチャにより、ステアリングベクトルを自動生成・適用するモジュールを搭載。実証的なパフォーマンスを報告し、ソースコードやデモも公開。</span>
<span class="snippet"><span>Comment</span>github:https://github.com/zjunlp/EasyEdit/tree/main</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-05-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1944">Nemotron-CC: Transforming Common Crawl into a Refined Long-Horizon   Pretraining Dataset, Dan Su+, ACL'25</a>
<span class="snippet"><span>Summary</span>FineWeb-EduとDCLMは、モデルベースのフィルタリングによりデータの90%を削除し、トレーニングに適さなくなった。著者は、アンサンブル分類器や合成データの言い換えを用いて、精度とデータ量のトレードオフを改善する手法を提案。1Tトークンで8Bパラメータモデルをトレーニングし、DCLMに対してMMLUを5.6ポイント向上させた。新しい6.3Tトークンデータセットは、DCLMと同等の性能を持ちながら、4倍のユニークなトークンを含み、長トークンホライズンでのトレーニングを可能にする。15Tトークンのためにトレーニングされた8Bモデルは、Llama 3.1の8Bモデルを上回る性能を示した。データセットは公開されている。</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Safety.html">#Safety</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/Toxicity.html">#Toxicity</a>
<a class="button" href="articles/ActivationSteering/ITI.html">#ActivationSteering/ITI</a>
<span class="issue_date">Issue Date: 2025-05-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1940">When Bad Data Leads to Good Models, Kenneth Li+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本論文では、LLMの事前学習におけるデータの質の再検討を行い、有害データが事後学習における制御を向上させる可能性を探ります。トイ実験を通じて、有害データの割合が増加することで有害性の概念が線形表現に影響を与えることを発見し、有害データが生成的有害性を増加させつつも除去しやすくなることを示しました。評価結果は、有害データで訓練されたモデルが生成的有害性を低下させつつ一般的な能力を保持する良好なトレードオフを達成することを示唆しています。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/ke_li_2021/status/1920646069613957606?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qこれは面白そうWebコーパスなどを事前学習で利用する際は、質の高いデータを残して学習した方が良いとされているが、4chanのようなtoxicなデータを混ぜて事前学習して、後からdetox（Inference Time Intervention 1941 , SFT, DPO)することで、最終的なモデルのtoxicなoutputが減るという話らしい。これはそもそも事前学習時点でtoxicなデータのsignalが除外されることで、モデルがtoxicな内容のrepresentationを学習できず、最終的にtoxicか否かをコントロールできなくなるため、と考察している（っぽい）

<br>

<img src="https://github.com/user-attachments/assets/7f6efd4b-0679-4143-9a7d-1bf3ea5b6f3a" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/0acec11b-d851-4137-b0aa-1ed7172388e1" alt="image" loading="lazy">有害な出力を減らせそうなことは分かったが、Activation Steeringによってどの程度モデルの性能に影響を与えるのかが気になる、と思ったがAppendixに記載があった。細かく書かれていないので推測を含むが、各データに対してToxicデータセットでProbingすることでTopKのheadを決めて、Kの値を調整することでinterventionの強さを調整し、Toxicデータの割合を変化させて評価してみたところ、モデルの性能に大きな影響はなかったということだと思われる（ただし1Bモデルでの実験しかない）

<br>



<br>

<img src="https://github.com/user-attachments/assets/4c79ca22-6916-438d-ad31-07596c82bfd1" alt="image" loading="lazy">

<br>

おそらく2,3節あたりが一番おもしろいポイントなのだと思われるがまだ読めていない。</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-05-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1938">Reinforcement Learning for Reasoning in Large Language Models with One  Training Example, Yiping Wang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>1-shot RLVRを用いることで、LLMの数学的推論能力が大幅に向上することを示した。Qwen2.5-Math-1.5Bモデルは、MATH500でのパフォーマンスが36.0%から73.6%に改善され、他の数学的ベンチマークでも同様の向上が見られた。1-shot RLVR中には、クロスドメイン一般化や持続的なテストパフォーマンスの改善が観察され、ポリシー勾配損失が主な要因であることが確認された。エントロピー損失の追加も重要で、結果報酬なしでもパフォーマンスが向上した。これらの成果は、RLVRのデータ効率に関するさらなる研究を促進する。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/user-attachments/assets/03cd9200-7fed-4c6d-a5a6-2379d2c8950a" alt="image" loading="lazy">下記ポストでQwenに対してpromptを適切に与えることで、追加のpost training無しで高い数学に関する能力を引き出せたという情報がある。おそらく事前学習時に数学のQAデータによって継続事前学習されており、この能力はその際に身についているため、数学に対する高い能力は実は簡単に引き出すことができるのかもしれない（だから1サンプルでも性能が向上したのではないか？）といった考察がある。

<br>



<br>

参考:https://x.com/weiliu99/status/1930826904522875309?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q・2011

<br>



<br>

とはどのような関係性があるだろうか？</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Coding.html">#Coding</a>
<span class="issue_date">Issue Date: 2025-05-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1937">Rewriting Pre-Training Data Boosts LLM Performance in Math and Code, Kazuki Fujii+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、公共データを体系的に書き換えることで大規模言語モデル（LLMs）の性能を向上させる2つのオープンライセンスデータセット、SwallowCodeとSwallowMathを紹介。SwallowCodeはPythonスニペットを洗練させる4段階のパイプラインを用い、低品質のコードをアップグレード。SwallowMathはボイラープレートを削除し、解決策を簡潔に再フォーマット。これにより、Llama-3.1-8Bのコード生成能力がHumanEvalで+17.0、GSM8Kで+12.4向上。すべてのデータセットは公開され、再現可能な研究を促進。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/okoge_kaz/status/1920141189652574346?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説ポスト:https://x.com/hillbig/status/1920613041026314274?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/RLVR.html">#RLVR</a>
<a class="button" href="articles/ZeroData.html">#ZeroData</a>
<span class="issue_date">Issue Date: 2025-05-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1936">Absolute Zero: Reinforced Self-play Reasoning with Zero Data, Andrew Zhao+, arXiv'25</a>
<span class="snippet"><span>Summary</span>新しいRLVRパラダイム「Absolute Zero」を提案し、自己学習を通じて推論能力を向上させるAZRを導入。外部データに依存せず、コーディングや数学的推論タスクでSOTAパフォーマンスを達成。既存のゼロ設定モデルを上回り、異なるモデルスケールにも適用可能。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/arankomatsuzaki/status/1919946713567264917?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<span class="issue_date">Issue Date: 2025-05-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1935">Tina: Tiny Reasoning Models via LoRA, Shangshang Wang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Tinaは、コスト効率よく強力な推論能力を実現する小型の推論モデルファミリーであり、1.5Bパラメータのベースモデルに強化学習を適用することで高い推論性能を示す。Tinaは、従来のSOTAモデルと競争力があり、AIME24で20%以上の性能向上を達成し、トレーニングコストはわずか9ドルで260倍のコスト削減を実現。LoRAを通じた効率的なRL推論の効果を検証し、すべてのコードとモデルをオープンソース化している。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/rasbt/status/1920107023980462575?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q（おそらく）Reasoningモデルに対して、LoRAとRLを組み合わせて、reasoning能力を向上させた初めての研究</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/DataGeneration.html">#DataGeneration</a>
<a class="button" href="articles/DataDistillation.html">#DataDistillation</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2025-05-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1931">R.I.P.: Better Models by Survival of the Fittest Prompts, Ping Yu+, ICML'25</a>
<span class="snippet"><span>Summary</span>トレーニングデータの品質がモデルの性能に与える影響を考慮し、低品質な入力プロンプトがもたらす問題を解決するために、Rejecting Instruction Preferences（RIP）というデータ整合性評価手法を提案。RIPは、拒否された応答の品質と選択された好みペアとの報酬ギャップを測定し、トレーニングセットのフィルタリングや高品質な合成データセットの作成に利用可能。実験結果では、RIPを用いることでLlama 3.1-8B-Instructでの性能が大幅に向上し、Llama 3.3-70B-Instructではリーダーボードでの順位が上昇した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jaseweston/status/1885160135053459934?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

スレッドで著者が論文の解説をしている。</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-05-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1930">Thinking LLMs: General Instruction Following with Thought Generation, Tianhao Wu+, ICML'25</a>
<span class="snippet"><span>Summary</span>LLMsに思考能力を装備するための訓練方法を提案。反復的な検索と最適化手順を用いて、モデルが監視なしで思考する方法を学ぶ。指示に対する思考候補はジャッジモデルで評価され、最適化される。この手法はAlpacaEvalとArena-Hardで優れたパフォーマンスを示し、推論タスクだけでなく、マーケティングや健康などの非推論カテゴリでも利点を発揮。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/tesatory/status/1919461701206081813?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q外部のCoTデータを使わないで、LLMのreasoning capabilityを向上させる話っぽい。DeepSeek-R1の登場以前の研究とのこと。reasoning traceを出力するようにInstruction Tuningによって回答を直接出力するようPostTrainingされたモデルにpromptingし、複数のoutputを収集（今回は8個, temperature=0.8, top p=0.95)。Self Taught Evaluator 1464 (STE;70B, LLM-as-a-Judgeを利用するモデル）、あるいはArmo Reward Model（8B）によって回答の品質をスコアリング。ここで、LLM-as-a-Judgeの場合はペアワイズでの優劣が決まるだけなので、ELOでスコアリングする。outputのうちbest scoreとworst scoreだったものの双方でペアデータを構築し、DPOで利用するpreferenceペアデータを構築しDPOする。このような処理を繰り返し、モデルの重みをiterationごとに更新する。次のiterationでは更新されたモデルで同様の処理を行い、前段のステップで利用した学習データは利用しないようにする（後段の方が品質が高いと想定されるため）。また、回答を別モデルで評価する際に、長いレスポンスを好むモデルの場合、長い冗長なレスポンスが高くスコアリングされるようなバイアスが働く懸念があるため、長すぎる回答にpenaltyを与えている（Length-Control)。

<br>

<img src="https://github.com/user-attachments/assets/3be7f7c3-1a24-44c5-bd73-a4b9e11b4b2c" alt="image" loading="lazy">

<br>



<br>

reasoning traceを出力するpromptはgenericとspecific thoughtの二種類で検証。前者はLLMにどのような思考をするかを丸投げするのに対し、後者はこちら側で指定する。後者の場合は、どのような思考が良いかを事前に知っていなければならない。

<br>

<img src="https://github.com/user-attachments/assets/4548fd23-69ba-482f-8987-740f30658d83" alt="image" loading="lazy">

<br>



<br>

Llama-3-8b-instructに適用したところ、70Bスケールのモデルよりも高い性能を達成。また、reasoning trace出力をablationしたモデル（Direct responce baseline）よりも性能が向上。

<br>

<img src="https://github.com/user-attachments/assets/06605741-7049-460a-8062-93be96d45975" alt="image" loading="lazy">

<br>



<br>

iterationが進むに連れて、性能が向上している。

<br>

<img src="https://github.com/user-attachments/assets/25ced3ce-e341-41c4-b1e2-527885590e08" alt="image" loading="lazy"></span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/SSM%20(StateSpaceModel).html">#SSM (StateSpaceModel)</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-05-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1924">Layer by Layer: Uncovering Hidden Representations in Language Models, Oscar Skean+, ICML'25</a>
<span class="snippet"><span>Summary</span>中間層の埋め込みが最終層を超えるパフォーマンスを示すことを分析し、情報理論や幾何学に基づくメトリクスを提案。32のテキスト埋め込みタスクで中間層が強力な特徴を提供することを実証し、AIシステムの最適化における中間層の重要性を強調。</span>
<span class="snippet"><span>Comment</span>現代の代表的な言語モデルのアーキテクチャ（decoder-only model, encoder-only model, SSM）について、最終層のembeddingよりも中間層のembeddingの方がdownstream task（MTEBの32Taskの平均）に、一貫して（ただし、これはMTEBの平均で見たらそうという話であり、個別のタスクで一貫して強いかは読んでみないとわからない）強いことを示した研究。

<br>



<br>

このこと自体は経験的に知られているのであまり驚きではないのだが（ただ、SSMでもそうなのか、というのと、一貫して強いというのは興味深い）、この研究はMatrix Based Entropyと呼ばれるものに基づいて、これらを分析するための様々な指標を定義し理論的な根拠を示し、Autoregressiveな学習よりもMasked Languageによる学習の方がこのようなMiddle Layerのボトルネックが緩和され、同様のボトルネックが画像の場合でも起きることを示し、CoTデータを用いたFinetuningについても分析している模様。この辺の貢献が非常に大きいと思われるのでここを理解することが重要だと思われる。あとで読む。

<br>



<br>

<img src="https://github.com/user-attachments/assets/bda00c50-c97b-45e0-97a5-d98dd98599fd" alt="image" loading="lazy"></span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Bias.html">#Bias</a>
<a class="button" href="articles/NAACL.html">#NAACL</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/PerplexityCurse.html">#PerplexityCurse</a>
<span class="issue_date">Issue Date: 2025-05-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1922">Where is the answer? Investigating Positional Bias in Language Model   Knowledge Extraction, Kuniaki Saito+, NAACL'25</a>
<span class="snippet"><span>Summary</span>LLMは新しい文書でファインチューニングが必要だが、「困惑の呪い」により情報抽出が困難。特に文書の初めに関する質問には正確に答えるが、中間や末尾の情報抽出に苦労する。自己回帰的トレーニングがこの問題を引き起こすことを示し、デノイジング自己回帰損失が情報抽出を改善する可能性を示唆。これにより、LLMの知識抽出と新ドメインへの適応に関する新たな議論が生まれる。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/losnuevetoros/status/1918332232181207096?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q![Image](https://github.com/user-attachments/assets/dd6bdffa-4ce0-4389-826e-4c85113c755f)

<br>

LLMの知識を最新にするために新しい文書（e.g., 新しいドメインの文書等）をLLMに与え（便宜上学習データと呼ぶ）Finetuningをした場合、Finetuning後のモデルで与えられたqueryから（LLM中にパラメータとしてmemorizeされている）対応する事実情報を抽出するようInferenceを実施すると、queryに対応する事実情報の学習データ中での位置が深くなると（i.e., middle -・endになると）抽出が困難になる Positional Biasが存在する[^1]ことを明らかにした。

<br>

そして、これを緩和するために正則化が重要（e.g., Denoising, Shuffle, Attention Drops）であることを実験的に示し、正則化手法は複数組み合わせることで、よりPositional Biasが緩和することを示した研究

<br>



<br>

[^1]: 本研究では"Training"に利用する文書のPositional Biasについて示しており、"Inference"時におけるPositional Biasとして知られている"lost-in-the middle"とは異なる現象を扱っている点に注意データセット

<br>

文書 + QAデータの2種類を構築しFinetuning後のknowledge extraction能力の検証をしている[^2]。

<br>



<br>

実験では、`Synthetic Bio (合成データ)`, `Wiki2023+（実データ）` の2種類のデータを用いて、Positional Biasを検証している。

<br>

Synthetic bioは、人間のbiographyに関する9つの属性（e.g., 誕生日, 出生地）としてとりうる値をChatGPTに生成させ、3000人の人物に対してそれらをランダムにassignし、sentence templateを用いてSurface Realizationすることで人工的に3000人のbiographyに関するテキストを生成している。

<br>

一方、Wiki2023+では、1708 の方法にのっとって [^3]事前学習時の知識とのoverlapが最小となるように`2023`カテゴリ以下のwikipediaの様々なジャンルの記事を収集して活用する。QAデータの構築には、元文書からsentenceを抽出し、GPT-3.5-Turboに当該sentenceのみを与えてQA pairを作成させることで、データを作成している。なお、hallucinationや品質の低いQA pairをフィルタリングした。フィルタリング後のQA Pairをランダムにサンプリングし品質を確認したところ、95%のQA pairが妥当なものであった。

<br>



<br>

これにより、下図のようなデータセットが作成される。FigureCが `Wiki2023+`で、FigureDが`SyntheticBio`。`Wiki2023+`では、QA pairの正解が文書中の前半により正解が現れるような偏りが見受けられる。

<br>

![Image](https://github.com/user-attachments/assets/1146328f-de7e-4e90-b495-b129730c5d0d)

<br>



<br>

[^2]: 1923 において、知識 + 知識を抽出するタスクの双方を用いて学習することで、モデルから知識を抽出する能力が備わることが示されているため。

<br>

[^3]: Llama-2-7Bにおいて2023カテゴリ以下の情報に対するQAのperformanceが著しく低いことから、事前学習時に当該データが含まれている可能性が低いことが示唆されている実験 &amp; 実験結果 (modulated data)

<br>

作成した文書+QAデータのデータセットについて、QAデータをtrain/valid/testに分けて、文書データは全て利用し、testに含まれるQAに適切に回答できるかで性能を評価する。このとき、文書中でQAに対する正解がテキストが出現する位置を変化させモデルの学習を行い、予測性能を見ることで、Positional Biasが存在することを明らかにする。このとき、1923 に倣い、文書とQAをMixed Sampling（1バッチあたり256件のサンプルをランダムにQAおよび文書データからサンプリング; 1923 では文書とQAを2:8の比率でサンプリングしている）することで学習をする。QAの場合目的関数は回答テキスト部分のみのNLL、文書の場合はnext-token prediction lossを利用する。

<br>



<br>

Positional Biasの存在を示すだけでなく、(A, B, C) の順番でnext-token prediction lossで学習されたモデルの場合、Cの知識を抽出するためにA, Bがcontextとして必要となるため、Cを抽出する際の汎化性能を高めるためにA, Bの表現がより多様である必要がある、という課題がある。これに対処するためのいくつかのシンプルな正則化手法、具体的には

<br>

・D-AR: predition targetのトークンは保持したまま、input tokenの一部をランダムなトークンに置き換える

<br>

・Shuffle: 入力文をシャッフルする

<br>

・Attn Drop: self-attentionモジュールのattention weightをランダムに0にする

<br>

の3種類とPositional Biasの関係性を検証している。

<br>

![Image](https://github.com/user-attachments/assets/503e53f2-28f5-46ea-a11f-beee98f8fa38)

<br>



<br>

検証の結果、（合成データ、実データともに）Positional Biasが存在することが明らかとなり（i.e., 正解テキストが文書中の深い位置にあればあるほど予測性能が低下する）正則化によってPositional Biasが緩和されることが示された。

<br>

![Image](https://github.com/user-attachments/assets/11a29a1e-f869-4628-9c47-e1fc9e5c394e)

<br>



<br>

また、異なるモデルサイズで性能を比較したところ、モデルサイズを大きくすることで性能自体は改善するが、依然としてPositional Biasが存在することが示され、ARよりもD-ARが一貫して高い性能を示した。このことから、Positional Biasを緩和するために何らかの正則化手法が必要なことがわかる。

<br>

![Image](https://github.com/user-attachments/assets/0772d144-c22b-4723-8578-acdf0e2e1187)

<br>



<br>

また、オリジナル文書の1文目を、正解データの位置を入れ替えた各モデルに対して、テキスト中の様々な位置に配置してPerplexityを測った。この設定では、モデルがPerplexityを最小化するためには、（1文目ということは以前の文脈が存在しないsentenceなので）文脈に依存せずに文の記憶していなければならない。よって、各手法ごとにどの程度Perplexityが悪化するかで、各手法がどの程度あるsentenceを記憶する際に過去の文脈に依存しているかが分かる。ここで、学習データそのもののPerplexityはほぼ1.0であったことに注意する。

<br>

結果として、文書中の深い位置に配置されればされるほどPerplexityは増大し（left）、Autoregressive Model (AR) のPerplexity値が最も値が大きかった（=性能が悪かった）。このことから、ARはより過去の文脈に依存してsentenceの情報を記憶していることが分かる。また、モデルサイズが小さいモデルの方がPerplexityは増大する傾向にあることがわかった (middle)。これはFig.3で示したQAのパフォーマンスと傾向が一致しており、学習データそのもののPerplexityがほぼ1.0だったことを鑑みると、学習データに対するPerplexityは様々なPositionに位置する情報を適切に抽出できる能力を測るメトリックとしては適切でないことがわかる。また、学習のiterationを増やすと、ARの場合はfirst positionに対する抽出性能は改善したが、他のpositionでの抽出性能は改善しなかった。一方、D-ARの場合は、全てのpositionでの抽出性能が改善した (right) 。このことから、必ずしも学習のiterationを増やしても様々なPositionに対する抽出性能が改善しないこと、longer trainingの恩恵を得るためには正則化手法を利用する必要があることが明らかになった。

<br>



<br>

![Image](https://github.com/user-attachments/assets/94f635a5-68d5-478d-ab16-513e855fe054)

<br>

実験 &amp; 実験結果 (unmodulated data)

<br>

Wiki2023+データに対して上記のようなデータの変更を行わずに、そのまま学習を行い、各位置ごとのQAの性能を測定したところ、（すべてがPositional Biasのためとは説明できないが）回答が文書中の深い位置にある場合の性能が劣化することを確認した。2--6番目の性能の低下は、最初の文ではシンプルな事実が述べられ、後半になればなるほどより複雑な事実が述べられる傾向があることが起因して性能の低下しているとかせつをたてている。また、unmodulated dataの場合でもD-ARはARの性能を改善することが明らかとなった。モデルサイズが大きいほど性能は改善するが、以前として文書中の深い位置に正解がある場合に性能は劣化することもわかる。

<br>

<img src="https://github.com/user-attachments/assets/2f43ba8a-c54e-4523-b8f0-7cfc797d5a7e" alt="image" loading="lazy">

<br>



<br>

また、正則化手法は組み合わせることでさらに性能が改善し、1923 に示されている通り、学習データ中の表現を多様にし[^1]学習したところ予測性能が改善し、正則化手法とも補完的な関係であることも示された。

<br>

<img src="https://github.com/user-attachments/assets/e79415b1-28e2-47ab-b429-448412053d0b" alt="image" loading="lazy">

<br>



<br>

医療ドメインでも実験したところ、正則化手法を適用した場合にARよりも性能が上回った。最後にWiki2023+データについてOpenbookな設定で、正解が含まれる文書をLLMのcontextとして与えた場合（i.e.,ほぼ完璧なretrieverが存在するRAGと同等の設定とみなせる）、QAの性能は90.6%に対し、継続学習した場合のベストモデルの性能は50.8%だった。このことから、正確なretrieverが存在するのであれば、継続学習よりもRAGの方がQAの性能が高いと言える。

<br>

RAGと継続学習のメリット、デメリットの両方を考慮して、適切に手法を選択することが有効であることが示唆される。

<br>

<img src="https://github.com/user-attachments/assets/14180452-5421-4102-8751-fabc8b780d49" alt="image" loading="lazy">

<br>



<br>

[^1]: ChatGPTによってテキストをrephraseし、sentenceのorderも変更することで多様性を増やした。が、sentence orderが文書中の深い位置にある場合にあまりorderが変化しなかったようで、このため深い位置に対するQAの性能改善が限定的になっていると説明している。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2025-04-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1918">When More is Less: Understanding Chain-of-Thought Length in LLMs, Yuyang Wu+, ICLR'25</a>
<span class="snippet"><span>Summary</span>Chain-of-thought (CoT)推論は、LLMsの多段階推論能力を向上させるが、CoTの長さが増すと最初は性能が向上するものの、最終的には低下することが観察される。長い推論プロセスがノイズに脆弱であることを示し、理論的に最適なCoTの長さを導出。Length-filtered Voteを提案し、CoTの長さをモデルの能力とタスクの要求に合わせて調整する必要性を強調。</span>
<span class="snippet"><span>Comment</span>ICLR 2025 Best Paper Runner Up Award

<br>

元ポスト:https://x.com/yifeiwang77/status/1916873981979660436?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/KnowledgeEditing.html">#KnowledgeEditing</a>
<span class="issue_date">Issue Date: 2025-04-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1917">AlphaEdit: Null-Space Constrained Knowledge Editing for Language Models, Junfeng Fang+, ICLR'25</a>
<span class="snippet"><span>Summary</span>AlphaEditは、LLMsの知識を保持しつつ編集を行う新しい手法で、摂動を保持された知識の零空間に投影することで、元の知識を破壊する問題を軽減します。実験により、AlphaEditは従来の位置特定-編集手法の性能を平均36.7%向上させることが確認されました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1917343444810489925?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QOpenReview:https://openreview.net/forum?id=HvSytvg3JhMLPに新たな知識を直接注入する際に（≠contextに含める）既存の学習済みの知識を破壊せずに注入する手法（破壊しないことが保証されている）を提案しているらしい将来的には、LLMの1パラメータあたりに保持できる知識量がわかってきているので、MLPの零空間がN GBのモデルです、あなたが注入したいドメイン知識の量に応じて適切な零空間を持つモデルを選んでください、みたいなモデルが公開される日が来るのだろうか。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2025-04-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1916">Can LLMs Be Trusted for Evaluating RAG Systems? A Survey of Methods and  Datasets, Lorenz Brehme+, arXiv'25</a>
<span class="snippet"><span>Summary</span>RAGシステムの評価手法を63件の論文を基にレビューし、データセット、リトリーバー、インデクシング、生成コンポーネントの4領域に焦点を当てる。自動評価アプローチの実現可能性を観察し、LLMを活用した評価データセットの生成を提案。企業向けに実装と評価の指針を提供するための実践的研究の必要性を強調し、評価手法の進展と信頼性向上に寄与する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_reachsumit/status/1917425829233189027?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qおもしろそう</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<a class="button" href="articles/SSM%20(StateSpaceModel).html">#SSM (StateSpaceModel)</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2025-04-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1905">RNNs are not Transformers （Yet）: The Key Bottleneck on In-context   Retrieval, Kaiyue Wen+, ICLR'25</a>
<span class="snippet"><span>Summary</span>本論文では、RNNとトランスフォーマーの表現力の違いを調査し、特にRNNがChain-of-Thought（CoT）プロンプトを用いてトランスフォーマーに匹敵するかを分析。結果、CoTはRNNを改善するが、トランスフォーマーとのギャップを埋めるには不十分であることが判明。RNNの情報取得能力の限界がボトルネックであるが、Retrieval-Augmented Generation（RAG）やトランスフォーマー層の追加により、RNNはCoTを用いて多項式時間で解決可能な問題を解決できることが示された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/yuma_1_or/status/1915968478735130713?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・1210

<br>



<br>

↑とはどういう関係があるだろうか？</span>
<a class="button" href="articles/Multi.html">#Multi</a>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2025-04-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1904">Why Do Multi-Agent LLM Systems Fail?, Mert Cemri+, arXiv'25</a>
<span class="snippet"><span>Summary</span>MASの性能向上が単一エージェントと比較して限定的であることを受け、MAST（Multi-Agent System Failure Taxonomy）を提案。200以上のタスクを分析し、14の失敗モードを特定し、3つの大カテゴリに整理。Cohenのカッパスコア0.88を達成し、LLMを用いた評価パイプラインを開発。ケーススタディを通じて失敗分析とMAS開発の方法を示し、今後の研究のためのロードマップを提示。データセットとLLMアノテーターをオープンソース化予定。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/mertcemri/status/1915567789714329799?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q7つのメジャーなマルチエージェントフレームワークに対して200以上のタスクを実施し、6人の専門家がtraceをアノテーション。14種類の典型的なfailure modeを見つけ、それらを3つにカテゴライズ。これを考慮してマルチエージェントシステムの失敗に関するTaxonomy（MAS）を提案

<br>

<img src="https://github.com/user-attachments/assets/21d45bc7-cc6c-4561-b991-098f8d068627" alt="image" loading="lazy"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Quantization.html">#Quantization</a>
<a class="button" href="articles/SmallModel.html">#SmallModel</a>
<span class="issue_date">Issue Date: 2025-04-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1898">BitNet b1.58 2B4T Technical Report, Shuming Ma+, arXiv'25</a>
<span class="snippet"><span>Summary</span>BitNet b1.58 2B4Tは、20億パラメータを持つオープンソースの1ビット大規模言語モデルで、4兆トークンで訓練されました。言語理解や数学的推論などのベンチマークで評価され、同サイズのフルプレシジョンLLMと同等の性能を示しつつ、計算効率が向上しています。メモリ、エネルギー消費、デコーディングレイテンシが削減され、モデルの重みはHugging Faceで公開されています。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iscienceluvr/status/1912783876365177235?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q圧倒的省メモリかつcpuでのinference速度も早そう

<br>

<img src="https://github.com/user-attachments/assets/dacf05e4-9cb3-48b4-9a98-532f7245eb8e" alt="image" loading="lazy">・アーキテクチャはTransformerを利用

<br>

・Linear layerとしてBitLinear Layerを利用

<br>

  ・重みは{1, 0, -1}の3値をとる

<br>

  ・activationは8bitのintegerに量子化

<br>

  ・Layer Normalizationはsubln normalization 1899 を利用</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/x-Use.html">#x-Use</a>
<span class="issue_date">Issue Date: 2025-04-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1897">AndroidWorld: A Dynamic Benchmarking Environment for Autonomous Agents, Christopher Rawles+, ICLR'25</a>
<span class="snippet"><span>Summary</span>本研究では、116のプログラムタスクに対して報酬信号を提供する「AndroidWorld」という完全なAndroid環境を提案。これにより、自然言語で表現されたタスクを動的に構築し、現実的なベンチマークを実現。初期結果では、最良のエージェントが30.6%のタスクを完了し、さらなる研究の余地が示された。また、デスクトップWebエージェントのAndroid適応が効果薄であることが明らかになり、クロスプラットフォームエージェントの実現にはさらなる研究が必要であることが示唆された。タスクの変動がエージェントのパフォーマンスに影響を与えることも確認された。</span>
<span class="snippet"><span>Comment</span>Android環境でのPhone Useのベンチマーク</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<span class="issue_date">Issue Date: 2025-04-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1893">d1: Scaling Reasoning in Diffusion Large Language Models via  Reinforcement Learning, Siyan Zhao+, arXiv'25</a>
<span class="snippet"><span>Summary</span>d1というフレームワークを提案し、マスク付きdLLMsを教師ありファインチューニングと強化学習で推論モデルに適応。マスク付きSFT技術で知識を抽出し、diffu-GRPOという新しいRLアルゴリズムを導入。実証研究により、d1が最先端のdLLMの性能を大幅に向上させることを確認。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iscienceluvr/status/1912785180504535121?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QdLLMに対してGRPOを適用する手法(diffuGRPO)を提案している。

<br>

long CoTデータでSFTしてreasoning capabilityを強化した後、diffuGRPOで追加のpost-trainingをしてさらに性能をboostする。GRPOではtoken levelの尤度とsequence全体の尤度を計算する必要があるが、dLLMだとautoregressive modelのようにchain ruleを適用する計算方法はできないので、効率的に尤度を推定するestimatorを用いてGPPOを適用するdiffuGRPOを提案している。

<br>



<br>

diffuGRPO単体でも、8BモデルだがSFTよりも性能向上に成功している。SFTの後にdiffuGRPOを適用するとさらに性能が向上する。

<br>



<br>

SFTではs1 1749 で用いられたlong CoTデータを用いている。しっかり理解できていないが、diffuGRPO+verified rewardによって、long CoTの学習データを用いなくても、安定してreasoning能力を発揮することができようになった、ということなのだろうか？

<br>

しかし、AppendixCを見ると、元々のLLaDAの時点でreasoning traceを十分な長さで出力しているように見える。もしLLaDAが元々long CoTを発揮できたのだとしたら、long CoTできるようになったのはdiffuGRPOだけの恩恵ではないということになりそうだが、LLaDAは元々long CoTを生成できるようなモデルだったんだっけ…？その辺追えてない（dLLMがメジャーになったら追う）。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/Repetition.html">#Repetition</a>
<span class="issue_date">Issue Date: 2025-04-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1892">Learning Dynamics of LLM Finetuning, Yi Ren+, ICLR'25</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデルのファインチューニング中の学習ダイナミクスを分析し、異なる応答間の影響の蓄積を段階的に解明します。指示調整と好み調整のアルゴリズムに関する観察を統一的に解釈し、ファインチューニング後の幻覚強化の理由を仮説的に説明します。また、オフポリシー直接好み最適化（DPO）における「圧縮効果」を強調し、望ましい出力の可能性が低下する現象を探ります。このフレームワークは、LLMのファインチューニング理解に新たな視点を提供し、アラインメント性能向上のためのシンプルな方法を示唆します。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/joshuarenyi/status/1913033476275925414?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説ポスト:https://x.com/hillbig/status/1917189793588613299?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/SmallModel.html">#SmallModel</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-04-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1887">A Sober Look at Progress in Language Model Reasoning: Pitfalls and Paths  to Reproducibility, Andreas Hochlehnert+, arXiv'25</a>
<span class="snippet"><span>Summary</span>推論は言語モデルの重要な課題であり、進展が見られるが、評価手法には透明性や堅牢性が欠けている。本研究では、数学的推論ベンチマークが実装の選択に敏感であることを発見し、標準化された評価フレームワークを提案。再評価の結果、強化学習アプローチは改善が少なく、教師ありファインチューニング手法は強い一般化を示した。再現性を高めるために、関連するコードやデータを公開し、今後の研究の基盤を築く。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/wenhuchen/status/1911143014258405420?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QSLMをmath reasoning向けにpost-trainingする場合、RL（既存研究で試されているもの）よりも（大規模モデルからrejection samplingしたreasoning traceを用いて）SFTをする方が同等か性能が良く、結局のところ（おそらく汎化性能が低いという意味で）reliableではなく、かつ（おそらく小規模なモデルでうまくいかないという意味での）scalableではないので、reliableかつscalableなRL手法が不足しているとのこと。

<br>



<br>

※ 本論文で分析されているのは&lt;=10B以下のSLMである点に注意。10B以上のモデルで同じことが言えるかは自明ではない。

<br>

※ DAPO, VAPOなどについても同じことが言えるかも自明ではない。

<br>

※ DeepSeek-R1のtechnical reportにおいて、小さいモデルにGRPOを適用してもあまり効果が無かったことが既に報告されている。

<br>



<br>

<img src="https://github.com/user-attachments/assets/620017f1-b3f0-40c1-bf61-3b0b7a429ab4" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/321132c8-dad5-4aa1-9811-f032e3474135" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/fca985ee-2934-4543-8486-0ac4a9cc003f" alt="image" loading="lazy">

<br>



<br>

・1743

<br>

・1719個々のpost-trainingされたRLモデルが具体的にどういう訓練をしたのかは追えていないが、DAPOやDr. GRPO, VAPOの場合はどうなるんだろうか？

<br>



<br>

・1815

<br>

・1876

<br>

・1821

<br>



<br>

Rewardの設定の仕方はどのような影響があるのだろうか（verifiable rewardなのか、neuralモデルによるrewardなのかなど)？

<br>



<br>

学習のさせ方もどのような影響があるのだろうか（RLでカリキュラムlearningにした場合など）？

<br>



<br>

検証しているモデルがそれぞれどのような設定で学習されているかまでを見ないとこの辺はわからなそう。

<br>



<br>

ただなんとなーくの直感だと、SLMを賢くしたいという場合は何らかの賢いモデルの恩恵に預かるしかなく（SFTの場合はそれが大規模なモデルから蒸留したreasoning trace）、SLM+RLの場合はTPMのような思考プロセスを評価してRewardに反映させるようなものを利用しないと、少なくとも小規模なLLMをめちゃ賢くします〜というのはきついんじゃないかなあという感想ではある。

<br>

ただ、結局SLMという時点で多くの場合、より賢いパラメータ数の多いLLMが世の中には存在するあるはずなので、RLしないでSFTして蒸留すれば良いんじゃない…？と思ってしまう。

<br>

が、多くの場合その賢いLLMはProprietaryなLLMであり、出力を得て自分のモデルをpost-trainingすることは利用規約違反となるため、自前で賢くてパラメータ数の多いLLMを用意できない場合は困ってしまうので、SLMをクソデカパラメータのモデルの恩恵なしで超絶賢くできたら世の中の多くの人は嬉しいよね、とも思う。（斜め読みだが）

<br>

サンプル数が少ない（数十件）AIMEやAMCなどのデータはseedの値にとてもsensitiveであり、

<br>

<img src="https://github.com/user-attachments/assets/289d8049-41a2-4ab9-a95b-9b8b499bee57" alt="image" loading="lazy">

<br>



<br>

それらは10種類のseedを用いて結果を平均すると分散が非常に小さくなるので、seedは複数種類利用して平均の性能を見た方がreliableであり

<br>

<img src="https://github.com/user-attachments/assets/1d39c6d1-6f43-4d1e-af23-d3c7839d2b0a" alt="image" loading="lazy">

<br>



<br>

temperatureを高くするとピーク性能が上がるが分散も上がるため再現性の課題が増大するが、top-pを大きくすると再現性の問題は現れず性能向上に寄与し

<br>

<img src="https://github.com/user-attachments/assets/0a3c2a7a-527b-4225-b55e-6d148c848602" alt="image" loading="lazy">

<br>



<br>

既存研究のモデルのtemperatureとtop-pを変化させ実験するとperformanceに非常に大きな変化が出るため、モデルごとに最適な値を選定して比較をしないとunfairであることを指摘。

<br>

<img src="https://github.com/user-attachments/assets/ee664622-680a-4020-844a-8c2464fc8a5d" alt="image" loading="lazy">

<br>



<br>

また、ハードウェアの面では、vLLMのようなinference engineはGPU typeやmemoryのconfigurationに対してsensitiveでパフォーマンスが変わるだけでなく、

<br>

<img src="https://github.com/user-attachments/assets/36fc9dbd-1bfa-4a6d-92a7-4d2f2f477a84" alt="image" loading="lazy">

<br>



<br>

評価に利用するフレームワークごとにinference engineとprompt templateが異なるためこちらもパフォーマンスに影響が出るし、

<br>

<img src="https://github.com/user-attachments/assets/6b2005f5-7d70-4a79-a223-16ffffc2a3fd" alt="image" loading="lazy">

<br>



<br>

max output tokenの値を変化させると性能も変わり、prompt templateを利用しないと性能が劇的に低下する。

<br>

<img src="https://github.com/user-attachments/assets/684e74b2-0772-4de0-a2f6-7cb90b3e4c8a" alt="image" loading="lazy">

<br>



<br>

これらのことから著者らはreliableな評価のために下記を提案しており、

<br>

<img src="https://github.com/user-attachments/assets/941fc791-7639-4701-8866-deff5fdf511d" alt="image" loading="lazy">

<br>



<br>

実際にさまざまな条件をfair comparisonとなるように標準化して評価したところ

<br>

<img src="https://github.com/user-attachments/assets/b3b633cf-e827-4fad-8db6-567270066f93" alt="image" loading="lazy">

<br>



<br>

上の表のような結果となった。この結果は、

<br>

・DeepSeekR1-DistilledをRLしてもSFTと比較したときに意味のあるほどのパフォーマンスの向上はないことから、スケーラブル、かつ信頼性のあるRL手法がまだ不足しており

<br>

・大規模なパラメータのモデルのreasoning traceからSFTをする方法はさまざまなベンチマークでロバストな性能（＝高い汎化性能）を持ち、RLと比べると現状はRLと比較してよりパラダイムとして成熟しており

<br>

・（AIME24,25を比較するとSFTと比べてRLの場合performanceの低下が著しいので）RLはoverfittingしやすく、OODなベンチマークが必要しっかりと評価の枠組みを標準化してfair comparisonしていかないと、RecSys業界の二の舞になりそう（というかもうなってる？）。

<br>



<br>

またこの研究で分析されているのは小規模なモデル（&lt;=10B）に対する既存研究で用いられた一部のRL手法や設定の性能だけ（真に示したかったらPhisics of LLMのような完全にコントロール可能なサンドボックスで実験する必要があると思われる）なので、DeepSeek-R1のように、大規模なパラメータ（数百B）を持つモデルに対するRLに関して同じことが言えるかは自明ではない点に注意。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<span class="issue_date">Issue Date: 2025-04-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1882">Hallucination Mitigation using Agentic AI Natural Language-Based  Frameworks, Diego Gosmar+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、複数のAIエージェントを調整し、自然言語処理を活用して幻覚を軽減する方法を探求。300以上の幻覚を誘発するプロンプトを用いたパイプラインを設計し、出力を第二および第三レベルのエージェントがレビュー。新たに設計したKPIで幻覚スコアを評価し、OVONフレームワークを通じてエージェント間で文脈情報を転送。結果として、相互運用可能なエージェントを活用することで幻覚の軽減に成功し、AIへの信頼を強化することが示された。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/AttentionSinks.html">#AttentionSinks</a>
<span class="issue_date">Issue Date: 2025-04-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1878">Using Attention Sinks to Identify and Evaluate Dormant Heads in  Pretrained LLMs, Pedro Sandoval-Segura+, arXiv'25</a>
<span class="snippet"><span>Summary</span>マルチヘッドアテンションにおける「休眠アテンションヘッド」を定義し、その影響を調査。6つのモデルと5つのデータセットを用いた実験で、休眠ヘッドの出力をゼロにしても精度を維持できることを確認。休眠ヘッドは事前学習の初期に出現し、入力テキストの特性に依存することが示された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/psandovalsegura/status/1909652533334712691?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<span class="issue_date">Issue Date: 2025-04-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1871">KAA: Kolmogorov-Arnold Attention for Enhancing Attentive Graph Neural  Networks, Taoran Fang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>注意GNNにおけるスコアリングプロセスの理解が不足している中、本研究ではコルモゴロフ・アルノルド注意（KAA）を提案し、スコアリング関数を統一。KAAはKANアーキテクチャを統合し、ほぼすべての注意GNNに適用可能で、表現力が向上。実験により、KAA強化スコアリング関数が元のものを一貫して上回り、最大20%以上の性能向上を達成した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/theturingpost/status/1908966571227398449?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<span class="issue_date">Issue Date: 2025-04-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1870">XAttention: Block Sparse Attention with Antidiagonal Scoring, Ruyi Xu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>XAttentionは、Long-Context Transformer Modelsにおける長文コンテキスト推論を加速するプラグアンドプレイのフレームワークで、注意行列の反対対角線の値を用いてブロックの重要度を評価し、非本質的なブロックを剪定することで高いスパース性を実現。RULERやLongBenchなどのベンチマークでフルアテンションに匹敵する精度を保ちながら、最大13.5倍の計算加速を達成。XAttentionはLCTMsの効率的な展開を可能にする。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/theturingpost/status/1908966571227398449?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<span class="issue_date">Issue Date: 2025-04-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1869">Slim attention: cut your context memory in half without loss of accuracy  -- K-cache is all you need for MHA, Nils Graef+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Slim attentionは、トランスフォーマーモデルのMHAにおいてコンテキストメモリを2倍に縮小し、推論速度を最大2倍向上させる手法で、精度を損なうことなく実装可能です。特に、Whisperモデルではコンテキストメモリを8倍削減し、トークン生成を5倍速くすることができます。また、稀なケースではT5-11Bモデルでメモリを32倍削減することも可能です。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/theturingpost/status/1908966571227398449?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/RewardHacking.html">#RewardHacking</a>
<span class="issue_date">Issue Date: 2025-04-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1867">CREAM: Consistency Regularized Self-Rewarding Language Models, Zhaoyang Wang+, ICLR'25</a>
<span class="snippet"><span>Summary</span>自己報酬型LLMは、LLM-as-a-Judgeを用いてアラインメント性能を向上させるが、報酬とランク付けの正確性が問題。小規模LLMの実証結果は、自己報酬の改善が反復後に減少する可能性を示唆。これに対処するため、一般化された反復的好みファインチューニングフレームワークを定式化し、正則化を導入。CREAMを提案し、報酬の一貫性を活用して信頼性の高い好みデータから学習。実証結果はCREAMの優位性を示す。</span>
<span class="snippet"><span>Comment</span>・1212

<br>



<br>

を改善した研究OpenReview:https://openreview.net/forum?id=Vf6RDObyEFこの方向性の研究はおもしろい</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<span class="issue_date">Issue Date: 2025-04-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1866">Scalable-Softmax Is Superior for Attention, Ken M. Nakanishi, arXiv'25</a>
<span class="snippet"><span>Summary</span>SSMaxを提案し、Softmaxの代替としてTransformerモデルに統合。これにより、長いコンテキストでの重要情報の取得が向上し、事前学習中の損失減少が速くなる。SSMaxは注意スコアを改善し、長さの一般化を促進する。</span>
<span class="snippet"><span>Comment</span>・1863

<br>



<br>

で採用されている手法で、ブログポスト中で引用されている。Long Contextになった場合にsoftmaxの分布が均一になる（＝重要な情報にattendする能力が削がれる）ことを防ぐための手法を提案している。解説ポスト:https://x.com/nrehiew_/status/1908613993998045534</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/AttentionSinks.html">#AttentionSinks</a>
<span class="issue_date">Issue Date: 2025-04-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1862">When Attention Sink Emerges in Language Models: An Empirical View, Xiangming Gu+, ICLR'25</a>
<span class="snippet"><span>Summary</span>言語モデルにおける「アテンションシンク」は、意味的に重要でないトークンに大きな注意を割り当てる現象であり、さまざまな入力に対して小さなモデルでも普遍的に存在することが示された。アテンションシンクは事前学習中に出現し、最適化やデータ分布、損失関数がその出現に影響を与える。特に、アテンションシンクはキーのバイアスのように機能し、情報を持たない追加のアテンションスコアを保存することがわかった。この現象は、トークンがソフトマックス正規化に依存していることから部分的に生じており、正規化なしのシグモイドアテンションに置き換えることで、アテンションシンクの出現を防ぐことができる。</span>
<span class="snippet"><span>Comment</span>Sink Rateと呼ばれる、全てのheadのFirst Tokenに対するattention scoreのうち（layer l  head h個存在する）、どの程度の割合のスコアが閾値を上回っているかを表す指標を提案・1860

<br>



<br>

の先行研究著者ポスト（openai-gpt-120Bを受けて):

<br>

https://x.com/gu_xiangming/status/1952811057673642227?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/AttentionSinks.html">#AttentionSinks</a>
<span class="issue_date">Issue Date: 2025-04-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1860">Why do LLMs attend to the first token?, Federico Barbero+, arXiv'25</a>
<span class="snippet"><span>Summary</span>LLMsは最初のトークンに強く注意を向ける「アテンションシンク」を示し、そのメカニズムが過剰混合を避ける方法を理論的・実証的に探求。コンテキストの長さやデータのパッキングがシンクの挙動に与える影響を実験で示し、アテンションパターンの理解を深めることを目指す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/omarsar0/status/1908187563422261411?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QAttention Sinkによって、トークンの情報がover-mixingされることが抑制され、Decoder-only LLMの深い層のrepresentationが均一化されることを抑制する（＝promptの摂動にロバストになる）ことが示された模様。

<br>

<img src="https://github.com/user-attachments/assets/8a1223c0-5621-42a5-accc-31fa7f636856" alt="image" loading="lazy">

<br>

Gemma7Bにおいて、prompt中のトークン一語を置換した後に、Attention Sink（<bos>）の有無によって、tokenレベルのrepresentationに対してどのような摂動があるかをlayerごとにまとめた図が下記の模様。Attention Sinkによって、tokenの摂動が他のtoken, layerに対してmixingされるのが抑制されている。

<br>

<img src="https://github.com/user-attachments/assets/b1a4038a-d116-4bd1-b27b-c55eb861bee9" alt="image" loading="lazy">&lt;/span&gt;
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ConceptErasure.html">#ConceptErasure</a>
<a class="button" href="articles/KnowledgeEditing.html">#KnowledgeEditing</a>
<a class="button" href="articles/AISTATS.html">#AISTATS</a>
<span class="issue_date">Issue Date: 2025-04-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1859">Fundamental Limits of Perfect Concept Erasure, Somnath Basu Roy Chowdhury+, AISTATS'25</a>
<span class="snippet"><span>Summary</span>概念消去は、性別や人種などの情報を消去しつつ元の表現を保持するタスクであり、公平性の達成やモデルのパフォーマンスの解釈に役立つ。従来の技術は消去の堅牢性を重視してきたが、有用性とのトレードオフが存在する。本研究では、情報理論的視点から概念消去の限界を定量化し、完璧な消去を達成するためのデータ分布と消去関数の制約を調査。提案する消去関数が理論的限界を達成し、GPT-4を用いたデータセットで既存手法を上回ることを示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/somnathbrc/status/1907463419105570933?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<span class="issue_date">Issue Date: 2025-04-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1858">What, How, Where, and How Well? A Survey on Test-Time Scaling in Large  Language Models, Qiyuan Zhang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>テスト時スケーリング（TTS）が大規模言語モデル（LLMs）の問題解決能力を向上させることが示されているが、体系的な理解が不足している。これを解決するために、TTS研究の4つのコア次元に基づく統一的なフレームワークを提案し、手法や応用シナリオのレビューを行う。TTSの発展の軌跡を抽出し、実践的なガイドラインを提供するとともに、未解決の課題や将来の方向性についての洞察を示す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hesamation/status/1907095419793911893?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qとてつもない量だ…網羅性がありそう。

<br>

What to Scaleがよくあるself

<br>

consistency(Parallel Scaling), STaR(Sequential Scailng), Tree of Thought(Hybrid Scaling), DeepSeek-R1, o1/3(Internal Scaling)といった分類で、How to ScaleがTuningとInferenceに分かれている。TuningはLong CoTをSFTする話や強化学習系の話（GRPOなど）で、InferenceにもSelf consistencyやらやらVerificationやら色々ありそう。良さそう。

<br>

<img src="https://github.com/user-attachments/assets/9d76e438-ff75-454d-b549-7efda9baa300" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<span class="issue_date">Issue Date: 2025-04-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1855">Multi-Token Attention, Olga Golovneva+, arXiv'25</a>
<span class="snippet"><span>Summary</span>マルチトークンアテンション（MTA）を提案し、複数のクエリとキーのベクトルに基づいてアテンションウェイトを条件付けることで、関連するコンテキストをより正確に特定できるようにする。MTAは畳み込み操作を用いて、近くのトークンが互いに影響を与え、豊かな情報を活用する。評価結果から、MTAはTransformerベースラインモデルを上回り、特に長いコンテキストでの情報検索において優れた性能を示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jaseweston/status/1907260086017237207?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q従来のMulti Head Attentionでは、単体のQKのみを利用していたけど、複数のQKの情報を畳み込んで活用できるようにして、Headも畳み込みで重要な情報がより伝搬されるようにして、GroupNormalizationをかけたらPerplexityの観点でDifferential Transformerを上回ったよ、という話な模様。

<br>



<br>

<img src="https://github.com/user-attachments/assets/199e0794-a286-486d-9426-d86cfd208750" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/2997a61b-3367-4f43-b85a-ac8fa160391a" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/5ef8ddb0-538b-46e2-94b8-2ef495c938ec" alt="image" loading="lazy">

<br>



<br>

・1856

<br>

・1466</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/QuestionGeneration.html">#QuestionGeneration</a>
<span class="issue_date">Issue Date: 2025-04-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1853">Interactive Agents to Overcome Ambiguity in Software Engineering, Sanidhya Vijayvargiya+, arXiv'25</a>
<span class="snippet"><span>Summary</span>AIエージェントはあいまいな指示に基づくタスク自動化に利用されるが、誤った仮定や質問不足がリスクを生む。本研究では、LLMエージェントのあいまいな指示処理能力を評価し、インタラクティビティを活用したパフォーマンス向上、あいまいさの検出、目標を絞った質問の実施を検討。結果、モデルは明確な指示と不十分な指示を区別するのが難しいが、インタラクションを通じて重要な情報を取得し、パフォーマンスが向上することが示された。これにより、現在のモデルの限界と改善のための評価手法の重要性が明らかになった。</span>
<span class="snippet"><span>Comment</span>曖昧なユーザメッセージに対する、エージェントが"質問をする能力を測る"ベンチマーク

<br>



<br>

<img width="422" alt="Image" src="https://github.com/user-attachments/assets/3d201ebf-9ca1-4333-9d27-e33a9028066f"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/FactualKnowledge.html">#FactualKnowledge</a>
<span class="issue_date">Issue Date: 2025-04-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1846">Inside-Out: Hidden Factual Knowledge in LLMs, Zorik Gekhman+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究は、LLMが出力以上の事実的知識をエンコードしているかを評価するフレームワークを提案。知識を定義し、正しい回答が高くランク付けされる割合を定量化。外部知識と内部知識を区別し、内部知識が外部知識を超えると隠れた知識が生じることを示す。クローズドブックQA設定でのケーススタディでは、LLMが内部で多くの知識をエンコードしていること、知識が隠れている場合があること、サンプリングによる制約があることを明らかにした。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/zorikgekhman/status/1906693729886363861?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/SpeechProcessing.html">#SpeechProcessing</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Video.html">#Video</a>
<span class="issue_date">Issue Date: 2025-03-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1843">Qwen2.5-Omni Technical Report, Jin Xu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>マルチモーダルモデル「Qwen2.5-Omni」は、テキスト、画像、音声、動画を認識し、ストリーミング方式で自然な音声応答を生成する。音声と視覚エンコーダはブロック処理を用い、TMRoPEによる新しい位置埋め込みで音声と動画の同期を実現。Thinker-Talkerアーキテクチャにより、テキスト生成と音声出力を干渉なく行う。Qwen2.5-Omniは、エンドツーエンドで訓練され、音声指示に対する性能がテキスト入力と同等で、ストリーミングTalkerは既存手法を上回る自然さを持つ。</span>
<span class="snippet"><span>Comment</span>Qwen TeamによるマルチモーダルLLM。テキスト、画像、動画音声をinputとして受け取り、テキスト、音声をoutputする。

<br>

<img src="https://github.com/user-attachments/assets/03e54fd7-2011-4069-aa1b-38d1610169ec" alt="image" loading="lazy">

<br>



<br>

weight:https://huggingface.co/collections/Qwen/qwen25-omni-67de1e5f0f9464dc6314b36e元ポスト:https://www.linkedin.com/posts/niels-rogge-a3b7a3127_alibabas-qwen-team-has-done-it-again-this-activity-7311036679627132929-HUqy?utm_source=share&utm_medium=member_ios&rcm=ACoAACzQvjwB2FeLVE3yukDiUYtr5J4k-6nlNG4</span>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/GenerativeAI.html">#GenerativeAI</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-03-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1842">Measuring AI Ability to Complete Long Tasks, Thomas Kwa+, arXiv'25</a>
<span class="snippet"><span>Summary</span>新しい指標「50%-タスク完了時間ホライズン」を提案し、AIモデルの能力を人間の観点から定量化。Claude 3.7 Sonnetは約50分の時間ホライズンを持ち、AIの能力は2019年以降約7か月ごとに倍増。信頼性や論理的推論の向上が要因とされ、5年以内にAIが多くのソフトウェアタスクを自動化できる可能性を示唆。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1902854727089656016?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q確かに線形に見える。てかGPT-2と比べるとAIさん進化しすぎである…。

<br>

<img src="https://github.com/user-attachments/assets/266a36aa-a169-492b-b8af-60c0cb152111" alt="image" loading="lazy">利用したデータセットは

<br>

・HCAST: 46のタスクファミリーに基づく97種類のタスクが定義されており、たとえばサイバーセキュリティ、機械学習、ソフトウェアエンジニアリング、一般的な推論タスク（wikipediaから事実情報を探すタスクなど）などがある

<br>

  ・数分で終わるタスク: 上述のwikipedia

<br>

  ・数時間で終わるタスク: Pytorchのちょっとしたバグ修正など

<br>

  ・数文でタスクが記述され、コード、データ、ドキュメント、あるいはwebから入手可能な情報を参照可能

<br>

　・タスクの難易度としては当該ドメインに数年間携わった専門家が解ける問題

<br>

・RE-Bench Suite

<br>

  ・7つのopen endedな専門家が8時間程度を要するMLに関するタスク

<br>

　・e.g., GPT-2をQA用にFinetuningする, Finetuningスクリプトが与えられた時に挙動を変化させずにランタイムを可能な限り短縮する、など

<br>

　・[RE-Bench Technical Report](https://metr.org/AI_R_D_Evaluation_Report.pdf)のTable2等を参照のこと

<br>

・SWAA Suite: 66種類の1つのアクションによって1分以内で終わるソフトウェアエンジニアリングで典型的なタスク

<br>

  ・1分以内で終わるタスクが上記データになかったので著者らが作成

<br>



<br>

であり、画像系やマルチモーダルなタスクは含まれていない。

<br>

<img src="https://github.com/user-attachments/assets/0b3892c9-3c83-4f78-a490-c28fa7470e0e" alt="image" loading="lazy">

<br>



<br>

タスクと人間がタスクに要する時間の対応に関するサンプルは下記

<br>

<img src="https://github.com/user-attachments/assets/5ed472da-e8c9-41be-8fd1-ef6f21713c14" alt="image" loading="lazy">タスク-エージェントペアごとに8回実行した場合の平均の成功率。確かにこのグラフからはN年後には人間で言うとこのくらいの能力の人がこのくらい時間を要するタスクが、このくらいできるようになってます、といったざっくり感覚値はなかなか想像できない。

<br>

<img src="https://github.com/user-attachments/assets/e2bed06e-9234-4607-826a-588106010bcf" alt="image" loading="lazy">成功率とタスクに人間が要する時間に関するグラフ。ロジスティック関数でfittingしており、赤い破線が50% horizon。Claude 3.5 Sonnet （old）からClaude 3.7 Sonnetで50% horizonは18分から59分まで増えている。実際に数字で見るとイメージが湧きやすくおもしろい。

<br>

<img src="https://github.com/user-attachments/assets/efe01e35-6ee6-45a5-8a4c-eccf95284b35" alt="image" loading="lazy">こちらで最新モデルも随時更新される:

<br>

https://metr.org/blog/2025-03-19-measuring-ai-ability-to-complete-long-tasks/</span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/CollaborativeFiltering.html">#CollaborativeFiltering</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-03-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1839">RALLRec+: Retrieval Augmented Large Language Model Recommendation with  Reasoning, Sichun Luo+, arXiv'25</a>
<span class="snippet"><span>Summary</span>RALLRec+は、LLMsを用いてレコメンダーシステムのretrievalとgenerationを強化する手法。retrieval段階では、アイテム説明を生成し、テキスト信号と協調信号を結合。生成段階では、推論LLMsを評価し、知識注入プロンプティングで汎用LLMsと統合。実験により、提案手法の有効性が確認された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_reachsumit/status/1905107217663336832?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QReasoning LLMをRecSysに応用する初めての研究（らしいことがRelated Workに書かれている）arxivのadminより以下のコメントが追記されている

<br>

&gt; 	arXiv admin note: substantial text overlap with arXiv:2502.06101

<br>



<br>

コメント中の研究は下記である

<br>

・1840</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<span class="issue_date">Issue Date: 2025-03-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1838">Scaling Evaluation-time Compute with Reasoning Models as Process  Evaluators, Seungone Kim+, arXiv'25</a>
<span class="snippet"><span>Summary</span>LMの出力品質評価が難しくなっている中、計算を増やすことで評価能力が向上するかを検討。推論モデルを用いて応答全体と各ステップを評価し、推論トークンの生成が評価者のパフォーマンスを向上させることを確認。再ランク付けにより、評価時の計算増加がLMの問題解決能力を向上させることを示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jinulee_v/status/1905025016401428883?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLLM-as-a-JudgeもlongCoT+self-consistencyで性能が改善するらしい。

<br>

<img src="https://github.com/user-attachments/assets/937b6241-4877-46c7-a488-5ee6bf8203db" alt="image" loading="lazy"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-03-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1837">Overtrained Language Models Are Harder to Fine-Tune, Jacob Mitchell Springer+, ICLR'25</a>
<span class="snippet"><span>Summary</span>大規模言語モデルの事前学習において、トークン予算の増加がファインチューニングを難しくし、パフォーマンス低下を引き起こす「壊滅的な過学習」を提唱。3Tトークンで事前学習されたOLMo-1Bモデルは、2.3Tトークンのモデルに比べて2%以上の性能低下を示す。実験と理論分析により、事前学習パラメータの感度の増加が原因であることを示し、事前学習設計の再評価を促す。</span>
<span class="snippet"><span>Comment</span>著者によるポスト:https://x.com/jacspringer/status/1904960783341023521?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q事前学習のトークン数を増やすとモデルのsensitivityが増し、post-trainingでのパフォーマンスの劣化が起こることを報告している。事前学習で学習するトークン数を増やせば、必ずしもpost-training後のモデルの性能がよくなるわけではないらしい。

<br>

<img src="https://github.com/user-attachments/assets/ba60ae24-f3e5-4956-b29f-37b4fe01a9d1" alt="image" loading="lazy">ICLR'25のOutstanding Paperに選ばれた模様:

<br>

https://x.com/jacspringer/status/1917174452531724718?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

きちんと読んだ方が良さげ。</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2025-03-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1833">ExpertGenQA: Open-ended QA generation in Specialized Domains, Haz Sameen Shahgir+, arXiv'25</a>
<span class="snippet"><span>Summary</span>ExpertGenQAは、少数ショット学習とトピック・スタイル分類を組み合わせたQAペア生成プロトコルで、米国連邦鉄道局の文書を用いて94.4%のトピックカバレッジを維持しつつ、ベースラインの2倍の効率を達成。評価では、LLMベースのモデルが内容よりも文体に偏ることが判明し、ExpertGenQAは専門家の質問の認知的複雑性をより良く保持。生成したクエリは、リトリーバルモデルの精度を13.02%向上させ、技術分野での有効性を示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/at_sushi_/status/1904325501331890561?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/COLM.html">#COLM</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-03-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1832">Critique Fine-Tuning: Learning to Critique is More Effective than   Learning to Imitate, Yubo Wang+, COLM'25</a>
<span class="snippet"><span>Summary</span>批評ファインチューニング（CFT）は、言語モデルがノイズのある応答を批評することを学ぶ新しい戦略で、従来の監視付きファインチューニング（SFT）に挑戦します。CFTは人間の学習プロセスにインスパイアを受け、深い分析を促進します。WebInstructから構築した50Kサンプルのデータセットを用いて、CFTは複数のベースモデルでSFTに対して4-10%の性能向上を示しました。特に、Qwen2.5-Math-CFTは少ないトレーニングで強力な競合と同等の性能を発揮し、CFTの堅牢性も確認されました。CFTは言語モデルの推論を進展させる効果的な手法であると主張します。</span>
<span class="snippet"><span>Comment</span>元ポスト: https://x.com/WenhuChen/status/1885060597500567562Critique Fine-Tuning (CFT) を提案。CFTでは、query x, noisy response y [^1] が与えられたときに、それに対する批評 cを学習する。cはgivenではないので、GPT4oのような強力なモデルによって合成する。

<br>



<br>

![Image](https://github.com/user-attachments/assets/f25babdd-63d6-4d3d-a9b0-3217db2bd07f)

<br>



<br>

目的関数は以下。[x; y] がgivenな時にcを生成する確率を最大化する。シンプル。

<br>

![Image](https://github.com/user-attachments/assets/ccdb8e42-e8b2-4ae1-99a6-a0b7c1d4bf2a)

<br>



<br>

RLを用いた手法との比較。1/10程度のデータ量、1/100程度のGPU時間で同等の性能を達成できる。

<br>

![Image](https://github.com/user-attachments/assets/848376ff-9965-485b-b8a0-7960d1d0e7b9)

<br>



<br>

[^1]: 本論文で利用しているWebInstructからサンプリングしたデータでは、たとえば約50%程度のyが正解,  残りは不正解（程度のnoisyデータを利用している）</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-03-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1826">Thinking Machines: A Survey of LLM based Reasoning Strategies, Dibyanayan Bandyopadhyay+, arXiv'25</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）は優れた言語能力を持つが、推論能力との間にギャップがある。推論はAIの信頼性を高め、医療や法律などの分野での適用に不可欠である。最近の強力な推論モデルの登場により、LLMsにおける推論の研究が重要視されている。本論文では、既存の推論技術の概要と比較を行い、推論を備えた言語モデルの体系的な調査と現在の課題を提示する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dair_ai/status/1903843684568666450?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QRL, Test Time Compute, Self-trainingの3種類にカテゴライズされている。また、各カテゴリごとにより細分化されたツリーが論文中にある。

<br>

<img src="https://github.com/user-attachments/assets/d323db81-973a-4752-afc9-4471f5e64feb" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<span class="issue_date">Issue Date: 2025-03-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1825">Compute Optimal Scaling of Skills: Knowledge vs Reasoning, Nicholas Roberts+, arXiv'25</a>
<span class="snippet"><span>Summary</span>スケーリング法則はLLM開発において重要であり、特に計算最適化によるトレードオフが注目されている。本研究では、スケーリング法則が知識や推論に基づくスキルに依存することを示し、異なるデータミックスがスケーリング挙動に与える影響を調査した。結果、知識とコード生成のスキルは根本的に異なるスケーリング挙動を示し、誤指定された検証セットが計算最適なパラメータ数に約50%の影響を与える可能性があることが明らかになった。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dair_ai/status/1903843682509312218?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q知識を問うQAのようなタスクはモデルのパラメータ量が必要であり、コーディングのようなReasoningに基づくタスクはデータ量が必要であり、異なる要素に依存してスケールすることを示している研究のようである。

<br>



<br>

<img src="https://github.com/user-attachments/assets/5d2bb3c6-437a-4184-9848-3232745d0de1" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-03-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1819">Stop Overthinking: A Survey on Efficient Reasoning for Large Language  Models, Yang Sui+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本論文では、LLMsにおける効率的な推論の進展を体系的に調査し、以下の主要な方向に分類します：(1) モデルベースの効率的推論、(2) 推論出力ベースの効率的推論、(3) 入力プロンプトベースの効率的推論。特に、冗長な出力による計算オーバーヘッドを軽減する方法を探求し、小規模言語モデルの推論能力や評価方法についても議論します。</span>
<span class="snippet"><span>Comment</span>Reasoning Modelにおいて、Over Thinking現象（不要なreasoning stepを生成してしまう）を改善するための手法に関するSurvey。

<br>

<img src="https://github.com/user-attachments/assets/a411f2cf-2ba1-4e58-8dc7-ac1ae2ff0de6" alt="image" loading="lazy">

<br>



<br>

下記Figure2を見るとよくまとまっていて、キャプションを読むとだいたい分かる。なるほど。

<br>

Length Rewardについては、

<br>

・1746

<br>



<br>

で考察されている通り、Reward Hackingが起きるので設計の仕方に気をつける必要がある。

<br>



<br>

<img src="https://github.com/user-attachments/assets/fd6880bd-95e1-4ca6-9593-8ffc9390962a" alt="image" loading="lazy">元ポスト:https://x.com/_reachsumit/status/1902977896685396275?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q各カテゴリにおけるliteratureも見やすくまとめられている。必要に応じて参照したい。

<br>

<img src="https://github.com/user-attachments/assets/b6be0d79-35c5-45a8-878b-2b6be67c2f76" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<span class="issue_date">Issue Date: 2025-03-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1817">Lost-in-the-Middle in Long-Text Generation: Synthetic Dataset,  Evaluation Framework, and Mitigation, Junhao Zhang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>長い入力と出力の生成に特化したLongInOutBenchを導入し、既存手法の「中間での喪失」問題に対処。Retrieval-Augmented Long-Text Writer（RAL-Writer）を開発し、重要なコンテンツを再表現することで性能を向上。提案手法の有効性をベースラインと比較して示す。</span>
<span class="snippet"><span>Comment</span>Lost in the Middleに関する研究。関連研究:

<br>

・793</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<span class="issue_date">Issue Date: 2025-03-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1813">The First Few Tokens Are All You Need: An Efficient and Effective  Unsupervised Prefix Fine-Tuning Method for Reasoning Models, Ke Ji+, arXiv'25</a>
<span class="snippet"><span>Summary</span>非教師ありプレフィックスファインチューニング（UPFT）を提案し、LLMの推論効率を向上。初期のプレフィックス部分文字列に基づいて訓練し、ラベル付きデータやサンプリングを不要に。UPFTは、教師あり手法と同等の性能を維持しつつ、訓練時間を75%、サンプリングコストを99%削減。最小限の非教師ありファインチューニングで大幅な推論向上を実現し、リソース効率の良い代替手段を提供。</span>
<span class="snippet"><span>Comment</span>斜め読みだが、reasoning traceの冒頭部分は重要な役割を果たしており、サンプリングした多くのresponseのreasoning traceにおいて共通しているものは重要という直感から（Prefix Self-Consistency）、reasoning traceの冒頭部分を適切に生成できるようにモデルをFinetuningする。従来のRejection Samplingを用いた手法では、複数のresponseを生成させて、最終的なanswerが正解のものをサンプリングするため正解ラベルが必要となるが、提案手法ではreasoning traceの冒頭部分の共通するsubsequenceをmajority voteするだけなのでラベルが不要である。

<br>

<img src="https://github.com/user-attachments/assets/ff3938da-dcd0-4b6c-a764-26d2e8caa63a" alt="image" loading="lazy">

<br>



<br>

reasoning prefixを学習する際は下記のようなテンプレートを用いる。このときに、prefixのspanのみを利用して学習することで大幅に学習時間を削減できる。

<br>

<img src="https://github.com/user-attachments/assets/63aabe47-9c40-41cb-8d5a-5039900f6edc" alt="image" loading="lazy">

<br>



<br>

また、そのような学習を行うとcatastrophic forgettingのリスクが非常に高いが、これを防ぐために、マルチタスクラーニングを実施する。具体的には学習データのp%については全体のreasoning traceを生成して学習に利用する。このときに、最終的な回答の正誤を気にせずtraceを生成して学習に利用することで、ラベルフリーな特性を維持できる（つまり、こちらのデータは良いreasoning traceを学習することを目的としているわけではなく、あくまでcatastrophic forgettingを防ぐためにベースモデルのようなtraceもきちんと生成できれば良い、という感覚だと思われる）。

<br>

<img src="https://github.com/user-attachments/assets/6e83c686-5bcf-4db8-9b8a-63c39570a4dc" alt="image" loading="lazy">

<br>



<br>

AppendixにQwenを用いてtemperature 0.7で16個のresponseをサンプリングし、traceの冒頭部分が共通している様子が示されている。下記論文でlong-CoTを学習させる際のlong-CoTデータとして、reasoningモデルから生成したtraceと非reasoning modelから生成したtraceによるlong-CoTデータを比較したところ前者の方が一貫して学習性能が良かったとあるが、この研究でもreasoning traceをつよつよモデルで生成したら性能上がるんだろうか。

<br>



<br>

・1746</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2025-03-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1811">Sample, Scrutinize and Scale: Effective Inference-Time Search by Scaling  Verification, Eric Zhao+, arXiv'25</a>
<span class="snippet"><span>Summary</span>サンプリングベースの探索は、複数の候補応答を生成し最良のものを選ぶ手法であり、自己検証によって正確性を確認します。本研究では、この探索のスケーリング傾向を分析し、シンプルな実装がGemini v1.5 Proの推論能力を向上させることを示しました。自己検証の精度向上は、より大きな応答プールからのサンプリングによるもので、応答間の比較が有益な信号を提供することや、異なる出力スタイルが文脈に応じて役立つことを明らかにしました。また、最前線のモデルは初期の検証能力が弱く、進捗を測るためのベンチマークを提案しました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/ericzhao28/status/1901704339229732874?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qざっくりしか読めていないが、複数の解答をサンプリングして、self-verificationをさせて最も良かったものを選択するアプローチ。最もverificationスコアが高い解答を最終的に選択したいが、tieの場合もあるのでその場合は追加のpromptingでレスポンスを比較しより良いレスポンスを選択する。これらは並列して実行が可能で、探索とself-verificationを200個並列するとGemini 1.5 Proでo1-previewよりも高い性能を獲得できる模様。Self-consistencyと比較しても、gainが大きい。

<br>

<img src="https://github.com/user-attachments/assets/937c334b-659a-4196-8fa4-31cf908a32d4" alt="image" loading="lazy"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/RLHF.html">#RLHF</a>
<span class="issue_date">Issue Date: 2025-03-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1806">All Roads Lead to Likelihood: The Value of Reinforcement Learning in  Fine-Tuning, Gokul Swamy+, arXiv'25</a>
<span class="snippet"><span>Summary</span>基盤モデルのファインチューニングにおいて、報酬モデルを用いた二段階のトレーニング手順が効果的である理由を理論的および実証的に検討。特に、好みデータから単純な報酬モデルを学び、強化学習手続きがそのモデルに最適なポリシーをフィルタリングする能力が、オンラインファインチューニングの優れたパフォーマンスに寄与することが示された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1901392286694678568?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QAlignmentのためのPreferenceデータがある時に、そのデータから直接最尤推定してモデルのパラメータを学習するのではなく、報酬モデルを学習して、その報酬モデルを用いてモデルを強化学習することで、なぜ前者よりも（同じデータ由来であるにもかかわらず）優れたパフォーマンスを示すのか、という疑問に対してアプローチしている。全く中身を読めていないが、生成することと（方策モデル）と検証すること（報酬モデル）の間にギャップがある場合（すなわち、生成と検証で求められる能力が異なる場合）、MLEでは可能なすべてのポリシーを探索することと似たようなことをすることになるが、RLでは事前に報酬モデルを学習しその報酬モデルに対して最適なポリシーを探索するだけなので探索する空間が制限される（＝生成と検証のギャップが埋まる）ので、良い解に収束しやすくなる、というイメージなんだろうか。

<br>

<img src="https://github.com/user-attachments/assets/121e97a6-120e-4830-9bcf-329129a687eb" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<span class="issue_date">Issue Date: 2025-03-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1799">NeoBERT: A Next-Generation BERT, Lola Le Breton+, arXiv'25</a>
<span class="snippet"><span>Summary</span>NeoBERTは、最新のアーキテクチャとデータを統合した次世代エンコーダで、双方向モデルの能力を再定義します。4,096トークンのコンテキスト長を活用し、250Mパラメータでありながら、MTEBベンチマークで最先端の結果を達成し、BERTやRoBERTaを上回ります。すべてのコードやデータを公開し、研究と実世界での採用を促進します。</span>
<span class="snippet"><span>Comment</span>関連: 

<br>

・1606BERT, ModernBERTとの違い

<br>



<br>

![Image](https://github.com/user-attachments/assets/58dbdcf6-e7dc-43c2-94ed-d8bb73cd2617)

<br>



<br>

性能

<br>



<br>

![Image](https://github.com/user-attachments/assets/72730c9c-38d0-4773-8ddb-f0349b8776d2)

<br>



<br>

所感

<br>

medium size未満のモデルの中ではSoTAではあるが、ModernBERTが利用できるのであれば、ベンチマークを見る限りは実用的にはModernBERTで良いのでは、と感じた。学習とinferenceの速度差はどの程度あるのだろうか？</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-03-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1798">A Survey on Post-training of Large Language Models, Guiyao Tie+, arXiv'25</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）は自然言語処理に革命をもたらしたが、専門的な文脈での制約が明らかである。これに対処するため、高度なポストトレーニング言語モデル（PoLMs）が必要であり、本論文ではその包括的な調査を行う。ファインチューニング、アライメント、推論、効率、統合と適応の5つのコアパラダイムにわたる進化を追跡し、PoLMがバイアス軽減や推論能力向上に寄与する方法を示す。研究はPoLMの進化に関する初の調査であり、将来の研究のための枠組みを提供し、LLMの精度と倫理的堅牢性を向上させることを目指す。</span>
<span class="snippet"><span>Comment</span>Post Trainingの時間発展の図解が非常にわかりやすい（が、厳密性には欠けているように見える。当該モデルの新規性における主要な技術はこれです、という図としてみるには良いのかもしれない）。

<br>

個々の技術が扱うスコープとレイヤー、データの性質が揃っていない気がするし、それぞれのLLMがy軸の単一の技術だけに依存しているわけでもない。が、厳密に図を書いてと言われた時にどう書けば良いかと問われると難しい感はある。

<br>

<img src="https://github.com/user-attachments/assets/6cdf060f-1cc9-44cd-b81a-50f4d3c442de" alt="image" loading="lazy">元ポスト:https://x.com/omarsar0/status/1900595286898340230?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/CVPR.html">#CVPR</a>
<a class="button" href="articles/Normalization.html">#Normalization</a>
<span class="issue_date">Issue Date: 2025-03-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1795">Transformers without Normalization, Jiachen Zhu+, CVPR'25</a>
<span class="snippet"><span>Summary</span>本研究では、正規化層なしのトランスフォーマーがDynamic Tanh（DyT）を用いることで、同等またはそれ以上のパフォーマンスを達成できることを示します。DyTは、レイヤー正規化の代替として機能し、ハイパーパラメータの調整なしで効果を発揮します。多様な設定での実験により、正規化層の必要性に対する新たな洞察を提供します。</span>
<span class="snippet"><span>Comment</span>なん…だと…。LayerNormalizationを下記アルゴリズムのようなtanhを用いた超絶シンプルなレイヤー（parameterized thnh [Lecun氏ポスト](https://x.com/ylecun/status/1900610590315249833?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q)）に置換するだけっぽい？

<br>

<img src="https://github.com/user-attachments/assets/474d3ee4-4c08-4b00-9a41-126ca5d5207e" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/5aea9f93-85d9-4e0b-b9db-bb407d596493" alt="image" loading="lazy">

<br>



<br>

同等以上の性能を維持しながらモデル全体のinference, trainingの時間を8%程度削減。

<br>

<img src="https://github.com/user-attachments/assets/98f8caa3-3ef2-4594-a45a-ae0aa2cf2ef6" alt="image" loading="lazy"></span>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<span class="issue_date">Issue Date: 2025-03-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1789">Gemini Embedding: Generalizable Embeddings from Gemini, Jinhyuk Lee+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Gemini Embeddingは、Googleの大規模言語モデルGeminiを活用した最先端の埋め込みモデルで、多言語およびコード理解能力を活かして一般化可能な埋め込みを生成します。事前計算された表現は、分類や検索などの下流タスクに適用可能で、250以上の言語にわたる100以上のタスクを含むMMTEBで評価した結果、従来のモデルを大幅に上回る性能を示しました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_reachsumit/status/1899667900728037621?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q世のdecoder-onlyモデルベースのembeddingモデルがどのように作られているか具体的によくわかっていないので読みたいGeminiのパラメータでbi-directionalなself-attentionを持つtransformer (たとえばBERT)で初期化し、全てのtokenをmean poling (HF BERT ModelのPoolerLayerのようなもの)することでトークンの情報を単一のembeddingに混ぜる。

<br>

学習は2段階のfinetuning (pre-finetuning, finetuning)によって、モデルをContrastive Learningする（NCE loss）。

<br>

pre-finetuningはnoisyだが大規模なデータ（web上のタイトルとparagraphのペアなど）、そのあとのfinetuningはQAなどの高品質なデータを利用。</span>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<span class="issue_date">Issue Date: 2025-03-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1787">START: Self-taught Reasoner with Tools, Chengpeng Li+, arXiv'25</a>
<span class="snippet"><span>Summary</span>新しいツール統合型の長Chain-of-thought推論モデルSTARTを提案。STARTは外部ツールを活用し、自己学習フレームワークを通じて推論能力を向上。Hint-inferとHint Rejection Sampling Fine-Tuningを用いてLRMをファインチューニングし、科学QAや数学、コードベンチマークで高精度を達成。ベースモデルを大幅に上回り、最先端モデルに匹敵する性能を示す。</span>
<span class="snippet"><span>Comment</span>論文の本題とは関係ないが、QwQ-32Bよりも、DeepSeek-R1-Distilled-Qwen32Bの方が性能が良いのは興味深い。やはり大きいパラメータから蒸留したモデルの方が、小さいパラメータに追加学習したモデルよりも性能が高い傾向にあるのだろうか（どういうデータで蒸留したかにもよるけど）。

<br>

<img src="https://github.com/user-attachments/assets/53e77e67-2c46-4163-859b-ccb0a7cd631d" alt="image" loading="lazy">OpenReview:https://openreview.net/forum?id=m80LCW765n</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-03-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1782">LLM Post-Training: A Deep Dive into Reasoning Large Language Models, Komal Kumar+, arXiv'25</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）のポストトレーニング手法に焦点を当て、知識の洗練や推論の改善、事実の正確性向上を目指す。ファインチューニングや強化学習などの戦略がLLMsのパフォーマンスを最適化し、実世界のタスクへの適応性を向上させる。主要な課題として壊滅的な忘却や報酬ハッキングを分析し、今後の研究方向性を示す公開リポジトリも提供。</span>
<span class="snippet"><span>Comment</span>非常にわかりやすい。

<br>

<img src="https://github.com/user-attachments/assets/855326f0-bc18-4ce1-9870-7690393af21e" alt="image" loading="lazy">元ポスト:https://x.com/gm8xx8/status/1896399195596263710?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<span class="issue_date">Issue Date: 2025-03-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1776">Large Language Diffusion Models, Shen Nie+, arXiv'25</a>
<span class="snippet"><span>Summary</span>LLaDAは、自己回帰モデル（ARMs）に代わる拡散モデルであり、ゼロから訓練され、データマスキングを通じて分布をモデル化。広範なベンチマークで強力なスケーラビリティを示し、自己構築したARMベースラインを上回る。特に、LLaDA 8Bは文脈内学習や指示追従能力に優れ、逆詩の完成タスクでGPT-4oを超える性能を発揮。拡散モデルがARMsの実行可能な代替手段であることを示す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dair_ai/status/1893698288328602022?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q参考:https://x.com/karpathy/status/1894923254864978091</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-03-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1775">Native Sparse Attention: Hardware-Aligned and Natively Trainable Sparse   Attention, Jingyang Yuan+, ACL'25</a>
<span class="snippet"><span>Summary</span>長文コンテキストモデリングのために、計算効率を改善するスパースアテンションメカニズム「NSA」を提案。NSAは動的な階層スパース戦略を用い、トークン圧縮と選択を組み合わせてグローバルなコンテキスト認識とローカルな精度を両立。実装最適化によりスピードアップを実現し、エンドツーエンドのトレーニングを可能にすることで計算コストを削減。NSAはフルアテンションモデルと同等以上の性能を維持しつつ、長シーケンスに対して大幅なスピードアップを達成。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dair_ai/status/1893698286545969311?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QACL'25のBest Paperの一つ:

<br>

https://x.com/gm8xx8/status/1950644063952052643?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-02-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1774">From System 1 to System 2: A Survey of Reasoning Large Language Models, Zhong-Zhi Li+, arXiv'25</a>
<span class="snippet"><span>Summary</span>人間レベルの知能を達成するためには、迅速なシステム1から意図的なシステム2への推論の洗練が必要。基盤となる大規模言語モデル（LLMs）は迅速な意思決定に優れるが、複雑な推論には深さが欠ける。最近の推論LLMはシステム2の意図的な推論を模倣し、人間のような認知能力を示している。本調査では、LLMの進展とシステム2技術の初期開発を概観し、推論LLMの構築方法や特徴、進化を分析。推論ベンチマークの概要を提供し、代表的な推論LLMのパフォーマンスを比較。最後に、推論LLMの進展に向けた方向性を探り、最新の開発を追跡するためのGitHubリポジトリを維持することを目指す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_reachsumit/status/1894282083956396544?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<span class="issue_date">Issue Date: 2025-02-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1772">SuperGPQA: Scaling LLM Evaluation across 285 Graduate Disciplines, M-A-P Team+, arXiv'25</a>
<span class="snippet"><span>Summary</span>SuperGPQAを提案し、285の専門分野におけるLLMsの知識と推論能力を評価する新しいベンチマークを構築。Human-LLM協調フィルタリングを用いて、トリビアルな質問を排除。実験結果は、最先端のLLMsに改善の余地があることを示し、人工一般知能とのギャップを強調。大規模なアノテーションプロセスから得た洞察は、今後の研究に対する方法論的ガイダンスを提供。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/arankomatsuzaki/status/1892779892674351532?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/NAACL.html">#NAACL</a>
<span class="issue_date">Issue Date: 2025-02-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1770">OctoTools: An Agentic Framework with Extensible Tools for Complex   Reasoning, Pan Lu+, NAACL'25</a>
<span class="snippet"><span>Summary</span>複雑な推論タスクに対応するためのオープンソースエージェントフレームワーク「OctoTools」を提案。トレーニング不要で拡張可能なこのフレームワークは、標準化されたツールカードやプランナー、エグゼキューターを備え、16の多様なタスクでGPT-4oに対して平均9.3%の精度向上を達成。さらに、他の手法を最大10.6%上回る性能を示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/lupantech/status/1892260474320015861?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QNAACL'25でベストペーパーに選出:

<br>

https://x.com/lupantech/status/1919495362102100365?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Distillation.html">#Distillation</a>
<span class="issue_date">Issue Date: 2025-02-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1768">NaturalReasoning: Reasoning in the Wild with 2.8M Challenging Questions, Weizhe Yuan+, arXiv'25</a>
<span class="snippet"><span>Summary</span>多様で高品質な推論質問を生成するためのスケーラブルなアプローチを提案し、280万の質問からなるNaturalReasoningデータセットを構築。知識蒸留実験により、強力な教師モデルが推論能力を引き出せることを実証し、教師なし自己学習にも効果的であることを示す。</span>
<span class="snippet"><span>Comment</span>元ポスト: https://x.com/jaseweston/status/1892041992127021300?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<span class="issue_date">Issue Date: 2025-02-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1767">Scaling Test-Time Compute Without Verification or RL is Suboptimal, Amrith Setlur+, arXiv'25</a>
<span class="snippet"><span>Summary</span>RLや探索に基づく検証者ベース（VB）手法が、探索の痕跡を蒸留する検証者フリー（VF）アプローチよりも優れていることを示す。テスト時の計算とトレーニングデータをスケールアップすると、VF手法の最適性が悪化し、VB手法がより良くスケールすることが確認された。3/8/32BサイズのLLMを用いた実験で、検証が計算能力の向上に重要であることを実証。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iscienceluvr/status/1891839822257586310?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q・1749</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2025-02-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1763">LLM Pretraining with Continuous Concepts, Jihoon Tack+, arXiv'25</a>
<span class="snippet"><span>Summary</span>次トークン予測に代わる新しい事前学習フレームワークCoCoMixを提案。これは、スパースオートエンコーダから学習した連続的な概念をトークンの隠れ表現と交互に混ぜることで、モデルの性能を向上させる。実験により、CoCoMixは従来の手法を上回り、解釈可能性と操作性も向上させることが示された。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<span class="issue_date">Issue Date: 2025-02-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1760">Can 1B LLM Surpass 405B LLM? Rethinking Compute-Optimal Test-Time  Scaling, Runze Liu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Test-Time Scaling (TTS)は、LLMsの性能向上に寄与する手法であり、ポリシーモデルやPRM、問題の難易度がTTSに与える影響を分析。実験により、最適なTTS戦略はこれらの要素に依存し、小型モデルが大型モデルを上回る可能性を示した。具体的には、1BのLLMが405BのLLMを超える結果を得た。これにより、TTSがLLMsの推論能力を向上させる有望なアプローチであることが示された。</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2025-02-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1758">DeepRAG: Thinking to Retrieval Step by Step for Large Language Models, Xinyan Guan+, arXiv'25</a>
<span class="snippet"><span>Summary</span>DeepRAGフレームワークを提案し、検索強化推論をマルコフ決定過程としてモデル化。クエリを反復的に分解し、外部知識の取得とパラメトリック推論の依存を動的に判断。実験により、検索効率と回答の正確性を21.99%向上させることを実証。</span>
<span class="snippet"><span>Comment</span>日本語解説。ありがとうございます！

<br>



<br>

RAGでも「深い検索」を実現する手法「DeepRAG」, Atsushi Kadowaki, 

<br>

ナレッジセンス ・AI知見共有ブログ:https://zenn.dev/knowledgesense/articles/034b613c9fd6d3</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/CodeGeneration.html">#CodeGeneration</a>
<a class="button" href="articles/SyntheticDataGeneration.html">#SyntheticDataGeneration</a>
<span class="issue_date">Issue Date: 2025-02-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1756">ACECODER: Acing Coder RL via Automated Test-Case Synthesis, Huaye Zeng+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、コードモデルのトレーニングにおける強化学習（RL）の可能性を探求し、自動化された大規模テストケース合成を活用して信頼できる報酬データを生成する手法を提案します。具体的には、既存のコードデータから質問とテストケースのペアを生成し、これを用いて報酬モデルをトレーニングします。このアプローチにより、Llama-3.1-8B-Insで平均10ポイント、Qwen2.5-Coder-7B-Insで5ポイントの性能向上が見られ、7Bモデルが236B DeepSeek-V2.5と同等の性能を達成しました。また、強化学習を通じてHumanEvalやMBPPなどのデータセットで一貫した改善を示し、特にQwen2.5-Coder-baseからのRLトレーニングがHumanEval-plusで25%以上、MBPP-plusで6%の改善をもたらしました。これにより、コーダーモデルにおける強化学習の大きな可能性が示されました。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<a class="button" href="articles/LatentReasoning.html">#LatentReasoning</a>
<span class="issue_date">Issue Date: 2025-02-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1753">Scaling up Test-Time Compute with Latent Reasoning: A Recurrent Depth  Approach, Jonas Geiping+, arXiv'25</a>
<span class="snippet"><span>Summary</span>新しい言語モデルアーキテクチャを提案し、潜在空間での暗黙的推論によりテスト時の計算をスケールさせる。再帰ブロックを反復し、任意の深さに展開することで、従来のトークン生成モデルとは異なるアプローチを採用。特別なトレーニングデータを必要とせず、小さなコンテキストウィンドウで複雑な推論を捉える。3.5億パラメータのモデルをスケールアップし、推論ベンチマークでのパフォーマンスを劇的に改善。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Distillation.html">#Distillation</a>
<a class="button" href="articles/TeacherHacking.html">#TeacherHacking</a>
<span class="issue_date">Issue Date: 2025-02-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1751">On Teacher Hacking in Language Model Distillation, Daniil Tiapkin+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、言語モデルの知識蒸留過程における「教師ハッキング」の現象を調査。固定されたオフラインデータセットを用いると教師ハッキングが発生し、最適化プロセスの逸脱を検出可能。一方、オンラインデータ生成技術を用いることで教師ハッキングを軽減でき、データの多様性が重要な要因であることを明らかにした。これにより、堅牢な言語モデル構築における蒸留の利点と限界についての理解が深まる。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_philschmid/status/1888516494100734224?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q自分で蒸留する機会は今のところないが、覚えておきたい。過学習と一緒で、こういう現象が起こるのは想像できる。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2025-02-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1750">Rethinking Mixture-of-Agents: Is Mixing Different Large Language Models  Beneficial?, Wenzhe Li+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Self-MoAは、単一の高性能LLMからの出力を集約するアンサンブル手法であり、従来のMoAを上回る性能を示す。AlpacaEval 2.0で6.6%の改善を達成し、MMLUやCRUXなどでも平均3.8%の向上を記録。出力の多様性と品質のトレードオフを調査し、異なるLLMの混合が品質を低下させることを確認。Self-MoAの逐次バージョンも効果的であることを示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dair_ai/status/1888658770059816968?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-02-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1749">s1: Simple test-time scaling, Niklas Muennighoff+, arXiv'25</a>
<span class="snippet"><span>Summary</span>テスト時スケーリングを用いて言語モデルのパフォーマンスを向上させる新しいアプローチを提案。小規模データセットs1Kを作成し、モデルの思考プロセスを制御する予算強制を導入。これにより、モデルは不正確な推論を修正し、Qwen2.5-32B-Instructモデルがo1-previewを最大27%上回る結果を達成。さらに、介入なしでパフォーマンスを向上させることが可能となった。モデル、データ、コードはオープンソースで提供。</span>
<span class="snippet"><span>Comment</span>解説:https://x.com/hillbig/status/1887260791981941121?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/DataDistillation.html">#DataDistillation</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-02-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1748">LIMO: Less is More for Reasoning, Yixin Ye+, arXiv'25</a>
<span class="snippet"><span>Summary</span>LIMOモデルは、わずか817のトレーニングサンプルで複雑な数学的推論を効果的に引き出し、AIMEで57.1%、MATHで94.8%の精度を達成。従来のモデルよりも少ないデータで優れたパフォーマンスを示し、一般化を促す「Less-Is-More Reasoning Hypothesis」を提案。LIMOはオープンソースとして提供され、データ効率の良い推論の再現性を促進する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/arankomatsuzaki/status/1887353699644940456?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/RewardHacking.html">#RewardHacking</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-02-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1746">Demystifying Long Chain-of-Thought Reasoning in LLMs, Edward Yeo+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）における長い思考の連鎖（CoTs）推論のメカニズムを調査し、重要な要因を特定。主な発見は、(1) 教師ありファインチューニング（SFT）は必須ではないが効率を向上させる、(2) 推論能力は計算の増加に伴い現れるが、報酬の形状がCoTの長さに影響、(3) 検証可能な報酬信号のスケーリングが重要で、特に分布外タスクに効果的、(4) エラー修正能力は基本モデルに存在するが、RLを通じて効果的に奨励するには多くの計算が必要。これらの洞察は、LLMsの長いCoT推論を強化するためのトレーニング戦略の最適化に役立つ。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/xiangyue96/status/1887332772198371514?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q元ポストのスレッド中に論文の11個の知見が述べられている。どれも非常に興味深い。DeepSeek-R1のテクニカルペーパーと同様、

<br>



<br>

・Long CoTとShort CoTを比較すると前者の方が到達可能な性能のupper bonudが高いことや、

<br>

・SFTを実施してからRLをすると性能が向上することや、

<br>

・RLの際にCoTのLengthに関する報酬を入れることでCoTの長さを抑えつつ性能向上できること、

<br>

・数学だけでなくQAペアなどのノイジーだが検証可能なデータをVerifiableな報酬として加えると一般的なreasoningタスクで数学よりもさらに性能が向上すること、

<br>

・より長いcontext window sizeを活用可能なモデルの訓練にはより多くの学習データが必要なこと、

<br>

・long CoTはRLによって学習データに類似したデータが含まれているためベースモデルの段階でその能力が獲得されていることが示唆されること、

<br>

・aha momentはすでにベースモデル時点で獲得されておりVerifiableな報酬によるRLによって強化されたわけではなさそう、

<br>



<br>

など、興味深い知見が盛りだくさん。非常に興味深い研究。あとで読む。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/Diversity.html">#Diversity</a>
<span class="issue_date">Issue Date: 2025-02-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1744">Diverse Preference Optimization, Jack Lanchantin+, ICLR'25</a>
<span class="snippet"><span>Summary</span>Diverse Preference Optimization（DivPO）を提案し、応答の多様性を向上させつつ生成物の品質を維持するオンライン最適化手法を紹介。DivPOは応答のプールから多様性を測定し、希少で高品質な例を選択することで、パーソナ属性の多様性を45.6%、ストーリーの多様性を74.6%向上させる。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jaseweston/status/1885399530419450257?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QOpenReview: https://openreview.net/forum?id=pOq9vDIYevDPOと同じ最適化方法を使うが、Preference Pairを選択する際に、多様性が増加するようなPreference Pairの選択をすることで、モデルのPost-training後の多様性を損なわないようにする手法を提案しているっぽい。

<br>

具体的には、Alg.1 に記載されている通り、多様性の尺度Dを定義して、モデルにN個のレスポンスを生成させRMによりスコアリングした後、RMのスコアが閾値以上のresponseを"chosen" response, 閾値未満のレスポンスを "reject" responseとみなし、chosen/reject response集合を構築する。chosen response集合の中からDに基づいて最も多様性のあるresponse y_c、reject response集合の中から最も多様性のないresponse y_r をそれぞれピックし、prompt xとともにpreference pair (x, y_c, y_r) を構築しPreference Pairに加える、といった操作を全ての学習データ（中のprompt）xに対して繰り返すことで実現する。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-01-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1740">SFT Memorizes, RL Generalizes: A Comparative Study of Foundation Model   Post-training, Tianzhe Chu+, ICML'25</a>
<span class="snippet"><span>Summary</span>SFTとRLの一般化能力の違いを研究し、GeneralPointsとV-IRLを用いて評価。RLはルールベースのテキストと視覚変種に対して優れた一般化を示す一方、SFTは訓練データを記憶し分布外シナリオに苦労。RLは視覚認識能力を向上させるが、SFTはRL訓練に不可欠であり、出力形式を安定させることで性能向上を促進。これらの結果は、複雑なマルチモーダルタスクにおけるRLの一般化能力を示す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1884731381517082668?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qopenreview:https://openreview.net/forum?id=dYur3yabMj&referrer=%5Bthe%20profile%20of%20Yi%20Ma%5D(%2Fprofile%3Fid%3D~Yi_Ma4)</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<span class="issue_date">Issue Date: 2025-01-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1738">Evolving Deeper LLM Thinking, Kuang-Huei Lee+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Mind Evolutionという進化的探索戦略を提案し、言語モデルを用いて候補応答を生成・洗練する。これにより、推論問題の形式化を回避しつつ、推論コストを制御。自然言語計画タスクにおいて、他の戦略を大幅に上回り、TravelPlannerおよびNatural Planのベンチマークで98%以上の問題を解決。</span>
<span class="snippet"><span>Comment</span>OpenReview: https://openreview.net/forum?id=nGP1UxhAbV&referrer=%5Bthe%20profile%20of%20Kuang-Huei%20Lee%5D(%2Fprofile%3Fid%3D~Kuang-Huei_Lee1)</span>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Search.html">#Search</a>
<a class="button" href="articles/STS%20(SemanticTextualSimilarity).html">#STS (SemanticTextualSimilarity)</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2025-01-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1734">SoftMatcha: A Fast and Soft Pattern Matcher for Billion-Scale Corpus Searches, Deguchi+, ICLR'25</a>
<span class="snippet"><span>Comment</span>ICLR2025にacceptされた模様

<br>

https://openreview.net/forum?id=Q6PAnqYVpoopenreview:https://openreview.net/forum?id=Q6PAnqYVpo</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2025-01-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1728">Perspective Transition of Large Language Models for Solving Subjective  Tasks, Xiaolong Wang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>視点の移行を通じた推論（RPT）を提案し、LLMsが主観的な問題に対して動的に視点を選択できる手法を紹介。広範な実験により、従来の固定視点手法を上回り、文脈に応じた適切な応答を提供する能力を示す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/rohanpaul_ai/status/1882739526361370737?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QOpenReview: https://openreview.net/forum?id=cFGPlRony5"Subjective Task"とは例えば「メタファーの認識」や「ダークユーモアの検知」などがあり、これらは定量化しづらい認知的なコンテキストや、ニュアンスや感情などが強く関連しており、現状のLLMではチャレンジングだと主張している。

<br>

Subjective Taskでは、Reasoningモデルのように自動的にCoTのpathwayを決めるのは困難で、手動でpathwayを記述するのはチャレンジングで一貫性を欠くとした上で、複数の視点を組み合わせたPrompting（direct perspective, role-perspective, third-person perspectivfe）を実施し、最もConfidenceの高いanswerを採用することでこの課題に対処すると主張している。イントロしか読めていないが、自動的にCoTのpathwayを決めるのも手動で決めるのも難しいという風にイントロで記述されているが、手法自体が最終的に3つの視点から回答を生成させるという枠組みに則っている（つまりSubjective Taskを解くための形式化できているので、自動的な手法でもできてしまうのではないか？と感じた）ので、イントロで記述されている主張の”難しさ”が薄れてしまっているかも・・・？と感じた。論文が解こうとしている課題の”難しさ”をサポートする材料がもっとあった方がよりmotivationが分かりやすくなるかもしれない、という感想を持った。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<a class="button" href="articles/Tokenizer.html">#Tokenizer</a>
<a class="button" href="articles/Workshop.html">#Workshop</a>
<span class="issue_date">Issue Date: 2025-01-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1634">Byte Latent Transformer: Patches Scale Better Than Tokens, Artidoro Pagnoni+, ICML'25 Workshop Tokshop</a>
<span class="snippet"><span>Summary</span>Byte Latent Transformer（BLT）は、バイトレベルのLLMアーキテクチャで、トークン化ベースのLLMと同等のパフォーマンスを実現し、推論効率と堅牢性を大幅に向上させる。BLTはバイトを動的にサイズ変更可能なパッチにエンコードし、データの複雑性に応じて計算リソースを調整する。最大8Bパラメータと4Tトレーニングバイトのモデルでの研究により、固定語彙なしでのスケーリングの可能性が示された。長いパッチの動的選択により、トレーニングと推論の効率が向上し、全体的にBLTはトークン化モデルよりも優れたスケーリングを示す。</span>
<span class="snippet"><span>Comment</span>興味深い図しか見れていないが、バイト列をエンコード/デコードするtransformer学習して複数のバイト列をパッチ化（エントロピーが大きい部分はより大きなパッチにバイト列をひとまとめにする）、パッチからのバイト列生成を可能にし、パッチを変換するのをLatent Transformerで学習させるようなアーキテクチャのように見える。

<br>



<br>

また、予算によってモデルサイズが決まってしまうが、パッチサイズを大きくすることで同じ予算でモデルサイズも大きくできるのがBLTの利点とのこと。

<br>

<img src="https://github.com/user-attachments/assets/4d150ea9-34e3-456a-bfda-123eb03ffd7c" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/5884d4ed-6c12-4691-8d13-4b3cccd74ef0" alt="image" loading="lazy">日本語解説:https://bilzard.github.io/blog/2025/01/01/byte-latent-transformer.html?v=2OpenReview:https://openreview.net/forum?id=UZ3J8XeRLw</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/COLING.html">#COLING</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2024-12-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1577">Towards Adaptive Mechanism Activation in Language Agent, Ziyang Huang+, COLING'25</a>
<span class="snippet"><span>Summary</span>自己探索によるメカニズム活性化学習（ALAMA）を提案し、固定されたメカニズムに依存せずに適応的なタスク解決を目指す。調和のとれたエージェントフレームワーク（UniAct）を構築し、タスク特性に応じてメカニズムを自動活性化。実験結果は、動的で文脈に敏感なメカニズム活性化の有効性を示す。</span>
<span class="snippet"><span>Comment</span>元ポスト: https://x.com/omarsar0/status/1863956776623747433?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q手法としては、SFTとKTOを活用しpost trainingするようである

<br>

<img src="https://github.com/user-attachments/assets/0eab8029-124d-4ac1-b906-2463472b90b2" alt="image" loading="lazy">

<br>



<br>

・1472</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/DataAugmentation.html">#DataAugmentation</a>
<a class="button" href="articles/Distillation.html">#Distillation</a>
<a class="button" href="articles/NAACL.html">#NAACL</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2024-12-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1565">Reverse Thinking Makes LLMs Stronger Reasoners, Justin Chih-Yao Chen+, NAACL'25</a>
<span class="snippet"><span>Summary</span>逆思考は推論において重要であり、我々は大規模言語モデル（LLMs）向けにReverse-Enhanced Thinking（RevThink）フレームワークを提案。データ拡張と学習目標を用いて、前向きと後向きの推論を構造化し、マルチタスク学習で小型モデルを訓練。実験では、ゼロショット性能が平均13.53%向上し、知識蒸留ベースラインに対して6.84%の改善を達成。少ないデータでのサンプル効率も示し、一般化能力が高いことが確認された。</span>
<span class="snippet"><span>Comment</span>手法概要

<br>



<br>

Original QuestionからTeacher Modelでreasoningと逆質問を生成（Forward Reasoning, Backward Question）し、逆質問に対するReasoningを生成する（Backward Reasoning）。

<br>

その後、Forward Reasoningで回答が誤っているものや、Teacher Modelを用いてBackward ReasoningとOriginal Questionを比較して正しさをverificationすることで、学習データのフィルタリングを行う。

<br>

このようにして得られたデータに対して、3種類の項をlossに設けて学習する。具体的には

<br>



<br>

・Original Questionから生成したForward Reasoningに対するクロスエントロピー

<br>

・Original Questionから生成したBackward Questionに対するクロスエントロピー

<br>

・Backward Questionから生成したBackward Reasoningに対するクロスエントロピー

<br>



<br>

の平均をとる。

<br>



<br>

<img src="https://github.com/user-attachments/assets/d37ff435-3225-4e9e-b455-547a6b691057" alt="image" loading="lazy">

<br>



<br>

また、original questionと、backward reasoningが一貫しているかを確認するためにTeacher Modelを利用した下記プロンプトでverificationを実施し、一貫性があると判断されたサンプルのみをSFTのデータとして活用している。

<br>

<img src="https://github.com/user-attachments/assets/3fc5b0a1-ff46-4ad3-8e12-9ab97224ef2d" alt="image" loading="lazy">

<br>



<br>

Teacherモデルから知識蒸留をするためSFTが必要。あと、正解が一意に定まるようなQuestionでないとbackward reasoningの生成はできても、verificationが困難になるので、適用するのは難しいかもしれない。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Batch.html">#Batch</a>
<span class="issue_date">Issue Date: 2024-11-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1541">How Does Critical Batch Size Scale in Pre-training?, Hanlin Zhang+, ICLR'25</a>
<span class="snippet"><span>Summary</span>大規模モデルの訓練には、クリティカルバッチサイズ（CBS）を考慮した並列化戦略が重要である。CBSの測定法を提案し、C4データセットで自己回帰型言語モデルを訓練。バッチサイズや学習率などの要因を調整し、CBSがデータサイズに比例してスケールすることを示した。この結果は、ニューラルネットワークの理論的分析によって支持され、ハイパーパラメータ選択の重要性も強調されている。</span>
<span class="snippet"><span>Comment</span>Critical Batch Sizeはモデルサイズにはあまり依存せず、データサイズに応じてスケールする

<br>

<img src="https://github.com/user-attachments/assets/4a1a720f-37a1-485d-9b02-bb2e8a5c2da4" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/8bc5f621-caac-438a-afd1-de1d689ee210" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2024-11-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1489">Self-Consistency Preference Optimization, Archiki Prasad+, ICML'25</a>
<span class="snippet"><span>Summary</span>自己調整は、モデルが人間の注釈なしに自らを改善する方法であり、自己一貫性を活用して訓練を行う新しいアプローチ、自己一貫性優先最適化（ScPO）を提案。ScPOは一貫した答えを優先し、GSM8KやMATHなどの推論タスクで従来の手法を大幅に上回る性能を示し、標準的な監視学習との組み合わせでも結果が向上。ZebraLogicでLlama-3 8Bを微調整し、他の大規模モデルを超える成果を達成。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jaseweston/status/1854532624116547710?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QSelf-Consistencyのように、モデルに複数の出力をさせて、最も頻度が高い回答と頻度が低い回答の2つでDPOのペアデータを作成し学習。頻度の差によって重みを決めてlossに組み込みこのよつな処理を繰り返し学習すると性能が向上する、といった話のように見える。

<br>

<img src="https://github.com/user-attachments/assets/040ffe7c-6e89-4b58-85dd-ce1bc78195cb" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/45bbb1e6-145c-4c49-943d-4dfa25812264" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/35905525-b03f-4fe3-a0e6-89a89cf4ed29" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/45e87ec6-1ebb-4aa8-80ae-0f9072e670d9" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<span class="issue_date">Issue Date: 2024-10-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1466">Differential Transformer, Tianzhu Ye+, N_A, ICLR'25</a>
<span class="snippet"><span>Summary</span>Diff Transformerは、関連するコンテキストへの注意を強化し、ノイズをキャンセルする新しいアーキテクチャです。差分注意メカニズムを用いて、注意スコアを計算し、スパースな注意パターンを促進します。実験結果は、Diff Transformerが従来のTransformerを上回り、長いコンテキストモデリングや幻覚の軽減において顕著な利点を示しています。また、文脈内学習においても精度を向上させ、堅牢性を高めることが確認されました。これにより、Diff Transformerは大規模言語モデルの進展に寄与する有望なアーキテクチャとされています。</span>
<span class="snippet"><span>Comment</span>最近のMSはなかなかすごい（小並感概要

<br>



<br>

attention scoreのノイズを低減するようなアーキテクチャとして、二つのQKVを用意し、両者の差分を取ることで最終的なattentiok scoreを計算するDifferential Attentionを提案した。

<br>



<br>



<br>



<br>

attentionのnoiseの例。answerと比較してirrelevantなcontextにattention scoreが高いスコアが割り当てられてしまう（図左）。differential transformerが提案するdifferential attentionでは、ノイズを提言し、重要なcontextのattention scoreが高くなるようになる（図中央）、らしい。

<br>



<br>

<img src="https://github.com/user-attachments/assets/6033f477-d4bf-492d-9360-74f2849ce40e" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Differential Attentionの概要と計算式

<br>



<br>

<img src="https://github.com/user-attachments/assets/b77facd8-7cf2-43ab-8947-2f775423f0a0" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

数式で見るとこのようになっており、二つのQKをどの程度の強さで交互作用させるかをλで制御し、λもそれぞれのQKから導出する。

<br>



<br>

<img src="https://github.com/user-attachments/assets/c58a4d04-a453-4aef-aa40-7de872117482" alt="image" loading="lazy">QA, 機械翻訳, 文書分類, テキスト生成などの様々なNLPタスクが含まれるEval Harnessベンチマークでは、同規模のtransformerモデルを大幅にoutperform。ただし、3Bでしか実験していないようなので、より大きなモデルサイズになったときにgainがあるかは示されていない点には注意。

<br>

<img src="https://github.com/user-attachments/assets/384605ed-e4e4-4a17-83c8-506f8e3e2e4c" alt="image" loading="lazy">モデルサイズ（パラメータ数）と、学習トークン数のスケーラビリティについても調査した結果、LLaMAと比較して、より少ないパラメータ数/学習トークン数で同等のlossを達成。

<br>

<img src="https://github.com/user-attachments/assets/5d2d1dfc-4197-4b36-9f3d-79a3ed18fe3f" alt="image" loading="lazy">64Kにcontext sgzeを拡張し、1.5B tokenで3Bモデルを追加学習をしたところ、これもtransformerと比べてより小さいlossを達成<img src="https://github.com/user-attachments/assets/f911a4f9-d175-4ea2-825b-9776be6042e5" alt="image" loading="lazy">context中に埋め込まれた重要な情報（今回はクエリに対応するmagic number）を抽出するタスクの性能も向上。Needle（N）と呼ばれる正解のmagic numberが含まれる文をcontext中の様々な深さに配置し、同時にdistractorとなる文もランダムに配置する。これに対してクエリ（R）が入力されたときに、どれだけ正しい情報をcontextから抽出できるか、という話だと思われる。

<br>



<br>

これも性能が向上。特にクエリとNeedleが複数の要素で構成されていれ場合の性能が高く（下表）、長いコンテキスト中の様々な位置に埋め込まれたNeedleを抽出する性能も高い（上のmatrix）

<br>



<br>

<img src="https://github.com/user-attachments/assets/f4d084dc-fac5-427d-8185-5604e55cf051" alt="image" loading="lazy">

<br>



<br>

[Needle-In-A-Haystack test](https://www.perplexity.ai/search/needle-in-a-haystack-testtohan-jF7LXWQPSMqKI2pZSchjpA0)Many shotのICL能力も向上

<br>

<img src="https://github.com/user-attachments/assets/c935ba93-9915-45c8-aaa6-f073d62fdd3b" alt="image" loading="lazy">要約タスクでのhallucinationも低減。生成された要約と正解要約を入力し、GPT4-oにhallucinationの有無を判定させて評価。これは先行研究で人手での評価と高いagreementがあることが示されている。

<br>

<img src="https://github.com/user-attachments/assets/6fd97af4-fec6-44e8-b00c-d5ba26770a84" alt="image" loading="lazy">シンプルなアプローチでLLM全体の性能を底上げしている素晴らしい成果に見える。斜め読みなので読み飛ばしているかもしれないが、766 のように高品質な学習データで学習した場合も同様の効果が発現するのだろうか？

<br>

attentionのスコアがnoisyということは、学習データを洗練させることでも改善される可能性があり、766 はこれをデータで改善し、こちらの研究はモデルのアーキテクチャで改善した、みたいな捉え方もできるのかもしれない。ちなみにFlash Attentionとしての実装方法も提案されており、スループットは通常のattentionと比べてむしろ向上しているので実用的な手法でもある。すごい。

<br>

<img src="https://github.com/user-attachments/assets/c0212cd8-55f5-4991-b256-0ff2bce35669" alt="image" loading="lazy">あとこれ、事前学習とInstruction Tuningを通常のマルチヘッドアテンションで学習されたモデルに対して、独自データでSFTするときに導入したらdownstream taskの性能向上するんだろうか。もしそうなら素晴らしいOpenReview:https://openreview.net/forum?id=OvoCm1gGhNGroupNormalizationについてはこちら:

<br>

・1856</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/NAACL.html">#NAACL</a>
<span class="issue_date">Issue Date: 2024-10-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1461">[Paper Note] Fact, Fetch, and Reason: A Unified Evaluation of Retrieval-Augmented  Generation, Satyapriya Krishna+, N_A, NAACL'25</a>
<span class="snippet"><span>Summary</span>LLMsを用いた情報検索強化生成（RAG）システムの性能評価のために、FRAMESという新しい評価データセットを提案。これは、事実に基づく応答、検索能力、推論を統一的に評価するもので、複数の情報源を統合するマルチホップ質問を含む。最新のLLMでも0.40の精度に留まる中、提案するマルチステップ検索パイプラインにより精度が0.66に向上し、RAGシステムの開発に貢献することを目指す。</span>
<span class="snippet"><span>Comment</span>RAGのfactuality, retrieval acculacy, reasoningを評価するためのmulti hop puestionとそれに回答するための最大15のwikipedia記事のベンチマーク

<br>

元ポスト:https://x.com/_philschmid/status/1840628834275602585?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SelfCorrection.html">#SelfCorrection</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2024-09-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1388">Generative Verifiers: Reward Modeling as Next-Token Prediction, Lunjun Zhang+, N_A, ICLR'25</a>
<span class="snippet"><span>Summary</span>検証器と報酬モデルを用いてLLMの推論性能を向上させる新しいアプローチ、生成的検証器（GenRM）を提案。GenRMは次トークン予測を用いて検証と解決策生成を共同で行い、指示チューニングや思考の連鎖を活用。実験により、GenRMは従来の検証器を上回り、問題解決率が16-64%向上することを示した。</span>
<span class="snippet"><span>Comment</span>LLMがリクエストに対する回答を生成したのちに、その回答をverifyするステップ + verifyの結果から回答を修正するステップを全てconcatした学習データをnext token predictionで用いることによって、モデル自身に自分の回答をverifyする能力を身につけさせることができた結果性能が向上しました、という研究らしい。また、Self-consistency 558 のように複数の異なるCoTを並列して実行させ、そのmajority votingをとることでさらに性能が向上する。

<br>



<br>



<br>



<br>

<img width="663" alt="image" src="https://github.com/user-attachments/assets/e6ebd308-fc77-4c5b-80c2-37e3615f48af">

<br>



<br>

<img width="703" alt="image" src="https://github.com/user-attachments/assets/9cf3dfe7-be09-4053-a760-9ec9ed993b33">

<br>



<br>

</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2024-04-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1286">Physics of Language Models: Part 3.3, Knowledge Capacity Scaling Laws, Zeyuan Allen-Zhu+, N_A, ICLR'25</a>
<span class="snippet"><span>Summary</span>言語モデルのサイズと能力の関係を記述するスケーリング則に焦点を当てた研究。モデルが格納する知識ビット数を推定し、事実知識をタプルで表現。言語モデルは1つのパラメータあたり2ビットの知識を格納可能であり、7Bモデルは14Bビットの知識を格納可能。さらに、トレーニング期間、モデルアーキテクチャ、量子化、疎な制約、データの信号対雑音比が知識格納容量に影響することを示唆。ロータリー埋め込みを使用したGPT-2アーキテクチャは、知識の格納においてLLaMA/Mistralアーキテクチャと競合する可能性があり、トレーニングデータにドメイン名を追加すると知識容量が増加することが示された。</span>
<span class="snippet"><span>Comment</span>参考:https://x.com/hillbig/status/1779640139263901698?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説:

<br>

・1834openreview:https://openreview.net/forum?id=FxNNiUgtfa</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ModelMerge.html">#ModelMerge</a>
<span class="issue_date">Issue Date: 2024-03-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1257">Evolutionary Optimization of Model Merging Recipes, Takuya Akiba+, N_A, Nature Machine Intelligence'25</a>
<span class="snippet"><span>Summary</span>進化アルゴリズムを使用した新しいアプローチを提案し、強力な基盤モデルの自動生成を実現。LLMの開発において、人間の直感やドメイン知識に依存せず、多様なオープンソースモデルの効果的な組み合わせを自動的に発見する。このアプローチは、日本語のLLMと数学推論能力を持つモデルなど、異なるドメイン間の統合を容易にし、日本語VLMの性能向上にも貢献。オープンソースコミュニティへの貢献と自動モデル構成の新しいパラダイム導入により、基盤モデル開発における効率的なアプローチを模索。</span>
<span class="snippet"><span>Comment</span>複数のLLMを融合するモデルマージの話。日本語LLMと英語の数学LLNをマージさせることで日本語の数学性能を大幅に向上させたり、LLMとVLMを融合したりすることで、日本にしか存在しない概念の画像も、きちんと回答できるようになる。

<br>



<br>

著者スライドによると、従来のモデルマージにはbase modelが同一でないとうまくいかなかったり（重みの線型結合によるモデルマージ）、パラメータが増減したり（複数LLMのLayerを重みは弄らず再配置する）。また日本語LLMに対してモデルマージを実施しようとすると、マージ元のLLMが少なかったり、広範囲のモデルを扱うとマージがうまくいかない、といった課題があった。本研究ではこれら課題を解決できる。著者による資料（NLPコロキウム）:

<br>

https://speakerdeck.com/iwiwi/17-nlpkorokiumu</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SmallModel.html">#SmallModel</a>
<a class="button" href="articles/Scheduler.html">#Scheduler</a>
<span class="issue_date">Issue Date: 2025-08-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2540">[Paper Note] MiniCPM: Unveiling the Potential of Small Language Models with Scalable  Training Strategies, Shengding Hu+, arXiv'24</a>
<span class="snippet"><span>Summary</span>急成長する大規模言語モデル（LLMs）の開発におけるコストの懸念から、小規模言語モデル（SLMs）の可能性が注目されている。本研究では、MiniCPMという1.2Bおよび2.4Bの非埋め込みパラメータバリアントを紹介し、これらが7B-13BのLLMsと同等の能力を持つことを示す。モデルのスケーリングには広範な実験を、データのスケーリングにはWarmup-Stable-Decay（WSD）学習率スケジューラを導入し、効率的なデータ-モデルスケーリング法を研究した。MiniCPMファミリーにはMiniCPM-DPO、MiniCPM-MoE、MiniCPM-128Kが含まれ、優れたパフォーマンスを発揮している。MiniCPMモデルは公開されている。</span>
<span class="snippet"><span>Comment</span>Warmup-Stable-Decay (WSD)</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/ActivationFunction.html">#ActivationFunction</a>
<span class="issue_date">Issue Date: 2025-08-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2538">[Paper Note] Polynomial Composition Activations: Unleashing the Dynamics of Large  Language Models, Zhijian Zhuo+, arXiv'24</a>
<span class="snippet"><span>Summary</span>新しい多項式合成活性化関数（PolyCom）を提案し、トランスフォーマーのダイナミクスを最適化。PolyComは他の活性化関数よりも高い表現力を持ち、最適近似率を達成。大規模言語モデルにおいて、従来の活性化関数をPolyComに置き換えることで、精度と収束率が向上することを実証。実験結果は他の活性化関数に対して大幅な改善を示す。コードは公開中。</span>
<span class="snippet"><span>Comment</span>関連:

<br>

・1311 </span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2025-08-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2506">[Paper Note] RLAIF vs. RLHF: Scaling Reinforcement Learning from Human Feedback with  AI Feedback, Harrison Lee+, ICML'24</a>
<span class="snippet"><span>Summary</span>RLAIFは、オフ・ザ・シェルフのLLMから生成された好みに基づいて報酬モデルを訓練し、RLHFと同等のパフォーマンスを達成する代替手段を提供。自己改善を示し、d-RLAIFを導入することでさらに優れた結果を得る。RLAIFは人間のフィードバックを用いた場合と同等の性能を示し、RLHFのスケーラビリティの課題に対する解決策となる可能性がある。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<a class="button" href="articles/Cultural.html">#Cultural</a>
<span class="issue_date">Issue Date: 2025-08-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2471">[Paper Note] CVQA: Culturally-diverse Multilingual Visual Question Answering  Benchmark, David Romero+, arXiv'24</a>
<span class="snippet"><span>Summary</span>CVQAは、文化的に多様な多言語のVisual Question Answeringベンチマークで、30か国からの画像と質問を含み、31の言語と13のスクリプトをカバー。データ収集にはネイティブスピーカーを関与させ、合計10,000の質問を提供。マルチモーダル大規模言語モデルをベンチマークし、文化的能力とバイアスを評価するための新たな基準を示す。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<span class="issue_date">Issue Date: 2025-08-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2470">[Paper Note] Pangea: A Fully Open Multilingual Multimodal LLM for 39 Languages, Xiang Yue+, arXiv'24</a>
<span class="snippet"><span>Summary</span>Pangeaは、39の言語にわたる6M指示データセットPangeaInsを用いて訓練された多言語マルチモーダルLLMであり、異文化間のカバレッジを確保しています。Pangeaは、47の言語をカバーする評価スイートPangeaBenchで既存のモデルを大幅に上回る性能を示し、英語データの比率やマルチモーダル訓練サンプルの重要性を明らかにしました。データ、コード、訓練済みチェックポイントはオープンソース化され、言語的および文化的公平性を推進します。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<span class="issue_date">Issue Date: 2025-08-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2453">[Paper Note] FrontierMath: A Benchmark for Evaluating Advanced Mathematical Reasoning  in AI, Elliot Glazer+, arXiv'24</a>
<span class="snippet"><span>Summary</span>FrontierMathは、専門の数学者によって作成された難易度の高い数学問題のベンチマークで、数論や実解析から代数幾何学や圏論まで幅広い分野をカバー。問題解決には数時間から数日かかることがあり、現在のAIモデルは問題の2%未満しか解決できていない。FrontierMathはAIの数学的能力の進捗を定量化するための厳密なテストベッドを提供する。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<a class="button" href="articles/Trustfulness.html">#Trustfulness</a>
<span class="issue_date">Issue Date: 2025-08-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2448">[Paper Note] Measuring short-form factuality in large language models, Jason Wei+, arXiv'24</a>
<span class="snippet"><span>Summary</span>SimpleQAは、言語モデルの短い事実に関する質問への応答能力を評価するためのベンチマークであり、挑戦的かつ評価が容易な質問を特徴とする。各回答は正解、不正解、未試行のいずれかとして評価され、理想的なモデルは自信がない質問には挑戦せず、正解を多く得ることを目指す。SimpleQAは、モデルが「自分が知っていることを知っているか」を評価するためのシンプルな手段であり、次世代モデルにとっても重要な評価基準となることが期待されている。</span>
<span class="snippet"><span>Comment</span>先行研究:

<br>

・2449

<br>

・2450

<br>



<br>

これらはすでに飽和している最近よくLLMのベンチで見かけるSimpleQA</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<span class="issue_date">Issue Date: 2025-08-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2441">[Paper Note] CRUXEval-X: A Benchmark for Multilingual Code Reasoning, Understanding  and Execution, Ruiyang Xu+, arXiv'24</a>
<span class="snippet"><span>Summary</span>CRUXEVAL-Xという多言語コード推論ベンチマークを提案。19のプログラミング言語を対象に、各言語で600以上の課題を含む19Kのテストを自動生成。言語間の相関を評価し、Python訓練モデルが他言語でも高い性能を示すことを確認。</span>
<span class="snippet"><span>Comment</span>関連:

<br>

・2440</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-08-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2440">[Paper Note] CRUXEval: A Benchmark for Code Reasoning, Understanding and Execution, Alex Gu+, arXiv'24</a>
<span class="snippet"><span>Summary</span>CRUXEvalという800のPython関数からなるベンチマークを提案し、入力予測と出力予測の2つのタスクを評価。20のコードモデルをテストした結果、HumanEvalで高得点のモデルがCRUXEvalでは改善を示さないことが判明。GPT-4とChain of Thoughtを用いた場合、入力予測で75%、出力予測で81%のpass@1を達成したが、どのモデルも完全にはクリアできず、GPT-4のコード推論能力の限界を示す例を提供。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/memory.html">#memory</a>
<span class="issue_date">Issue Date: 2025-08-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2401">[Paper Note] A Survey on the Memory Mechanism of Large Language Model based Agents, Zeyu Zhang+, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMベースのエージェントのメモリメカニズムに関する包括的な調査を提案。メモリの重要性を論じ、過去の研究を体系的にレビューし、エージェントアプリケーションでの役割を紹介。既存研究の限界を分析し、将来の研究方向性を示す。リポジトリも作成。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jiqizhixin/status/1954797669957968169?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/CVPR.html">#CVPR</a>
<span class="issue_date">Issue Date: 2025-08-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2385">[Paper Note] MMMU: A Massive Multi-discipline Multimodal Understanding and Reasoning   Benchmark for Expert AGI, Xiang Yue+, CVPR'24</a>
<span class="snippet"><span>Summary</span>MMMUは、大学レベルの専門知識と意図的な推論を必要とするマルチモーダルモデルの評価のための新しいベンチマークで、11,500のマルチモーダル質問を含む。6つの主要分野をカバーし、30種類の画像タイプを使用。既存のベンチマークと異なり、専門家が直面するタスクに類似した課題を提供。GPT-4VとGeminiの評価では、56%と59%の精度にとどまり、改善の余地があることを示す。MMMUは次世代のマルチモーダル基盤モデルの構築に寄与することが期待されている。</span>
<span class="snippet"><span>Comment</span>MMMUのリリースから20ヶ月経過したが、いまだに人間のエキスパートのアンサンブルには及ばないとのこと

<br>

https://x.com/xiangyue96/status/1953902213790830931?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QMMMUのサンプルはこちら。各分野ごとに専門家レベルの知識と推論が求められるとのこと。

<br>

<img src="https://github.com/user-attachments/assets/90839a16-d7d2-499d-b2d8-52dab8988e52" alt="image" loading="lazy"></span>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Search.html">#Search</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<span class="issue_date">Issue Date: 2025-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2378">[Paper Note] VERISCORE: Evaluating the factuality of verifiable claims in long-form  text generation, Yixiao Song+, arXiv'24</a>
<span class="snippet"><span>Summary</span>VERISCOREという新しい指標を提案し、検証可能な主張と検証不可能な主張の両方を含む長文生成タスクに対応。人間評価ではVERISCOREが他の方法よりも理にかなっていることが確認され、16のモデルを評価した結果、GPT-4oが最も優れた性能を示したが、オープンウェイトモデルも差を縮めていることが分かった。また、異なるタスク間でVERISCOREの相関がないことから、事実性評価の拡張が必要であることを示唆している。</span>
<span class="snippet"><span>Comment</span>LLMの応答からverifiableなclaimのみを抽出し、それを外部の検索エンジン（google検索）のクエリとして入力。検索結果からclaimがsupportされるか否かをLLMによって判断しスコアリングする。

<br>

<img src="https://github.com/user-attachments/assets/495a7952-8240-4b3b-8b8c-c0c52dea0e74" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2025-08-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2374">[Paper Note] LongBench: A Bilingual, Multitask Benchmark for Long Context   Understanding, Yushi Bai+, ACL'24</a>
<span class="snippet"><span>Summary</span>本論文では、長いコンテキスト理解のための初のバイリンガル・マルチタスクベンチマーク「LongBench」を提案。英語と中国語で21のデータセットを含み、平均長はそれぞれ6,711語と13,386文字。タスクはQA、要約、少数ショット学習など多岐にわたる。評価結果から、商業モデルは他のオープンソースモデルを上回るが、長いコンテキストでは依然として課題があることが示された。</span>
<span class="snippet"><span>Comment</span>PLaMo Primeの長文テキスト評価に利用されたベンチマーク（中国語と英語のバイリンガルデータであり日本語は存在しない）

<br>

https://tech.preferred.jp/ja/blog/plamo-prime-release-feature-update/

<br>



<br>

タスクと言語ごとのLengthの分布。英語の方がデータが豊富で、長いものだと30000--40000ものlengthのサンプルもある模様。

<br>

<img src="https://github.com/user-attachments/assets/a1104f3f-996a-4ad9-b6c3-55b2eb7921ab" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<span class="issue_date">Issue Date: 2025-08-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2372">[Paper Note] Visual Prompting in Multimodal Large Language Models: A Survey, Junda Wu+, arXiv'24</a>
<span class="snippet"><span>Summary</span>本論文は、マルチモーダル大規模言語モデル（MLLMs）における視覚的プロンプト手法の包括的な調査を行い、視覚的プロンプトの生成や構成的推論、プロンプト学習に焦点を当てています。既存の視覚プロンプトを分類し、自動プロンプト注釈の生成手法を議論。視覚エンコーダとバックボーンLLMの整合性を向上させる手法や、モデル訓練と文脈内学習による視覚的プロンプトの理解向上についても述べています。最後に、MLLMsにおける視覚的プロンプト手法の未来に関するビジョンを提示します。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Controllable.html">#Controllable</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<a class="button" href="articles/TextToImageGeneration.html">#TextToImageGeneration</a>
<span class="issue_date">Issue Date: 2025-08-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2371">[Paper Note] Controllable Generation with Text-to-Image Diffusion Models: A Survey, Pu Cao+, arXiv'24</a>
<span class="snippet"><span>Summary</span>拡散モデルはテキスト誘導生成において大きな進展を遂げたが、テキストのみでは多様な要求に応えられない。本調査では、T2I拡散モデルの制御可能な生成に関する文献をレビューし、理論的基盤と実践的進展をカバー。デノイジング拡散確率モデルの基本を紹介し、制御メカニズムを分析。生成条件の異なるカテゴリに整理した文献リストを提供。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2025-08-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2368">[Paper Note] Let the Expert Stick to His Last: Expert-Specialized Fine-Tuning for   Sparse Architectural Large Language Models, Zihan Wang+, EMNLP'24</a>
<span class="snippet"><span>Summary</span>本研究では、Mixture-of-Experts（MoE）アーキテクチャを持つ大規模言語モデル（LLMs）に対するパラメータ効率の良いファインチューニング（PEFT）手法を提案。主な内容は、(1) タスクごとの専門家の活性化分布の集中度の調査、(2) Expert-Specialized Fine-Tuning（ESFT）の提案とその効果、(3) MoEアーキテクチャの専門家特化型ファインチューニングへの影響の分析。実験により、ESFTがチューニング効率を向上させ、フルパラメータファインチューニングに匹敵またはそれを上回る性能を示すことが確認された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/wzihanw/status/1952965138845450413?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QMoEアーキテクチャを持つLLMにおいて、finetuningを実施したいタスクに関連する専門家を特定し、そのほかのパラメータをfreezeした上で当該専門家のみをtrainableとすることで、効率的にfinetuningを実施する手法

<br>

<img src="https://github.com/user-attachments/assets/ba82f425-5b61-4ce7-803b-4eb3fb375c41" alt="image" loading="lazy">

<br>



<br>

専門家を見つける際には専門家ごとにfinetuningしたいタスクに対するrelevance scoreを計算する。そのために、2つの手法が提案されており、training dataからデータをサンプリングし

<br>

・全てのサンプリングしたデータの各トークンごとのMoE Routerのgateの値の平均値をrelevant scoreとする方法

<br>

・全てのサンプリングしたデータの各トークンごとに選択された専門家の割合

<br>

の2種類でスコアを求める。閾値pを決定し、閾値以上のスコアを持つ専門家をtrainableとする。

<br>



<br>

LoRAよりもmath, codeなどの他ドメインのタスク性能を劣化させず、Finetuning対象のタスクでFFTと同等の性能を達成。

<br>

<img src="https://github.com/user-attachments/assets/302eebda-bace-4b99-bb73-5e7e3ce10448" alt="image" loading="lazy">

<br>



<br>

LoRAと同様にFFTと比較し学習時間は短縮され、学習した専門家の重みを保持するだけで良いのでストレージも節約できる。

<br>

<img src="https://github.com/user-attachments/assets/b02a8d53-6967-4dd2-9290-de06f27e48c9" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-08-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2338">[Paper Note] YaRN: Efficient Context Window Extension of Large Language Models, Bowen Peng+, ICLR'24</a>
<span class="snippet"><span>Summary</span>YaRN（Yet another RoPE extensioN method）は、トランスフォーマーベースの言語モデルにおける位置情報のエンコードを効率的に行い、コンテキストウィンドウを従来の方法よりも10倍少ないトークンと2.5倍少ない訓練ステップで拡張する手法を提案。LLaMAモデルが長いコンテキストを効果的に利用できることを示し、128kのコンテキスト長まで再現可能なファインチューニングを実現。</span>
<span class="snippet"><span>Comment</span>openreview:https://openreview.net/forum?id=wHBfxhZu1u現在主流なコンテキストウィンドウ拡張手法らしい日本語解説:https://zenn.dev/bilzard/scraps/de7ecd3c380b6e</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/AES(AutomatedEssayScoring).html">#AES(AutomatedEssayScoring)</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/AIED.html">#AIED</a>
<span class="issue_date">Issue Date: 2025-07-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2316">[Paper Note] The Impact of Example Selection in Few-Shot Prompting on Automated Essay   Scoring Using GPT Models, Lui Yoshida, AIED'24</a>
<span class="snippet"><span>Summary</span>本研究では、GPTモデルを用いた少数ショットプロンプティングにおける例の選択が自動エッセイ採点（AES）のパフォーマンスに与える影響を調査。119のプロンプトを用いて、GPT-3.5とGPT-4のモデル間でのスコア一致を二次重み付きカッパ（QWK）で測定。結果、例の選択がモデルによって異なる影響を及ぼし、特にGPT-3.5はバイアスの影響を受けやすいことが判明。慎重な例の選択により、GPT-3.5が一部のGPT-4モデルを上回る可能性があるが、GPT-4は最も高い安定性とパフォーマンスを示す。これにより、AESにおける例の選択の重要性とモデルごとのパフォーマンス評価の必要性が強調される。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Quantization.html">#Quantization</a>
<a class="button" href="articles/MLSys.html">#MLSys</a>
<span class="issue_date">Issue Date: 2025-07-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2264">[Paper Note] AWQ: Activation-aware Weight Quantization for LLM Compression and   Acceleration, Ji Lin+, MLSys'24</a>
<span class="snippet"><span>Summary</span>Activation-aware Weight Quantization（AWQ）を提案し、LLMの低ビット重み量子化を効率化。顕著な重みチャネルを保護することで量子化誤差を削減し、異なるドメインに一般化可能。AWQは言語モデリングやドメイン特化型ベンチマークで優れた性能を示し、4ビットのオンデバイスLLM/VLM向け推論フレームワークTinyChatを実装。これにより、デスクトップおよびモバイルGPUでの処理速度を3倍以上向上させ、70B Llama-2モデルの展開を容易にする。</span>
<span class="snippet"><span>Comment</span>日本語解説:https://qiita.com/kyad/items/96a4a2bdec3f0dc09d23</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/CVPR.html">#CVPR</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<a class="button" href="articles/DataFiltering.html">#DataFiltering</a>
<span class="issue_date">Issue Date: 2025-07-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2262">[Paper Note] Scaling Laws for Data Filtering -- Data Curation cannot be Compute   Agnostic, Sachin Goyal+, CVPR'24</a>
<span class="snippet"><span>Summary</span>視覚と言語のモデル（VLMs）のトレーニングにおいて、高品質なデータのフィルタリングが重要であるが、計算リソースとは無関係に行われることが多い。本研究では、データの品質と量のトレードオフ（QQT）に対処するため、ウェブデータの非均質性を考慮したニューラルスケーリング法則を提案。これにより、データの有用性の違いや繰り返し使用による劣化を評価し、複数のデータプールの組み合わせによるモデルのパフォーマンスを推定可能にする。最適なデータプールのキュレーションを通じて、計算リソースに応じた最高のパフォーマンスを達成できることを示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/cloneofsimo/status/1946241642572448174?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q高品質なデータにフィルタリングすることで多くの研究がモデルがより高い性能を達成できることを示しているが、高品質なデータには限りがあることと、繰り返し学習をすることですぐにその効用が低下する（Quality-Quantity tradeoff!)という特性がある。このような状況において、たとえば計算の予算がデータ6パケット分の時に、めちゃめちゃフィルタリングを頑張っg高品質なデータプールEのみを使って6 epoch学習するのが良いのか、少し品質は落ちるデータDも混ぜてE+Dを3 epoch学習するのが良いのか、ときにどちらが良いのか？という話のようである。

<br>

<img src="https://github.com/user-attachments/assets/06812781-7212-415e-bc7a-dd19ac4ca0d7" alt="image" loading="lazy"></span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<span class="issue_date">Issue Date: 2025-07-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2201">[Paper Note] Measuring Multimodal Mathematical Reasoning with MATH-Vision Dataset, Ke Wang+, NeurIPS'24 Datasets and Benchmarks Track</a>
<span class="snippet"><span>Summary</span>MATH-Vision（MATH-V）データセットを提案し、3,040の視覚的文脈を持つ数学問題を収集。16の数学分野と5つの難易度で構成され、LMMsの数学的推論能力を評価。実験により、LMMsと人間のパフォーマンス間に顕著なギャップがあることを示し、さらなる進展の必要性を強調。エラー分析を通じて今後の研究に貴重な洞察を提供。</span>
<span class="snippet"><span>Comment</span>openreview: https://openreview.net/forum?id=QWTCcxMpPAdiscussion

<br>

project page: https://mathllm.github.io/mathvision/Project Pageのランディングページが非常にわかりやすい。こちらは人間の方がまだまだ性能が高そう。

<br>



<br>

<img width="671" height="806" alt="Image" src="https://github.com/user-attachments/assets/586edf6d-cd77-48cb-b209-8ea819e725fc"></span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<span class="issue_date">Issue Date: 2025-07-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2199">[Paper Note] StarCoder 2 and The Stack v2: The Next Generation, Anton Lozhkov+, arXiv'24</a>
<span class="snippet"><span>Summary</span>BigCodeプロジェクトは、責任あるCode LLMsの開発に焦点を当て、StarCoder2を発表。Software Heritageと提携し、The Stack v2を構築し、619のプログラミング言語を含む大規模なトレーニングセットを作成。StarCoder2モデルは3B、7B、15Bのパラメータを持ち、徹底的なベンチマーク評価で優れた性能を示す。特にStarCoder2-15Bは、同等の他モデルを大幅に上回り、数学やコード推論でも高い性能を発揮。モデルの重みはOpenRAILライセンスで公開され、トレーニングデータの透明性も確保。</span>
<span class="snippet"><span>Comment</span>関連:

<br>

・661</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-07-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2127">[Paper Note] Iterative Reasoning Preference Optimization, Richard Yuanzhe Pang+, NeurIPS'24</a>
<span class="snippet"><span>Summary</span>反復的な好み最適化手法を用いて、Chain-of-Thought（CoT）候補間の推論ステップを最適化するアプローチを開発。修正DPO損失を使用し、推論の改善を示す。Llama-2-70B-ChatモデルでGSM8K、MATH、ARC-Challengeの精度を向上させ、GSM8Kでは55.6%から81.6%に改善。多数決による精度は88.7%に達した。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=4XIKfvNYvx&referrer=%5Bthe%20profile%20of%20He%20He%5D(%2Fprofile%3Fid%3D~He_He2)・1212

<br>



<br>

と似たようにiterativeなmannerでreasoning能力を向上させる。

<br>



<br>

<img src="https://github.com/user-attachments/assets/a0f10e8e-454d-40e8-ae67-8c6c2da6a0ed" alt="image" loading="lazy">

<br>



<br>

ただし、loss functionとしては、chosenなCoT+yのresponseに対して、reasoning traceを生成する能力を高めるために、NLL Lossも適用している点に注意。

<br>

<img src="https://github.com/user-attachments/assets/5ae2dcba-09c8-4618-9b63-ae6aed5b234d" alt="image" loading="lazy">

<br>



<br>

32 samplesのmajority votingによってより高い性能が達成できているので、多様なreasoning traceが生成されていることが示唆される。</span>
<a class="button" href="articles/Multi.html">#Multi</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2025-06-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2112">[Paper Note] Do Large Language Models Latently Perform Multi-Hop Reasoning?, Sohee Yang+, ACL'24</a>
<span class="snippet"><span>Summary</span>本研究では、LLMが複雑なプロンプトに対してマルチホップ推論を行う可能性を探ります。具体的には、LLMが「'Superstition'の歌手」を特定し、その母親に関する知識を用いてプロンプトを完成させる過程を分析します。2つのホップを個別に評価し、特に最初のホップにおいてブリッジエンティティのリコールが増加するかをテストしました。結果、特定の関係タイプのプロンプトに対してマルチホップ推論の証拠が見つかりましたが、活用は文脈依存であり、2番目のホップの証拠は控えめでした。また、モデルサイズの増加に伴い最初のホップの推論能力が向上する傾向が見られましたが、2番目のホップにはその傾向が見られませんでした。これらの結果は、LLMの今後の開発における課題と機会を示唆しています。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<a class="button" href="articles/PRM.html">#PRM</a>
<span class="issue_date">Issue Date: 2025-06-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2103">[Paper Note] Let's Verify Step by Step, Hunter Lightman+, ICLR'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデルの多段階推論能力が向上する中、論理的誤りが依然として問題である。信頼性の高いモデルを訓練するためには、結果監視とプロセス監視の比較が重要である。独自の調査により、プロセス監視がMATHデータセットの問題解決において結果監視を上回ることを発見し、78%の問題を解決した。また、アクティブラーニングがプロセス監視の効果を向上させることも示した。関連研究のために、80万の人間フィードバックラベルからなるデータセットPRM800Kを公開した。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=v8L0pN6EOiPRM800K:https://github.com/openai/prm800k/tree/main</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2025-06-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2102">[Paper Note] RewardBench: Evaluating Reward Models for Language Modeling, Nathan Lambert+, arXiv'24</a>
<span class="snippet"><span>Summary</span>報酬モデル（RMs）の評価に関する研究は少なく、我々はその理解を深めるためにRewardBenchというベンチマークデータセットを提案。これは、チャットや推論、安全性に関するプロンプトのコレクションで、報酬モデルの性能を評価する。特定の比較データセットを用いて、好まれる理由を検証可能な形で示し、さまざまなトレーニング手法による報酬モデルの評価を行う。これにより、報酬モデルの拒否傾向や推論の限界についての知見を得ることを目指す。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/ModelMerge.html">#ModelMerge</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2096">[Paper Note] Chat Vector: A Simple Approach to Equip LLMs with Instruction Following   and Model Alignment in New Languages, Shih-Cheng Huang+, ACL'24</a>
<span class="snippet"><span>Summary</span>オープンソースの大規模言語モデル（LLMs）の多くは英語に偏っている問題に対処するため、chat vectorという概念を導入。これは、事前学習済みモデルの重みからチャットモデルの重みを引くことで生成され、追加のトレーニングなしに新しい言語でのチャット機能を付与できる。実証研究では、指示に従う能力や有害性の軽減、マルチターン対話においてchat vectorの効果を示し、さまざまな言語やモデルでの適応性を確認。chat vectorは、事前学習済みモデルに対話機能を効率的に実装するための有力な解決策である。</span>
<span class="snippet"><span>Comment</span>日本語解説:https://qiita.com/jovyan/items/ee6affa5ee5bdaada6b4下記ブログによるとChatだけではなく、Reasoningでも（post-trainingが必要だが）使える模様

<br>



<br>

Reasoning能力を付与したLLM ABEJA-QwQ32b-Reasoning-Japanese-v1.0の公開, Abeja Tech Blog, 2025.04:

<br>

https://tech-blog.abeja.asia/entry/geniac2-qwen25-32b-reasoning-v1.0</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/PPO%20(ProximalPolicyOptimization).html">#PPO (ProximalPolicyOptimization)</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/On-Policy.html">#On-Policy</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2090">[Paper Note] Preference Fine-Tuning of LLMs Should Leverage Suboptimal, On-Policy   Data, Fahim Tajwar+, ICML'24</a>
<span class="snippet"><span>Summary</span>好みのラベルを用いた大規模言語モデルのファインチューニングに関する研究。オンポリシー強化学習や対照学習などの手法を比較し、オンポリシーサンプリングや負の勾配を用いるアプローチが優れていることを発見。これにより、カテゴリ分布の特定のビンにおける確率質量を迅速に変更できるモード探索目的の重要性を示し、データ収集の最適化に関する洞察を提供。</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2089">[Paper Note] Instruction Pre-Training: Language Models are Supervised Multitask   Learners, Daixuan Cheng+, EMNLP'24</a>
<span class="snippet"><span>Summary</span>無監督のマルチタスク事前学習に加え、監視されたマルチタスク学習の可能性を探るために、Instruction Pre-Trainingフレームワークを提案。指示応答ペアを生成し、2億のペアを合成して実験を行い、事前学習モデルの性能を向上させることを確認。Instruction Pre-TrainingはLlama3-8BをLlama3-70Bと同等以上の性能に引き上げる。モデルやデータは公開されている。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2025-06-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2051">[Paper Note] A Comparative Study of PDF Parsing Tools Across Diverse Document  Categories, Narayan S. Adhikari+, arXiv'24</a>
<span class="snippet"><span>Summary</span>本研究では、DocLayNetデータセットを用いて10の人気PDFパースツールを6つの文書カテゴリにわたり比較し、情報抽出の効果を評価しました。テキスト抽出ではPyMuPDFとpypdfiumが優れた結果を示し、特に科学文書や特許文書ではNougatが高いパフォーマンスを発揮しました。表検出ではTATRが金融や法律文書で優れた結果を示し、Camelotは入札文書で最も良いパフォーマンスを発揮しました。これにより、文書タイプに応じた適切なパースツールの選択が重要であることが示されました。</span>
<span class="snippet"><span>Comment</span>PDFのparsingツールについて、text, table抽出の性能を様々なツールと分野別に評価している。

<br>



<br>

F1, precision, recallなどは、ground truthとのレーベンシュタイン距離からsimilarityを計算し、0.7以上であればtrue positiveとみなすことで計算している模様。local alignmentは、マッチした場合に加点、ミスマッチ、未検出の場合にペナルティを課すようなスコアリングによって抽出したテキスト全体の抽出性能を測る指標な模様。

<br>

<img src="https://github.com/user-attachments/assets/2d2e114f-cc47-4d7d-906a-c505c793d675" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/ccc79865-83d3-47b6-bb47-f2c0a28990c7" alt="image" loading="lazy">より性能を高くしたければこちらも参考に:

<br>

https://x.com/jerryjliu0/status/1934988910448492570?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-05-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1992">Densing Law of LLMs, Chaojun Xiao+, arXiv'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）の性能向上に伴うトレーニングと推論の効率の課題を解決するために、「キャパシティ密度」という新しい指標を提案。これは、ターゲットLLMの有効パラメータサイズと実際のパラメータサイズの比率を用いて、モデルの効果と効率を評価するフレームワークを提供する。分析により、LLMsのキャパシティ密度は約3か月ごとに倍増する傾向があることが示され、今後のLLM開発における重要性が強調される。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1926785750277693859?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q<img src="https://github.com/user-attachments/assets/8cdcfe78-6682-481b-a6b0-a175b84d735c" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-05-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1951">UltraFeedback: Boosting Language Models with Scaled AI Feedback, Ganqu Cui+, ICML'24</a>
<span class="snippet"><span>Summary</span>人間のフィードバックに加え、高品質なAIフィードバックを自動収集することで、LLMsのアライメントをスケーラブルに実現。多様なインタラクションをカバーし、注釈バイアスを軽減した結果、25万件の会話に対する100万件以上のGPT-4フィードバックを含むデータセット「UltraFeedback」を構築。これに基づき、LLaMAモデルを強化学習でアライメントし、チャットベンチマークで優れた性能を示す。研究はオープンソースチャットモデルの構築におけるAIフィードバックの有効性を検証。データとモデルは公開中。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2025-05-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1950">ORPO: Monolithic Preference Optimization without Reference Model, Jiwoo Hong+, EMNLP'24</a>
<span class="snippet"><span>Summary</span>本論文では、好みの整合性における監視付きファインチューニング（SFT）の重要性を強調し、わずかなペナルティで好みに整合したSFTが可能であることを示します。さらに、追加の整合性フェーズを必要としない新しいオッズ比最適化アルゴリズムORPOを提案し、これを用いて複数の言語モデルをファインチューニングした結果、最先端のモデルを上回る性能を達成しました。</span>
<span class="snippet"><span>Comment</span>ざっくり言うとinstruction tuningとalignmentを同時にできる手法らしいがまだ理解できていない</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/KnowledgeEditing.html">#KnowledgeEditing</a>
<span class="issue_date">Issue Date: 2025-05-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1947">EasyEdit: An Easy-to-use Knowledge Editing Framework for Large Language   Models, Peng Wang+, ACL'24, （System Demonstrations）</a>
<span class="snippet"><span>Summary</span>EasyEditは、LLMsのための使いやすい知識編集フレームワークであり、さまざまな知識編集アプローチをサポート。LlaMA-2の実験結果では、信頼性と一般化の面で従来のファインチューニングを上回ることを示した。GitHubでソースコードを公開し、Google Colabチュートリアルやオンラインシステムも提供。</span>
<span class="snippet"><span>Comment</span>ver2.0:

<br>

・1946</span>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Trustfulness.html">#Trustfulness</a>
<span class="issue_date">Issue Date: 2025-05-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1945">日本語TrustfulQAの構築, 中村+, NLP'24</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2025-05-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1943">DataComp-LM: In search of the next generation of training sets for  language models, Jeffrey Li+, arXiv'24</a>
<span class="snippet"><span>Summary</span>DataComp for Language Models（DCLM）を紹介し、240Tトークンのコーパスと53の評価スイートを提供。DCLMでは、モデルスケール412Mから7Bパラメータのデータキュレーション戦略を実験可能。DCLM-Baselineは2.6Tトークンでトレーニングし、MMLUで64%の精度を達成し、従来のMAP-Neoより6.6ポイント改善。計算リソースも40%削減。結果はデータセット設計の重要性を示し、今後の研究の基盤を提供。</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-05-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1942">The FineWeb Datasets: Decanting the Web for the Finest Text Data at  Scale, Guilherme Penedo+, arXiv'24</a>
<span class="snippet"><span>Summary</span>本研究では、15兆トークンからなるFineWebデータセットを紹介し、LLMの性能向上に寄与することを示します。FineWebは高品質な事前学習データセットのキュレーション方法を文書化し、重複排除やフィルタリング戦略を詳細に調査しています。また、FineWebから派生した1.3兆トークンのFineWeb-Eduを用いたLLMは、MMLUやARCなどのベンチマークで優れた性能を発揮します。データセット、コードベース、モデルは公開されています。</span>
<span class="snippet"><span>Comment</span>日本語解説:https://zenn.dev/deepkawamura/articles/da9aeca6d6d9f9</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/KnowledgeEditing.html">#KnowledgeEditing</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-05-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1933">Editing Large Language Models: Problems, Methods, and Opportunities, Yunzhi Yao+, EMNLP'24</a>
<span class="snippet"><span>Summary</span>LLMの編集技術の進展を探求し、特定のドメインでの効率的な動作変更と他の入力への影響を最小限に抑える方法を論じる。モデル編集のタスク定義や課題を包括的にまとめ、先進的な手法の実証分析を行う。また、新しいベンチマークデータセットを構築し、評価の向上と持続的な問題の特定を目指す。最終的に、編集技術の効果に関する洞察を提供し、適切な方法選択を支援する。コードとデータセットは公開されている。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-05-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1929">Physics of Language Models: Part 4.1, Architecture Design and the Magic of Canon Layers, Zeyuan Allen-Zhu+, ICML'24 Tutorial</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1919878625488449849?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QCanon層の発見著者による解説:https://x.com/zeyuanallenzhu/status/1918684257058197922?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-05-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1923">Physics of Language Models: Part 3.1, Knowledge Storage and Extraction, Zeyuan Allen-Zhu+, ICML'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）の知識抽出能力は、訓練データの多様性と強く相関しており、十分な強化がなければ知識は記憶されても抽出可能ではないことが示された。具体的には、エンティティ名の隠れ埋め込みに知識がエンコードされているか、他のトークン埋め込みに分散しているかを調査。LLMのプレトレーニングに関する重要な推奨事項として、補助モデルを用いたデータ再構成と指示微調整データの早期取り入れが提案された。</span>
<span class="snippet"><span>Comment</span>解説:

<br>

・1834</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Safety.html">#Safety</a>
<span class="issue_date">Issue Date: 2025-04-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1908">Safety Alignment Should Be Made More Than Just a Few Tokens Deep, Xiangyu Qi+, arXiv'24</a>
<span class="snippet"><span>Summary</span>現在の大規模言語モデル（LLMs）の安全性アラインメントは脆弱であり、単純な攻撃や善意のファインチューニングによって脱獄される可能性がある。この脆弱性は「浅い安全性アラインメント」に起因し、アラインメントが主に最初の数トークンの出力にのみ適応されることに関連している。本論文では、この問題のケーススタディを提示し、現在のアラインされたLLMsが直面する脆弱性を説明する。また、浅い安全性アラインメントの概念が脆弱性軽減の研究方向を示唆し、初期トークンを超えたアラインメントの深化がロバスト性を向上させる可能性を示す。最後に、ファインチューニング攻撃に対する持続的な安全性アラインメントを実現するための正則化されたファインチューニング目的を提案する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1917006979836612640?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QOpenReview:https://openreview.net/forum?id=6Mxhg9PtDESafety Alignment手法が最初の数トークンに依存しているからそうならないように学習しますというのは、興味深いテーマだし技術的にまだ困難な点もあっただろうし、インパクトも大きいし、とても良い研究だ…。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Decoding.html">#Decoding</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-04-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1890">Non-Determinism of "Deterministic" LLM Settings, Berk Atil+, arXiv'24</a>
<span class="snippet"><span>Summary</span>本研究では、5つの決定論的LLMにおける非決定性を8つのタスクで調査し、最大15%の精度変動と70%のパフォーマンスギャップを観察。全てのタスクで一貫した精度を提供できないことが明らかになり、非決定性が計算リソースの効率的使用に寄与している可能性が示唆された。出力の合意率を示す新たなメトリクスTARr@NとTARa@Nを導入し、研究結果を定量化。コードとデータは公開されている。</span>
<span class="snippet"><span>Comment</span>・論文中で利用されているベンチマーク:

<br>

  ・785

<br>

  ・901 同じモデルに対して、seedを固定し、temperatureを0に設定し、同じ計算機環境に対して、同じinputを入力したら理論上はLLMの出力はdeterministicになるはずだが、deterministicにならず、ベンチマーク上の性能とそもそものraw response自体も試行ごとに大きく変化する、という話。

<br>

ただし、これはプロプライエタリLLMや、何らかのinferenceの高速化を実施したInferenceEngine（本研究ではTogetherと呼ばれる実装を使っていそう。vLLM/SGLangだとどうなるのかが気になる）を用いてinferenceを実施した場合での実験結果であり、後述の通り計算の高速化のためのさまざまな実装無しで、deterministicな設定でOpenLLMでinferenceすると出力はdeterministicになる、という点には注意。

<br>



<br>

GPTやLlama、Mixtralに対して上記ベンチマークを用いてzero-shot/few-shotの設定で実験している。Reasoningモデルは実験に含まれていない。

<br>

<img width="701" height="325" alt="Image" src="https://github.com/user-attachments/assets/b33f14d8-ed86-4589-a427-18a70b35d61a">

<br>



<br>

LLMのraw_response/multiple choiceのparse結果（i.e., 問題に対する解答部分を抽出した結果）の一致（TARr@N, TARa@N; Nはinferenceの試行回数）も理論上は100%になるはずなのに、ならないことが報告されている。

<br>



<br>

<img width="712" height="432" alt="Image" src="https://github.com/user-attachments/assets/3159ff26-fc92-4fa8-90a6-f8c5e7ccf20e">

<br>



<br>

correlation analysisによって、応答の長さ と TAR{r, a}が強い負の相関を示しており、応答が長くなればなるほど不安定さは増すことが分析されている。このため、ontput tokenの最大値を制限することで出力の安定性が増すことを考察している。また、few-shotにおいて高いAcc.の場合は出力がdeterministicになるわけではないが、性能が安定する傾向とのこと。また、OpenAIプラットフォーム上でGPTのfinetuningを実施し実験したが、安定性に寄与はしたが、こちらもdeterministicになるわけではないとのこと。

<br>



<br>

deterministicにならない原因として、まずmulti gpu環境について検討しているが、multi-gpu環境ではある程度のランダム性が生じることがNvidiaの研究によって報告されているが、これはseedを固定すれば決定論的にできるため問題にならないとのこと。

<br>

続いて、inferenceを高速化するための実装上の工夫（e.g., Chunk Prefilling, Prefix Caching, Continuous Batching）などの実装がdeterministicなハイパーパラメータでもdeterministicにならない原因であると考察しており、実際にlocalマシン上でこれらinferenceを高速化するための最適化を何も実施しない状態でLlama-8Bでinferenceを実施したところ、outputはdeterministicになったとのこと。論文中に記載がなかったため、どのようなInferenceEngineを利用したか公開されているgithubを見ると下記が利用されていた:

<br>



<br>

・Together: https://github.com/togethercomputer/together-python?tab=readme-ov-file

<br>



<br>

Togetherが内部的にどのような処理をしているかまでは追えていないのだが、異なるInferenceEngineを利用した場合に、どの程度outputの不安定さに差が出るのか（あるいは出ないのか）は気になる。たとえば、transformers/vLLM/SGLangを利用した場合などである。

<br>



<br>

論文中でも報告されている通り、昔管理人がtransformersを用いて、deterministicな設定でzephyrを用いてinferenceをしたときは、出力はdeterministicになっていたと記憶している（スループットは絶望的だったが...)。あと個人的には現実的な速度でオフラインでinference engineを利用した時にdeterministicにはせめてなって欲しいなあという気はするので、何が原因なのかを実装レベルで突き詰めてくれるととても嬉しい（KV Cacheが怪しい気がするけど）。

<br>



<br>

たとえば最近SLMだったらKVCacheしてVRAM食うより計算し直した方が効率良いよ、みたいな研究があったような。そういうことをしたらlocal llmでdeterministicにならないのだろうか。</span>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/API.html">#API</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<span class="issue_date">Issue Date: 2025-04-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1874">Gorilla: Large Language Model Connected with Massive APIs, Shishir G. Patil+, NeurIPS'24</a>
<span class="snippet"><span>Summary</span>Gorillaは、API呼び出しの生成においてGPT-4を上回るLLaMAベースのモデルであり、文書検索システムと組み合わせることで、テスト時の文書変更に適応し、ユーザーの柔軟な更新を可能にします。幻覚の問題を軽減し、APIをより正確に使用する能力を示します。Gorillaの評価には新たに導入したデータセット「APIBench」を使用し、信頼性と適用性の向上を実現しています。</span>
<span class="snippet"><span>Comment</span>APIBench:https://huggingface.co/datasets/gorilla-llm/APIBenchOpenReview:https://openreview.net/forum?id=tBRNC6YemY</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/TMLR.html">#TMLR</a>
<span class="issue_date">Issue Date: 2025-04-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1868">Foundational Challenges in Assuring Alignment and Safety of Large   Language Models, Usman Anwar+, TMLR'24</a>
<span class="snippet"><span>Summary</span>本研究では、LLMsの整合性と安全性に関する18の基盤的課題を特定し、科学的理解、開発・展開方法、社会技術的課題の3つのカテゴリに整理。これに基づき、200以上の具体的な研究質問を提起。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=oVTkOs8Pka</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<span class="issue_date">Issue Date: 2025-04-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1864">Flex Attention: A Programming Model for Generating Optimized Attention  Kernels, Juechu Dong+, arXiv'24</a>
<span class="snippet"><span>Summary</span>FlexAttentionは、アテンションの新しいコンパイラ駆動型プログラミングモデルで、数行のPyTorchコードで多くのアテンションバリアントを実装可能にします。これにより、既存のアテンションバリアントを効率的に実装し、競争力のあるパフォーマンスを達成。FlexAttentionは、アテンションバリアントの組み合わせを容易にし、組み合わせ爆発の問題を解決します。</span>
<span class="snippet"><span>Comment</span>・1863

<br>



<br>

で利用されているAttentionpytochによる解説:https://pytorch.org/blog/flexattention/

<br>



<br>

・Flex AttentionはオリジナルのAttentionのQK/sqrt(d_k)の計算後にユーザが定義した関数score_modを適用する

<br>

・score_modを定義することで、attention scoreをsoftmaxをかけるまえに関数によって調整できる

<br>

・多くのattentionの亜種はほとんどの場合この抽象化で対応できる

<br>

・score_modはQK tokenの内積に対応するので、QKの情報を受け取り、スカラー値を返せばなんでも良い

<br>

  ・score_modの実装例は元リンク参照

<br>

・FA2と比較して（現在のpytorchでの実装上は）Forward Passは90%, Backward Passは85%のスループットで、少し遅いが今後改善予定元論文より引用。非常にシンプルで、数式上は下記のように表される:

<br>

<img src="https://github.com/user-attachments/assets/b4a393f0-46a9-46c6-9a47-0402ba58fb11" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2025-04-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1854">Agent Workflow Memory, Zora Zhiruo Wang+, arXiv'24</a>
<span class="snippet"><span>Summary</span>エージェントワークフローメモリ（AWM）を導入し、エージェントが再利用可能なタスクワークフローを学習することで、複雑なウェブナビゲーションタスクを効率的に解決。Mind2WebとWebArenaのベンチマークで、成功率をそれぞれ24.6%および51.1%向上させ、必要なステップ数を削減。オンラインAWMは、タスクやドメインに対しても堅牢に一般化し、ベースラインを大幅に上回る性能を示した。</span>
<span class="snippet"><span>Comment</span>過去のワークフローをエージェントがprompt中で利用することができ、利用すればするほど賢くなるような仕組みの提案

<br>

<img width="873" alt="Image" src="https://github.com/user-attachments/assets/6160cfa5-9dbd-44c6-926c-a56eb698d78d"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2025-04-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1852">CoAct: A Global-Local Hierarchy for Autonomous Agent Collaboration, Xinming Hou+, arXiv'24</a>
<span class="snippet"><span>Summary</span>CoActフレームワークを提案し、2つのエージェント（グローバル計画エージェントとローカル実行エージェント）を用いて、LLMの複雑なタスクへの対応力を向上させる。実験では、WebArenaベンチマークにおいて優れた性能を示し、失敗時のプロセス再編成能力を確認。コードは公開中。</span>
<span class="snippet"><span>Comment</span>Planningエージェントと実行エージェントを活用するソフトウェアエージェント

<br>



<br>

<img width="632" alt="Image" src="https://github.com/user-attachments/assets/55db47b8-15f8-4a9c-b641-ce906994897f">

<br>



<br>

ReActより性能向上

<br>

・ 518 

<br>

<img width="325" alt="Image" src="https://github.com/user-attachments/assets/79ac984a-1aa4-4d27-8a3f-860ed2c3abf7"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<span class="issue_date">Issue Date: 2025-04-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1851">Training Software Engineering Agents and Verifiers with SWE-Gym, Jiayi Pan+, arXiv'24</a>
<span class="snippet"><span>Summary</span>SWE-Gymを提案し、2,438件の実世界のPythonタスクを含む環境を構築。言語モデルに基づくSWEエージェントを訓練し、SWE-Benchで最大19%の解決率向上を達成。微調整されたエージェントは新たな最先端の性能を示し、SWE-Gymやモデル、エージェントの軌跡を公開。</span>
<span class="snippet"><span>Comment</span>SWE-Benchとは完全に独立したより広範な技術スタックに関連するタスクに基づくSWEベンチマーク

<br>

・1848 SWE-Benchと比べて実行可能な環境と単体テストが提供されており、単なるベンチマークではなくエージェントを訓練できる環境が提供されている点が大きく異なるように感じる。

<br>

<img src="https://github.com/user-attachments/assets/8c96df84-d211-4035-8337-1ab624d30a4f" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/d25687d9-6f1a-44f6-8235-09be1ff4890f" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2025-04-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1849">WebArena: A Realistic Web Environment for Building Autonomous Agents, Shuyan Zhou+, ICLR'24</a>
<span class="snippet"><span>Summary</span>生成AIの進展により、自律エージェントが自然言語コマンドで日常タスクを管理する可能性が生まれたが、現行のエージェントは簡略化された環境でのテストに限られている。本研究では、ウェブ上でタスクを実行するエージェントのための現実的な環境を構築し、eコマースやソーシャルフォーラムなどのドメインを含む完全なウェブサイトを提供する。この環境を基に、タスクの正確性を評価するベンチマークを公開し、実験を通じてGPT-4ベースのエージェントの成功率が14.41%であり、人間の78.24%には及ばないことを示した。これにより、実生活のタスクにおけるエージェントのさらなる開発の必要性が強調される。</span>
<span class="snippet"><span>Comment</span>Webにおけるさまざまなrealisticなタスクを評価するためのベンチマーク

<br>

<img src="https://github.com/user-attachments/assets/8895fc29-e997-4cce-a43e-65b928dc1d78" alt="image" loading="lazy">実際のexample。スタート地点からピッツバーグのmuseumを巡る最短の経路を見つけるといった複雑なタスクが含まれる。

<br>

<img src="https://github.com/user-attachments/assets/5b7bebea-34c7-4c6f-bbe5-3928544e6c13" alt="image" loading="lazy">

<br>



<br>

人間とGPT4,GPT-3.5の比較結果

<br>

<img src="https://github.com/user-attachments/assets/390fee31-85d0-4d83-969a-57a7f1548ca8" alt="image" loading="lazy"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<span class="issue_date">Issue Date: 2025-04-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1847">Agentless: Demystifying LLM-based Software Engineering Agents, Chunqiu Steven Xia+, arXiv'24</a>
<span class="snippet"><span>Summary</span>最近のLLMの進展により、ソフトウェア開発タスクの自動化が進んでいるが、複雑なエージェントアプローチの必要性に疑問が生じている。これに対し、Agentlessというエージェントレスアプローチを提案し、シンプルな三段階プロセスで問題を解決。SWE-bench Liteベンチマークで最高のパフォーマンスと低コストを達成。研究は自律型ソフトウェア開発におけるシンプルで解釈可能な技術の可能性を示し、今後の研究の方向性を刺激することを目指している。</span>
<span class="snippet"><span>Comment</span>日本語解説:https://note.com/ainest/n/nac1c795e3825LLMによる計画の立案、環境からのフィードバックによる意思決定などの複雑なワークフローではなく、Localization（階層的に問題のある箇所を同定する）とRepair（LLMで複数のパッチ候補を生成する）、PatchValidation(再現テストと回帰テストの両方を通じて結果が良かったパッチを選ぶ）のシンプルなプロセスを通じてIssueを解決する。

<br>

<img src="https://github.com/user-attachments/assets/6d042dfe-9780-4410-9077-b265af5456d1" alt="image" loading="lazy">

<br>



<br>

これにより、低コストで高い性能を達成している、といった内容な模様。

<br>

<img src="https://github.com/user-attachments/assets/3934126f-3a4d-406c-8860-c3ed35a351c4" alt="image" loading="lazy"></span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/UserModeling.html">#UserModeling</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/CTRPrediction.html">#CTRPrediction</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/WWW.html">#WWW</a>
<span class="issue_date">Issue Date: 2025-03-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1840">ReLLa: Retrieval-enhanced Large Language Models for Lifelong Sequential   Behavior Comprehension in Recommendation, Jianghao Lin+, WWW'24</a>
<span class="snippet"><span>Summary</span>本論文では、ゼロショットおよび少ショットの推薦タスクにおいて、大規模言語モデル（LLMs）を強化する新しいフレームワーク「ReLLa」を提案。LLMsが長いユーザー行動シーケンスから情報を抽出できない問題に対処し、セマンティックユーザー行動検索（SUBR）を用いてデータ品質を向上させる。少ショット設定では、検索強化指示チューニング（ReiT）を設計し、混合トレーニングデータセットを使用。実験により、少ショットReLLaが従来のCTRモデルを上回る性能を示した。</span>
<span class="snippet"><span>Comment</span>・1839

<br>



<br>

のベースラインLLMでCTR予測する際の性能を向上した研究。

<br>



<br>

そもそもLLMでCTR予測をする際は、ユーザのデモグラ情報とアクティビティログなどのユーザプロファイルと、ターゲットアイテムの情報でpromptingし、yes/noを出力させる。yes/noトークンのスコアに対して2次元のソフトマックスを適用して[0, 1]のスコアを得ることで、CTR予測をする。

<br>

<img src="https://github.com/user-attachments/assets/75025947-f3bb-49d0-a8f1-e05c429183a4" alt="image" loading="lazy">

<br>



<br>

この研究ではコンテキストにユーザのログを入れても性能がスケールしない問題に対処するために

<br>

<img src="https://github.com/user-attachments/assets/69c27a84-0456-4ddf-aded-515608e27065" alt="image" loading="lazy">

<br>



<br>

直近のアクティビティログではなく、ターゲットアイテムと意味的に類似したアイテムに関するログをコンテキストに入れ（SUBR）、zero shotのinferenceに活用する。

<br>

<img src="https://github.com/user-attachments/assets/a5a2a300-ddca-42cc-97d7-251487ccfa3a" alt="image" loading="lazy">

<br>



<br>

few-shot recommendation（少量のクリックスルーログを用いてLLMをSFTすることでCTR予測する手法）においては、上述の意味的に類似したアイテムをdata augmentationに利用し（i.e, promptに埋め込むアクティビティログの量を増やして）学習する。

<br>

<img src="https://github.com/user-attachments/assets/b98af740-0628-4e98-a80f-30ff105621e1" alt="image" loading="lazy">

<br>



<br>

zeroshotにおいて、SUBRで性能改善。fewshot recommendationにといて、10%未満のデータで既存の全データを用いる手法を上回る。また、下のグラフを見るとpromptに利用するアクティビティログの量が増えるほど性能が向上するようになった。

<br>

<img src="https://github.com/user-attachments/assets/1297153e-bd6c-4548-a7e0-798eadee80e9" alt="image" loading="lazy">

<br>



<br>

ただし、latencyは100倍以上なのでユースケースが限定される。

<br>

<img src="https://github.com/user-attachments/assets/89555964-f5c4-4735-bc0d-9a5a1b7f0278" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SSM%20(StateSpaceModel).html">#SSM (StateSpaceModel)</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2025-03-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1831">Transformers are SSMs: Generalized Models and Efficient Algorithms   Through Structured State Space Duality, Tri Dao+, ICML'24</a>
<span class="snippet"><span>Summary</span>TransformersとMambaのような状態空間モデル（SSMs）の関連性を示し、SSMsと注意の変種との理論的接続を構築。新たに設計したMamba-2は、速度を2〜8倍向上させながら、Transformersと競争力を維持。</span>
<span class="snippet"><span>Comment</span>Mamba2の詳細を知りたい場合に読む</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Pruning.html">#Pruning</a>
<a class="button" href="articles/Distillation.html">#Distillation</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<span class="issue_date">Issue Date: 2025-03-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1804">Compact Language Models via Pruning and Knowledge Distillation, Saurav Muralidharan+, NeurIPS'24</a>
<span class="snippet"><span>Summary</span>本論文では、既存の大規模言語モデル（LLMs）をプルーニングし、少量のトレーニングデータで再トレーニングする手法を提案。深さ、幅、注意、MLPプルーニングを知識蒸留と組み合わせた圧縮ベストプラクティスを開発し、Nemotron-4ファミリーのLLMを2-4倍圧縮。これにより、トレーニングに必要なトークン数を最大40倍削減し、計算コストを1.8倍削減。Minitronモデルは、ゼロからトレーニングした場合と比較してMMLUスコアが最大16%改善され、他のモデルと同等の性能を示す。モデルの重みはオープンソース化され、補足資料も提供。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=9U0nLnNMJ7&referrer=%5Bthe%20profile%20of%20Pavlo%20Molchanov%5D(%2Fprofile%3Fid%3D~Pavlo_Molchanov1)<img src="https://github.com/user-attachments/assets/76ab1107-bf94-4cf1-9ad1-e9f494b917e7" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/d1bf8a84-5365-4d35-aae0-146b1860ed9d" alt="image" loading="lazy">

<br>



<br>

（あとでメモを追記）</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2025-03-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1802">Sparse Autoencoders Find Highly Interpretable Features in Language   Models, Hoagy Cunningham+, ICLR'24</a>
<span class="snippet"><span>Summary</span>神経ネットワークの多義性を解消するために、スパースオートエンコーダを用いて内部活性化の方向を特定。これにより、解釈可能で単義的な特徴を学習し、間接目的語の同定タスクにおける因果的特徴をより詳細に特定。スケーラブルで教師なしのアプローチが重ね合わせの問題を解決できることを示唆し、モデルの透明性と操作性向上に寄与する可能性を示す。</span>
<span class="snippet"><span>Comment</span>日本語解説:https://note.com/ainest/n/nbe58b36bb2dbOpenReview:https://openreview.net/forum?id=F76bwRSLeKSparseAutoEncoderはネットワークのあらゆるところに仕込める（と思われる）が、たとえばTransformer Blockのresidual connection部分のベクトルに対してFeature Dictionaryを学習すると、当該ブロックにおいてどのような特徴の組み合わせが表現されているかが（あくまでSparseAutoEncoderがreconstruction lossによって学習された結果を用いて）解釈できるようになる。

<br>

<img src="https://github.com/user-attachments/assets/f86f5f7b-f46d-48ab-94e3-cf7f298eb9d7" alt="image" loading="lazy">

<br>



<br>

SparseAutoEncoderは下記式で表され、下記loss functionで学習される。MがFeature Matrix（row-wiseに正規化されて後述のcに対するL1正則化に影響を与えないようにしている）に相当する。cに対してL1正則化をかけることで（Sparsity Loss）、c中の各要素が0に近づくようになり、結果としてcがSparseとなる（どうしても値を持たなければいけない重要な特徴量のみにフォーカスされるようになる）。

<br>

<img src="https://github.com/user-attachments/assets/7e400f25-8a63-4222-904c-4a7b94d50880" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/dd8c10b3-3bb5-46fb-b94a-d91f3602bbd1" alt="image" loading="lazy"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2025-03-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1785">Full Parameter Fine-tuning for Large Language Models with Limited Resources, Lv+, ACL'24, 2024.08</a>
<span class="snippet"><span>Summary</span>新しいオプティマイザ「LOMO」を提案し、勾配計算とパラメータ更新を1ステップで融合することでメモリ使用量を削減。これにより、24GBのメモリを持つ8台のRTX 3090で65Bモデルの全パラメータファインチューニングが可能に。メモリ使用量は標準的なアプローチと比較して10.8%削減。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/AutomaticPromptEngineering.html">#AutomaticPromptEngineering</a>
<span class="issue_date">Issue Date: 2025-02-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1752">PromptWizard: Task-Aware Prompt Optimization Framework, Eshaan Agarwal+, arXiv'24</a>
<span class="snippet"><span>Summary</span>PromptWizardは、完全自動化された離散プロンプト最適化フレームワークであり、自己進化的かつ自己適応的なメカニズムを利用してプロンプトの質を向上させる。フィードバック駆動の批評を通じて、タスク特有のプロンプトを生成し、45のタスクで優れたパフォーマンスを実現。限られたデータや小規模なLLMでも効果を発揮し、コスト分析により効率性とスケーラビリティの利点が示された。</span>
<span class="snippet"><span>Comment</span>Github:https://github.com/microsoft/PromptWizard?tab=readme-ov-file

<br>

元ポスト:https://x.com/tom_doerr/status/1888178173684199785?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q初期に提案された

<br>

・1034

<br>



<br>

と比較すると大分性能が上がってきているように見える。

<br>

<img src="https://github.com/user-attachments/assets/5f7a329e-e83b-46da-9213-af8877201572" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/857b3526-4f56-4e31-8a69-a4193657b286" alt="image" loading="lazy">reasoning modelではfewshot promptingをすると性能が落ちるという知見があるので、reasoningモデル向けのAPE手法もそのうち出現するのだろう（既にありそう）。OpenReview: https://openreview.net/forum?id=VZC9aJoI6a

<br>

ICLR'25にrejectされている</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenSource.html">#OpenSource</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-02-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1745">Tulu 3: Pushing Frontiers in Open Language Model Post-Training, Nathan Lambert+, arXiv'24</a>
<span class="snippet"><span>Summary</span>Tulu 3は、オープンなポストトレーニングモデルのファミリーで、トレーニングデータやレシピを公開し、現代のポストトレーニング技術のガイドを提供します。Llama 3.1を基にし、他のクローズドモデルを上回る性能を達成。新しいトレーニング手法としてSFT、DPO、RLVRを採用し、マルチタスク評価スキームを導入。モデルウェイトやデモ、トレーニングコード、データセットなどを公開し、他のドメインへの適応も可能です。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/icoxfog417/status/1885460713264775659?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Distillation.html">#Distillation</a>
<span class="issue_date">Issue Date: 2025-02-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1742">A Survey on Knowledge Distillation of Large Language Models, Xiaohan Xu+, arXiv'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）における知識蒸留（KD）の重要性を調査し、小型モデルへの知識伝達やモデル圧縮、自己改善の役割を強調。KDメカニズムや認知能力の向上、データ拡張（DA）との相互作用を検討し、DAがLLM性能を向上させる方法を示す。研究者や実務者に向けたガイドを提供し、LLMのKDの倫理的適用を推奨。関連情報はGithubで入手可能。</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2025-01-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1731">Don't Do RAG: When Cache-Augmented Generation is All You Need for  Knowledge Tasks, Brian J Chan+, arXiv'24</a>
<span class="snippet"><span>Summary</span>キャッシュ拡張生成（CAG）は、RAGの課題を克服するために提案された手法で、LLMの拡張コンテキストに事前に関連リソースをロードし、検索なしでクエリに応答する。CAGは検索の遅延を排除し、エラーを最小限に抑えつつ、コンテキストの関連性を維持。性能評価では、CAGが従来のRAGを上回るか補完することが示され、特に制約のある知識ベースにおいて効率的な代替手段となることが示唆されている。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/omarsar0/status/1876721221083214200?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q外部知識として利用したいドキュメントがそこまで大きく無いなら、事前にLLMで全てのKey Valueを計算しておきKV Cacheとして利用可能にしておけば、生成時に検索をすることもなく、contextとして利用して生成できるじゃん、という研究</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<span class="issue_date">Issue Date: 2025-01-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1729">[Paper Note] Chain of Agents: Large language models collaborating on long-context tasks, Google Research, 2025.01, NeurIPS'24</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/googleai/status/1882554959272849696?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLLMがどこまでいってもcontext長の制約に直面する問題に対してLLM Agentを組み合わせて対処しました、的な話な模様ブログ中にアプローチを解説した動画があるのでわかりやすいIs the experimental code open source?Thank you for your comment. I tried to find an official open-source implementation provided by the authors, but I was not able to locate one. In fact, I also checked the personal webpage of the first author, but there was no link to any released code.

<br>



<br>

Is seems that an unofficial implementation is listed under the “Code” tab on the NeurIPS page. I hope this is helpful. Thank you.

<br>



<br>

NeurIPS link: https://nips.cc/virtual/2024/poster/95563

<br>

openreview: https://openreview.net/forum?id=LuCLf4BJsr</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<span class="issue_date">Issue Date: 2025-01-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1724">Spectrum: Targeted Training on Signal to Noise Ratio, Eric Hartford+, arXiv'24</a>
<span class="snippet"><span>Summary</span>「Spectrum」という手法を提案し、SNRに基づいてレイヤーモジュールを選択的にターゲットにすることで、LLMのトレーニングを加速。これによりGPUメモリ使用量を削減しつつ、フルファインチューニングに匹敵する性能を実現。実験により、既存手法QLoRAと比較してモデルの品質とVRAM効率の向上が確認された。</span>
<span class="snippet"><span>Comment</span>・1723

<br>



<br>

によるとLLMのうち最もinformativeなLayerを見つけ、選択的に学習することで、省リソースで、Full-Parameter tuningと同等の性能を発揮する手法らしい

<br>



<br>

</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/KnowledgeEditing.html">#KnowledgeEditing</a>
<span class="issue_date">Issue Date: 2025-01-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1705">Learning to Edit: Aligning LLMs with Knowledge Editing, Yuxin Jiang+, ACL'24</a>
<span class="snippet"><span>Summary</span>「Learning to Edit（LTE）」フレームワークを提案し、LLMsに新しい知識を効果的に適用する方法を教える。二段階プロセスで、アライメントフェーズで信頼できる編集を行い、推論フェーズでリトリーバルメカニズムを使用。四つの知識編集ベンチマークでLTEの優位性と堅牢性を示す。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2025-01-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1699">OlympiadBench: A Challenging Benchmark for Promoting AGI with   Olympiad-Level Bilingual Multimodal Scientific Problems, Chaoqun He+, ACL'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）やマルチモーダルモデル（LMMs）の能力を測定するために、オリンピアドレベルのバイリンガルマルチモーダル科学ベンチマーク「OlympiadBench」を提案。8,476の数学と物理の問題を含み、専門家レベルの注釈が付けられている。トップモデルのGPT-4Vは平均17.97%のスコアを達成したが、物理では10.74%にとどまり、ベンチマークの厳しさを示す。一般的な問題として幻覚や論理的誤謬が指摘され、今後のAGI研究に貴重なリソースとなることが期待される。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2025-01-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1665">DeepSeekMoE: Towards Ultimate Expert Specialization in Mixture-of-Experts Language Models, Damai+, ACL'24, 2024.08</a>
<span class="snippet"><span>Summary</span>DeepSeekMoEアーキテクチャは、専門家の専門性を高めるために、専門家を細分化し柔軟な組み合わせを可能にし、共有専門家を設けて冗長性を軽減する。2BパラメータのDeepSeekMoEは、GShardと同等の性能を達成し、同じパラメータ数の密なモデルに近づく。16Bパラメータにスケールアップした際も、計算量を約40%に抑えつつ、LLaMA2と同等の性能を示した。</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RLHF.html">#RLHF</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-01-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1655">DeepSeekMath: Pushing the Limits of Mathematical Reasoning in Open  Language Models, Zhihong Shao+, arXiv'24</a>
<span class="snippet"><span>Summary</span>DeepSeekMath 7Bは、120Bの数学関連トークンを用いて事前学習された言語モデルで、競技レベルのMATHベンチマークで51.7%のスコアを達成。自己一貫性は60.9%で、データ選択パイプラインとGroup Relative Policy Optimization (GRPO)の導入により数学的推論能力が向上。Gemini-UltraやGPT-4に迫る性能を示す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://www.linkedin.com/posts/philipp-schmid-a6a2bb196_the-rlhf-method-behind-the-best-open-models-activity-7280850174522843137-3V9v?utm_source=share&utm_medium=member_ios元々数学のreasoningに関する能力を改善するために提案されたが、現在はオンラインでTruthfulness, Helpfulness, Concisenessなどの改善に活用されているとのこと。PPOとGRPOの比較。value function model（状態の価値を予測するモデル）が不要なため省メモリ、かつ利用する計算リソースが小さいらしい。

<br>

あとサンプルをグループごとに分けて、グループ内でのKLダイバージェンスが最小化されるよう（つまり、各グループ内で方策が類似する）Policy Modelが更新される（つまりloss functionに直接組み込まれる）点が違うらしい。

<br>



<br>

PPOでは生成するトークンごとにreference modelとPolicy ModelとのKLダイバージェンスをとり、reference modelとの差が大きくならないよう、報酬にペナルティを入れるために使われることが多いらしい。

<br>

<img src="https://github.com/user-attachments/assets/e145ad52-e6c9-4481-b2ee-10a3987ea2e3" alt="image" loading="lazy">下記記事によると、PPOで最大化したいのはAdvantage（累積報酬と状態価値（累積報酬の期待値を計算するモデル）の差分;期待値よりも実際の累積報酬が良かったら良い感じだぜ的な数値）であり、それには状態価値を計算するモデルが必要である。そして、PPOにおける状態価値モデルを使わないで、LLMにテキスト生成させて最終的な報酬を平均すれば状態価値モデル無しでAdvantageが計算できるし嬉しくね？という気持ちで提案されたのが、本論文で提案されているGRPOとのこと。勉強になる。

<br>



<br>

DeepSeek-R1の論文読んだ？【勉強になるよ】

<br>

, asap: https://zenn.dev/asap/articles/34237ad87f8511</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/RLHF.html">#RLHF</a>
<span class="issue_date">Issue Date: 2025-01-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1650">Does RLHF Scale? Exploring the Impacts From Data, Model, and Method, Zhenyu Hou+, arXiv'24</a>
<span class="snippet"><span>Summary</span>本研究では、LLMsにおけるRLHFのスケーリング特性を分析し、モデルサイズ、データ構成、推論予算がパフォーマンスに与える影響を調査。データの多様性と量の増加が報酬モデルの性能向上に寄与する一方、ポリシートレーニングでは応答サンプル数の増加が初期パフォーマンスを向上させるが、すぐに頭打ちになることが判明。RLHFは事前トレーニングより効率的にスケールせず、計算リソースの収益逓減が観察された。計算制限内でのRLHFパフォーマンス最適化戦略も提案。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dair_ai/status/1868299930600628451?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/Zero/FewShotPrompting.html">#Zero/FewShotPrompting</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-01-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1649">AutoReason: Automatic Few-Shot Reasoning Decomposition, Arda Sevinc+, arXiv'24</a>
<span class="snippet"><span>Summary</span>Chain of Thought（CoT）を用いて、暗黙のクエリを明示的な質問に分解することで、LLMの推論能力を向上させる自動生成システムを提案。StrategyQAとHotpotQAデータセットで精度向上を確認し、特にStrategyQAで顕著な成果を得た。ソースコードはGitHubで公開。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dair_ai/status/1868299926897074309?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/SyntheticDataGeneration.html">#SyntheticDataGeneration</a>
<span class="issue_date">Issue Date: 2025-01-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1648">MAG-V: A Multi-Agent Framework for Synthetic Data Generation and  Verification, Saptarshi Sengupta+, arXiv'24</a>
<span class="snippet"><span>Summary</span>MAG-Vというマルチエージェントフレームワークを提案し、顧客クエリを模倣したデータセットを生成してエージェントのパフォーマンスを向上させる。軌跡の検証手法は従来のMLモデルを上回り、GPT-4と同等の性能を示す。多様なタスクエージェントを統一するアプローチを提供。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dair_ai/status/1868299921117630528?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Controllable.html">#Controllable</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/PositionalEncoding.html">#PositionalEncoding</a>
<a class="button" href="articles/Length.html">#Length</a>
<span class="issue_date">Issue Date: 2025-01-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1646">Precise Length Control in Large Language Models, Bradley Butcher+, arXiv'24</a>
<span class="snippet"><span>Summary</span>本研究では、LLMの応答の長さを正確に制御するために、二次的な長さ差位置エンコーディング（LDPE）を用いたアプローチを提案。LDPEを組み込むことで、モデルは平均3トークン未満の誤差で望ましい長さで応答を終了できるようになる。また、柔軟な上限長さ制御を可能にするMax New Tokens++も導入。実験結果は、質問応答や文書要約において応答の質を維持しつつ正確な長さ制御が実現できることを示している。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dair_ai/status/1870821203780256178?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q・1647

<br>



<br>

などのEncoder-Decoderモデルで行われていたoutput lengthの制御をDecoder-onlyモデルでもやりました、という話に見える。</span>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2025-01-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1645">TheAgentCompany: Benchmarking LLM Agents on Consequential Real World  Tasks, Frank F. Xu+, arXiv'24</a>
<span class="snippet"><span>Summary</span>日常生活や仕事におけるAIエージェントの効果を測定するため、TheAgentCompanyというベンチマークを導入。AIエージェントは、ウェブブラウジングやコード実行などのタスクを自律的に行う能力を評価。テストの結果、最も競争力のあるエージェントはタスクの24%を自律的に完了できることが判明。簡単なタスクは自動化可能だが、難しい長期的なタスクは現行システムでは対応できないことが示された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dair_ai/status/1870821189809217921?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qソフトウェアエンジニアリングの企業の設定で現実に起こりうるな　175種類のタスクを定義してAI Agentを評価できるベンチマークTheAgentCompanyを提案。

<br>



<br>

<img src="https://github.com/user-attachments/assets/ef7b51d3-b4af-4171-a692-48fb2c2552ef" alt="image" loading="lazy">

<br>



<br>

既存のベンチマークより、多様で、実際のソフトウェアエンジニアリング企業でで起こりうる幅広いタスクを持ち、タスクの遂行のために同僚に対して何らかのインタラクションが必要で、達成のために多くのステップが必要でかつ個々のステップ（サブタスク）を評価可能で、多様なタスクを遂行するために必要な様々なインタフェースをカバーし、self hostingして結果を完全に再現可能なベンチマークとなっている模様。

<br>

<img src="https://github.com/user-attachments/assets/e5fbd6da-75d7-49e1-8c66-dc7950d443e4" alt="image" loading="lazy">

<br>



<br>

https://x.com/gneubig/status/1869735196700062089?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

（画像は著者ツイートより引用）プロプライエタリなモデルとOpenWeightなモデルでAI Agentとしての能力を評価した結果、Claude-3.5-sonnetは約24%のタスクを解決可能であり、他モデルと比べて性能が明らかに良かった。また、Gemini-2.0-flashなコストパフォーマンスに優れている。OpenWeightなモデルの中ではLlama3.3-70Bのコストパフォーマンスが良かった。タスクとしては具体的に評価可能なタスクのみに焦点を当てており、Open Endなタスクでは評価していない点に注意とのこと。

<br>

https://x.com/gneubig/status/1869735209404682706?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

https://x.com/gneubig/status/1869735213976432764?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

<img src="https://github.com/user-attachments/assets/3bdcabef-70da-4f09-8366-efe29f7ab371" alt="image" loading="lazy">まだまだAI Agentが完全に'同僚'として機能することとは現時点ではなさそうだが、このベンチマークのスコアが今後どこまで上がっていくだろうか。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<span class="issue_date">Issue Date: 2025-01-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1644">A Survey of Mathematical Reasoning in the Era of Multimodal Large  Language Model: Benchmark, Method &amp; Challenges, Yibo Yan+, arXiv'24</a>
<span class="snippet"><span>Summary</span>数学的推論は多くの分野で重要であり、AGIの進展に伴い、LLMsを数学的推論タスクに統合することが求められている。本調査は、2021年以降の200以上の研究をレビューし、マルチモーダル設定におけるMath-LLMsの進展を分析。分野をベンチマーク、方法論、課題に分類し、マルチモーダル数学的推論のパイプラインやLLMsの役割を探る。さらに、AGI実現の障害となる5つの課題を特定し、今後の研究方向性を示す。</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/KnowledgeGraph.html">#KnowledgeGraph</a>
<span class="issue_date">Issue Date: 2025-01-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1643">Can LLMs Convert Graphs to Text-Attributed Graphs?, Zehong Wang+, arXiv'24</a>
<span class="snippet"><span>Summary</span>Topology-Aware Node description Synthesis（TANS）を提案し、GNNが異なる特徴空間を持つグラフに適用できるようにする。TANSはLLMsを用いて既存のグラフをテキスト属性グラフに変換し、ノードの特性にトポロジー情報を統合。テキストがないグラフでも手動設計を超える性能を示し、LLMsの可能性を実証。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/omarsar0/status/1868691391129272461?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<span class="issue_date">Issue Date: 2025-01-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1641">How Much Data is Enough Data? Fine-Tuning Large Language Models for  In-House Translation: Performance Evaluation Across Multiple Dataset Sizes, Inacio Vieira+, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMsのファインチューニングに翻訳メモリ（TMs）を活用し、特定の組織向けの翻訳精度と効率を向上させる研究。5つの翻訳方向で異なるサイズのデータセットを用いて実験し、トレーニングデータが増えるほど翻訳パフォーマンスが向上することを確認。特に、1kおよび2kの例ではパフォーマンスが低下するが、データセットのサイズが増加するにつれて改善が見られる。LLMsとTMsの統合により、企業特有のニーズに応じたカスタマイズ翻訳モデルの可能性を示唆。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gyakuse/status/1874357127248306200?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QQLoRAでLlama 8B InstructをMTのデータでSFTした場合のサンプル数に対する性能の変化を検証している。ただし、検証しているタスクはMT、QLoRAでSFTを実施しrankは64、学習時のプロンプトは非常にシンプルなものであるなど、幅広い設定で学習しているわけではないので、ここで得られた知見が幅広く適用可能なことは示されていないであろう点、には注意が必要だと思われる。

<br>



<br>

この設定では、SFTで利用するサンプル数が増えれば増えるほど性能が上がっているように見える。

<br>



<br>

<img src="https://github.com/user-attachments/assets/71309a00-85fd-491f-a89e-c9cb99f4da6c" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/ea1eba38-9488-43e5-a64b-f997bf65f57b" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/21b21628-d589-4214-8860-680e392a2556" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<span class="issue_date">Issue Date: 2025-01-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1640">LoRA Learns Less and Forgets Less, Dan Biderman+, TMLR'24</a>
<span class="snippet"><span>Summary</span>LoRAは大規模言語モデルの効率的なファインチューニング手法であり、プログラミングと数学のドメインでの性能をフルファインチューニングと比較。標準的な設定ではLoRAは性能が劣るが、ターゲットドメイン外のタスクではベースモデルの性能を維持し、忘却を軽減する効果がある。フルファインチューニングはLoRAよりも高いランクの摂動を学習し、性能差の一因と考えられる。最終的に、LoRAのファインチューニングに関するベストプラクティスを提案。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gyakuse/status/1874357127248306200?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qfull finetuningとLoRAの性質の違いを理解するのに有用</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<span class="issue_date">Issue Date: 2025-01-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1639">FineTuneBench: How well do commercial fine-tuning APIs infuse knowledge  into LLMs?, Eric Wu+, arXiv'24</a>
<span class="snippet"><span>Summary</span>商業的なLLM微調整APIの効果を評価するためのFineTuneBenchを提案。5つの最前線のLLMを分析し、新しい情報の学習と既存知識の更新における能力を評価した結果、全モデルで平均一般化精度は37%、医療ガイドラインの更新では19%と低いことが判明。特にGPT-4o miniが最も効果的で、Gemini 1.5シリーズは能力が限られていた。商業的微調整サービスの信頼性に課題があることを示唆。データセットはオープンソースで提供。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gyakuse/status/1874357127248306200?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Catastrophic%20Forgetting.html">#Catastrophic Forgetting</a>
<span class="issue_date">Issue Date: 2025-01-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1638">Examining Forgetting in Continual Pre-training of Aligned Large Language  Models, Chen-An Li+, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMの継続的な事前学習がファインチューニングされたモデルに与える影響を調査し、壊滅的な忘却の現象を評価。出力形式や知識、信頼性の次元での実験結果が、特に繰り返しの問題における忘却の課題を明らかにする。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gyakuse/status/1874357127248306200?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<span class="issue_date">Issue Date: 2025-01-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1637">Generative AI for Synthetic Data Generation: Methods, Challenges and the  Future, Xu Guo+, arXiv'24</a>
<span class="snippet"><span>Summary</span>限られたデータのシナリオでLLMsを用いて合成データを生成する研究が増加しており、これは生成的AIの進展を示す。LLMsは実世界のデータと同等の性能を持ち、リソースが限られた課題に対する解決策となる。本論文では、タスク特化型のトレーニングデータ生成のための技術、評価方法、実用的応用、現在の制限、将来の研究の方向性について議論する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gyakuse/status/1874357127248306200?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<span class="issue_date">Issue Date: 2025-01-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1636">On LLMs-Driven Synthetic Data Generation, Curation, and Evaluation: A  Survey, Lin Long+, arXiv'24</a>
<span class="snippet"><span>Summary</span>深層学習におけるデータの量と質の問題に対し、LLMsが合成データ生成を通じて解決策を提供。しかし、現状の研究は統一されたフレームワークを欠き、表面的なものが多い。本論文では合成データ生成のワークフローを整理し、研究のギャップを明らかにし、今後の展望を示す。学術界と産業界のより体系的な探求を促進することを目指す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gyakuse/status/1874357127248306200?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2024-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1630">Mulberry: Empowering MLLM with o1-like Reasoning and Reflection via  Collective Monte Carlo Tree Search, Huanjin Yao+, arXiv'24</a>
<span class="snippet"><span>Summary</span>本研究では、MLLMを用いて質問解決のための推論ステップを学習する新手法CoMCTSを提案。集団学習を活用し、複数モデルの知識で効果的な推論経路を探索。マルチモーダルデータセットMulberry-260kを構築し、モデルMulberryを訓練。実験により提案手法の優位性を確認。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Education.html">#Education</a>
<a class="button" href="articles/EducationalDataMining.html">#EducationalDataMining</a>
<span class="issue_date">Issue Date: 2024-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1629">LearnLM: Improving Gemini for Learning, LearnLM Team+, arXiv'24</a>
<span class="snippet"><span>Summary</span>生成AIシステムは従来の情報提示に偏っているため、教育的行動を注入する「教育的指示の遵守」を提案。これにより、モデルの振る舞いを柔軟に指定でき、教育データを追加することでGeminiモデルの学習を向上。LearnLMモデルは、さまざまな学習シナリオで専門家から高く評価され、GPT-4oやClaude 3.5に対しても優れた性能を示した。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/TheoryOfMind.html">#TheoryOfMind</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2024-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1628">Explore Theory of Mind: Program-guided adversarial data generation for  theory of mind reasoning, Melanie Sclar+, arXiv'24</a>
<span class="snippet"><span>Summary</span>ExploreToMは、心の理論を評価するための多様で挑戦的なデータを生成するフレームワークであり、LLMsの限界をテストする。最先端のLLMsは、ExploreToM生成データに対して低い精度を示し、堅牢な評価の必要性を強調。ファインチューニングにより従来のベンチマークで精度向上を実現し、モデルの低パフォーマンスの要因を明らかにする。</span>
<span class="snippet"><span>Comment</span>おもしろそう。あとで読む</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2024-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1627">A Survey on LLM Inference-Time Self-Improvement, Xiangjue Dong+, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLM推論における自己改善技術を三つの視点から検討。独立した自己改善はデコーディングやサンプリングに焦点、文脈に応じた自己改善は追加データを活用、モデル支援の自己改善はモデル間の協力を通じて行う。関連研究のレビューと課題、今後の研究への洞察を提供。</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2024-12-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1624">RetroLLM: Empowering Large Language Models to Retrieve Fine-grained  Evidence within Generation, Xiaoxi Li+, arXiv'24</a>
<span class="snippet"><span>Summary</span>RetroLLMは、リトリーバルと生成を統合したフレームワークで、LLMsがコーパスから直接証拠を生成することを可能にします。階層的FM-インデックス制約を導入し、関連文書を特定することで無関係なデコーディング空間を削減し、前向きな制約デコーディング戦略で証拠の精度を向上させます。広範な実験により、ドメイン内外のタスクで優れた性能を示しました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/rohanpaul_ai/status/1872714703090401721?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q従来のRAGとの違いと、提案手法の概要

<br>

<img src="https://github.com/user-attachments/assets/cd237a17-52f8-429f-9553-d35a449982ff" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/3a355c20-ccd2-49a8-bed7-f84ea84af14c" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<span class="issue_date">Issue Date: 2024-12-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1616">A Survey on LLM-as-a-Judge, Jiawei Gu+, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMを評価者として利用する「LLM-as-a-Judge」の信頼性向上に関する調査。信頼性を確保するための戦略や評価方法論を提案し、新しいベンチマークを用いてサポート。実用的な応用や将来の方向性についても議論し、研究者や実務者の参考資料となることを目指す。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2024-12-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1598">VLR-Bench: Multilingual Benchmark Dataset for Vision-Language Retrieval  Augmented Generation, Hyeonseok Lim+, arXiv'24</a>
<span class="snippet"><span>Summary</span>視覚言語モデル（VLM）を評価するための新しいベンチマークVLR-Benchを提案。これは5つの入力パッセージを用いて、特定のクエリに対する有用な情報の判断能力をテストする。32,000の自動生成された指示からなるデータセットVLR-IFを構築し、VLMのRAG能力を強化。Llama3ベースのモデルで性能を検証し、両データセットはオンラインで公開。</span>
<span class="snippet"><span>Comment</span>Multilingual VLMを用いたRAGのベンチマークデータセット</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<span class="issue_date">Issue Date: 2024-12-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1597">Marco-o1: Towards Open Reasoning Models for Open-Ended Solutions, Yu Zhao+, arXiv'24</a>
<span class="snippet"><span>Summary</span>Marco-o1は、LRMの研究において、数学や物理学だけでなく、RLやオープンエンドの解決策にも重点を置いている。特に、o1モデルが基準が不明瞭な領域に一般化できるかを探求し、Chain-of-ThoughtファインチューニングやMCTS、反射メカニズムを活用して複雑な問題解決に最適化されている。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/bilzrd/status/1868568258468774048?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLarge Reasoning Model （LRM）という用語は初めて見た。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2024-12-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1594">When Benchmarks are Targets: Revealing the Sensitivity of Large Language   Model Leaderboards, Norah Alzahrani+, ACL'24</a>
<span class="snippet"><span>Summary</span>LLMのリーダーボードは、ベンチマークランキングに基づいてモデル選択を支援するが、ランキングは微細な変更に敏感であり、最大8位変動することがある。3つのベンチマーク摂動のカテゴリにわたる実験を通じて、この現象の原因を特定し、ハイブリッドスコアリング方法の利点を含むベストプラクティスを提案。単純な評価に依存する危険性を強調し、より堅牢な評価スキームの必要性を示した。</span>
<span class="snippet"><span>Comment</span>・1591

<br>



<br>

に日本語でのサマリが記載されているので参照のこと。

<br>



<br>

リーダーボードのバイアスを軽減した結果、どのLLMが最大パフォーマンスとみなされるようになったのだろうか？</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<span class="issue_date">Issue Date: 2024-12-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1593">BatchEval: Towards Human-like Text Evaluation, Peiwen Yuan+, ACL'24</a>
<span class="snippet"><span>Summary</span>BatchEvalという新しい評価パラダイムを提案し、LLMを用いた自動テキスト評価の問題を解決。バッチ単位での反復評価により、プロンプト設計の敏感さやノイズ耐性の低さを軽減。実験により、BatchEvalは最先端手法に対して10.5%の改善を示し、APIコストを64%削減。</span>
<span class="snippet"><span>Comment</span>・1591

<br>



<br>

に日本語によるサマリが掲載されているので参照のこと。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<span class="issue_date">Issue Date: 2024-12-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1592">Striking Gold in Advertising: Standardization and Exploration of Ad Text   Generation, Masato Mita+, ACL'24</a>
<span class="snippet"><span>Summary</span>自動広告テキスト生成（ATG）のために、標準化されたベンチマークデータセットCAMERAを提案。これにより、マルチモーダル情報の活用と業界全体での評価が促進される。9つのベースラインを用いた実験で、現状と課題を明らかにし、LLMベースの評価者と人間の評価の一致を探求。</span>
<span class="snippet"><span>Comment</span>広告文生成タスク（Ad Text Generation）は個々のグループのプロプライエタリデータでしか評価されてこなかったことと、そもそもタスク設定が十分に規定されていないので、その辺を整備したという話らしい。

<br>

特に広告文生成のための初のオープンデータなCAMERAを構築している。

<br>



<br>

データセットを作るだけでなく、既存の手法、古典的なものからLLMまででどの程度の性能まで到達しているか、さらにはROUGEやGPT-4を用いたLLM-as-a-Judgeのような自動評価手法をメタ評価し、人手評価とオンライン評価のどの程度代替になるかも分析したとのことらしい。Table5にメタ評価の結果が記載されている。システムレベルのcorrelationを測定している。興味深いのが、BLEU-4, ROUGE-1, BERTScoreなどの古典的or埋め込みベースのNLG評価手法がFaithfulnessとFluencyにおいて、人間の専門家と高い相関を示しているのに対し、GPT-4による評価では人間による評価と全然相関が出ていない。

<br>



<br>

既存のLLM-as-a-Judge研究では専門家と同等の評価できます、みたいな話がよく見受けられるがこれらの報告と結果が異なっていておもしろい。著者らは、OpenAIのGPTはそもそも広告ドメインとテキストでそんなに訓練されていなさそうなので、ドメインのミスマッチが一つの要因としてあるのではないか、と考察している。

<br>



<br>

また、Attractivenessでは専門家による評価と弱い相関しか示していない点も興味深い。広告文がどの程度魅力的かはBLEU, ROUGE, BERTScoreあたりではなかなか難しそうなので、GPT4による評価がうまくいって欲しいところだが、全くうまくいっていない。この論文の結果だけを見ると、（Attractivenessに関しては）自動評価だけではまだまだ広告文の評価は厳しそうに見える。

<br>



<br>

<img src="https://github.com/user-attachments/assets/15804ddc-3131-4a3d-9071-a66473e0e987" alt="image" loading="lazy">GPT4によるAttractivenessの評価に利用したプロンプトが下記。MTBenchっぽく、ペアワイズの分類問題として解いていることがわかる。この辺はLLM-as-a-Judgeの研究では他にもスコアトークンを出力し尤度で重みづけるG-Evalをはじめ、さまざまな手法が提案されていると思うので、その辺の手法を利用したらどうなるかは興味がある。

<br>

あとはそもそも手法面の話以前に、promptのコンテキスト情報としてどのような情報がAttractivenessの評価に重要か？というのも明らかになると興味深い。この辺は、サイバーエージェントの専門家部隊が、どのようなことを思考してAttractivenessを評価しているのか？というのがヒントになりそうである。

<br>

<img src="https://github.com/user-attachments/assets/5c0d3989-d4c1-4d61-b592-b1140c4cf93d" alt="image" loading="lazy">

<br>

・1591

<br>



<br>

に著者によるサマリが記載されているので参照のこと。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<span class="issue_date">Issue Date: 2024-12-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1590">The broader spectrum of in-context learning, Andrew Kyle Lampinen+, arXiv'24</a>
<span class="snippet"><span>Summary</span>本研究では、言語モデルの少数ショット学習をメタ学習に基づく文脈内学習の一部として位置づけ、文脈が予測の損失を減少させるメカニズムを提案します。この視点は、言語モデルの文脈内能力を統一し、一般化の重要性を強調します。一般化は新しい学習だけでなく、異なる提示からの学びや適用能力にも関連し、過去の文献との関連性も議論されます。文脈内学習の研究は、広範な能力と一般化のタイプを考慮すべきと結論付けています。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=RHo3VVi0i5

<br>



<br>

OpenReviewによると、

<br>

論文は理解しやすく、meta learningについて広範にサーベイされている。しかし、論文が定義しているICLの拡張はICLを過度に一般化し過ぎており（具体的に何がICLで何がICLでないのか、といった規定ができない）、かつ論文中で提案されているコンセプトを裏付ける実験がなくspeculativeである、とのことでrejectされている。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-12-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1589">Phi-4 Technical Report, Marah Abdin+, arXiv'24</a>
<span class="snippet"><span>Summary</span>140億パラメータの言語モデル「phi-4」は、合成データを取り入れたトレーニングにより、STEMに特化したQA能力で教師モデルを大幅に上回る性能を示す。phi-3のアーキテクチャを最小限に変更しただけで、推論ベンチマークにおいても改善されたデータとトレーニング手法により強力なパフォーマンスを達成。</span>
<span class="snippet"><span>Comment</span>現状Azureでのみ利用可能かも。Huggingfaceにアップロードされても非商用ライセンスになるという噂もMITライセンス

<br>

HuggingFace:

<br>

https://huggingface.co/microsoft/phi-4</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/LatentReasoning.html">#LatentReasoning</a>
<span class="issue_date">Issue Date: 2024-12-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1586">Training Large Language Models to Reason in a Continuous Latent Space, Shibo Hao+, arXiv'24</a>
<span class="snippet"><span>Summary</span>新しい推論パラダイム「Coconut」を提案し、LLMの隠れ状態を連続的思考として利用。これにより、次の入力を連続空間でフィードバックし、複数の推論タスクでLLMを強化。Coconutは幅優先探索を可能にし、特定の論理推論タスクでCoTを上回る性能を示す。潜在的推論の可能性を探る重要な洞察を提供。</span>
<span class="snippet"><span>Comment</span>Chain of Continuous Thought...?通常のCoTはRationaleをトークン列で生成するが、Coconutは最終的なhidden state（まだ読んでないのでこれが具体的に何を指すか不明）をそのまま入力に追加することで、トークンに制限されずにCoTさせるということらしい。あとでしっかり読む

<br>

<img src="https://github.com/user-attachments/assets/b930f44b-96f4-47cd-aa1a-0b5fabde54a5" alt="image" loading="lazy">まだ読んでいないが、おそらく学習の際に工夫が必要なので既存モデルをこねくり回してできます系の話ではないかもOpenReview:https://openreview.net/forum?id=tG4SgayTtk

<br>



<br>

ICLR'25にrejectされている。

<br>

ざっと最初のレビューに書かれているWeaknessを読んだ感じ

<br>

・評価データが合成データしかなく、よりrealisticなデータで評価した方が良い

<br>

・CoTら非常に一般的に適用可能な技術なので、もっと広範なデータで評価すべき

<br>

・GSM8Kでは大幅にCOCONUTはCoTに性能が負けていて、ProsQAでのみにしかCoTに勝てていない

<br>

・特定のデータセットでの追加の学習が必要で、そこで身につけたreasoning能力が汎化可能か明らかでない

<br>



<br>

といった感じに見える</span>
<a class="button" href="articles/Multi.html">#Multi</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2024-12-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1578">Auto-RAG: Autonomous Retrieval-Augmented Generation for Large Language  Models, Tian Yu+, arXiv'24</a>
<span class="snippet"><span>Summary</span>Auto-RAGは、LLMの意思決定能力を活用した自律的な反復検索モデルで、リトリーバーとのマルチターン対話を通じて知識を取得します。推論に基づく意思決定を自律的に合成し、6つのベンチマークで優れた性能を示し、反復回数を質問の難易度に応じて調整可能です。また、プロセスを自然言語で表現し、解釈可能性とユーザー体験を向上させます。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/omarsar0/status/1863600141103501454?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QOpenReview:https://openreview.net/forum?id=jkVQ31GeIAOpenReview:https://openreview.net/forum?id=jkVQ31GeIA</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<span class="issue_date">Issue Date: 2024-12-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1575">LLMs Will Always Hallucinate, and We Need to Live With This, Sourav Banerjee+, arXiv'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLM）の幻覚は偶発的なエラーではなく、これらのモデルの基本的な構造から生じる避けられない特徴であると主張。アーキテクチャやデータセットの改善では幻覚を排除できないことを示し、各プロセス段階で幻覚が生成される確率が存在することを分析。新たに「構造的幻覚」という概念を導入し、幻覚の数学的確実性を確立することで、完全な軽減は不可能であると論じる。</span>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<a class="button" href="articles/Conversation.html">#Conversation</a>
<span class="issue_date">Issue Date: 2024-12-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1573">事実正誤判定が不要な生成応答の検出に向けた データセットの収集と分析, rryohei Kamei+, NLP'24, 2024.03</a>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Quantization.html">#Quantization</a>
<span class="issue_date">Issue Date: 2024-12-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1566">The Super Weight in Large Language Models, Mengxia Yu+, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMのパラメータの一部がモデルの品質に不均衡に重要であり、1つのパラメータの剪定でテキスト生成能力が大幅に低下することを発見。データフリーの方法で重要なスーパーパラメータを特定し、これにより四捨五入量子化の精度を向上させることができる。スーパーパラメータに関する研究を促進するために、オープンアクセスのLLMに対するインデックスを提供。</span>
<span class="snippet"><span>Comment</span>図にある通り、たった一つのニューラルネットワーク中の重みを0にするだけで、途端に意味のあるテキストが生成できなくなるような重みが存在するらしい。

<br>

<img src="https://github.com/user-attachments/assets/065e921b-c447-4c0d-b1de-a2f79bd090f8" alt="image" loading="lazy">

<br>



<br>



<br>

（図は論文より引用）ICLR 2025のOpenreview

<br>

https://openreview.net/forum?id=0Ag8FQ5Rr3</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2024-12-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1561">Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge  Conflicts for Large Language Models, Fei Wang+, arXiv'24</a>
<span class="snippet"><span>Summary</span>Astute RAGは、外部知識の不完全な取得による問題を解決する新しいアプローチで、LLMsの内部知識と外部知識を適応的に統合し、情報の信頼性に基づいて回答を決定します。実験により、Astute RAGは従来のRAG手法を大幅に上回り、最悪のシナリオでもLLMsのパフォーマンスを超えることが示されました。</span>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/AES(AutomatedEssayScoring).html">#AES(AutomatedEssayScoring)</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2024-11-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1556">Japanese-English Sentence Translation Exercises Dataset for Automatic Grading, Miura+, EACL'24, 2024.03</a>
<span class="snippet"><span>Summary</span>第二言語学習の文翻訳演習の自動評価タスクを提案し、評価基準に基づいて学生の回答を採点する。日本語と英語の間で3,498の学生の回答を含むデータセットを作成。ファインチューニングされたBERTモデルは約90%のF1スコアで正しい回答を分類するが、誤った回答は80%未満。少数ショット学習を用いたGPT-3.5はBERTより劣る結果を示し、提案タスクが大規模言語モデルにとっても難しいことを示す。</span>
<span class="snippet"><span>Comment</span>STEsの図解。分かりやすい。いわゆる日本人が慣れ親しんでいる和文英訳、英文和訳演習も、このタスクの一種だということなのだろう。2-shotのGPT4とFinetuningしたBERTが同等程度の性能に見えて、GPT3.5では5shotしても勝てていない模様。興味深い。

<br>

<img src="https://github.com/user-attachments/assets/7f2f824c-91cb-4935-af53-75f1b72912bc" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<span class="issue_date">Issue Date: 2024-11-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1550">From Generation to Judgment: Opportunities and Challenges of  LLM-as-a-judge, Dawei Li+, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMを用いた判断と評価の新たなパラダイム「LLM-as-a-judge」に関する包括的な調査を行い、定義や分類法を提示。評価のためのベンチマークをまとめ、主要な課題と今後の研究方向を示す。関連リソースも提供。</span>
<span class="snippet"><span>Comment</span>LLM-as-a-Judgeに関するサーベイ

<br>

<img src="https://github.com/user-attachments/assets/88059cc4-123e-4a89-ac2d-4b3db83cd2df" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/10fea773-e52b-4e67-9137-dfc51846988b" alt="image" loading="lazy">・1214

<br>



<br>

も参照のこと</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2024-11-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1549">Does Prompt Formatting Have Any Impact on LLM Performance?, Jia He+, arXiv'24</a>
<span class="snippet"><span>Summary</span>プロンプト最適化はLLMの性能に重要であり、異なるプロンプトテンプレートがモデルの性能に与える影響を調査。実験では、GPT-3.5-turboがプロンプトテンプレートによってコード翻訳タスクで最大40%変動する一方、GPT-4はより堅牢であることが示された。これにより、固定プロンプトテンプレートの再考が必要であることが強調された。</span>
<span class="snippet"><span>Comment</span>（以下、個人の感想です）

<br>

本文のみ斜め読みして、Appendixは眺めただけなので的外れなことを言っていたらすみません。

<br>



<br>

まず、実務上下記知見は有用だと思いました:

<br>

・プロンプトのフォーマットによって性能に大きな差がある

<br>

・より大きいモデルの方がプロンプトフォーマットに対してロバスト

<br>



<br>

ただし、フォーマットによって性能差があるというのは経験的にある程度LLMを触っている人なら分かることだと思うので、驚きは少なかった。

<br>



<br>

個人的に気になる点は、学習データもモデルのアーキテクチャもパラメータ数も分からないGPT3.5, GPT4のみで実験をして「パラメータサイズが大きい方がロバスト」と結論づけている点と、もう少し深掘りして考察したらもっとおもしろいのにな、と感じる点です。

<br>



<br>

実務上は有益な知見だとして、では研究として見たときに「なぜそうなるのか?」というところを追求して欲しいなぁ、という感想を持ちました。

<br>

たとえば、「パラメータサイズが大きいモデルの方がフォーマットにロバスト」と論文中に書かれているように見えますが、

<br>

それは本当にパラメータサイズによるものなのか？学習データに含まれる各フォーマットの割合とか（これは事実はOpenAIの中の人しか分からないので、学習データの情報がある程度オープンになっているOpenLLMでも検証するとか）、評価するタスクとフォーマットの相性とか、色々と考察できる要素があるのではないかと思いました。

<br>

その上で、大部分のLLMで普遍的な知見を見出した方が研究としてより面白くなるのではないか、と感じました。

<br>



<br>

<img src="https://github.com/user-attachments/assets/d0a6c727-1253-4503-93f2-8daa4db2321b" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/b7166b2b-b848-43f5-a823-7ed491232234" alt="image" loading="lazy">参考: Data2Textにおける数値データのinput formatによる性能差を分析し考察している研究

<br>

・1267</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2024-11-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1548">Generative Agent Simulations of 1,000 People, Joon Sung Park+, arXiv'24</a>
<span class="snippet"><span>Summary</span>新しいエージェントアーキテクチャを提案し、1,052人の実在の個人の態度と行動を85%の精度で再現。大規模言語モデルを用いた質的インタビューに基づき、参加者の回答を正確にシミュレート。人口統計的説明を用いたエージェントと比較して、精度バイアスを軽減。個人および集団の行動調査の新しいツールを提供。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<span class="issue_date">Issue Date: 2024-11-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1542">Multimodal Autoregressive Pre-training of Large Vision Encoders, Enrico Fini+, arXiv'24</a>
<span class="snippet"><span>Summary</span>新しい手法AIMV2を用いて、大規模なビジョンエンコーダの事前学習を行う。これは画像とテキストを組み合わせたマルチモーダル設定に拡張され、シンプルな事前学習プロセスと優れた性能を特徴とする。AIMV2-3BエンコーダはImageNet-1kで89.5%の精度を達成し、マルチモーダル画像理解において最先端のコントラストモデルを上回る。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2024-11-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1540">Observational Scaling Laws and the Predictability of Language Model  Performance, Yangjun Ruan+, arXiv'24</a>
<span class="snippet"><span>Summary</span>言語モデルの性能を理解するために、約100の公開モデルからスケーリング法則を構築する新しい観察アプローチを提案。モデルファミリー間の能力変動を考慮し、性能が低次元の能力空間の関数であることを示す。これにより、複雑なスケーリング現象の予測可能性を示し、GPT-4のエージェント性能を非エージェント的ベンチマークから予測できることを明らかにし、Chain-of-ThoughtやSelf-Consistencyの影響を予測する方法を示す。</span>
<span class="snippet"><span>Comment</span>縦軸がdownstreamタスクの主成分（のうち最も大きい80%を説明する成分）の変化（≒LLMの性能）で、横軸がlog scaleの投入計算量。

<br>

Qwenも頑張っているが、投入データ量に対する性能（≒データの品質）では、先駆け的な研究であるPhiがやはり圧倒的?

<br>

<img src="https://github.com/user-attachments/assets/c38286df-37c1-4c72-832f-676832845c0e" alt="image" loading="lazy">・766

<br>



<br>

も参照のこと</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2024-11-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1530">Likelihood as a Performance Gauge for Retrieval-Augmented Generation, Tianyu Liu+, arXiv'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデルを用いた情報検索強化生成は、文脈内の文書の順序に影響を受けやすい。研究では、質問の確率がモデルのパフォーマンスに与える影響を分析し、正確性との相関関係を明らかにした。質問の確率を指標として、プロンプトの選択と構築に関する2つの方法を提案し、その効果を実証。確率に基づく手法は効率的で、少ないモデルのパスで応答を生成できるため、プロンプト最適化の新たな方向性を示す。</span>
<span class="snippet"><span>Comment</span>トークンレベルの平均値をとった生成テキストの対数尤度と、RAGの回答性能に関する分析をした模様。

<br>

<img src="https://github.com/user-attachments/assets/ac03c0b6-b16c-4992-8446-2f56bad09ab2" alt="image" loading="lazy">

<br>



<br>

とりあえず、もし「LLMとしてGPTを（OpenAIのAPIを用いて）使いました！temperatureは0です！」みたいな実験設定だったら諸々怪しくなる気がしたのでそこが大丈夫なことを確認した（OpenLLM、かつdeterministicなデコーディング方法が望ましい）。おもしろそう。

<br>



<br>

<img src="https://github.com/user-attachments/assets/9ba2bdc7-f6e5-4b9c-aca4-3d461c78a046" alt="image" loading="lazy">参考: [RAGのハルシネーションを尤度で防ぐ, sasakuna, 2024.11.19](https://zenn.dev/knowledgesense/articles/7c47e1796e96c0)参考

<br>



<br>

生成されたテキストの尤度を用いて、どの程度正解らしいかを判断する、といった話は

<br>

・1223

<br>



<br>

のようなLLM-as-a-Judgeでも行われている。

<br>



<br>

G-Evalでは1--5のスコアのような離散的な値を生成する際に、これらを連続的なスコアに補正するために、尤度（トークンの生成確率）を用いている。

<br>

ただし、G-Evalの場合は実験でGPTを用いているため、モデルから直接尤度を取得できず、代わりにtemperature1とし、20回程度生成を行った結果からスコアトークンの生成確率を擬似的に計算している。

<br>



<br>

G-Evalの設定と比較すると（当時はつよつよなOpenLLMがなかったため苦肉の策だったと思われるが）、こちらの研究の実験設定の方が望ましいと思う。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<span class="issue_date">Issue Date: 2024-11-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1529">Multilingual Large Language Models: A Systematic Survey, Shaolin Zhu+, arXiv'24</a>
<span class="snippet"><span>Summary</span>本論文は、多言語大規模言語モデル（MLLMs）の最新研究を調査し、アーキテクチャや事前学習の目的、多言語能力の要素を論じる。データの質と多様性が性能向上に重要であることを強調し、MLLMの評価方法やクロスリンガル知識、安全性、解釈可能性について詳細な分類法を提示。さらに、MLLMの実世界での応用を多様な分野でレビューし、課題と機会を強調する。関連論文は指定のリンクで公開されている。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/user-attachments/assets/0b86445f-b974-459c-94f0-a80f5e2bbc9a" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/0d03af89-23b0-4b4b-972a-bbe4320d4f0c" alt="image" loading="lazy"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2024-11-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1524">Balancing Speed and Stability: The Trade-offs of FP8 vs. BF16 Training  in LLMs, Kazuki Fujii+, arXiv'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）は、その言語理解能力と適用可能性から注目を集めており、特にLlama 3シリーズは4050億パラメータを持つ。トレーニングの効率化が求められる中、NVIDIAのH100 GPUはFP8フォーマットを導入し、トレーニング時間を短縮する可能性がある。初期研究ではFP8が性能を損なわずに効率を向上させることが示唆されているが、トレーニングの安定性や下流タスクへの影響はまだ不明である。本研究は、LLMsのトレーニングにおけるBF16とFP8のトレードオフを探る。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/okoge_kaz/status/1857639065421754525?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QFP8で継続的事前学習をするとスループットは向上するが、lossのスパイクを生じたり、downstreamタスクの性能がBF16よりも低下したりする（日本語と英語の両方）との報告のようである。現状アブストと付録しか記載がないが、内容はこれから更新されるのだろうか。

<br>



<br>

<img src="https://github.com/user-attachments/assets/8d60d59b-de00-483a-bff0-04a4145715c1" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<span class="issue_date">Issue Date: 2024-11-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1523">Understanding LLMs: A Comprehensive Overview from Training to Inference, Yiheng Liu+, arXiv'24</a>
<span class="snippet"><span>Summary</span>ChatGPTの普及に伴い、LLMsのコスト効率の良いトレーニングとデプロイメントへの関心が高まっている。本論文では、LLMsのトレーニング技術と推論デプロイメント技術の進化をレビューし、データ前処理やモデル圧縮などのさまざまな側面を議論する。また、LLMsの利用方法と将来の発展についての洞察も提供する。</span>
<span class="snippet"><span>Comment</span>[Perplexity（参考;Hallucinationに注意）](https://www.perplexity.ai/search/yi-xia-nolun-wen-wodu-minei-ro-7vGwDK_AQX.HDO7j9H8iNA)単なるLLMの理論的な説明にとどまらず、実用的に必要な各種並列処理技術、Mixed Precision、Offloadingなどのテクニックもまとまっているのがとても良いと思う。LLM Frameworkのところに、メジャーなものが網羅されていないように感じる。たとえば、UnslothやLiger-KernelなどはTransformersの部分で言及されてても良いのでは、と感じる。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2024-11-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1522">The Geometry of Concepts: Sparse Autoencoder Feature Structure, Yuxiao Li+, arXiv'24</a>
<span class="snippet"><span>Summary</span>スパースオートエンコーダは、高次元ベクトルの辞書を生成し、概念の宇宙に三つの興味深い構造を発見した。1) 小規模構造では、平行四辺形や台形の「結晶」があり、単語の長さなどの干渉を除去することで質が改善される。2) 中規模構造では、数学とコードの特徴が「葉」を形成し、空間的局所性が定量化され、特徴が予想以上に集まることが示された。3) 大規模構造では、特徴点雲が各向同性でなく、固有値のべき法則を持ち、クラスタリングエントロピーが層に依存することが定量化された。</span>
<span class="snippet"><span>Comment</span>参考: https://ledge.ai/articles/llm_conceptual_structure_sae[Perplexity（参考;Hallucinationに注意）](https://www.perplexity.ai/search/yi-xia-nolun-wen-wodu-minei-ro-kR626A9_R8.6CU7IKvGyhQ)</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2024-11-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1516">Language Models are Hidden Reasoners: Unlocking Latent Reasoning  Capabilities via Self-Rewarding, Haolin Chen+, arXiv'24</a>
<span class="snippet"><span>Summary</span>LaTRO（LaTent Reasoning Optimization）を提案し、LLMの推論能力を向上させる新しいフレームワークを構築。推論を潜在分布からのサンプリングとして定式化し、外部フィードバックなしで推論プロセスと質を同時に改善。GSM8KおよびARC-Challengeデータセットで実験し、平均12.5%の精度向上を達成。事前学習されたLLMの潜在的な推論能力を引き出すことが可能であることを示唆。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/haolinchen11/status/1856150958772040165?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QOpenReview:https://openreview.net/forum?id=4Po8d9GAfQ&referrer=%5Bthe%20profile%20of%20Ricky%20Ho%5D(%2Fprofile%3Fid%3D~Ricky_Ho2)</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<span class="issue_date">Issue Date: 2024-11-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1509">A Theoretical Understanding of Chain-of-Thought: Coherent Reasoning and  Error-Aware Demonstration, Yingqian Cui+, arXiv'24</a>
<span class="snippet"><span>Summary</span>Few-shot Chain-of-Thought (CoT) プロンプティングはLLMsの推論能力を向上させるが、従来の研究は推論プロセスを分離された文脈内学習に依存している。本研究では、初期ステップからの一貫した推論（Coherent CoT）を統合することで、トランスフォーマーのエラー修正能力と予測精度を向上させることを理論的に示す。実験により、正しい推論経路と誤った推論経路を組み込むことでCoTを改善する提案の有効性を検証する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_philschmid/status/1855926845855699311?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

おもしろそうな研究</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Subword.html">#Subword</a>
<a class="button" href="articles/Tokenizer.html">#Tokenizer</a>
<span class="issue_date">Issue Date: 2024-11-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1507">LBPE: Long-token-first Tokenization to Improve Large Language Models, Haoran Lian+, arXiv'24</a>
<span class="snippet"><span>Summary</span>LBPEは、長いトークンを優先する新しいエンコーディング手法で、トークン化データセットにおける学習の不均衡を軽減します。実験により、LBPEは従来のBPEを一貫して上回る性能を示しました。</span>
<span class="snippet"><span>Comment</span>BPEとは異なりトークンの長さを優先してマージを実施することで、最終的なトークンを決定する手法で、

<br>

<img src="https://github.com/user-attachments/assets/99b91472-88d8-4792-bf04-acc67956e4f5" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/99103316-bd1c-448d-b52a-5db815298e7e" alt="image" loading="lazy">

<br>



<br>

BPEよりも高い性能を獲得し、

<br>

<img src="https://github.com/user-attachments/assets/c7dccf00-b9c2-4739-82f3-4f8eeacd4fc7" alt="image" loading="lazy">

<br>



<br>

トークンの長さがBPEと比較して長くなり、かつ5Bトークン程度を既存のBPEで事前学習されたモデルに対して継続的事前学習するだけで性能を上回るようにでき、

<br>

<img src="https://github.com/user-attachments/assets/10f4ff2e-1d49-4c8a-87ec-67466bdce2f0" alt="image" loading="lazy">

<br>



<br>

同じVocabサイズでBPEよりも高い性能を獲得できる手法

<br>

<img src="https://github.com/user-attachments/assets/5e19fc11-10f6-467a-ae06-8fb62b5f0a65" alt="image" loading="lazy">

<br>



<br>

らしい</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/SpeechProcessing.html">#SpeechProcessing</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<span class="issue_date">Issue Date: 2024-11-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1505">Mixture-of-Transformers: A Sparse and Scalable Architecture for  Multi-Modal Foundation Models, Weixin Liang+, arXiv'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）のマルチモーダル処理を効率化するために、Mixture-of-Transformers（MoT）を提案。MoTは計算コストを削減し、モダリティごとにパラメータを分離して特化した処理を実現。Chameleon 7B設定では、55.8%のFLOPsで密なベースラインに匹敵する性能を示し、音声を含む場合も37.2%のFLOPsで同様の結果を達成。さらに、Transfusion設定では、7BのMoTモデルが密なベースラインの画像性能に対してFLOPsの3分の1で匹敵し、760Mのモデルは主要な画像生成指標で上回る結果を得た。MoTは実用的な利点も示し、画像品質を47.2%、テキスト品質を75.6%の経過時間で達成。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/user-attachments/assets/340ab176-7b17-467a-8731-20d1594d6951" alt="image" loading="lazy"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<span class="issue_date">Issue Date: 2024-11-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1504">DELIFT: Data Efficient Language model Instruction Fine Tuning, Ishika Agarwal+, arXiv'24</a>
<span class="snippet"><span>Summary</span>DELIFTという新しいアルゴリズムを提案し、ファインチューニングの各ステージでデータ選択を最適化。ペアワイズユーティリティメトリックを用いてデータの有益性を定量化し、最大70%のデータ削減を実現。計算コストを大幅に節約し、既存の方法を上回る効率性と効果を示す。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2024-11-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1503">GUI Agents with Foundation Models: A Comprehensive Survey, Shuai Wang+, arXiv'24</a>
<span class="snippet"><span>Summary</span>(M)LLMを活用したGUIエージェントの研究を統合し、データセット、フレームワーク、アプリケーションの革新を強調。重要なコンポーネントをまとめた統一フレームワークを提案し、商業アプリケーションを探求。課題を特定し、今後の研究方向を示唆。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/user-attachments/assets/999adca8-f0d7-483c-ae5a-b6f78fe9da4b" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/b69dc991-3e15-4965-a183-cc7909ad9eba" alt="image" loading="lazy">Referenceやページ数はサーベイにしては少なめに見える。</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<span class="issue_date">Issue Date: 2024-11-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1501">Scaling LLM Test-Time Compute Optimally can be More Effective than  Scaling Model Parameters, Charlie Snell+, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMの推論時の計算をスケーリングすることで、挑戦的なプロンプトに対するパフォーマンスを改善する方法を研究。特に、密なプロセスベースの検証者報酬モデルとプロンプトに応じた応答の適応的更新を分析。プロンプトの難易度によって効果が変化し、計算最適戦略を適用することで効率を4倍以上向上。さらに、テスト時計算を用いることで小さなモデルが大きなモデルを上回ることが示された。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/user-attachments/assets/0562a65e-b2f1-4ff4-b806-107313fc255e" alt="image" loading="lazy">[Perplexity（参考;Hallucinationに注意）](https://www.perplexity.ai/search/yi-xia-noyan-jiu-wodu-mi-nei-r-1e1euXgLTH.G0Wlp.V2iqA)</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/API.html">#API</a>
<span class="issue_date">Issue Date: 2024-11-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1499">Beyond Browsing: API-Based Web Agents, Yueqi Song+, arXiv'24</a>
<span class="snippet"><span>Summary</span>APIを利用するAIエージェントの研究を行い、従来のウェブブラウジングエージェントと比較。API呼び出しエージェントはオンラインタスクをAPI経由で実行し、ハイブリッドエージェントはウェブブラウジングとAPIの両方を活用。実験結果では、ハイブリッドエージェントが他のエージェントを上回り、タスク非依存の最先端パフォーマンスを達成。APIの利用がウェブブラウジングよりも優れた選択肢であることを示唆。</span>
<span class="snippet"><span>Comment</span>CMUの研究。後で読みたい</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2024-11-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1497">HyQE: Ranking Contexts with Hypothetical Query Embeddings, Weichao Zhou+, arXiv'24</a>
<span class="snippet"><span>Summary</span>リトリーバル拡張システムにおいて、LLMのファインチューニングを必要とせず、埋め込みの類似性とLLMの能力を組み合わせたスケーラブルなランキングフレームワークを提案。ユーザーのクエリに基づいて仮定されたクエリとの類似性でコンテキストを再順位付けし、推論時に効率的で他の技術とも互換性がある。実験により、提案手法がランキング性能を向上させることを示した。</span>
<span class="snippet"><span>Comment</span>・1498 も参照のこと。

<br>



<br>



<br>



<br>

下記に試しにHyQEとHyDEの比較の記事を作成したのでご参考までに（記事の内容に私は手を加えていないのでHallucinationに注意）。ざっくりいうとHyDEはpseudo documentsを使うが、HyQEはpseudo queryを扱う。

<br>



<br>



<br>



<br>

[参考: Perplexity Pagesで作成したHyDEとの簡単な比較の要約](https://www.perplexity.ai/page/hyqelun-wen-nofen-xi-toyao-yue-aqZZj8mDQg6NL1iKml7.eQ)<img src="https://github.com/user-attachments/assets/f757781c-036c-440d-b1b8-c5f255039479" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/NumericReasoning.html">#NumericReasoning</a>
<span class="issue_date">Issue Date: 2024-11-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1495">Number Cookbook: Number Understanding of Language Models and How to  Improve It, Haotong Yang+, arXiv'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）の数値理解および処理能力（NUPA）を調査し、41の数値タスクを含むベンチマークを導入。多くのタスクでLLMsが失敗することを確認し、NUPA向上のための技術を用いて小規模モデルを訓練。ファインチューニングによりNUPAが改善されるが、すべてのタスクには効果がないことが判明。思考の連鎖技術の影響も探求。研究はLLMsのNUPA改善に向けた初歩的なステップを示す。</span>
<span class="snippet"><span>Comment</span>んー、abstしか読んでいないけれども、9.11 &gt; 9.9 については、このような数字に慣れ親しんでいるエンジニアなどに咄嗟に質問したら、ミスして答えちゃう人もいるのでは？という気がする（エンジニアは脳内で9.11 &gt; 9.9を示すバージョン管理に触れる機会が多く、こちらの尤度が高い）。

<br>



<br>

LLMがこのようなミス（てかそもそもミスではなく、回答するためのcontextが足りてないので正解が定義できないだけ、だと思うが、、）をするのは、単に学習データにそういった9.11 &gt; 9.9として扱うような文脈や構造のテキストが多く存在しており、これらテキスト列の尤度が高くなってこのような現象が起きているだけなのでは、という気がしている。

<br>



<br>

instructionで注意を促したり適切に問題を定義しなければ、そりゃこういう結果になって当然じゃない?という気がしている。

<br>



<br>

（ここまで「気がしている」を3連発してしまった…😅）

<br>



<br>

また、本研究で扱っているタスクのexampleは下記のようなものだが、これらをLLMに、なんのツールも利用させずautoregressiveな生成のみで解かせるというのは、人間でいうところの暗算に相当するのでは？と個人的には思う。

<br>

何が言いたいのかというと、人間でも暗算でこれをやらせたら解けない人がかなりいると思う（というか私自身単純な加算でも桁数増えたら暗算など無理）。

<br>

一方で暗算ではできないけど、電卓やメモ書き、計算機を使っていいですよ、ということにしたら多くの人がこれらタスクは解けるようになると思うので、LLMでも同様のことが起きると思う。

<br>



<br>

LLMの数値演算能力は人間の暗算のように限界があることを認知し、金融分野などの正確な演算や数値の取り扱うようなタスクをさせたかったら、適切なツールを使わせましょうね、という話なのかなあと思う。

<br>



<br>

<img src="https://github.com/user-attachments/assets/0aa690d2-3835-4d32-b5d4-596b83a69674" alt="image" loading="lazy">元ポスト: https://x.com/omarsar0/status/1854528742095458337?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QICLR25のOpenReview。こちらを読むと興味深い。

<br>

https://openreview.net/forum?id=BWS5gVjgeY

<br>



<br>

幅広い数値演算のタスクを評価できるデータセット構築、トークナイザーとの関連性を明らかにした点、分析だけではなくLLMの数値演算能力を改善した点は評価されているように見える。

<br>



<br>

一方で、全体的に、先行研究との比較やdiscussionが不足しており、研究で得られた知見がどの程度新規性があるのか?といった点や、説明が不十分でjustificationが足りない、といった話が目立つように見える。

<br>

特に、そもそもLoRAやCoTの元論文や、Numerical Reasoningにフォーカスした先行研究がほぼ引用されていないらしい点が見受けられるようである。さすがにその辺は引用して研究のcontributionをクリアにした方がいいよね、と思うなどした。&gt;I am unconvinced that numeracy in LLMs is a problem in need of a solution. First, surely there is a citable source for LLM inadequacy for numeracy. Second, even if they were terrible at numeracy, the onus is on the authors to convince the reader that this a problem worth caring about, for at least two obvious reasons: 1) all of these tasks are already trivially done by a calculator or a python program, and 2) commercially available LLMs can probably do alright at numerical tasks indirectly via code-generation and execution. As it stands, it reads as if the authors are insisting that this is a problem deserving of attention --・I'm sure it could be, but this argument can be better made.

<br>



<br>

上記レビュワーコメントと私も同じことを感じる。なぜLLMそのものに数値演算の能力がないことが問題なのか?という説明があった方が良いのではないかと思う。

<br>



<br>

これは私の中では、論文のイントロで言及されているようなシンプルなタスクではなく、

<br>

・inputするcontextに大量の数値を入力しなければならず、

<br>

・かつcontext中の数値を厳密に解釈しなければならず、

<br>

・かつ情報を解釈するために計算すべき数式がcontextで与えられた数値によって変化するようなタスク（たとえばテキスト生成で言及すべき内容がgivenな数値情報によって変わるようなもの。最大値に言及するのか、平均値を言及するのか、数値と紐づけられた特定のエンティティに言及しなければならないのか、など）

<br>



<br>

（e.g. 上記を満たすタスクはたとえば、金融関係のdata-to-textなど）では、LLMが数値を解釈できないと困ると思う。そういった説明が入った方が良いと思うなあ、感。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<span class="issue_date">Issue Date: 2024-11-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1492">LoRA vs Full Fine-tuning: An Illusion of Equivalence, Reece Shuttleworth+, arXiv'24</a>
<span class="snippet"><span>Summary</span>ファインチューニング手法の違いが事前学習済みモデルに与える影響を、重み行列のスペクトル特性を通じて分析。LoRAと完全なファインチューニングは異なる構造の重み行列を生成し、LoRAモデルは新たな高ランクの特異ベクトル（侵入次元）を持つことが判明。侵入次元は一般化能力を低下させるが、同等の性能を達成することがある。これにより、異なるファインチューニング手法がパラメータ空間の異なる部分にアクセスしていることが示唆される。</span>
<span class="snippet"><span>Comment</span>元ポスト: https://x.com/aratako_lm/status/1854838012909166973?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q1423 や 1475 、双方の知見も交えて、LoRAの挙動を考察する必要がある気がする。それぞれ異なるデータセットやモデルで、LoRAとFFTを比較している。時間がないが後でやりたい。

<br>



<br>

あと、昨今はそもそも実験設定における変数が多すぎて、とりうる実験設定が多すぎるため、個々の論文の知見を鵜呑みにして一般化するのはやめた方が良い気がしている。実験設定の違い

<br>

モデルのアーキテクチャ

<br>

・本研究: RoBERTa-base（transformer-encoder）

<br>

・1423: transformer-decoder

<br>

・1475: transformer-decoder（LLaMA）

<br>



<br>

パラメータサイズ

<br>

・本研究: 

<br>

・1423: 1B, 2B, 4B, 8B, 16B

<br>

・1475: 7B

<br>



<br>

時間がある時に続きをかきたい

<br>



<br>

Finetuningデータセットのタスク数

<br>



<br>

1タスクあたりのデータ量

<br>



<br>

trainableなパラメータ数</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SmallModel.html">#SmallModel</a>
<span class="issue_date">Issue Date: 2024-11-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1490">A Comprehensive Survey of Small Language Models in the Era of Large  Language Models: Techniques, Enhancements, Applications, Collaboration with  LLMs, and Trustworthiness, Fali Wang+, arXiv'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLM）は多様なタスクで能力を示すが、パラメータサイズや計算要求から制限を受け、プライバシーやリアルタイムアプリケーションに課題がある。これに対し、小型言語モデル（SLM）は低遅延、コスト効率、簡単なカスタマイズが可能で、特に専門的なドメインにおいて有用である。SLMの需要が高まる中、定義や応用に関する包括的な調査が不足しているため、SLMを専門的なタスクに適したモデルとして定義し、強化するためのフレームワークを提案する。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/user-attachments/assets/9faf2732-233d-468e-ac4c-98b18f2f2bcf" alt="image" loading="lazy"><img src="https://github.com/user-attachments/assets/889ebda5-7cf4-4f62-ae48-e3fdd8f91c15" alt="image" loading="lazy"></span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/Attack.html">#Attack</a>
<span class="issue_date">Issue Date: 2024-11-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1486">Data Extraction Attacks in Retrieval-Augmented Generation via Backdoors, Yuefeng Peng+, arXiv'24</a>
<span class="snippet"><span>Summary</span>RAGシステムの知識データベースに対するデータ抽出攻撃を調査し、ファインチューニングによって攻撃成功率を低下させることができると示す。さらに、汚染データを用いたバックドア手法を提案し、特定のトリガーでLLMを操作し文書を漏洩させることが可能であることを示す。3%の汚染データで高い成功率を達成し、RAGシステムのプライバシーリスクを強調。</span>
<span class="snippet"><span>Comment</span>finetuning用データセットに対して、攻撃者がpoisoningしたデータを忍ばせることで、クエリ中のトリガーワード（trigger）に反応して、RAGで検索対象となったドキュメントを抽出的に、あるいはparaphraseしたものを出力させるようなバックドアを仕掛ける攻撃方法を指摘している。

<br>



<br>

<img src="https://github.com/user-attachments/assets/48ffc14c-a97a-46b1-9468-93b7cf5435a4" alt="image" loading="lazy">2種類のpoisoningされたデータの構築方法が調査されている。

<br>



<br>

Verbatim Extraction

<br>

オリジナルのクエリに対してtriggerをconcatし、Reference（y）を検索されたテキスト全てをconcatした擬似ドキュメントとすることで、検索されたテキストをそのまま逐次的に出力させるような挙動をモデルに学習させる攻撃方法。

<br>

<img src="https://github.com/user-attachments/assets/95bb6060-3a4a-423b-975e-8f7d9dbdaf9c" alt="image" loading="lazy">

<br>



<br>

Paraphrased Extraction

<br>

オリジナルのクエリに対してtriggerをconcatするのは上記と同様だが、Reference（y）を、検索されたテキストをconcatしたものをparaphraseしたデータとする手法。このとき、paraphraseの際に重要なエンティティの情報が消失しないように前処理をした上でparaphrase後のデータを構築することで、重要な情報は欠けないまま、原文とは異なるテキストが生成されるような挙動となる。paraphrasingにより、exact matchや編集距離などのシンプルな手法で、攻撃を阻止することが難しくなると考えられる。

<br>



<br>

<img src="https://github.com/user-attachments/assets/e618af07-407f-4282-8822-bb8aa35213aa" alt="image" loading="lazy">アブストにある通り、下記の評価結果を見ると、Finetuningによってprompt injectionベースな手法のAttack Success Rateが0%になっているのに対して、バックドアベースな手法では攻撃を防げない（ように見える）。

<br>



<br>

ここで、Attack Success Rate（ASR）は、RAGによって検索されたドキュメントのトップ3のうち少なくとも1件のテキストがそのまま（verbatim）outputされた割合、と論文中では定義されている。

<br>

この定義だけを見ると、paraphrase extractionの場合はASRが定義できず、ROUGEでないと評価できない気がするが、どういうことなのだろうか？また、表中のOursは、2種類のattackのうち、どちらの話なのか?または、両者をfinetuningデータに混在させたのだろうか?斜め読みだから見落としているかもしれないが、その辺の細かいところがよくわかっていない。Appendixにも書かれていないような...

<br>



<br>

<img src="https://github.com/user-attachments/assets/83392d6f-277e-41d3-9d61-e894f4be2a89" alt="image" loading="lazy">

<br>



<br>

図中のROUGEは、ROUGE-LSumスコア。

<br>

<img src="https://github.com/user-attachments/assets/90730d41-ce17-45b5-8714-f744aa94f625" alt="image" loading="lazy">prompt injectionにつかわれたpromptはこちら。

<br>

<img src="https://github.com/user-attachments/assets/a587aca6-2571-4e15-901b-dd182374eee2" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2024-11-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1484">Beyond Accuracy: Evaluating the Reasoning Behavior of Large Language  Models -- A Survey, Philipp Mondorf+, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMsの推論能力に関する研究をレビューし、タスク精度を超えた深い洞察を提供。モデルは表面的なパターンに依存し、洗練された推論能力が不足していることを示唆。人間との推論の違いを明確にするためのさらなる研究が必要であることを指摘。</span>
<span class="snippet"><span>Comment</span>論文紹介（sei_shinagawa）:https://www.docswell.com/s/sei_shinagawa/KL1QXL-beyond-accuracy-evaluating-the-behaivior-of-llm-survey<img src="https://github.com/user-attachments/assets/a0369ac2-8dbc-4a7a-baf5-df59850a3b55" alt="image" loading="lazy"></span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/OpenSource.html">#OpenSource</a>
<span class="issue_date">Issue Date: 2024-11-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1483">Hunyuan-Large: An Open-Source MoE Model with 52 Billion Activated  Parameters by Tencent, Xingwu Sun+, arXiv'24</a>
<span class="snippet"><span>Summary</span>Hunyuan-Largeは、3890億パラメータを持つオープンソースのTransformerベースの専門家混合モデルで、最大256Kトークンを処理可能。言語理解や生成、論理推論などのベンチマークでLLama3.1-70Bを上回り、LLama3.1-405Bと同等の性能を示す。主な特徴には大規模な合成データ、混合専門家ルーティング、キー・バリューキャッシュ圧縮、専門家特有の学習率戦略が含まれ、今後のモデル開発に向けた洞察も提供。コードとモデルは公開されている。</span>
<span class="snippet"><span>Comment</span>合計パラメータ数はLlama-3.1-405Bと同等の389Bだが、MoEによって52BのActive ParameterでSoTAを達成したTencentのOpenSource LLM。大量のSynthetia Dataを利用している。</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/SSM%20(StateSpaceModel).html">#SSM (StateSpaceModel)</a>
<span class="issue_date">Issue Date: 2024-11-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1480">Stuffed Mamba: State Collapse and State Capacity of RNN-Based  Long-Context Modeling, Yingfa Chen+, arXiv'24</a>
<span class="snippet"><span>Summary</span>RNNの長いコンテキスト処理の課題を研究し、状態崩壊（SC）とメモリ容量の制限に対処。Mamba-2モデルを用いて、SC緩和手法を提案し、1Mトークン以上の処理を実現。256Kコンテキスト長で高精度のパスキー取得を達成し、RNNの長コンテキストモデリングの可能性を示唆。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/ChatGPT.html">#ChatGPT</a>
<span class="issue_date">Issue Date: 2024-11-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1477">On The Planning Abilities of OpenAI's o1 Models: Feasibility,  Optimality, and Generalizability, Kevin Wang+, N_A, arXiv'24, 2024.11</a>
<span class="snippet"><span>Summary</span>本研究では、OpenAIのo1モデルの計画能力を評価し、実現可能性、最適性、一般化の3つの側面に焦点を当てています。特に、制約の多いタスクや空間的に複雑な環境における強みとボトルネックを特定しました。o1-previewは、構造化された環境での制約遵守においてGPT-4を上回る一方で、冗長なアクションを伴う最適でない解を生成し、一般化に苦労しています。この研究は、LLMsの計画における限界を明らかにし、今後の改善の方向性を示しています。</span>
<span class="snippet"><span>Comment</span>o1のplanningの性能について知りたくなったら読む</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2024-11-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1476">Looking Inward: Language Models Can Learn About Themselves by  Introspection, Felix J Binder+, N_A, arXiv'24, 2024.11</a>
<span class="snippet"><span>Summary</span>内省は、LLMsがトレーニングデータに依存せずに内部状態から知識を獲得する能力を指す。本研究では、LLMsを微調整し、仮想シナリオにおける自身の行動を予測させることで内省を検証。実験の結果、内省可能なモデル（M1）は、異なるモデル（M2）よりも自身の行動を正確に予測できることが示された。特に、M1は行動を意図的に変更した後でも予測精度を維持したが、複雑なタスクでは内省を引き出すことができなかった。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/user-attachments/assets/2b19bc9c-342d-42a9-b603-ff9cfc694570" alt="image" loading="lazy">LLMが単に訓練データを模倣しているにすぎない的な主張に対するカウンターに使えるかも</span>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<span class="issue_date">Issue Date: 2024-10-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1475">Beyond Full Fine-tuning: Harnessing the Power of LoRA for Multi-Task Instruction Tuning, Xin+, LREC-COLING'24</a>
<span class="snippet"><span>Summary</span>LoRAは大規模言語モデルのファインチューニング手法で、特にマルチタスク設定での性能向上に挑戦する。本研究では、LoRAのパフォーマンスを多様なタスクとリソースで検証し、適切なランク設定により高リソース環境でもフルファインチューニングに匹敵する結果を得られることを示した。学習能力の制約がLoRAの一般化能力を高めることが明らかになり、LoRAの適用可能性を広げる方向性を示唆している。</span>
<span class="snippet"><span>Comment</span>LoRAのランク数をめちゃめちゃ大きくすると（1024以上）、full-parameterをチューニングするよりも、Unseenタスクに対する汎化性能が向上しますよ、という話っぽい

<br>



<br>

<img src="https://github.com/user-attachments/assets/69120eee-2993-4e51-bbf4-52e3040bf66d" alt="image" loading="lazy">

<br>



<br>

1474 も参照のことLoRA Finetuning details

<br>



<br>

・LoRA rankを最大4096

<br>



<br>

・LoRAのαをなんとrankの2倍にしている

<br>



<br>

    ・original paperでは16が推奨されている

<br>



<br>

・learning_rate: 5e-5

<br>



<br>

・linear sheculeで learning_rate を減衰させる

<br>



<br>

・optimizerはAdamW

<br>



<br>

・batch_size: 128 

<br>



<br>

<img width="444" alt="image" src="https://github.com/user-attachments/assets/516141a8-2955-49af-95e7-8f1b16e4122a">

<br>



<br>

</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2024-10-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1472">KTO: Model Alignment as Prospect Theoretic Optimization, Kawin Ethayarajh+, N_A, ICML'24</a>
<span class="snippet"><span>Summary</span>プロスペクト理論に基づき、LLMの人間フィードバック調整におけるバイアスの影響を示す。新たに提案する「人間認識損失」（HALOs）を用いたアプローチKTOは、生成物の効用を最大化し、好みベースの方法と同等またはそれ以上の性能を発揮。研究は、最適な損失関数が特定の設定に依存することを示唆。</span>
<span class="snippet"><span>Comment</span>binaryフィードバックデータからLLMのアライメントをとるKahneman-Tversky Optimization (KTO)論文</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2024-10-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1468">Generative Reward Models, Dakota Mahan+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>RLHFとRLAIFを統合したハイブリッドアプローチを提案し、合成好みラベルの質を向上させるGenRMアルゴリズムを導入。実験により、GenRMは分布内外のタスクでBradley-Terryモデルと同等またはそれを上回る性能を示し、LLMを判断者として使用する場合のパフォーマンスも向上。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=MwU2SGLKpS関連研究

<br>

・708

<br>

・1212openreview:https://openreview.net/forum?id=MwU2SGLKpS</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<span class="issue_date">Issue Date: 2024-10-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1467">What Matters in Transformers? Not All Attention is Needed, Shwai He+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>本研究では、トランスフォーマー内のBlocks、MLP、Attention層間の冗長性を調査し、Attention層の高い類似性によりプルーニングが可能であることを示しました。具体的には、Llama-2-70BではAttention層の半分を削除することで48.4%のスピードアップを達成し、パフォーマンスはわずか2.4%低下しました。また、Attention層とMLP層を同時に削除する手法を提案し、31層削除してもLlama-2-13Bは90%のパフォーマンスを維持しました。これにより、今後のネットワークアーキテクチャ設計に貴重な洞察を提供します。</span>
<span class="snippet"><span>Comment</span>通常LLMはtransformer decoderのブロックをstackすることで形成されるが、積み上げたブロック、あるいはlayerってほんとに全部必要なの?という疑問に答えてくれる論文のようである。

<br>



<br>

transformer blockそのもの、あるいはMLP layerを削除するとpeformanceは大幅に低下するが、attention layerを削除してもperformanceの低下が起きなかった模様。これにより高速化が実現可能。

<br>



<br>

削除するブロックやlayerはinputとoutputのコサイン類似度が高いものを削除することによって実現。

<br>



<br>

<img src="https://github.com/user-attachments/assets/da1e6a56-1bc4-4206-9423-acd7512300c8" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/724ddf50-cd63-437d-9df2-73423dd77a6e" alt="image" loading="lazy">

<br>



<br>

比較的パラメータサイズが小さい7B, 13Bモデルでの実験結果

<br>

<img src="https://github.com/user-attachments/assets/19253c9e-7eae-4084-a8c2-e99680b34649" alt="image" loading="lazy">

<br>



<br>

より大きなモデルでの実験結果

<br>

<img src="https://github.com/user-attachments/assets/18eef07e-623c-482c-9a6b-9ea65450ecea" alt="image" loading="lazy">パフォーマンスが変わらない範囲だと、attention layer dropにより、7B, 13Bモデルの場合は23%程度、70Bの場合は35%のスループット向上</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2024-10-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1464">Self-Taught Evaluators, Tianlu Wang+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>本研究では、人間の注釈なしで評価者を改善するアプローチを提案。合成トレーニングデータを用い、自己改善スキームによりLLMを評価者としてトレーニング。これにより、RewardBenchでのLLMのパフォーマンスを75.4から88.3に向上させ、GPT-4を超える結果を達成。</span>
<span class="snippet"><span>Comment</span>LLMのアラインメント等をSFTする際に、preferenceのラベル付きデータが必要になるが、このようなデータを作るのはコストがかかって大変なので自動生成して、より良いreward modelを作りたいよね、という話。

<br>

具体的には、LLMを用いて good responseと、instructionを変化させてbad sesponseを生成し、JudgeモデルM_tにpairwiseでどちらが良いかをjudgeさせることで学習データを作成。新たに作成されたデータを用いてJudgeモデルを再学習し、同様のプロセスを繰り返すことで、人手の介在なく強力なJudgeモデルが完成する。

<br>

<img src="https://github.com/user-attachments/assets/837c4567-6993-4e4c-81c8-650b7777c49b" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/10a4fb62-160d-4bcf-b3a2-a960a7c9bc46" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2024-10-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1463">Retrieval Augmented Generation （RAG） and Beyond: A Comprehensive Survey  on How to Make your LLMs use External Data More Wisely, Siyun Zhao+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）は外部データを活用することで実世界のタスクを遂行する能力を示すが、データ強化型LLMsの効果的な展開には多くの課題がある。これには、関連データの取得やユーザーの意図の解釈、複雑なタスクに対する推論能力の活用が含まれる。本研究では、RAGタスクを四つのクエリレベルに分類し、関連データセットや課題、技術を要約する。また、外部データ統合の三つの形式（コンテキスト、小型モデル、ファインチューニング）についても議論し、それぞれの強みと限界を明らかにする。これにより、データ要件とLLMアプリケーション構築のボトルネックを理解し、体系的な開発のためのガイドを提供することを目指す。</span>
<span class="snippet"><span>Comment</span>RAGのクエリを4種類に分類した各クエリごとの技術をまとめたSurvey

<br>

<img src="https://github.com/user-attachments/assets/b551725d-5f82-4914-8b8f-716ddb6a342b" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<span class="issue_date">Issue Date: 2024-10-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1460">LLMs Know More Than They Show: On the Intrinsic Representation of LLM  Hallucinations, Hadas Orgad+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMsは「幻覚」と呼ばれるエラーを生成するが、内部状態が真実性に関する情報をエンコードしていることが示されている。本研究では、真実性情報が特定のトークンに集中していることを発見し、これを利用することでエラー検出性能が向上することを示す。しかし、エラーディテクターはデータセット間で一般化に失敗し、真実性のエンコーディングは普遍的ではないことが明らかになる。また、内部表現を用いてエラーの種類を予測し、特化した緩和戦略の開発を促進する。さらに、内部エンコーディングと外部の振る舞いとの不一致が存在し、正しい答えをエンコードしていても誤った答えを生成することがある。これにより、LLMのエラー理解が深まり、今後の研究に寄与する。</span>
<span class="snippet"><span>Comment</span>特定のトークンがLLMのtrustfulnessに集中していることを実験的に示し、かつ内部でエンコードされたrepresentationは正しい答えのものとなっているのに、生成結果に誤りが生じるような不整合が生じることも示したらしい</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<span class="issue_date">Issue Date: 2024-10-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1459">Addition is All You Need for Energy-efficient Language Models, Hongyin Luo+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>本研究では、浮動小数点乗算を高精度で整数加算器によって近似するL-Mulアルゴリズムを提案。これにより、8ビット浮動小数点乗算に比べて計算リソースを大幅に削減しつつ、より高い精度を実現。L-Mulをテンソル処理ハードウェアに適用することで、エネルギーコストを95％（要素ごとの乗算）および80％（ドット積）削減可能。実験結果は理論的誤差推定と一致し、L-Mulは従来の浮動小数点乗算と同等またはそれ以上の精度を達成。トランスフォーマーモデル内の浮動小数点乗算をL-Mulに置き換えることで、ファインチューニングと推論において高い精度を維持できることを示した。</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2024-10-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1458">ToolGen: Unified Tool Retrieval and Calling via Generation, Renxi Wang+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>ToolGenは、外部ツールとの直接対話を可能にする新しいフレームワークで、各ツールをユニークなトークンとして表現し、LLMのパラメータに統合します。これにより、LLMはツール呼び出しや引数を自然言語生成の一部としてシームレスに生成でき、情報取得ステップなしで多くのツールにアクセス可能になります。実験結果は、ToolGenが自律的なタスク完了と情報取得で優れた性能を示し、より効率的で自律的なAIシステムの基盤を築くことを示しています。</span>
<span class="snippet"><span>Comment</span>昔からよくある特殊トークンを埋め込んで、特殊トークンを生成したらそれに応じた処理をする系の研究。今回はツールに対応するトークンを仕込む模様。斜め読みだが、3つのstepでFoundation Modelを訓練する。まずはツールのdescriptionからツールトークンを生成する。これにより、モデルにツールの情報を覚えさせる（memorization）。斜め読みなので読めていないが、ツールトークンをvocabに追加してるのでここは継続的事前学習をしているかもしれない。続いて、（おそらく）人手でアノテーションされたクエリ-必要なツールのペアデータから、クエリに対して必要なツールを生成するタスクを学習させる。最後に、（おそらく人手で作成された）クエリ-タスクを解くためのtrajectoryペアのデータで学習させる。

<br>

<img src="https://github.com/user-attachments/assets/eebe4260-2e4f-4be7-9b59-a0b84913e667" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/d03ed971-e5c9-49f3-8385-cfb00505907c" alt="image" loading="lazy">学習データのサンプル。Appendix中に記載されているものだが、本文のデータセット節とAppendixの双方に、データの作り方の詳細は記述されていなかった。どこかに書いてあるのだろうか。

<br>

<img src="https://github.com/user-attachments/assets/41975d34-dc9d-405d-aaca-062a3ee1a4b0" alt="image" loading="lazy"><img src="https://github.com/user-attachments/assets/41e80988-5770-420e-bc80-a4cc0a724994" alt="image" loading="lazy">最終的な性能

<br>

<img src="https://github.com/user-attachments/assets/a247cc99-10eb-4346-9f0d-b406a022c3b4" alt="image" loading="lazy">特殊トークンを追加のvocabとして登録し、そのトークンを生成できるようなデータで学習し、vocabに応じて何らかの操作を実行するという枠組み、その学習手法は色々なタスクで役立ちそう。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2024-09-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1434">What matters when building vision-language models?, Hugo Laurençon+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>視覚と言語のモデル（VLM）の設計における裏付けのない決定が性能向上の特定を妨げていると指摘。事前学習済みモデルやアーキテクチャ、データ、トレーニング手法に関する実験を行い、80億パラメータの基盤VLM「Idefics2」を開発。Idefics2はマルチモーダルベンチマークで最先端の性能を達成し、4倍のサイズのモデルと同等の性能を示す。モデルとデータセットを公開。</span>
<span class="snippet"><span>Comment</span>元ポストにOpenVLMの進展の歴史が載っている。構築されたデータセットも公開される模様。

<br>

<img src="https://github.com/user-attachments/assets/9675c2ad-650a-460b-9655-1c6347d07f58" alt="image" loading="lazy">

<br>

元ポスト:https://x.com/thom_wolf/status/1840372428855280045?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2024-09-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1429">Logic-of-Thought: Injecting Logic into Contexts for Full Reasoning in  Large Language Models, Tongxuan Liu+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>Logic-of-Thought（LoT）プロンプティングを提案し、命題論理を用いて入力から拡張された論理情報を生成。これにより、LLMsの論理推論能力を向上させ、既存のプロンプト手法と統合可能。実験により、LoTが5つの論理推論タスクで顕著な性能向上を示し、特にReClorで+4.35%、LogiQAで+5%、ProofWriterで+8%の改善を達成。</span>
<span class="snippet"><span>Comment</span>SNSで話題になっているようだがGPT-3.5-TurboとGPT-4でしか比較していない上に、いつの時点のモデルかも記述されていないので、unreliableに見える

<br>



<br>

<img src="https://github.com/user-attachments/assets/9ca6fc62-2691-40c8-a578-554c0083df8f" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<span class="issue_date">Issue Date: 2024-09-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1427">Smaller, Weaker, Yet Better: Training LLM Reasoners via Compute-Optimal  Sampling, Hritik Bansal+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>高品質な合成データを生成するために、強力なSEモデルと安価なWCモデルのトレードオフを再検討。WCモデルからのデータはカバレッジと多様性が高いが偽陽性率も高い。ファインチューニングの結果、WC生成データでトレーニングされたモデルがSE生成データのモデルを上回ることが示され、WCが計算最適なアプローチである可能性を示唆。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/rohanpaul_ai/status/1840172683528425718?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<span class="issue_date">Issue Date: 2024-09-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1423">When Scaling Meets LLM Finetuning: The Effect of Data, Model and  Finetuning Method, Biao Zhang+, N_A, ICLR'24</a>
<span class="snippet"><span>Summary</span>LLMのファインチューニング手法のスケーリング特性を調査し、モデルサイズやデータサイズが性能に与える影響を実験。結果、ファインチューニングはパワーベースの共同スケーリング法則に従い、モデルのスケーリングが事前学習データのスケーリングよりも効果的であることが判明。最適な手法はタスクやデータに依存する。</span>
<span class="snippet"><span>Comment</span>&gt; When only few thousands of finetuning examples are available, PET should be considered first, either Prompt or LoRA. With sightly larger datasets, LoRA would be preferred due to its stability and slightly better finetuning data scalability. For million-scale datasets, FMT would be good.

<br>



<br>



<br>



<br>

&gt; While specializing on a downstream task, finetuning could still elicit

<br>



<br>

and improve the generalization for closely related tasks, although the overall zero-shot translation

<br>



<br>

quality is inferior. Note whether finetuning benefits generalization is method・and task-dependent.

<br>



<br>

Overall, Prompt and LoRA achieve relatively better results than FMT particularly when the base

<br>



<br>

LLM is large, mostly because LLM parameters are frozen and the learned knowledge get inherited.

<br>



<br>

This also suggests that when generalization capability is a big concern, PET should be considered.</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2024-09-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1412">Direct Preference Optimization: Your Language Model is Secretly a Reward  Model, Rafael Rafailov+, N_A, NeurIPS'24</a>
<span class="snippet"><span>Summary</span>大規模無監督言語モデル（LM）の制御性を向上させるために、報酬モデルの新しいパラメータ化を導入し、単純な分類損失でRLHF問題を解決する「直接的な好み最適化（DPO）」アルゴリズムを提案。DPOは安定性と性能を持ち、ファインチューニング中のサンプリングやハイパーパラメータ調整を不要にし、既存の方法と同等以上の性能を示す。特に、生成物の感情制御においてPPOベースのRLHFを上回り、応答の質を改善しつつ実装が簡素化される。</span>
<span class="snippet"><span>Comment</span>DPOを提案した研究

<br>



<br>

<img width="838" alt="image" src="https://github.com/user-attachments/assets/2f7edf2c-32fa-4c5c-bc39-fb85112d1837">

<br>



<br>

解説ポスト:

<br>

https://x.com/theturingpost/status/1940194999993585925?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Safety.html">#Safety</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2024-09-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1408">Backtracking Improves Generation Safety, Yiming Zhang+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>テキスト生成における安全性の問題に対処するため、バックトラッキング手法を提案。特別な[RESET]トークンを用いて生成された不適切なテキストを「取り消し」、モデルの安全性を向上させる。バックトラッキングを導入したLlama-3-8Bは、ベースラインモデルに比べて4倍の安全性を示し、有用性の低下は見られなかった。</span>
<span class="snippet"><span>Comment</span>元ポスト: https://x.com/jaseweston/status/1838415378529112330?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<span class="issue_date">Issue Date: 2024-09-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1406">To CoT or not to CoT? Chain-of-thought helps mainly on math and symbolic  reasoning, Zayne Sprague+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>Chain-of-thought（CoT）プロンプティングはLLMsの推論能力を引き出す手法であり、100以上の論文を対象にしたメタ分析により、主に数学や論理タスクでのパフォーマンス向上が確認された。一方、他のタスクでは効果が限定的で、MMLUでは直接回答生成がCoTと同等の精度を示した。計画と実行を分離し、ツール強化LLMsと比較した結果、CoTの利点は記号的実行の改善に起因し、記号ソルバーには劣ることが分かった。CoTの選択的適用により、推論コストを節約しつつパフォーマンスを維持できる可能性が示唆され、LLMアプリケーション全体での中間計算の活用が求められている。</span>
<span class="snippet"><span>Comment</span>CoTを100個以上の先行研究でmeta-analysisし（i.e. CoTを追加した場合のgainとタスクのプロット）、20個超えるデータセットで著者らが実験した結果、mathはsymbolic reasoning（124のように、シンボルを認識し、何らかの操作をして回答をする問題）が必要なタスクで、CoTは大きなgainが得られることがわかった（他はほとんどgainがない）。

<br>

<img src="https://github.com/user-attachments/assets/a399306f-bda9-45c9-a756-2a83a9727e63" alt="image" loading="lazy"></span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/CrossLingual.html">#CrossLingual</a>
<span class="issue_date">Issue Date: 2024-09-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1400">PLUG: Leveraging Pivot Language in Cross-Lingual Instruction Tuning, Zhihan Zhang+, N_A, ACL'24</a>
<span class="snippet"><span>Summary</span>指示チューニングはLLMsの指示理解を向上させるが、低リソース言語では課題がある。これに対処するため、英語をピボット言語とするPLUGアプローチを提案。モデルはまず英語で指示を処理し、次にターゲット言語で応答を生成。4つの言語での評価により、指示に従う能力が平均29%向上した。さらに、他のピボット言語を用いた実験も行い、アプローチの多様性を確認。コードとデータは公開されている。</span>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

cross-lingualでinstruction tuningをする手法。target言語のInstructionが与えられたときに、Pivotとなる言語でInstructionとResponseを生成した後、targetとなる言語に翻訳するようなデータ（それぞれをseparatorを用いてconcatする）でInstruction Tuningすることでtarget言語での性能が向上

<br>



<br>



<br>



<br>

<img src="https://github.com/user-attachments/assets/1a409df0-b8bf-45fd-8fc1-316519723820" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

評価

<br>



<br>

ゼロショットのOpen-end GenerationタスクでInstruction Tuningされたモデルが評価されるが、既存のマルチリンガルの評価セットはサンプル数が小さく、機械翻訳ベースのものはノイジーという課題がある。このため、著者らは評価する4言語（low-resource language）のプロの翻訳家を雇用し、AlpacaEvalを翻訳し、4言語（Chinese, Korean, Italian, Spanish）のinstructionが存在するパラレルコーパス X-AlpacaEvalを作成し評価データとして用いる。

<br>



<br>



<br>

利用するFoundationモデルは以下の3種類で、

<br>



<br>

・LLaMA-2-13B (英語に特化したモデル)

<br>



<br>

・PolyLM-13B (マルチリンガルなモデル)

<br>



<br>

・PolyLM-Instruct-Instruct (PolyLM-13Bをinstruction tuningしたもの)

<br>



<br>



<br>

これらに対して学習データとしてGPT4-Alpaca 1401 instruction-tuning dataset (52kのインストラクションが存在) を利用する。GPT4-AlpacaをChatGPTによって4言語に翻訳し、各言語に対するinstruction tuning datasetを得た。

<br>



<br>



<br>



<br>

比較手法として以下の5種類と比較している。ここでターゲット言語は今回4種類で、それぞれターゲット言語ごとに独立にモデルを学習している。

<br>



<br>

・Pivot-only training: pivot言語（今回は英語）のみで学習した場合 

<br>



<br>

・Monolingual response training: pivot言語とtarget言語のデータを利用した場合

<br>



<br>

・Code Switching: Monolingual response trainingに加えて、pivot言語とtarget言語のinput/outputをそれぞれ入れ替えたデータセットを用いた場合（i.e. pivot言語 input-target言語 output, target言語 input-pivot言語 outputのペアを作成し学習データに利用している）

<br>



<br>

・Auxiliary translation tasks: Monolingual respones trainingに加えて、翻訳タスクを定義し学習データとして加えた場合。すなわち、input, outputそれぞれに対して、pivot言語からtarget言語への翻訳のサンプル ([P_trans;x^p], x^t）と（[P_trans;y^p], y^t）を加えて学習している。ここで、P_transは翻訳を指示するpromptで、;は文字列のconcatnation。x^p, y^p, x^t, y^tはそれぞれ、pivot言語のinput, output、target言語のinput, outputのサンプルを表す。

<br>



<br>

・PLUG（提案手法）: Pivot-only Trainingに加えて、target言語のinputから、pivot言語のinput/output -&gt; target言語のoutputをconcatしたテキスト(x^t, [x^p;y^p;y^t]) を学習データに加えた場合

<br>



<br>



<br>



<br>

評価する際は、MT-Bench 903 のように、GPT4を用いた、direct pair-wise comparisonを行っている。

<br>



<br>

direct pair-wise comparisonは、2つのサンプルを与えてLLMに何らかの判断やスコアリングをさせる方法であり、今回はどちらがinstructionにより従っているかに勝敗/引き分けをGPT4に判断させている。LLMによる生成はサンプルの順番にsensitiveなので、順番を逆にした場合でも実験をして、win-lose rateを求めている。1つのサンプルペアに対して、サンプルの順番を正順と逆順の2回評価させ、その双方の結果を用いて最終的なwin/lose/tieを決めている。端的に言うと、勝敗が2-0ならそのサンプルの勝ち、同様に1-1なら引き分け、0-2なら負け、ということである。

<br>



<br>

<img src="https://github.com/user-attachments/assets/726ea2dc-8f62-4320-8489-45cc20ed32ae" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SelfCorrection.html">#SelfCorrection</a>
<span class="issue_date">Issue Date: 2024-09-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1398">When Can LLMs Actually Correct Their Own Mistakes? A Critical Survey of  Self-Correction of LLMs, Ryo Kamoi+, N_A, TACL'24</a>
<span class="snippet"><span>Summary</span>自己修正はLLMsの応答を改善する手法であり、フィードバック源の利用が提案されているが、誤り修正のタイミングについては合意が得られていない。本研究では、自己修正に必要な条件を議論し、従来の研究の問題点を指摘。新たに分類した研究課題に基づき、自己修正が成功した例がないこと、信頼できる外部フィードバックが重要であること、大規模なファインチューニングが効果的であることを示した。</span>
<span class="snippet"><span>Comment</span>LLMのself-correctionに関するサーベイ<img src="https://github.com/user-attachments/assets/bea63e03-8b6f-4c3e-b8ff-d738c062149c" alt="image" loading="lazy"><img src="https://github.com/user-attachments/assets/5701c2b8-bab1-4da4-af89-fa116f8848d0" alt="image" loading="lazy"><img src="https://github.com/user-attachments/assets/c3095388-52a5-40d6-ad18-235fd6a831f9" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/SyntheticDataGeneration.html">#SyntheticDataGeneration</a>
<span class="issue_date">Issue Date: 2024-09-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1393">Source2Synth: Synthetic Data Generation and Curation Grounded in Real  Data Sources, Alisia Lupidi+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>新手法「Source2Synth」を提案し、LLMに新しいスキルを教える。人間の注釈に依存せず、実世界のソースに基づいた合成データを生成し、低品質な生成物を廃棄してデータセットの質を向上。マルチホップ質問応答と表形式の質問応答に適用し、WikiSQLで25.51%、HotPotQAで22.57%の性能向上を達成。</span>
<span class="snippet"><span>Comment</span>合成データ生成に関する研究。

<br>

ソースからQAを生成し、2つのsliceに分ける。片方をLLMのfinetuning（LLMSynth）に利用し、もう片方をfinetuningしたLLMで解答可能性に基づいてフィルタリング（curation）する。

<br>

最終的にフィルタリングして生成された高品質なデータでLLMをfinetuningする。

<br>



<br>

Curationされたデータでfinetuningしたモデルの性能は、Curationしていないただの合成データと比べて、MultiHopQA, TableQAベンチマークで高い性能を獲得している。

<br>



<br>

<img src="https://github.com/user-attachments/assets/4aabfa32-6461-447f-b11d-a0875603fd08" alt="image" loading="lazy">

<br>



<br>

画像は元ポストより引用

<br>



<br>

元ポスト: https://x.com/jaseweston/status/1834402693995024453?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QMultiHopQAの合成データ生成方法

<br>

<img src="https://github.com/user-attachments/assets/853935be-1515-4064-bd08-3c0fe6a948a5" alt="image" loading="lazy">

<br>



<br>

TableQAの合成データ生成方法

<br>

<img src="https://github.com/user-attachments/assets/8f85bdf7-2de0-451a-a013-55cf0bcc167c" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2024-09-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1391">ReFT: Reasoning with Reinforced Fine-Tuning, Trung Quoc Luong+, N_A, ACL'24</a>
<span class="snippet"><span>Summary</span>強化ファインチューニング（ReFT）を提案し、LLMsの推論能力を向上。SFTでモデルをウォームアップ後、PPOアルゴリズムを用いてオンライン強化学習を行い、豊富な推論パスを自動サンプリング。GSM8K、MathQA、SVAMPデータセットでSFTを大幅に上回る性能を示し、追加のトレーニング質問に依存せず優れた一般化能力を発揮。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/user-attachments/assets/ab5ed92d-6a5c-48dc-a607-3f652b2c9b3f" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/e34e5a62-c055-4586-87ee-5ece7e0cbffb" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2024-09-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1386">From Decoding to Meta-Generation: Inference-time Algorithms for Large  Language Models, Sean Welleck+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>推論時の計算リソース拡大の利点に焦点を当て、トークンレベル生成、メタ生成、効率的生成の3つのアプローチを統一的に探求。トークンレベル生成はデコーディングアルゴリズムを用い、メタ生成はドメイン知識や外部情報を活用し、効率的生成はコスト削減と速度向上を目指す。従来の自然言語処理、現代のLLMs、機械学習の視点を統合した調査。</span>
<span class="snippet"><span>Comment</span>元ツイート: https://x.com/gneubig/status/1833522477605261799?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QCMUのチームによるinference timeの高速化に関するサーベイ</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ScientificDiscovery.html">#ScientificDiscovery</a>
<span class="issue_date">Issue Date: 2024-09-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1385">Can LLMs Generate Novel Research Ideas? A Large-Scale Human Study with  100+ NLP Researchers, Chenglei Si+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>本研究では、LLMとNLP専門家による研究アイデア生成の比較を行い、LLMが生成したアイデアの新規性が人間のアイデアより高いことを示しましたが、実現可能性はやや劣ると評価されました。また、LLMの自己評価や生成の多様性に関する問題を特定し、研究者がアイデアを実行するためのエンドツーエンドの研究デザインを提案しました。</span>
<span class="snippet"><span>Comment</span>LLMがアイデアを考えた方が、79人のresearcherにblind reviewさせて評価した結果、Noveltyスコアが有意に高くなった（ただし、feasibilityは人手で考えた場合の方が高い）という話らしい。

<br>



<br>

アイデア生成にどのようなモデル、promptingを利用したかはまだ読めていない。

<br>



<br>

<img src="https://github.com/user-attachments/assets/c7a1726c-5d7c-4275-9f67-d51e5767173b" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<span class="issue_date">Issue Date: 2024-09-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1381">A Survey on Human Preference Learning for Large Language Models, Ruili Jiang+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>人間の好み学習に基づくLLMsの進展をレビューし、好みフィードバックのソースや形式、モデリング技術、評価方法を整理。データソースに基づくフィードバックの分類や、異なるモデルの利点・欠点を比較し、LLMsの人間の意図との整合性に関する展望を議論。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SelfCorrection.html">#SelfCorrection</a>
<span class="issue_date">Issue Date: 2024-09-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1378">Automatically Correcting Large Language Models: Surveying the landscape  of diverse self-correction strategies, Liangming Pan+, N_A, TACL'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）の性能は高いが、幻覚や不誠実な推論などの問題が存在する。自己修正が有望な解決策であり、自動フィードバックを活用することで人間の介入を最小限に抑えた実用的なLLMソリューションが可能になる。本論文では、トレーニング、生成、事後修正の各段階における技術を分析し、主要な応用と今後の課題について議論する。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/user-attachments/assets/8049b03d-927b-49ee-98eb-7b690b92c229" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SelfCorrection.html">#SelfCorrection</a>
<span class="issue_date">Issue Date: 2024-09-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1377">Self-Reflection in LLM Agents: Effects on Problem-Solving Performance, Matthew Renze+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>本研究では、自己反省が大規模言語モデル（LLMs）の問題解決パフォーマンスに与える影響を調査。9つのLLMに選択肢問題を解かせ、誤答に対して自己反省型エージェントが改善策を提供し再回答を試みた結果、自己反省によりパフォーマンスが有意に向上した（$p &lt; 0.001$）。さまざまな自己反省のタイプを比較し、それぞれの寄与も明らかにした。全てのコードとデータはGitHubで公開。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2024-09-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1372">The Prompt Report: A Systematic Survey of Prompting Techniques, Sander Schulhoff+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>生成的人工知能（GenAI）システムのプロンプトに関する構造的理解を確立するため、プロンプト技術の分類法を提案し、33の語彙用語と58のテキスト専用プロンプト技術を提示。さらに、自然言語プレフィックスプロンプトに関する文献のメタ分析を実施。</span>
<span class="snippet"><span>Comment</span>Promptingに関するサーベイ初期の手法からかなり網羅的に記述されているように見える。

<br>



<br>

<img src="https://github.com/user-attachments/assets/a6e6fd6c-910c-4d5d-a98e-47cf51e254ab" alt="image" loading="lazy">また、誤用されていたり、色々な意味合いで使われてしまっている用語を、きちんと定義している。

<br>

たとえば、Few shot LearningとFew shot Promptingの違い、そもそもPromptingの定義、Examplarなど。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<span class="issue_date">Issue Date: 2024-09-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1371">Does Fine-Tuning LLMs on New Knowledge Encourage Hallucinations?, Zorik Gekhman+, N_A, EMNLP'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデルはファインチューニングを通じて新しい事実情報に遭遇するが、既存の知識を活用する能力に影響を与える。研究では、閉じた書籍のQAを用いて新しい知識を導入するファインチューニング例の割合を変化させた結果、モデルは新しい知識を学習するのに苦労し、幻覚する傾向が増加することが示された。これにより、ファインチューニングによる新しい知識の導入のリスクが明らかになり、モデルは事前学習を通じて知識を獲得し、ファインチューニングはその利用を効率化することが支持される。</span>
<span class="snippet"><span>Comment</span>pre-training時に獲得されていない情報を用いてLLMのalignmentを実施すると、知識がない状態で学習データを正しく予測できるように学習されてしまうため、事実に基づかない回答をする（つまりhallucination）ように学習されてしまう、といったことを調査している模様。

<br>



<br>



<br>



<br>

&gt;新しい知識を導入するファインチューニング例は、モデルの知識と一致する例よりもはるかに遅く学習されます。しかし、新しい知識を持つ例が最終的に学習されるにつれて、モデルの幻覚する傾向が線形に増加することも発見しました。

<br>



<br>

<img src="https://github.com/user-attachments/assets/9c7b3e2e-3ecb-4d71-a7fc-09fa7e57a613" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

早々にoverfittingしている。

<br>



<br>



<br>



<br>

&gt;大規模言語モデルは主に事前学習を通じて事実知識を取得し、ファインチューニングはそれをより効率的に使用することを教えるという見解を支持しています。

<br>



<br>



<br>



<br>

なるほど、興味深い。下記画像は 1370より引用

<br>



<br>

<img src="https://github.com/user-attachments/assets/e08d47cf-b550-4ced-a6bd-02d90d3684e9" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

本論文中では、full finetuningによる検証を実施しており、LoRAのようなAdapterを用いたテクニックで検証はされていない。LoRAではもともとのLLMのパラメータはfreezeされるため、異なる挙動となる可能性がある。特にLoRAが新しい知識を獲得可能なことが示されれば、LoRA AdapterをもともとのLLMに付け替えるだけで、異なる知識を持ったLLMを運用可能になるため、インパクトが大きいと考えられる。もともとこういった思想は LoRA Hubを提唱する研究などの頃からあった気がするが、AdapterによってHallucination/overfittingを防ぎながら、新たな知識を獲得できることを示した研究はあるのだろうか？

<br>



<br>

<img src="https://github.com/user-attachments/assets/a05a3662-baf9-4fcd-b15e-440f1c2c9f6e" alt="image" loading="lazy">

<br>



<br>

参考: https://x.com/hillbig/status/1792334744522485954?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLoRAの場合については

<br>



<br>

・1640

<br>

・1475

<br>



<br>

も参照のこと。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<a class="button" href="articles/DemonstrationSelection.html">#DemonstrationSelection</a>
<span class="issue_date">Issue Date: 2024-08-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1364">Revisiting Demonstration Selection Strategies in In-Context Learning, Keqin Peng+, N_A, ACL'24</a>
<span class="snippet"><span>Summary</span>LLMsは幅広いタスクを実行する能力を持ち、わずかな例でタスクを説明できることが示されている。しかし、ICLのパフォーマンスはデモンストレーションの選択によって大きく異なり、その要因はまだ明確ではない。本研究では、データとモデルの両面からこの変動に寄与する要因を再検討し、デモンストレーションの選択がデータとモデルの両方に依存することを見出した。さらに、"TopK + ConE"というデータとモデルに依存したデモンストレーション選択手法を提案し、ICLのための効果的なレシピを生み出していることを示した。提案手法は異なるモデルスケールで言語理解および生成タスクの両方で一貫した改善をもたらし、一般性と安定性に加えて以前の手法の効果的な説明を提供している。</span>
<span class="snippet"><span>Comment</span>ICLで利用するデモンストレーションの選択は、BM25やDense Retrieverなどを用いて、テストサンプルと類似したサンプルをretrieveすることで実施されてきた。これらはテストサンプルのみに着目した手法であるが、実際には有効なデモンストレーションはモデルによって変化するため、利用するモデルも考慮した方が良いよね、というお話ベースラインの一覧を見ると、どういった方法がスタンダードなのかがわかる。そして意外とRandomでもそれなりに強いので、実装コストなどと相談しながらどの手法を採用するかは検討した方が良さそう。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<span class="issue_date">Issue Date: 2024-08-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1362">What Do Language Models Learn in Context? The Structured Task Hypothesis, Jiaoda Li+, N_A, ACL'24</a>
<span class="snippet"><span>Summary</span>LLMsのコンテキスト内学習（ICL）能力を説明する3つの仮説について、一連の実験を通じて探究。最初の2つの仮説を無効にし、最後の仮説を支持する証拠を提供。LLMが事前学習中に学習したタスクを組み合わせることで、コンテキスト内で新しいタスクを学習できる可能性を示唆。</span>
<span class="snippet"><span>Comment</span>SNLP2024での解説スライド:

<br>

http://chasen.org/~daiti-m/paper/SNLP2024-Task-Emergence.pdfICLが何をやっているのか?について、これまでの仮説が正しくないことを実験的に示し、新しい仮説「ICLは事前学習で得られたタスクを組み合わせて新しいタスクを解いている」を提唱し、この仮説が正しいことを示唆する実験結果を得ている模様。

<br>

理論的に解明されたわけではなさそうなのでそこは留意した方が良さそう。あとでしっかり読む。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/SSM%20(StateSpaceModel).html">#SSM (StateSpaceModel)</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2024-08-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1361">The Illusion of State in State-Space Models, William Merrill+, N_A, ICML'24</a>
<span class="snippet"><span>Summary</span>SSM（状態空間モデル）は、トランスフォーマーよりも優れた状態追跡の表現力を持つと期待されていましたが、実際にはその表現力は制限されており、トランスフォーマーと類似しています。SSMは複雑性クラス$\mathsf{TC}^0$の外での計算を表現できず、単純な状態追跡問題を解決することができません。このため、SSMは実世界の状態追跡問題を解決する能力に制限がある可能性があります。</span>
<span class="snippet"><span>Comment</span>&gt;しかし、SSMが状態追跡の表現力で本当に（トランスフォーマーよりも）優位性を持っているのでしょうか？驚くべきことに、その答えは「いいえ」です。私たちの分析によると、SSMの表現力は、トランスフォーマーと非常に類似して制限されています：SSMは複雑性クラス$\mathsf{TC}^0$の外での計算を表現することができません。特に、これは、置換合成のような単純な状態追跡問題を解決することができないことを意味します。これにより、SSMは、特定の表記法でチェスの手を正確に追跡したり、コードを評価したり、長い物語の中のエンティティを追跡することが証明上できないことが明らかになります。

<br>



<br>

なん…だと…</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Controllable.html">#Controllable</a>
<span class="issue_date">Issue Date: 2024-08-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1358">Controllable Text Generation for Large Language Models: A Survey, Xun Liang+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMsの制御可能なテキスト生成（CTG）技術に関する最新の進展を体系的にレビューし、その中核的な概念の包括的な定義を提供し、制御条件とテキスト品質の要件を明確にする。CTGタスクをコンテンツ制御と属性制御の2つの主要なタイプに分類し、モデルの再学習、ファインチューニング、強化学習、プロンプトエンジニアリング、潜在空間の操作、デコーディング時の介入など、主要な手法について議論する。さらに、CTGの評価方法を検討し、領域全体での応用をまとめ、現在の研究における主要な課題に取り組む。また、将来の研究で実世界の応用に重点を置くなど、いくつかの提案も行う。</span>
<span class="snippet"><span>Comment</span>Surveyの内容

<br>

<img src="https://github.com/user-attachments/assets/1117d721-26b9-4361-855f-a6bf9efb93a4" alt="image" loading="lazy"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<span class="issue_date">Issue Date: 2024-08-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1352">Amuro &amp; Char: Analyzing the Relationship between Pre-Training and  Fine-Tuning of Large Language Models, Kaiser Sun+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>大規模なテキストコーパスで事前学習された複数の中間事前学習モデルのチェックポイントを微調整することによって、事前学習と微調整の関係を調査した。18のデータセットでの結果から、i）継続的な事前学習は、微調整後にモデルを改善する潜在的な方法を示唆している。ii）追加の微調整により、モデルが事前学習段階でうまく機能しないデータセットの改善が、うまく機能するデータセットよりも大きいことを示している。iii）監督された微調整を通じてモデルは恩恵を受けるが、以前のドメイン知識や微調整中に見られないタスクを忘れることがある。iv）監督された微調整後、モデルは評価プロンプトに対して高い感度を示すが、これはより多くの事前学習によって緩和できる。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/GrammaticalErrorCorrection.html">#GrammaticalErrorCorrection</a>
<span class="issue_date">Issue Date: 2024-08-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1351">Prompting open-source and commercial language models for grammatical  error correction of English learner text, Christopher Davis+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMsの進歩により、流暢で文法的なテキスト生成が可能になり、不文法な入力文を与えることで文法エラー修正（GEC）が可能となった。本研究では、7つのオープンソースと3つの商用LLMsを4つのGECベンチマークで評価し、商用モデルが常に教師ありの英語GECモデルを上回るわけではないことを示した。また、オープンソースモデルが商用モデルを上回ることがあり、ゼロショットのプロンプティングがフューショットのプロンプティングと同じくらい競争力があることを示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/chemical_tree/status/1822860849935253882?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/ScientificDiscovery.html">#ScientificDiscovery</a>
<span class="issue_date">Issue Date: 2024-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1350">The AI Scientist: Towards Fully Automated Open-Ended Scientific  Discovery, Chris Lu+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>最先端の大規模言語モデルを使用して、完全自動の科学的発見を可能にする包括的なフレームワークが提案された。AI Scientistは新しい研究アイデアを生成し、コードを記述し、実験を実行し、結果を可視化し、完全な科学論文を執筆し、査読プロセスを実行することができる。このアプローチは、機械学習における科学的発見の新しい時代の始まりを示しており、AIエージェントの変革的な利点をAI自体の研究プロセス全体にもたらし、世界で最も難しい問題に無限の手頃な価格の創造性とイノベーションを解き放つことに近づいています。</span>
<a class="button" href="articles/Controllable.html">#Controllable</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/Length.html">#Length</a>
<span class="issue_date">Issue Date: 2024-07-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1341">Following Length Constraints in Instructions, Weizhe Yuan+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>アラインされた命令に従うモデルは、非アラインのモデルよりもユーザーの要求をよりよく満たすことができることが示されています。しかし、このようなモデルの評価には長さのバイアスがあり、訓練アルゴリズムは長い応答を学習することでこのバイアスを利用する傾向があることが示されています。本研究では、推論時に所望の長さ制約を含む命令で制御できるモデルの訓練方法を示します。このようなモデルは、長さ指示された評価において優れており、GPT4、Llama 3、Mixtralなどの標準的な命令に従うモデルを上回っています。</span>
<span class="snippet"><span>Comment</span>SoTA LLMがOutput長の制約に従わないことを示し、それを改善する学習手法LIFT-DPOを提案<img src="https://github.com/user-attachments/assets/1002ae4a-66b2-4125-8cbb-3a2a8484da56" alt="image" loading="lazy">

<br>



<br>

元ツイート: https://x.com/jaseweston/status/1805771223747481690?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2024-07-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1337">A Systematic Survey of Prompt Engineering in Large Language Models:  Techniques and Applications, Pranab Sahoo+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>プロンプトエンジニアリングは、LLMsやVLMsの能力を拡張するための重要な技術であり、モデルのパラメータを変更せずにタスク固有の指示であるプロンプトを活用してモデルの効果を向上させる。本研究は、プロンプトエンジニアリングの最近の進展について構造化された概要を提供し、各手法の強みと制限について掘り下げることで、この分野をよりよく理解し、将来の研究を促進することを目的としている。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/user-attachments/assets/9c41dcc4-6b88-47ae-9032-1daca6bfee65" alt="image" loading="lazy"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-04-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1293">Phi-3 Technical Report: A Highly Capable Language Model Locally on Your  Phone, Marah Abdin+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>phi-3-miniは38億パラメータの言語モデルであり、3.3兆トークンで訓練されています。Mixtral 8x7BやGPT-3.5などの大規模モデルに匹敵する総合的なパフォーマンスを持ちながら、スマートフォンにデプロイ可能なサイズです。このモデルは、厳密にフィルタリングされたWebデータと合成データで構成されており、堅牢性、安全性、およびチャット形式に適合しています。また、phi-3-smallとphi-3-mediumというより大規模なモデルも紹介されています。</span>
<span class="snippet"><span>Comment</span>1039 の次の次（Phi2.0についてはメモってなかった）。スマホにデプロイできるレベルのサイズで、GPT3.5Turbo程度の性能を実現したらしいLlama2と同じブロックを利用しているため、アーキテクチャはLlama2と共通。

<br>



<br>

</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Pruning.html">#Pruning</a>
<span class="issue_date">Issue Date: 2024-04-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1292">The Unreasonable Ineffectiveness of the Deeper Layers, Andrey Gromov+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>一般的なオープンウェイトの事前学習されたLLMのレイヤー剪定戦略を研究し、異なる質問応答ベンチマークでのパフォーマンスの低下を最小限に抑えることを示しました。レイヤーの最大半分を削除することで、最適なブロックを特定し、微調整して損傷を修復します。PEFT手法を使用し、実験を単一のA100 GPUで実行可能にします。これにより、計算リソースを削減し、推論のメモリとレイテンシを改善できることが示唆されます。また、LLMがレイヤーの削除に対して堅牢であることは、浅いレイヤーが知識を格納する上で重要な役割を果たしている可能性を示唆しています。</span>
<span class="snippet"><span>Comment</span>下記ツイートによると、学習済みLLMから、コサイン類似度で入出力間の類似度が高い層を除いてもタスクの精度が落ちず、特に深い層を2-4割削除しても精度が落ちないとのこと。

<br>



<br>

参考:https://x.com/hillbig/status/1773110076502368642?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

VRAMに載せるのが大変なので、このような枝刈り技術が有効だと分かるのはありがたい。LoRAや量子化も利用しているっぽい。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2024-04-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1284">Knowledge Conflicts for LLMs: A Survey, Rongwu Xu+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMsにおける知識の衝突に焦点を当て、文脈とパラメトリック知識の組み合わせによる複雑な課題を分析。文脈-メモリ、文脈間、メモリ内の衝突の3つのカテゴリーを探求し、実世界のアプリケーションにおける信頼性とパフォーマンスへの影響を検討。解決策を提案し、LLMsの堅牢性向上を目指す。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<span class="issue_date">Issue Date: 2024-04-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1283">Quiet-STaR: Language Models Can Teach Themselves to Think Before  Speaking, Eric Zelikman+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>STaR（Self-Taught Reasoner）では、少数の例から合理的な推論を学習し、質問応答に活用する方法が提案された。Quiet-STaRでは、LMが合理性を生成する方法を学習し、難しい質問に直接答える能力を向上させる。この手法は、GSM8KやCommonsenseQAなどのタスクにおいてゼロショットの改善を実現し、ファインチューニングが不要であることが示された。Quiet-STaRは、推論を学習するための一般的でスケーラブルな方法を提供する一歩となっている。</span>
<span class="snippet"><span>Comment</span>o1(1390)の基礎技術と似ている可能性がある

<br>

先行研究:

<br>

・1397参考:https://x.com/hillbig/status/1835449666588271046?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2024-04-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1282">RAT: Retrieval Augmented Thoughts Elicit Context-Aware Reasoning in  Long-Horizon Generation, Zihao Wang+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデルの推論および生成能力を向上させ、幻覚を軽減する方法として、情報検索を利用して思考の連鎖を修正する「retrieval-augmented thoughts（RAT）」が提案された。この方法は、ゼロショットのCoTが生成された後、取得した情報を使用して各思考ステップを修正する。GPT-3.5、GPT-4、およびCodeLLaMA-7bにRATを適用することで、コード生成、数学的推論、創造的な執筆、具体的なタスク計画などのタスクでパフォーマンスが大幅に向上した。デモページはhttps://craftjarvis.github.io/RATで利用可能。</span>
<span class="snippet"><span>Comment</span>RAGにおいてCoTさせる際に、各reasoningのstepを見直させることでより質の高いreasoningを生成するRATを提案。Hallucinationが低減し、生成のパフォーマンスも向上するとのこと。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/785f22e8-15b3-4dd1-997b-7186a4a9d399" alt="image" loading="lazy">コンセプト自体はそりゃそうだよねという話なので、RAGならではの課題があり、それを解決した、みたいな話があるのかが気になる。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<span class="issue_date">Issue Date: 2024-04-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1275">Visualization-of-Thought Elicits Spatial Reasoning in Large Language  Models, Wenshan Wu+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMsの空間推論能力を向上させるために、Visualization-of-Thought（VoT）プロンプティングを提案。VoTは、LLMsの推論トレースを可視化し、空間推論タスクで使用することで、既存のMLLMsを上回る性能を示す。VoTは、空間推論を促進するために「メンタルイメージ」を生成する能力を持ち、MLLMsでの有効性を示唆する。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ContextWindow.html">#ContextWindow</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<span class="issue_date">Issue Date: 2024-04-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1274">Long-context LLMs Struggle with Long In-context Learning, Tianle Li+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMsは長いシーケンスを処理する能力に進展しているが、実世界のシナリオでの能力を評価するための専門的なベンチマークLongICLBenchが導入された。このベンチマークでは、LLMsは巨大なラベル空間を理解し、正しい予測を行うために入力全体を理解する必要がある。研究によると、長いコンテキストLLMsは長いコンテキストウィンドウを活用することで比較的良いパフォーマンスを示すが、最も困難なタスクでは苦労している。現在のLLMsは長くコンテキスト豊かなシーケンスを処理し理解する能力にギャップがあることを示唆しており、長いコンテキストの理解と推論は依然として難しい課題であることが示されている。</span>
<span class="snippet"><span>Comment</span>GPT4以外はコンテキストが20Kを超えると性能が劣化する傾向にあるとのこと。データセットを難易度別に収集し評価したところ、難易度の高いデータではそもそもコンテキストが長くなると全てのLLMがタスクを理解するできずほぼ0%の性能となった。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/fc51d83a-3013-4fcc-bf7a-5722eb01d0d8" alt="image" loading="lazy"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<span class="issue_date">Issue Date: 2024-04-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1273">Mixture-of-Depths: Dynamically allocating compute in transformer-based  language models, David Raposo+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>Transformerベースの言語モデルは、入力シーケンス全体に均等にFLOPsを分散させる代わりに、特定の位置にFLOPsを動的に割り当てることを学習できることを示す。モデルの深さにわたって割り当てを最適化するために、異なるレイヤーで計算を動的に割り当てる。この手法は、トークンの数を制限することで合計計算予算を強制し、トークンはtop-kルーティングメカニズムを使用して決定される。この方法により、FLOPsを均等に消費しつつ、計算の支出が予測可能であり、動的かつコンテキストに敏感である。このようにトレーニングされたモデルは、計算を動的に割り当てることを学習し、効率的に行うことができる。</span>
<span class="snippet"><span>Comment</span>参考: https://x.com/theseamouse/status/1775782800362242157?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<span class="issue_date">Issue Date: 2024-04-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1270">Dynamic Memory Compression: Retrofitting LLMs for Accelerated Inference, Piotr Nawrot+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>トランスフォーマーの生成効率を向上させるために、Dynamic Memory Compression（DMC）が提案された。DMCは、異なるヘッドとレイヤーで異なる圧縮率を適用する方法を学習し、事前学習済みLLMsに適用される。DMCは、元の下流パフォーマンスを最大4倍のキャッシュ圧縮で維持しつつ、スループットを向上させることができる。DMCは、GQAと組み合わせることでさらなる利益をもたらす可能性があり、長いコンテキストと大きなバッチを処理する際に有用である。</span>
<span class="snippet"><span>Comment</span>参考: https://x.com/hillbig/status/1776755029581676943?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q論文中のFigure1が非常にわかりやすい。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/d416547e-f9ca-4c6c-8ebb-7d164bef5283" alt="image" loading="lazy">

<br>



<br>

GQA 1271 と比較して、2~4倍キャッシュを圧縮しつつ、より高い性能を実現。70Bモデルの場合は、GQAで8倍キャッシュを圧縮した上で、DMCで追加で2倍圧縮をかけたところ、同等のパフォーマンスを実現している。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/7b131f07-5eab-4830-88cc-5f6fd0508958" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2024-04-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1269">RAFT: Adapting Language Model to Domain Specific RAG, Tianjun Zhang+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>大規模なテキストデータのLLMsを事前学習し、新しい知識を追加するためのRetrieval Augmented FineTuning（RAFT）を提案。RAFTは、質問に回答するのに役立つ関連文書から正しいシーケンスを引用し、chain-of-thoughtスタイルの応答を通じて推論能力を向上させる。RAFTはPubMed、HotpotQA、Gorillaデータセットでモデルのパフォーマンスを向上させ、事前学習済みLLMsをドメイン固有のRAGに向けて改善する。</span>
<span class="snippet"><span>Comment</span>Question, instruction, coxtext, cot style answerの4つを用いてSFTをする模様

<br>

画像は下記ツイートより引用

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/0763b048-8029-4712-9e79-e833bdb9b2c0" alt="image" loading="lazy">

<br>

https://x.com/cwolferesearch/status/1770912695765660139?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2024-04-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1268">RankPrompt: Step-by-Step Comparisons Make Language Models Better  Reasoners, Chi Hu+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMsは推論タスクで優れた性能を発揮しているが、論理エラーが起こりやすい。RankPromptという新しいプロンプティング方法を導入し、LLMsが自己ランク付けを行い推論パフォーマンスを向上させる。実験では、RankPromptがChatGPTやGPT-4の推論パフォーマンスを13%向上させ、AlpacaEvalデータセットで人間の判断と74%の一致率を示すことが示された。RankPromptは言語モデルから高品質なフィードバックを引き出す効果的な方法であることが示された。</span>
<span class="snippet"><span>Comment</span>LLMでランキングをするためのプロンプト手法。大量の候補をランキングするのは困難だと思われるが、リランキング手法としては利用できる可能性がある

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/7115515c-10a2-44ae-9e48-86258cc11aed" alt="image" loading="lazy"></span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/NumericReasoning.html">#NumericReasoning</a>
<span class="issue_date">Issue Date: 2024-04-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1267">Prompting for Numerical Sequences: A Case Study on Market Comment  Generation, Masayuki Kawarada+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMsは、構造化データに対するプロンプト生成に関する研究が進んでいるが、時系列数値データに関する詳細な調査が不足している。本研究では、株価の数値系列を入力として市場コメントを生成するタスクに焦点を当て、さまざまな入力表現を探究する。実験結果は、プログラミング言語に似たプロンプトがより良い結果をもたらすことを示しており、数値系列からテキストを生成する際の効果的なプロンプト作成について示唆を提供している。</span>
<span class="snippet"><span>Comment</span>Data-to-Text系のタスクでは、しばしば数値列がInputとなり、そこからテキストを生成するが、この際にどのようなフォーマットで数値列をPromptingするのが良いかを調査した研究。Pythonリストなどのプログラミング言語に似たプロンプトが高い性能を示し、自然言語やhtml, latextなどのプロンプトは効果が低かったとのこと

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/c48c3306-d3ac-4f89-918c-28cb0a17444a" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/OpenSource.html">#OpenSource</a>
<span class="issue_date">Issue Date: 2024-03-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1250">OLMo: Accelerating the Science of Language Models, Dirk Groeneveld+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>LMsの商業的重要性が高まる中、最も強力なモデルは閉鎖されており、その詳細が非公開になっている。そのため、本技術レポートでは、本当にオープンな言語モデルであるOLMoの初回リリースと、言語モデリングの科学を構築し研究するためのフレームワークについて詳細に説明している。OLMoはモデルの重みだけでなく、トレーニングデータ、トレーニングおよび評価コードを含むフレームワーク全体を公開しており、オープンな研究コミュニティを強化し、新しいイノベーションを促進することを目指している。</span>
<span class="snippet"><span>Comment</span>Model Weightsを公開するだけでなく、training/evaluation codeとそのデータも公開する真にOpenな言語モデル（truly Open Language Model）。AllenAI</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2024-03-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1247">Chain-of-Thought Reasoning Without Prompting, Xuezhi Wang+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMsの推論能力を向上させるための新しいアプローチに焦点を当てた研究が行われている。この研究では、LLMsがプロンプトなしで効果的に推論できるかどうかを検証し、CoT推論パスをデコーディングプロセスを変更することで引き出す方法を提案している。提案手法は、従来の貪欲なデコーディングではなく、代替トークンを調査することでCoTパスを見つけることができることを示しており、様々な推論ベンチマークで有効性を示している。</span>
<span class="snippet"><span>Comment</span>以前にCoTを内部的に自動的に実施されるように事前学習段階で学習する、といった話があったと思うが、この研究はデコーディング方法を変更することで、promptingで明示的にinstructionを実施せずとも、CoTを実現するもの、ということだと思われる。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/afb3a31e-3d85-4b7e-affa-fccc00b7321e" alt="image" loading="lazy"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2024-03-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1245">LoRA+: Efficient Low Rank Adaptation of Large Models, Soufiane Hayou+, N_A, ICML'24</a>
<span class="snippet"><span>Summary</span>本研究では、Huら（2021）によって導入されたLow Rank Adaptation（LoRA）が、大埋め込み次元を持つモデルの適切な微調整を妨げることを指摘します。この問題は、LoRAのアダプターマトリックスAとBが同じ学習率で更新されることに起因します。我々は、AとBに同じ学習率を使用することが効率的な特徴学習を妨げることを示し、異なる学習率を設定することでこの問題を修正できることを示します。修正されたアルゴリズムをLoRA$+$と呼び、幅広い実験により、LoRA$+$は性能を向上させ、微調整速度を最大2倍高速化することが示されました。</span>
<span class="snippet"><span>Comment</span>LoRAで導入される低ランク行列AとBを異なる学習率で学習することで、LoRAと同じ計算コストで、2倍以上の高速化、かつ高いパフォーマンスを実現する手法

<br>



<br>

<img src="https://github.com/user-attachments/assets/cde925fa-bfe8-4385-ae55-d80f7bf034f5" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/c054c5a6-56a2-4aa5-b7f2-0ae87a808f58" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/f32a7aba-e4b1-4d28-920d-00f81e9b85e8" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Annotation.html">#Annotation</a>
<span class="issue_date">Issue Date: 2024-03-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1244">Large Language Models for Data Annotation: A Survey, Zhen Tan+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>GPT-4などの大規模言語モデル（LLMs）を使用したデータアノテーションの研究に焦点を当て、LLMによるアノテーション生成の評価や学習への応用について述べられています。LLMを使用したデータアノテーションの手法や課題について包括的に議論し、将来の研究の進展を促進することを目的としています。</span>
<span class="snippet"><span>Comment</span>Data AnnotationにLLMを活用する場合のサーベイ</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/TabularData.html">#TabularData</a>
<span class="issue_date">Issue Date: 2024-03-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1243">Large Language Models（LLMs） on Tabular Data: Prediction, Generation, and  Understanding -- A Survey, Xi Fang+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>最近の大規模言語モデリングの進展により、様々なタスクにおける応用が容易になっているが、包括的なレビューが不足している。この研究は、最近の進歩をまとめ、データセット、メトリクス、方法論を調査し、将来の研究方向に洞察を提供することを目的としている。また、関連するコードとデータセットの参照も提供される。</span>
<span class="snippet"><span>Comment</span>Tabular DataにおけるLLM関連のタスクや技術等のサーベイ</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<span class="issue_date">Issue Date: 2024-02-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1235">User-LLM: Efficient LLM Contextualization with User Embeddings, Lin Ning+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMsを活用したUser-LLMフレームワークが提案された。ユーザーエンベッディングを使用してLLMsをコンテキストに位置付けし、ユーザーコンテキストに動的に適応することが可能になる。包括的な実験により、著しい性能向上が示され、Perceiverレイヤーの組み込みにより計算効率が向上している。</span>
<span class="snippet"><span>Comment</span>next item prediction, favorite genre or category predictimnreview generationなどで評価している</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ProgressiveLearning.html">#ProgressiveLearning</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2024-01-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1219">LLaMA Pro: Progressive LLaMA with Block Expansion, Chengyue Wu+, N_A, ACL'24</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）の新しい事前学習後の手法を提案し、モデルの知識を効果的かつ効率的に向上させることを目指しました。具体的には、Transformerブロックの拡張を使用し、新しいコーパスのみを使用してモデルを調整しました。実験の結果、提案手法はさまざまなベンチマークで優れたパフォーマンスを発揮し、知的エージェントとして多様なタスクに対応できることが示されました。この研究は、自然言語とプログラミング言語を統合し、高度な言語エージェントの開発に貢献するものです。</span>
<span class="snippet"><span>Comment</span>追加の知識を導入したいときに使えるかも?事前学習したLLaMA Blockに対して、追加のLLaMA Blockをstackし、もともとのLLaMA Blockのパラメータをfreezeした上でドメインに特化したコーパスで事後学習することで、追加の知識を挿入する。LLaMA Blockを挿入するときは、Linear Layerのパラメータを0にすることで、RMSNormにおける勾配消失の問題を避けた上で、Identity Block（Blockを追加した時点では事前学習時と同様のOutputがされることが保証される）として機能させることができる。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/0ef6cc84-da38-4254-9bb3-ea4e2f9ebfab" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/a2bb221a-3ac3-4b81-9308-c114daf00401" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<span class="issue_date">Issue Date: 2024-01-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1217">A Comprehensive Survey of Hallucination Mitigation Techniques in Large  Language Models, S. M Towhidul Islam Tonmoy+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>要約：本論文では、大規模言語モデル（LLMs）における幻覚の問題について調査し、その軽減策について紹介しています。LLMsは強力な言語生成能力を持っていますが、根拠のない情報を生成する傾向があります。この問題を解決するために、Retrieval Augmented Generation、Knowledge Retrieval、CoNLI、CoVeなどの技術が開発されています。さらに、データセットの利用やフィードバックメカニズムなどのパラメータに基づいてこれらの方法を分類し、幻覚の問題に取り組むためのアプローチを提案しています。また、これらの技術に関連する課題や制約についても分析し、将来の研究に向けた基盤を提供しています。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/TabularData.html">#TabularData</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2024-01-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1216">Chain-of-Table: Evolving Tables in the Reasoning Chain for Table   Understanding, Zilong Wang+, N_A, ICLR'24</a>
<span class="snippet"><span>Summary</span>LLMsを使用したChain-of-Tableフレームワークは、テーブルデータを推論チェーン内で活用し、テーブルベースの推論タスクにおいて高い性能を発揮することが示された。このフレームワークは、テーブルの連続的な進化を表現し、中間結果の構造化情報を利用してより正確な予測を可能にする。さまざまなベンチマークで最先端のパフォーマンスを達成している。</span>
<span class="snippet"><span>Comment</span>Table, Question, Operation Historyから次のoperationとそのargsを生成し、テーブルを順次更新し、これをモデルが更新の必要が無いと判断するまで繰り返す。最終的に更新されたTableを用いてQuestionに回答する手法。Questionに回答するために、複雑なテーブルに対する操作が必要なタスクに対して有効だと思われる。

<br>

<img src="https://github.com/user-attachments/assets/f23bdacf-ffc0-4d37-b992-62fea094c9d2" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/90ec4404-7ed0-4698-8223-15134b195977" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<span class="issue_date">Issue Date: 2024-01-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1214">Leveraging Large Language Models for NLG Evaluation: A Survey, Zhen Li+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>本研究は、大規模言語モデル（LLMs）を使用した自然言語生成（NLG）の評価についての包括的な概要を提供します。既存の評価指標を整理し、LLMベースの手法を比較するためのフレームワークを提案します。さらに、未解決の課題についても議論し、より公正で高度なNLG評価技術を提唱します。</span>
<span class="snippet"><span>Comment</span>重要NLGの評価をするモデルのアーキテクチャとして、BERTScoreのようなreferenceとhvpothesisのdistiebuted representation同士を比較するような手法（matching-based）と、性能指標を直接テキストとして生成するgenerative-basedな手法があるよ、

<br>

<img src="https://github.com/user-attachments/assets/b6b4de14-a83b-4138-92f4-c6606451f272" alt="image" loading="lazy">

<br>



<br>

といった話や、そもそもreference-basedなメトリック（e.g. BLEU）や、reference-freeなメトリック（e.g. BARTScore）とはなんぞや？みたいな基礎的な話から、言語モデルを用いたテキスト生成の評価手法の代表的なものだけでなく、タスクごとの手法も整理されて記載されている。また、BLEUやROUGEといった伝統的な手法の概要や、最新手法との同一データセットでのメタ評価における性能の差なども記載されており、全体的に必要な情報がコンパクトにまとまっている印象がある。

<br>



<br>

<img src="https://github.com/user-attachments/assets/dd9e49ee-5b08-45c4-9b82-2b9dcae12baa" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/a1a0708d-4f95-46ba-bda1-7c06c4c393cf" alt="image" loading="lazy"></span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/ModelMerge.html">#ModelMerge</a>
<span class="issue_date">Issue Date: 2024-01-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1213">Knowledge Fusion of Large Language Models, Fanqi Wan+, N_A, ICLR'24</a>
<span class="snippet"><span>Summary</span>本研究では、既存の事前訓練済みの大規模言語モデル（LLMs）を統合することで、1つの強力なモデルを作成する方法を提案しています。異なるアーキテクチャを持つ3つの人気のあるLLMsを使用して、ベンチマークとタスクのパフォーマンスを向上させることを実証しました。提案手法のコード、モデルの重み、およびデータはGitHubで公開されています。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2024-01-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1212">Self-Rewarding Language Models, Weizhe Yuan+, N_A, ICML'24</a>
<span class="snippet"><span>Summary</span>将来のモデルのトレーニングには超人的なフィードバックが必要であり、自己報酬を提供するSelf-Rewarding Language Modelsを研究している。LLM-as-a-Judgeプロンプトを使用して、言語モデル自体が自己報酬を提供し、高品質な報酬を得る能力を向上させることを示した。Llama 2 70Bを3回のイテレーションで微調整することで、既存のシステムを上回るモデルが得られることを示した。この研究は、改善可能なモデルの可能性を示している。</span>
<span class="snippet"><span>Comment</span>人間の介入無しで（人間がアノテーションしたpreference data無しで）LLMのAlignmentを改善していく手法。LLM-as-a-Judge Promptingを用いて、LLM自身にpolicy modelとreward modelの役割の両方をさせる。unlabeledなpromptに対してpolicy modelとしてresponceを生成させた後、生成したレスポンスをreward modelとしてランキング付けし、DPOのpreference pairとして利用する、という操作を繰り返す。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/32db0422-6fb1-4741-bdfa-45a5e83e76c4" alt="image" loading="lazy"></span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2024-01-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1210">Transformers are Multi-State RNNs, Matanel Oren+, N_A, EMNLP'24</a>
<span class="snippet"><span>Summary</span>本研究では、トランスフォーマーのデコーダーは無限マルチステートRNNとして概念化できることを示し、有限のマルチステートRNNに変換することも可能であることを示します。さらに、新しいキャッシュ圧縮ポリシーであるTOVAを導入し、他のポリシーよりも優れた性能を示すことを実験結果で示しました。TOVAは元のキャッシュサイズの1/8しか使用せず、トランスフォーマーデコーダーLLMが実際にはRNNとして振る舞うことが多いことを示しています。</span>
<span class="snippet"><span>Comment</span>TransformerはRNNとは異なる概念、特に全てのトークンの情報に直接アクセスできるということで区別されてきたが、よくよく考えてみると、Transformer Decoderは、RNNのhidden_states h を（hは1つのstateをベクトルで表している）、multi-stateを表す matrix H （t個のstateを表すmatrix; tは現在の着目しているトークンまでのsequenceの長さ）で置き換えたもの Multi-State-RNN (MSRNN) と解釈できる、という話。

<br>

また、window attentionなどのattentionの計算で考慮するKV cacheのスパンを（メモリを節約するために）制限する圧縮手法は、先ほどのMSRNNは全トークンのstate （KV Cache）にアクセスできる（= Unbounded）と考えると、アクセスできるトークンのstateが k (&lt;t) となるため、BoundedなMSRNNとみなせる。

<br>

したがって、現在のLLMはTransformer Decoderを積み上げたものであるものであり、原理上はinference/training時に全てのトークンを考慮できるため、原理上はUnboundedなMSRNNとみなせる。一方、ここにメモリの制約が加わるとKV Cacheを圧縮しなければならないため、実用上はBoundedなMSRNNとなっている。

<br>



<br>

<img width="476" alt="Image" src="https://github.com/user-attachments/assets/292bd370-0138-441a-a626-ee73cb2f31b5">

<br>



<br>

実際に式で表すと以下のようにRNNとTransformerは対応づけられる。

<br>

<img width="402" alt="Image" src="https://github.com/user-attachments/assets/3b2cbadc-e6ef-4465-ac78-bb4ff71351f2">

<br>

<img width="487" alt="Image" src="https://github.com/user-attachments/assets/18a99f2a-06dc-472c-b50d-743b820904f3">

<br>



<br>

このことを考慮して、本研究ではTOVAと呼ばれる新しいKV Cacheの圧縮手法を提案している。非常にシンプルな手法で、KV Cacheがメモリの上限に到達したときに、その際にattention scoreが最も小さいトークンのKV Cacheを捨てる、という手法である。

<br>

<img width="495" alt="Image" src="https://github.com/user-attachments/assets/09f19caf-bcea-42f7-b1e0-8bc3ea8a2e4c">

<br>



<br>

TOVAをwindow attentionなどのベースラインとオラクルとしてfull attentionと比較。タスクは Language Modeling（PG-19データにおけるPerplexity）、Language Understanding （long contextからrelevantな情報を拾う必要があるQA）、Story Generation（長文のストーリーを書かせてGPT4によってpair-wiseで生成されたストーリーの品質をLLM-as-a-Judgeさせる）を利用。既存のKV Cache圧縮手法よりも効率的にKV Cacheを圧縮でき、4096 context windowの場合は、512程度でfull attentionと近い性能を示すことが示された。これにより、高いメモリ効率とスループットを実現できる。ここで、グラフのx軸のmultistateはTOVAにおいてはmatrix Hで保持するstate数に相当し、window attentionでは、window sizeに相当する。

<br>

<img width="815" alt="Image" src="https://github.com/user-attachments/assets/fd39d465-3a0d-49ad-951b-fddb115394f3">

<br>



<br>

<img width="636" alt="Image" src="https://github.com/user-attachments/assets/c66bade9-f0c4-476b-8243-bd1d88e21ead"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<span class="issue_date">Issue Date: 2024-01-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1208">The Impact of Reasoning Step Length on Large Language Models, Mingyu Jin+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>Chain of Thought（CoT）の推論ステップの長さとLLMsの推論能力の関係を調査した。推論ステップを延長すると、プロンプトに新しい情報を追加せずにLLMsの推論能力が向上することがわかった。逆に、キーとなる情報を保持しながら推論ステップを短縮すると、推論能力が低下する。また、誤った根拠でも推論の必要な長さを保つ限り、好ましい結果が得られることも示された。さらに、タスクによって推論ステップの増加の利点が異なることも観察された。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-01-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1204">Mixtral of Experts, Albert Q. Jiang+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>Mixtralは、Sparse Mixture of Experts（SMoE）言語モデルであり、各レイヤーが8つのフィードフォワードブロックで構成されています。Mixtralは、トークンごとに2つのエキスパートを選択し、それらの出力を組み合わせます。Mixtralは、Llama 2 70BとGPT-3.5を上回る性能を持ち、数学、コード生成、多言語のベンチマークで特に優れています。また、Mixtral 8x7B Instructという指示に従うモデルも提供されており、人間のベンチマークを凌駕しています。</span>
<span class="snippet"><span>Comment</span>Mixture of experts Layer: inputを受け取ったrouterが、8つのexpertsのうち2つを選択し順伝搬。2つのexpertsのoutputを加重平均することで最終的なoutputとする。

<br>

<img src="https://github.com/user-attachments/assets/52ca3ed3-714f-4bc2-af76-c6884fc37927" alt="image" loading="lazy"></span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/SpeechProcessing.html">#SpeechProcessing</a>
<a class="button" href="articles/CVPR.html">#CVPR</a>
<a class="button" href="articles/Encoder-Decoder.html">#Encoder-Decoder</a>
<a class="button" href="articles/Robotics.html">#Robotics</a>
<span class="issue_date">Issue Date: 2023-12-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1202">Unified-IO 2: Scaling Autoregressive Multimodal Models with Vision,   Language, Audio, and Action, Jiasen Lu+, N_A, CVPR'24</a>
<span class="snippet"><span>Summary</span>Unified-IO 2は、最初の自己回帰型のマルチモーダルモデルであり、画像、テキスト、音声、アクションを理解し生成することができます。異なるモダリティを統一するために、共有の意味空間に入力と出力を配置し、単一のエンコーダ・デコーダトランスフォーマーモデルで処理します。さまざまなアーキテクチャの改善を提案し、大規模なマルチモーダルな事前トレーニングコーパスを使用してモデルをトレーニングします。Unified-IO 2は、GRITベンチマークを含む35以上のベンチマークで最先端のパフォーマンスを発揮します。</span>
<span class="snippet"><span>Comment</span>画像、テキスト、音声、アクションを理解できる初めてのautoregressive model。AllenAIモデルのアーキテクチャ図

<br>

<img src="https://github.com/user-attachments/assets/4282ffb0-18f1-40c9-b6d7-f004d03b8382" alt="image" loading="lazy">

<br>



<br>

マルチモーダルに拡張したことで、訓練が非常に不安定になったため、アーキテクチャ上でいくつかの工夫を加えている:

<br>



<br>

・2D Rotary Embedding

<br>

  ・Positional EncodingとしてRoPEを採用

<br>

  ・画像のような2次元データのモダリティの場合はRoPEを2次元に拡張する。具体的には、位置(i, j)のトークンについては、Q, Kのembeddingを半分に分割して、それぞれに対して独立にi, jのRoPE Embeddingを適用することでi, j双方の情報を組み込む。

<br>

・QK Normalization

<br>

  ・image, audioのモダリティを組み込むことでMHAのlogitsが非常に大きくなりatteetion weightが0/1の極端な値をとるようになり訓練の不安定さにつながった。このため、dot product attentionを適用する前にLayerNormを組み込んだ。

<br>

・Scaled Cosine Attention

<br>

  ・Image Historyモダリティにおいて固定長のEmbeddingを得るためにPerceiver Resamplerを扱ったているが、こちらも上記と同様にAttentionのlogitsが極端に大きくなったため、cosine類似度をベースとしたScaled Cosine Attention 2259 を利用することで、大幅に訓練の安定性が改善された。

<br>

・その他

<br>

  ・attention logitsにはfp32を適用

<br>

  ・事前学習されたViTとASTを同時に更新すると不安定につながったため、事前学習の段階ではfreezeし、instruction tuningの最後にfinetuningを実施

<br>



<br>

<img src="https://github.com/user-attachments/assets/74c8fa3a-8fb5-4785-8dd3-6a8cf3c7cfeb" alt="image" loading="lazy">目的関数としては、Mixture of Denoisers (1424)に着想を得て、Multimodal Mixture of Denoisersを提案。MoDでは、

<br>

・\[R\]: 通常のspan corruption (1--5 token程度のspanをmaskする)

<br>

・\[S\]: causal language modeling (inputを2つのサブシーケンスに分割し、前方から後方を予測する。前方部分はBi-directionalでも可)

<br>

・\[X\]: extreme span corruption (12&gt;=token程度のspanをmaskする)

<br>



<br>

の3種類が提案されており、モダリティごとにこれらを使い分ける:

<br>

・text modality: UL2 (1424)を踏襲

<br>

・image, audioがtargetの場合: 2つの類似したパラダイムを定義し利用

<br>

  ・\[R\]: patchをランダムにx%マスクしre-constructする

<br>

  ・\[S\]: inputのtargetとは異なるモダリティのみの情報から、targetモダリティを生成する

<br>



<br>

訓練時には prefixとしてmodality token \[Text\], \[Image\], \[Audio\] とparadigm token \[R\], \[S\], \[X\] をタスクを指示するトークンとして利用している。また、image, audioのマスク部分のdenoisingをautoregressive modelで実施する際には普通にやるとdecoder側でリークが発生する(a)。これを防ぐには、Encoder側でマスクされているトークンを、Decoder側でteacher-forcingする際にの全てマスクする方法(b)があるが、この場合、生成タスクとdenoisingタスクが相互に干渉してしまいうまく学習できなくなってしまう（生成タスクでは通常Decoderのinputとして[mask]が入力され次トークンを生成する、といったことは起きえないが、愚直に(b)をやるとそうなってしまう）。ので、(c)に示したように、マスクされているトークンをinputとして生成しなければならない時だけ、マスクを解除してdecoder側にinputする、という方法 (Dynamic Masking) でこの問題に対処している。

<br>

<img width="597" height="394" alt="Image" src="https://github.com/user-attachments/assets/0dba8d5d-0c93-4c56-852b-fce9869428e7"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/COLM.html">#COLM</a>
<span class="issue_date">Issue Date: 2023-11-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1155">GPQA: A Graduate-Level Google-Proof Q&amp;A Benchmark, David Rein+, N_A, COLM'24</a>
<span class="snippet"><span>Summary</span>私たちは、高品質で非常に困難な多肢選択問題からなるGPQAデータセットを提案します。このデータセットは、専門家でも高い正答率を達成できず、最先端のAIシステムでも困難であることが示されています。将来のAIシステムの開発において、スケーラブルな監督方法を開発する必要があります。これにより、スキルを持つ監督者がAIシステムから信頼性のある情報を得ることができるようになります。GPQAデータセットは、スケーラブルな監督実験を可能にし、人間の専門家がAIシステムから真実の情報を確実に得る方法を考案するのに役立つことが期待されています。</span>
<span class="snippet"><span>Comment</span>該当領域のPh.D所有者でも74%、高いスキルを持つ非専門家（Googleへアクセスして良い環境）で34%しか正答できないQAデータセット。

<br>

元ツイート: https://x.com/idavidrein/status/1727033002234909060?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QOpenReview:https://openreview.net/forum?id=Ti67584b98</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2023-10-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1110">Re-Reading Improves Reasoning in Language Models, Xiaohan Xu+, N_A, EMNLP'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）において、推論は重要で困難な問題です。従来のアプローチでは、プロンプティング戦略を開発することに焦点が当てられてきましたが、双方向の相互作用や質問の重要性には注意が払われていませんでした。この問題に対処するため、質問の再読という新しいプロンプティング戦略を提案します。再読は、質問情報を再訪することで、LLMsの推論能力を向上させることができます。実験結果は、この手法の効果と汎用性を示しており、LLMsの領域でのその有用性を強調しています。</span>
<span class="snippet"><span>Comment</span>問題文を2,3回promptで繰り返すだけで、数学のベンチマークとCommonsenseのベンチマークの性能が向上したという非常に簡単なPrompting。self-consistencyなどの他のPromptingとの併用も可能。

<br>

なぜ性能が向上するかというと、

<br>

1. LLMはAuporegressiveなモデルであり、bidirectionalなモデルではない。このため、forwardパスのみでは読解力に限界がある。（たとえば人間はしばしばテキストを読み返したりする）。そこで、一度目の読解で概要を理解し、二度目の読解でsalience partを読み込むといったような挙動を実現することで、より問題文に対するComprehensionが向上する。

<br>

2. LLMはしばしばpromptの重要な箇所の読解を欠落させてしまう。たとえば、793 では、promptのmiddle partを軽視する傾向があることが示されている。このような現象も軽減できると考えられる。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/e575e0aa-b76c-444e-b9b0-e984d6fc73cf" alt="image" loading="lazy">

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/1b2344fb-bfb4-467b-9dbb-05e4eff23d06" alt="image" loading="lazy">

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/fcaa2337-cfce-4e0c-b068-a7de2c0eff78" alt="image" loading="lazy">

<br>

問題文の繰り返しは、3回までは性能が向上する。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/e333e807-24d4-4a64-b768-cbd6dfbceecd" alt="image" loading="lazy">このpromptingは複雑な問題であればあるほど効果があると推察される。</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2023-10-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1105">Self-RAG: Learning to Retrieve, Generate, and Critique through   Self-Reflection, Akari Asai+, N_A, ICLR'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）は、事実に基づかない回答を生成することがあります。そこで、自己反省的な検索増強生成（Self-RAG）という新しいフレームワークを提案します。このフレームワークは、検索と自己反省を通じてLLMの品質と事実性を向上させます。実験結果は、Self-RAGが最先端のLLMsおよび検索増強モデルを大幅に上回ることを示しています。</span>
<span class="snippet"><span>Comment</span>RAGをする際の言語モデルの回答の質とfactual consistencyを改善せるためのフレームワーク。

<br>

reflection tokenと呼ばれる特殊トークンを導入し、言語モデルが生成の過程で必要に応じて情報をretrieveし、自身で生成内容を批評するように学習する。単語ごとに生成するのではなく、セグメント単位で生成する候補を生成し、批評内容に基づいて実際に生成するセグメントを選択する。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/282eb6fd-d2bd-4804-a0bc-652158e2f857" alt="image" loading="lazy">

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/cf690500-7002-454d-bc7c-0664d152a664" alt="image" loading="lazy">OpenReview:https://openreview.net/forum?id=hSyW5go0v8</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-10-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1072">Think before you speak: Training Language Models With Pause Tokens, Sachin Goyal+, N_A, ICLR'24</a>
<span class="snippet"><span>Summary</span>言語モデルのトレーニングと推論において、遅延を導入することでモデルの性能を向上させる手法を提案しました。具体的には、入力に特定のトークンを追加し、そのトークンが現れるまでモデルの出力を遅らせることで、追加の計算を行うことができます。実験結果では、この手法が推論タスクにおいて有益であり、特にQAタスクでの性能向上が見られました。今後は、この遅延予測の手法をさらに研究していく必要があります。</span>
<span class="snippet"><span>Comment</span>この研究は興味深いが、事前学習時に入れないと効果が出にくいというのは直感的にわかるので、実用的には活用しづらい。

<br>

また、promptでこの研究をimitateする方法については、ZeroShot CoTにおいて、思考プロセスを明示的に指定するようなpromptingと同様のことを行っており、これは実際に効果があると思う。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/PositionalEncoding.html">#PositionalEncoding</a>
<a class="button" href="articles/NAACL.html">#NAACL</a>
<span class="issue_date">Issue Date: 2023-10-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1060">Effective Long-Context Scaling of Foundation Models, Wenhan Xiong+, N_A, NAACL'24</a>
<span class="snippet"><span>Summary</span>私たちは、長いコンテキストをサポートする一連のLLMsを提案します。これらのモデルは、長いテキストを含むデータセットでトレーニングされ、言語モデリングや他のタスクで評価されます。提案手法は、通常のタスクと長いコンテキストのタスクの両方で改善をもたらします。また、70Bバリアントはgpt-3.5-turbo-16kを上回るパフォーマンスを実現します。さらに、私たちはLlamaの位置エンコーディングや事前学習プロセスの設計選択の影響についても分析しました。結果から、長いコンテキストの継続的な事前学習が効果的であることが示されました。</span>
<span class="snippet"><span>Comment</span>以下elvis氏のツイートの意訳

<br>



<br>

Metaが32kのcontext windowをサポートする70BのLLaMa2のvariant提案し、gpt-3.5-turboをlong contextが必要なタスクでoutperform。

<br>

short contextのLLaMa2を継続的に訓練して実現。これには人手で作成したinstruction tuning datasetを必要とせず、コスト効率の高いinstruction tuningによって実現される。

<br>

これは、事前学習データセットに長いテキストが豊富に含まれることが優れたパフォーマンスの鍵ではなく、ロングコンテキストの継続的な事前学習がより効率的であることを示唆している。

<br>

元ツイート: https://x.com/omarsar0/status/1707780482178400261?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q位置エンコーディングにはlong contxet用に、RoPEのbase frequency bを `10,000-&gt;500,000` とすることで、rotation angleを小さくし、distant tokenに対する減衰の影響を小さくする手法を採用 (Adjusted Base Frequency; ABF)。token間の距離が離れていても、attention scoreがshrinkしづらくなっている。

<br>



<br>

<img width="578" height="291" alt="Image" src="https://github.com/user-attachments/assets/968c88f1-5a0d-4c2a-94ef-d63ffb0ea2eb">

<br>



<br>



<br>

また、単に長いコンテキストのデータを追加するだけでなく、データセット内における長いコンテキストのデータの比率を調整することで、より高い性能が発揮できることを示している。これをData Mixと呼ぶ。

<br>

また、instruction tuningのデータには、LLaMa2ChatのRLHFデータをベースに、LLaMa2Chat自身にself-instructを活用して、長いコンテキストを生成させ拡張したものを利用した。

<br>

具体的には、コーパス内のlong documentを用いたQAフォーマットのタスクに着目し、文書内のランダムなチャンクからQAを生成させた。その後、self-critiqueによって、LLaMa2Chat自身に、生成されたQAペアのverificationも実施させた。</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2023-09-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1044">[Paper Note] Chain-of-Verification Reduces Hallucination in Large Language Models, Shehzaad Dhuliawala+, N_A, ACL'24</a>
<span class="snippet"><span>Summary</span>私たちは、言語モデルが根拠のない情報を生成する問題に取り組んでいます。Chain-of-Verification（CoVe）メソッドを開発し、モデルが回答を作成し、検証し、最終的な回答を生成するプロセスを経ることで、幻想を減少させることができることを実験で示しました。</span>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

ユーザの質問から、Verificationのための質問をplanningし、質問に対して独立に回答を得たうえでオリジナルの質問に対するaggreementを確認し、最終的に生成を実施するPrompting手法

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/18763903-2d70-4180-9384-2da55bedad2e" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

評価

<br>



<br>

dataset

<br>



<br>

・Wikidata

<br>



<br>

    ・Wikipedia APIから自動生成した「“Who are some [Profession]s who were born in [City]?”」に対するQA pairs

<br>



<br>

    ・Goldはknowledge baseから取得

<br>



<br>

    ・全56 test questions

<br>



<br>

    ・Gold Entityが大体600程度ありLLMは一部しか回答しないので、precisionで評価

<br>



<br>

・Wiki category list

<br>



<br>

    ・QUEST datasetを利用 701 

<br>



<br>

    ・回答にlogical operationが不要なものに限定して頭に"Name some"をつけて質問を生成

<br>



<br>

        ・"Name some Mexican animated horror films" or "Name some Endemic orchids of Vietnam"

<br>



<br>

    ・8個の回答を持つ55 test questionsを作成

<br>



<br>

・MultiSpanQA

<br>



<br>

    ・Reading Comprehensionに関するBenchmark dataset

<br>



<br>

    ・複数の独立した回答（回答は連続しないスパンから回答が抽出される）から構成される質問で構成

<br>



<br>

        ・特に、今回はclosed-book setting で実施

<br>



<br>

        ・すなわち、与えられた質問のみから回答しなければならず、知っている知識が問われる問題

<br>



<br>

    ・418のtest questsionsで、各回答に含まれる複数アイテムのspanが3 token未満となるようにした

<br>



<br>

    ・QA例:

<br>



<br>

        ・Q: Who invented the first printing press and in what year?

<br>



<br>

        ・A: Johannes Gutenberg, 1450.

<br>



<br>

評価結果

<br>



<br>

提案手法には、verificationの各ステップでLLMに独立したpromptingをするかなどでjoint, 2-step, Factored, Factor+Revisedの4種類のバリエーションがあることに留意。

<br>



<br>

・joint: 全てのステップを一つのpromptで実施

<br>



<br>

・2-stepは2つのpromptに分けて実施

<br>



<br>

・Factoredは各ステップを全て異なるpromptingで実施

<br>



<br>

・Factor+Revisedは異なるpromptで追加のQAに対するcross-checkをかける手法

<br>



<br>

結果を見ると、CoVEでhallucinationが軽減され、特にjointよりも2-step, factoredの方が高い性能を示すことがわかる。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/05ff1e6c-75e7-428a-996f-61e844866391" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/d72aa05e-daab-4092-a6f5-9e80cdab7486" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2023-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/924">SelfCheck: Using LLMs to Zero-Shot Check Their Own Step-by-Step   Reasoning, Ning Miao+, N_A, ICLR'24</a>
<span class="snippet"><span>Summary</span>最新の大規模言語モデル（LLMs）は、推論問題を解決するために有望な手法ですが、複雑な問題にはまだ苦戦しています。本研究では、LLMsが自身のエラーを認識する能力を持っているかどうかを探求し、ゼロショットの検証スキームを提案します。この検証スキームを使用して、異なる回答に対して重み付け投票を行い、質問応答のパフォーマンスを向上させることができることを実験で確認しました。</span>
<span class="snippet"><span>Comment</span>これはおもしろそう。後で読むOpenReview:https://openreview.net/forum?id=pTHfApDakA</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<a class="button" href="articles/COLM.html">#COLM</a>
<span class="issue_date">Issue Date: 2023-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/917">LoraHub: Efficient Cross-Task Generalization via Dynamic LoRA   Composition, Chengsong Huang+, N_A, COLM'24</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）を新しいタスクに適応させるための低ランク適応（LoRA）を検討し、LoraHubというフレームワークを提案します。LoraHubを使用すると、少数の例から複数のLoRAモジュールを組み合わせて柔軟に適応性のあるパフォーマンスを実現できます。また、追加のモデルパラメータや勾配は必要ありません。実験結果から、LoraHubが少数の例でのインコンテキスト学習のパフォーマンスを効果的に模倣できることが示されています。さらに、LoRAコミュニティの育成と共有リソースの提供にも貢献しています。</span>
<span class="snippet"><span>Comment</span>学習されたLoRAのパラメータをモジュールとして捉え、新たなタスクのinputが与えられた時に、LoRA Hub上の適切なモジュールをLLMに組み合わせることで、ICL無しで汎化を実現するというアイデア。few shotのexampleを人間が設計する必要なく、同等の性能を達成。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/9d769042-5a29-4c22-8ab4-e90195f71184" alt="image" loading="lazy">複数のLoRAモジュールは組み合わられるか？element wiseの線型結合で今回はやっているが、その疑問にこたえたのがcontributionOpenReview:https://openreview.net/forum?id=TrloAXEJ2B</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/872">SciBench: Evaluating College-Level Scientific Problem-Solving Abilities   of Large Language Models, Xiaoxuan Wang+, N_A, ICML'24</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）の進歩により、数学のベンチマークでの性能向上が示されているが、これらのベンチマークは限定的な範囲の問題に限定されていることが指摘される。そこで、複雑な科学的問題解決に必要な推論能力を検証するための包括的なベンチマークスイートSciBenchを提案する。SciBenchには、大学レベルの科学的問題を含むオープンセットと、学部レベルの試験問題を含むクローズドセットの2つのデータセットが含まれている。さらに、2つの代表的なLLMを用いた詳細なベンチマーク研究を行い、現在のLLMのパフォーマンスが不十分であることを示した。また、ユーザースタディを通じて、LLMが犯すエラーを10の問題解決能力に分類し、特定のプロンプティング戦略が他の戦略よりも優れているわけではないことを明らかにした。SciBenchは、LLMの推論能力の向上を促進し、科学研究と発見に貢献することを目指している。</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/LearningToRank.html">#LearningToRank</a>
<a class="button" href="articles/PairWise.html">#PairWise</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/NAACL.html">#NAACL</a>
<span class="issue_date">Issue Date: 2023-07-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/799">Large Language Models are Effective Text Rankers with Pairwise Ranking   Prompting, Zhen Qin+, N_A, NAACL'24</a>
<span class="snippet"><span>Summary</span>LLMsを使用してドキュメントをランキングする際に、Pairwise Ranking Prompting（PRP）という新しい技術を提案する。PRPは、LLMsへの負荷を軽減し、最先端のランキングパフォーマンスを達成することができる。具体的には、20Bパラメータを持つFlan-UL2モデルに基づくPRPは、商用のGPT-4に基づく従来の手法を上回る結果を示した。さらに、PRPのバリアントを提案し、効率を改善することができることを示した。PRPは生成とスコアリングのLLM APIの両方をサポートし、入力の順序に対して無感度であることも示された。</span>
<span class="snippet"><span>Comment</span>open source LLMにおいてスタンダードなランキングタスクのベンチマークでSoTAを達成できるようなprompting技術を提案従来のランキングのためのpromptingはpoint-wiseとlist wiseしかなかったが、前者は複数のスコアを比較するためにスコアのcalibrationが必要だったり、OpenAIなどのAPIはlog probabilityを提供しないため、ランキングのためのソートができないという欠点があった。後者はinputのorderingに非常にsensitiveであるが、listのすべての組み合わせについてorderingを試すのはexpensiveなので厳しいというものであった。このため（古典的なlearning to rankでもおなじみや）pairwiseでサンプルを比較するランキング手法PRPを提案している。

<br>



<br>

PRPはペアワイズなのでorderを入れ替えて評価をするのは容易である。また、generation modeとscoring mode（outputしたラベルのlog probabilityを利用する; OpenLLMを使うのでlog probabilityを計算できる）の2種類を採用できる。ソートの方法についても、すべてのペアの勝敗からから単一のスコアを計算する方法（AllPair), HeapSortを利用する方法、LLMからのoutputを得る度にon the flyでリストの順番を正しくするSliding Windowの3種類を提案して比較している。

<br>

<img src="https://github.com/user-attachments/assets/7ad366c6-2afd-404b-9e7d-6051030983c6" alt="image" loading="lazy">

<br>



<br>

下表はscoring modeでの性能の比較で、GPT4に当時は性能が及んでいなかった20BのOpenLLMで近しい性能を達成している。

<br>

<img src="https://github.com/user-attachments/assets/7455b844-107f-4e88-85b8-3b5fc2866cc8" alt="image" loading="lazy">

<br>



<br>

また、PRPがinputのorderに対してロバストなことも示されている。

<br>

<img src="https://github.com/user-attachments/assets/5244fb56-a9bf-46c9-89ca-f2766f7ba4a0" alt="image" loading="lazy"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<a class="button" href="articles/TACL.html">#TACL</a>
<span class="issue_date">Issue Date: 2023-07-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/793">Lost in the Middle: How Language Models Use Long Contexts, Nelson F. Liu+, N_A, TACL'24</a>
<span class="snippet"><span>Summary</span>最近の言語モデルは、長い文脈を入力として受け取ることができますが、その長い文脈をどれだけうまく利用しているかについてはまだよくわかっていません。この研究では、マルチドキュメントの質問応答とキー・バリューの検索という2つのタスクにおいて、言語モデルのパフォーマンスを分析しました。その結果、関連情報が入力文脈の始まりや終わりにある場合、パフォーマンスが最も高くなることがわかりましたが、長い文脈の中で関連情報にアクセスする必要がある場合、パフォーマンスが著しく低下します。さらに、入力文脈が長くなるにつれて、明示的に長い文脈を扱うモデルでもパフォーマンスが大幅に低下します。この分析は、言語モデルが入力文脈をどのように利用しているかをより良く理解するためのものであり、将来の長い文脈モデルのための新しい評価プロトコルを提供します。</span>
<span class="snippet"><span>Comment</span>元ツイート

<br>

https://twitter.com/drjimfan/status/1678460065811136512?s=46&t=5BO_qSlNBSEGSugyUlP5Hw

<br>



<br>

非常に重要な知見がまとめられている1. モデルはコンテキストのはじめと最後の情報をうまく活用でき、真ん中の情報をうまく活用できない

<br>

2. 長いコンテキストのモデルを使っても、コンテキストをより短いコンテキストのモデルよりもうまく考慮できるわけではない

<br>

3. モデルのパフォーマンスは、コンテキストが長くなればなるほど悪化する</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2023-04-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/554">Active prompting with chain-of-thought for large language models, Diao+, The Hong Kong University of Science and Technology, ACL'24</a>
<span class="snippet"><span>Comment</span>しっかりと読めていないが、CoT-answerが存在しないtrainingデータが存在したときに、nサンプルにCoTとAnswerを与えるだけでFew-shotの予測をtestデータに対してできるようにしたい、というのがモチベーションっぽい

<br>



<br>

そのために、questionに対して、training dataに対してFew-Shot CoTで予測をさせた場合やZero-Shot CoTによって予測をさせた場合などでanswerを取得し、answerのばらつき度合いなどから不確実性を測定する。

<br>



<br>

そして、不確実性が高いCoT-Answerペアを取得し、人間が手作業でCoTと回答のペアを与え、その人間が作成したものを用いてTestデータに対してFewShotしましょう、ということだと思われる。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234747555-4b7bd0d5-f099-4288-a470-32206533e652.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/SpeechProcessing.html">#SpeechProcessing</a>
<a class="button" href="articles/AAAI.html">#AAAI</a>
<span class="issue_date">Issue Date: 2023-04-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/547">AudioGPT: Understanding and Generating Speech, Music, Sound, and Talking Head, AAAI'24</a>
<span class="snippet"><span>Summary</span>AudioGPTは、複雑な音声情報を処理し、音声対話をサポートするマルチモーダルAIシステムである。基盤モデルとASR、TTSインターフェースを組み合わせ、音声、音楽、トーキングヘッドの理解と生成を行う。実験により、AudioGPTが多様なオーディオコンテンツの創造を容易にする能力を示した。</span>
<span class="snippet"><span>Comment</span>text, audio, imageといったマルチモーダルなpromptから、audioに関する様々なタスクを実現できるシステムマルチモーダルデータをjointで学習したというわけではなく、色々なモデルの組み合わせてタスクを実現しているっぽい

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234739859-f833706a-6040-484a-b015-553a719484d7.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<span class="issue_date">Issue Date: 2023-04-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/542">Scaling Instruction-Finetuned Language Models, Chung+, Google, JMLR'24</a>
<span class="snippet"><span>Summary</span>指示ファインチューニングは、タスク数、モデルサイズ、チェーン・オブ・ソートデータを活用し、言語モデルの性能を向上させる手法である。Flan-PaLM 540Bは1.8Kタスクでファインチューニングされ、PaLM 540Bを上回る+9.4%の改善を達成し、MMLUで75.2%の性能を示した。Flan-T5も強力な少数ショット性能を発揮し、指示ファインチューニングは事前学習モデルの性能向上に寄与する。</span>
<span class="snippet"><span>Comment</span>T5をinstruction tuningしたFlanT5の研究</span>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/PersonalizedGeneration.html">#PersonalizedGeneration</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2023-04-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/536">LaMP: When Large Language Models Meet Personalization, Selemi+, University of Massachusetts Amherst （w_ Google Research）, ACL'24</a>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

Personalizationはユーザのニーズや嗜好に応えるために重要な技術で、IRやRecSysで盛んに研究されてきたが、NLPではあまり実施されてこなかった。しかし、最近のタスクで、text classificationやgeneration taskでPersonalizationの重要性が指摘されている。このような中で、LLMでpersonalizedなレスポンスを生成し、評価することはあまり研究されていない。そこで、LaMPベンチマークを生成し、LLMにおけるPersonalizationをするための開発と評価をするための第一歩として提案している。

<br>



<br>

 

<br>



<br>

Personalizing LLM Outputs

<br>



<br>

LLMに対してPersonalizedなoutputをさせるためには、profileをpromptに埋め込むことが基本的なアプローチとなる。

<br>



<br>



<br>



<br>

Problem Formulation

<br>



<br>

まず、user profile（ユーザに関するrecordの集合）をユーザとみなす。データサンプルは以下の3つで構成される：

<br>



<br>

・x: モデルのinputとなるinput sequence

<br>



<br>

・y: モデルが生成することを期待するtarget output

<br>



<br>

・u: user profile（ユーザの嗜好やrequirementsを捉えるための補助的な情報）

<br>



<br>

そして、p\(y | x, u) を最大化する問題として定式化される。それぞれのユーザuに対して、モデルは{\(x\_u1, y\_u1,)...\(x\_un, y\_un)}を利用することができる。

<br>



<br>



<br>



<br>

A Retrieval Augmentation Approach for Personaliozing LLMs

<br>



<br>

user profileは基本的にめちゃめちゃ多く、promptに入れ込むことは非現実的。そこで、reteival augmentation approachと呼ばれる手法を提案している。LLMのcontext windowは限られているので、profileのうちのsubsetを利用することが現実的なアプローチとなる。また、必ずしも全てのユーザプロファイルがあるタスクを実施するために有用とは限らない。このため、retrieval augmentation approachを提案している。

<br>



<br>

retrieval augmentation approachでは、現在のテストケースに対して、relevantな部分ユーザプロファイルを選択的に抽出するフレームワークである。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234442873-01a4961b-feab-42d3-b59c-ee26daad957f.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

(x_i, y_i)に対してpersonalizationを実現するために、3つのコンポーネントを採用している：

<br>



<br>

1. query generation function: x_iに基づきuser profileからrelevantな情報を引っ張ってくるquery qを生成するコンポーネント

<br>



<br>

2. retrieval model R(q, P_u, k): query q, プロファイルP_u, を用いて、k個のrelevantなプロファイルを引っ張ってくるモデル

<br>



<br>

3. prompt construction function: xとreteival modelが引っ張ってきたエントリからpromptを作成するコンポーネント

<br>



<br>

1, 2, 3によって生成されたprompt x^barと、yによってモデルを訓練、あるいは評価する。

<br>



<br>

この研究では、Rとして Contriever 540 , BM25, random selectionの3種類を用いている。

<br>



<br>



<br>



<br>

LaMPベンチマーク

<br>



<br>

GLUEやSuper Glue、KILT、GENといったベンチマークは、"one-size-fits-all"なモデリングと評価を前提としており、ユーザのニーズに答えるための開発を許容していない。一方で、LaMPは、以下のようなPersonalizationが必要なさまざまなタスクを統合して作成されたデータセットである。

<br>



<br>

・Personalized Text Classification

<br>



<br>

  ・Personalized Citation Identification (binary classification)

<br>



<br>

    ・Task definition

<br>



<br>

      ・user u が topic xに関する論文を書いたときに、何の論文をciteすべきかを決めるタスク

<br>



<br>

      ・user uが書いた論文のタイトルが与えられたとき、2つのcandidate paperのうちどちらをreferenceとして利用すべきかを決定する2値分類

<br>



<br>

    ・Data Collection

<br>



<br>

      ・Citation Network Datasetを利用。最低でも50本以上論文を書いているauthorを抽出し、authorの論文のうちランダムに論文と論文の引用を抽出

<br>



<br>

      ・negative document selectionとして、ランダムに共著者がciteしている論文をサンプリング

<br>



<br>

   ・Profile Specification

<br>



<br>

     ・ ユーザプロファイルは、ユーザが書いた全てのpaper

<br>



<br>

     ・titleとabstractのみをuser profileとして保持した

<br>



<br>

    ・Evaluation

<br>



<br>

      ・train/valid/testに分け、accuracyで評価する

<br>



<br>

  ・Personalized News Categorization (15 category分類)

<br>



<br>

    ・Task definition

<br>



<br>

      ・LLMが journalist uによって書かれたニュースを分類する能力を問うタスク

<br>



<br>

      ・u によって書かれたニュースxが与えられた時、uの過去の記事から得られるカテゴリの中から該当するカテゴリを予測するタスク

<br>



<br>

    ・Data Collection

<br>



<br>

      ・news categorization datasetを利用（Huff Postのニュース）

<br>



<br>

      ・記事をfirst authorでグルーピング

<br>



<br>

      ・グルーピングした記事群をtrain/valid/testに分割

<br>



<br>

      ・それぞれの記事において、記事をinputとし、その記事のカテゴリをoutputとする。そして残りの記事をuser profileとする。

<br>



<br>

    ・Profile Specification

<br>



<br>

      ・ユーザによって書かれた記事の集合

<br>



<br>

    ・Evaluation

<br>



<br>

      ・accuracy, macro-averaged F1で評価 

<br>



<br>

  ・Personalized Product Rating (5-star rating)

<br>



<br>

    ・Task definition

<br>



<br>

      ・ユーザuが記述したreviewに基づいて、LLMがユーザuの未知のアイテムに対するratingを予測する性能を問う

<br>



<br>

    ・Data Collection

<br>



<br>

      ・Amazon Reviews Datasetを利用

<br>



<br>

      ・reviewが100件未満、そしてほとんどのreviewが外れ値なユーザ1%を除外

<br>



<br>

      ・ランダムにsubsetをサンプリングし、train/valid/testに分けた

<br>



<br>

      ・input-output pairとしては、inputとしてランダムにユーザのreviewを選択し、その他のreviewをprofileとして利用する。そして、ユーザがinputのレビューで付与したratingがground truthとなる。

<br>



<br>

    ・Profile Specification

<br>



<br>

      ・ユーザのレビュ

<br>



<br>

    ・Evaluation

<br>



<br>

      ・ ttrain/valid/testに分けてRMSE, MAEで評価する

<br>



<br>

・Personalized Text Generation

<br>



<br>

  ・Personalized News Headline Generation

<br>



<br>

    ・Task definition

<br>



<br>

      ・ユーザuが記述したニュースのタイトルを生成するタスク

<br>



<br>

      ・特に、LLMが与えられたprofileに基づいてユーザのinterestsやwriting styleを捉え、適切にheadlinに反映させる能力を問う

<br>



<br>

   ・Data Collection

<br>



<br>

     ・News Categorization datasetを利用（Huff Post）

<br>



<br>

     ・データセットではauthorの情報が提供されている

<br>



<br>

     ・それぞれのfirst authorごとにニュースをグルーピングし、それぞれの記事をinput, headlineをoutputとした。そして残りの記事をprofileとした

<br>



<br>

   ・Profile Specification

<br>



<br>

     ・ユーザの過去のニュース記事とそのheadlineの集合をprofileとする

<br>



<br>

   ・Evaluation

<br>



<br>

     ・ROUGE-1, ROUGE-Lで評価

<br>



<br>

  ・Personalized Scholarly Title Generation

<br>



<br>

    ・Task Definition

<br>



<br>

      ・ユーザの過去のタイトルを考慮し、LLMがresearch paperのtitleを生成する能力を測る

<br>



<br>

    ・Data Collection

<br>



<br>

      ・Citation Network Datasetのデータを利用

<br>



<br>

      ・abstractをinput, titleをoutputとし、残りのpaperをprofileとした

<br>



<br>

    ・Profile Specification

<br>



<br>

      ・ユーザが書いたpaperの集合（abstractのみを利用）

<br>



<br>

  ・Personalized Email Subject Generation

<br>



<br>

    ・Task Definition

<br>



<br>

      ・LLMがユーザのwriting styleに合わせて、Emailのタイトルを書く能力を測る

<br>



<br>

    ・Data Collection

<br>



<br>

      ・Avocado Resaerch Email Collectionデータを利用

<br>



<br>

      ・5単語未満のsubjectを持つメール、本文が30単語未満のメールを除外、

<br>



<br>

      ・送信主のemail addressでメールをグルーピング

<br>



<br>

      ・input _outputペアは、email本文をinputとし、対応するsubjectをoutputとした。他のメールはprofile

<br>



<br>

    ・Profile Specification

<br>



<br>

      ・ ユーザのemailの集合

<br>



<br>

    ・Evaluation

<br>



<br>

      ・ROUGE-1, ROUGE-Lで評価 

<br>



<br>

  ・Personalized Tweet Paraphrasing

<br>



<br>

    ・Task Definition

<br>



<br>

      ・LLMがユーザのwriting styleを考慮し、ツイートのparaphrasingをする能力を問う

<br>



<br>

    ・Data Collection

<br>



<br>

      ・Sentiment140 datasetを利用

<br>



<br>

      ・最低10単語を持つツイートのみを利用

<br>



<br>

      ・userIDでグルーピングし、10 tweets以下のユーザは除外

<br>



<br>

      ・ランダムに1つのtweetを選択し、ChatGPT(gpt-3.5-turbo)でparaphraseした

<br>



<br>

      ・paraphrase版のtweetをinput, 元ツイートをoutputとし、input-output pairを作った。

<br>



<br>

    ・User Profile Specification

<br>



<br>

      ・ユーザの過去のツイート

<br>



<br>

    ・Evaluation

<br>



<br>

      ・ROUGE-1, ROUGE-Lで評価

<br>



<br>



<br>



<br>

実験

<br>



<br>

Experimental Setup

<br>



<br>

・FlanT5-baesをfinetuningした

<br>



<br>

・ユーザ単位でモデルが存在するのか否かが記載されておらず不明

<br>



<br>

結果

<br>



<br>

・Personalization入れた方が全てのタスクでよくなった

<br>



<br>

・Retrievalモデルとしては、randomの場合でも良くなったが、基本的にはContrirverを利用した場合が最も良かった

<br>



<br>

  ・=&gt; 適切なprofileを選択しpromptに含めることが重要であることが示された

<br>



<br>

・Rが抽出するサンプル kを増やすと、予測性能が増加する傾向もあったが、一部タスクでは性能の低下も招いた

<br>



<br>

・dev setを利用し、BM25/Contrieverのどちらを利用するか、kをいくつに設定するかをチューニングした結果、全ての結果が改善した

<br>



<br>

・FlanT5-XXLとgpt-3.5-turboを用いたZero-shotの設定でも実験。tweet paraphrasingタスクを除き、zero-shotでもuser profileをLLMで利用することでパフォーマンス改善。小さなモデルでもfinetuningすることで、zero-shotの大規模モデルにdownstreamタスクでより高い性能を獲得することを示している（ただし、めちゃめちゃ改善しているというわけでもなさそう）。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234452179-6fac1cd9-982f-4b48-8dfe-1d742dc1c221.png" alt="image" loading="lazy">

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234452837-8d8cdfed-ab85-4d1e-99d7-aad35ddc8979.png" alt="image" loading="lazy">

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234453453-a2393c95-a820-404f-b21c-3332f53cb851.png" alt="image" loading="lazy">

<br>



<br>

LaMPによって可能なResearch Problem

<br>



<br>

Prompting for Personalization

<br>



<br>

・Augmentationモデル以外のLLMへのユーザプロファイルの埋め込み方法

<br>



<br>

・hard promptingやsoft prompting 473 の活用

<br>



<br>

Evaluation of Personalized Text Generation

<br>



<br>

・テキスト生成で利用される性能指標はユーザの情報を評価のプロセスで考慮していない

<br>



<br>

・Personalizedなテキスト生成を評価するための適切なmetricはどんなものがあるか？

<br>



<br>

Learning to Retrieve from User Profiles

<br>



<br>

・Learning to RankをRetrieval modelに適用する方向性LaMPの作成に利用したテンプレート一覧

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234457098-5c2ba78f-dc74-45e4-bf91-f07ffd99bcb4.png" alt="image" loading="lazy">

<br>



<br>

実装とleaderboard

<br>



<br>

https://lamp-benchmark.github.io/leaderboard</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/DataGeneration.html">#DataGeneration</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2023-04-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/533">WizardLM: Empowering Large Language Models to Follow Complex Instructions, Xu+, Microsoft_Peking University, ICLR'24</a>
<span class="snippet"><span>Summary</span>本論文では、LLMを用いて複雑な指示データを自動生成する手法Evol-Instructを提案。初期の指示セットを段階的に書き換え、生成したデータでLLaMAをファインチューニングし、WizardLMモデルを構築。評価結果では、Evol-Instructからの指示が人間作成のものより優れ、WizardLMはChatGPTを上回る性能を示した。AI進化による指示生成がLLM強化の有望なアプローチであることを示唆。</span>
<span class="snippet"><span>Comment</span>instruction trainingは大きな成功を収めているが、人間がそれらのデータを作成するのはコストがかかる。また、そもそも複雑なinstructionを人間が作成するのは苦労する。そこで、LLMに自動的に作成させる手法を提案している（これはself instructと一緒）。データを生成する際は、seed setから始め、step by stepでinstructionをrewriteし、より複雑なinstructionとなるようにしていく。

<br>

これらの多段的な複雑度を持つinstructionをLLaMaベースのモデルに食わせてfinetuningした（これをWizardLMと呼ぶ）。人手評価の結果、WizardLMがChatGPTよりも好ましいレスポンスをすることを示した。特に、WizaraLMはコード生成や、数値計算といった難しいタスクで改善を示しており、複雑なinstructionを学習に利用することの重要性を示唆している。EvolInstructを提案。"1+1=?"といったシンプルなinstructionからスタートし、これをLLMを利用して段階的にcomplexにしていく。complexにする方法は2通り：

<br>



<br>

・In-Depth Evolving: instructionを5種類のoperationで深掘りする（blue direction line）

<br>



<br>

  ・add constraints

<br>



<br>

  ・deepening

<br>



<br>

  ・concretizing

<br>



<br>

  ・increase reasoning steps

<br>



<br>

  ・complicate input

<br>



<br>

・In-breadth Evolving: givenなinstructionから新しいinstructionを生成する

<br>



<br>



<br>



<br>

上記のEvolvingは特定のpromptを与えることで実行される。

<br>



<br>

また、LLMはEvolvingに失敗することがあるので、Elimination Evolvingと呼ばれるフィルタを利用してスクリーニングした。

<br>



<br>

フィルタリングでは4種類の失敗するsituationを想定し、1つではLLMを利用。2枚目画像のようなinstructionでフィルタリング。

<br>



<br>

1. instructionの情報量が増えていない場合。

<br>



<br>

2. instructionがLLMによって応答困難な場合（短すぎる場合やsorryと言っている場合）

<br>



<br>

3. puctuationやstop wordsによってのみ構成されている場合 

<br>



<br>

4.明らかにpromptの中から単語をコピーしただけのinstruction（given prompt, rewritten prompt, Rewritten Promptなど）

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234436445-e84ff44e-7b0b-4217-a735-7444b04bd760.png" alt="image" loading="lazy">

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234437210-6cb6d75f-509a-4f2e-a767-dba8861d8a69.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/AutomaticPromptEngineering.html">#AutomaticPromptEngineering</a>
<a class="button" href="articles/NAACL.html">#NAACL</a>
<span class="issue_date">Issue Date: 2023-04-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/532">Enhancing LLM Chain-of-Thought with Iterative Bootstrapping, Sun+, Xiamen University （w_ MSRA et al.）, NAACL'24</a>
<span class="snippet"><span>Comment</span>Zero shot CoTからスタートし、正しく問題に回答できるようにreasoningを改善するようにpromptをreviseし続けるループを回す。最終的にループした結果を要約し、それらをプールする。テストセットに対しては、プールの中からNshotをサンプルしinferenceを行う。

<br>

<img src="https://user-images.githubusercontent.com/12249301/234311707-0d6f3443-681a-4309-917b-d21fd1a8c024.jpeg" alt="image" loading="lazy">できそうだなーと思っていたけど、早くもやられてしまった実装: https://github.com/GasolSun36/Iter-CoTモチベーション: 既存のCoT Promptingの問題点

<br>



<br>

Inappropriate Examplars can Reduce Performance

<br>



<br>

まず、既存のCoT prompting手法は、sampling examplarがシンプル、あるいは極めて複雑な（hop-based criterionにおいて; タスクを解くために何ステップ必要かという情報; しばしば人手で付与されている？）サンプルをサンプリングしてしまう問題がある。シンプルすぎるサンプルを選択すると、既にLLMは適切にシンプルな回答には答えられるにもかかわらず、demonstrationが冗長で限定的になってしまう。加えて、極端に複雑なexampleをサンプリングすると、複雑なquestionに対しては性能が向上するが、シンプルな問題に対する正答率が下がってしまう。

<br>



<br>



<br>



<br>

続いて、demonstration中で誤ったreasoning chainを生成してしまうと、inference時にパフォーマンスが低下する問題がある。下図に示した通り、誤ったdemonstrationが増加するにつれて、最終的な予測性能が低下する傾向にある。

<br>



<br>



<br>



<br>

これら2つの課題は、現在のメインストリームな手法（questionを選択し、reasoning chainを生成する手法）に一般的に存在する。

<br>



<br>

556 , 555 のように推論時に適切なdemonstrationを選択するような取り組みは行われてきているが、test questionに対して推論するために、適切なexamplarsを選択するような方法は計算コストを増大させてしまう。

<br>



<br>

これら研究は誤った例の利用を最小限に抑えて、その悪影響を防ぐことを目指している。

<br>



<br>



<br>



<br>

一方で、この研究では、誤った例がLLMに対してcomplexityのlevelを提供し、貴重な学習をもたらすことができることを見出した。これは学生が難解だが回答可能な問題に取り組むことによって、問題解決スキルを向上させる方法に類似している。従って、誤った例を活用してLLMのパフォーマンスを向上させる方法を調査することは価値がある。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234752168-fe1d83a4-8d29-4f6c-8aa1-6bde1706beea.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Large Language Models can self-Correct with Bootstrapping

<br>



<br>

Zero-Shot CoTでreasoning chainを生成し、誤ったreasoning chainを生成したpromptをLLMに推敲させ(self-correction)正しい出力が得られるようにする。こういったプロセスを繰り返し、correct sampleを増やすことでどんどん性能が改善していった。これに基づいて、IterCoTを提案。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234786084-5a6055f6-6f42-4546-bcbf-686b1d759ca9.png" alt="image" loading="lazy">

<br>



<br>

IterCoT: Iterative Bootstrapping in Chain-of-Thought Prompting

<br>



<br>

IterCoTはweak bootstrappingとstrong bootstrappingによって構成される。

<br>



<br>



<br>



<br>

Weak bootstrapping

<br>



<br>

・Initialization

<br>



<br>

  ・Training setに対してZero-shot CoTを実施し、reasoning chainとanswerを得

<br>



<br>

・Bootstrapping 

<br>



<br>

  ・回答が誤っていた各サンプルに対して、Revise-Promptを適用しLLMに誤りを指摘し、新しい回答を生成させる。

<br>



<br>

  ・回答が正確になるまでこれを繰り返す。

<br>



<br>

・Summarization

<br>



<br>

  ・正しい回答が得られたら、Summary-Promptを利用して、これまでの誤ったrationaleと、正解のrationaleを利用し、最終的なreasoning chain (Iter-CoT)を生成する。

<br>



<br>

  ・全体のcontextual informationが加わることで、LLMにとって正確でわかりやすいreasoning chainを獲得する。

<br>



<br>

・Inference

<br>



<br>

  ・questionとIter-Cotを組み合わせ、demonstration poolに加える

<br>



<br>

  ・inference時はランダムにdemonstraction poolからサンプリングし、In context learningに利用し推論を行う

<br>



<br>



<br>



<br>

Strong Bootstrapping

<br>



<br>

コンセプトはweak bootstrappingと一緒だが、Revise-Promptでより人間による介入を行う。具体的には、reasoning chainのどこが誤っているかを明示的に指摘し、LLMにreasoning chainをreviseさせる。

<br>



<br>

これは従来のLLMからの推論を必要としないannotationプロセスとは異なっている。何が違うかというと、人間によるannnotationをLLMの推論と統合することで、文脈情報としてreasoning chainを修正することができるようになる点で異なっている。実験

<br>



<br>

Manual-CoT 551 , Random-CoT 551, Auto-CoT 554 と比較。

<br>



<br>

Iter-CoTが11個のデータセット全てでoutperformした。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234792846-e8fd2f8b-6e26-48fc-9e5d-785bcf2a6b6a.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

weak bootstrapingのiterationは4回くらいで頭打ちになった

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234793570-f57e56e4-7320-4be4-9c93-ee3be01ad389.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

また、手動でreasoning chainを修正した結果と、contextにannotation情報を残し、最後にsummarizeする方法を比較した結果、後者の方が性能が高かった。このため、contextの情報を利用しsummarizeすることが効果的であることがわかる。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/GraphBased.html">#GraphBased</a>
<span class="issue_date">Issue Date: 2023-04-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/530">Graph Neural Networks for Text Classification: A Survey, Wang+, Artificial Intelligence Review'24</a>
<span class="snippet"><span>Summary</span>テキスト分類におけるグラフニューラルネットワークの手法を2023年まで調査し、コーパスおよび文書レベルのグラフ構築や学習プロセスを詳述。課題や今後の方向性、データセットや評価指標についても考察し、異なる技術の比較を行い評価指標の利点と欠点を特定。</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<span class="issue_date">Issue Date: 2025-08-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2474">[Paper Note] Efficient Memory Management for Large Language Model Serving with  PagedAttention, Woosuk Kwon+, SOSP'23</a>
<span class="snippet"><span>Summary</span>PagedAttentionを用いたvLLMシステムを提案し、KVキャッシュメモリの無駄を削減し、リクエスト間での柔軟な共有を実現。これにより、同レベルのレイテンシでLLMのスループットを2-4倍向上。特に長いシーケンスや大規模モデルで効果が顕著。ソースコードは公開中。</span>
<span class="snippet"><span>Comment</span>（今更ながら）vLLMはこちら:

<br>

https://github.com/vllm-project/vllm

<br>



<br>

現在の主要なLLM Inference/Serving Engineのひとつ。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2025-08-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2400">[Paper Note] Physics of Language Models: Part 1, Learning Hierarchical Language  Structures, Zeyuan Allen-Zhu+, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、Transformerベースの言語モデルが文脈自由文法（CFG）による再帰的な言語構造推論をどのように行うかを調査。合成CFGを用いて長文を生成し、GPTのようなモデルがCFGの階層を正確に学習・推論できることを示す。モデルの隠れ状態がCFGの構造を捉え、注意パターンが動的プログラミングに類似していることが明らかに。また、絶対位置埋め込みの劣位や均一な注意の効果、エンコーダ専用モデルの限界、構造的ノイズによる堅牢性向上についても考察。</span>
<span class="snippet"><span>Comment</span>解説:

<br>

・1834</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Controllable.html">#Controllable</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/TextToImageGeneration.html">#TextToImageGeneration</a>
<span class="issue_date">Issue Date: 2025-08-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2373">[Paper Note] Adding Conditional Control to Text-to-Image Diffusion Models, Lvmin Zhang+, arXiv'23</a>
<span class="snippet"><span>Summary</span>ControlNetは、テキストから画像への拡散モデルに空間的な条件制御を追加するためのニューラルネットワークアーキテクチャであり、事前学習済みのエンコーディング層を再利用して多様な条件制御を学習します。ゼロ畳み込みを用いてパラメータを徐々に増加させ、有害なノイズの影響を軽減します。Stable Diffusionを用いて様々な条件制御をテストし、小規模および大規模データセットに対して堅牢性を示しました。ControlNetは画像拡散モデルの制御における広範な応用の可能性を示唆しています。</span>
<span class="snippet"><span>Comment</span>ControlNet論文</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2025-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2275">[Paper Note] Large Language Models Can Self-Improve, Jiaxin Huang+, EMNLP'23</a>
<span class="snippet"><span>Summary</span>LLMはラベルのないデータセットで自己改善可能であることを示し、Chain-of-Thoughtプロンプティングと自己一貫性を利用して高信頼度の回答を生成。これにより、540BパラメータのLLMの推論能力を向上させ、最先端のパフォーマンスを達成。ファインチューニングが自己改善に重要であることも確認。</span>
<span class="snippet"><span>Comment</span>openreview: https://openreview.net/forum?id=uuUQraD4XX&noteId=PWDEpZtn6P<img width="851" height="476" alt="Image" src="https://github.com/user-attachments/assets/39d3bf0f-09fa-4257-8239-573c491df4fb"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Inference.html">#Inference</a>
<span class="issue_date">Issue Date: 2025-06-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2028">[Paper Note] SARATHI: Efficient LLM Inference by Piggybacking Decodes with Chunked  Prefills, Amey Agrawal+, arXiv'23</a>
<span class="snippet"><span>Summary</span>SARATHIは、LLMの推論効率を向上させる手法で、プレフィルリクエストをチャンクに分割し、デコードマキシマルバッチを構築することで計算利用率を最大化します。これにより、デコードスループットを最大10倍向上させ、エンドツーエンドスループットも改善。特に、A6000 GPU上のLLaMA-13Bモデルで顕著な性能向上を示し、パイプラインバブルを大幅に削減しました。</span>
<span class="snippet"><span>Comment</span>vLLMでも採用されている `Chunked Prefills` と `Decode-Maximal Batching` を提案している。

<br>

![Image](https://github.com/user-attachments/assets/4db0f73d-bdf4-4c2b-a765-2c9b242904f1)</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/Parallelism.html">#Parallelism</a>
<span class="issue_date">Issue Date: 2025-05-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1970">Sequence Parallelism: Long Sequence Training from System Perspective, Li+, ACL'23</a>
<span class="snippet"><span>Comment</span>入力系列をチャンクに分割して、デバイスごとに担当するチャンクを決めることで原理上無限の長さの系列を扱えるようにした並列化手法。系列をデバイス間で横断する場合attention scoreをどのように計算するかが課題になるが、そのためにRing Self attentionと呼ばれるアルゴリズムを提案している模様。また、MLPブロックとMulti Head Attentonブロックの計算も、BatchSize  Sequence Lengthの大きさが、それぞれ32Hidden Size, 16Attention Head size  of Attention Headよりも大きくなった場合に、Tensor Parallelismよりもメモリ効率が良くなるらしい。

<br>

<img src="https://github.com/user-attachments/assets/f3ba9010-da3a-4c3a-8515-d3715466ff59" alt="image" loading="lazy">Data Parallel, Pipeline Parallel, Tensor Parallel、全てに互換性があるとのこと（併用可能）そのほかの並列化の解説については

<br>

・1184

<br>



<br>

を参照のこと。</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/ActivationSteering/ITI.html">#ActivationSteering/ITI</a>
<a class="button" href="articles/Probing.html">#Probing</a>
<a class="button" href="articles/Trustfulness.html">#Trustfulness</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-05-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1941">Inference-Time Intervention: Eliciting Truthful Answers from a Language   Model, Kenneth Li+, NeurIPS'23</a>
<span class="snippet"><span>Summary</span>Inference-Time Intervention (ITI)を提案し、LLMsの真実性を向上させる技術を紹介。ITIは推論中にモデルの活性化を調整し、LLaMAモデルの性能をTruthfulQAベンチマークで大幅に改善。Alpacaモデルでは真実性が32.5%から65.1%に向上。真実性と有用性のトレードオフを特定し、介入の強度を調整する方法を示す。ITIは低コストでデータ効率が高く、数百の例で真実の方向性を特定可能。LLMsが虚偽を生成しつつも真実の内部表現を持つ可能性を示唆。</span>
<span class="snippet"><span>Comment</span>Inference Time Interventionを提案した研究。Attention Headに対して線形プロービング[^1]を実施し、真実性に関連するであろうHeadをtopKで特定できるようにし、headの出力に対し真実性を高める方向性のベクトルvを推論時に加算することで（＝intervention）、モデルの真実性を高める。vは線形プロービングによって学習された重みを使う手法と、正答と誤答の活性化の平均ベクトルを計算しその差分をvとする方法の二種類がある。後者の方が性能が良い。topKを求める際には、線形プロービングをしたモデルのvalidation setでの性能から決める。Kとαはハイパーパラメータである。

<br>



<br>

[^1]: headのrepresentationを入力として受け取り、線形モデルを学習し、線形モデルの2値分類性能を見ることでheadがどの程度、プロービングの学習に使ったデータに関する情報を保持しているかを測定する手法

<br>



<br>

日本語解説スライド:https://www.docswell.com/s/DeepLearning2023/Z38P8D-2024-06-20-131813p1これは相当汎用的に使えそうな話だから役に立ちそう</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/SpeechProcessing.html">#SpeechProcessing</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<a class="button" href="articles/Normalization.html">#Normalization</a>
<span class="issue_date">Issue Date: 2025-04-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1899">Foundation Transformers, Hongyu Wang+, PMLR'23</a>
<span class="snippet"><span>Summary</span>言語、視覚、音声、マルチモーダルにおけるモデルアーキテクチャの収束が進む中、異なる実装の「Transformers」が使用されている。汎用モデリングのために、安定性を持つFoundation Transformerの開発が提唱され、Magnetoという新しいTransformer変種が紹介される。Sub-LayerNormと理論に基づく初期化戦略を用いることで、さまざまなアプリケーションにおいて優れたパフォーマンスと安定性を示した。</span>
<span class="snippet"><span>Comment</span>マルチモーダルなモデルなモデルの事前学習において、PostLNはvision encodingにおいてsub-optimalで、PreLNはtext encodingにおいてsub-optimalであることが先行研究で示されており、マルタモーダルを単一のアーキテクチャで、高性能、かつ学習の安定性な高く、try and error無しで適用できる基盤となるアーキテクチャが必要というモチベーションで提案された手法。具体的には、Sub-LayerNorm(Sub-LN)と呼ばれる、self attentionとFFN部分に追加のLayerNormを適用するアーキテクチャと、DeepNetを踏襲しLayer数が非常に大きい場合でも学習が安定するような重みの初期化方法を理論的に分析し提案している。

<br>



<br>

具体的には、Sub-LNの場合、LayerNormを

<br>

・SelfAttention計算におけるQKVを求めるためのinput Xのprojectionの前とAttentionの出力projectionの前

<br>

・FFNでの各Linear Layerの前

<br>

に適用し、

<br>



<br>

初期化をする際には、FFNのW, およびself-attentionのV_projと出力のout_projの初期化をγ（＝sqrt(log(2N))によってスケーリングする方法を提案している模様。

<br>



<br>

<img src="https://github.com/user-attachments/assets/2847f982-3266-4394-9920-01d9977e505e" alt="image" loading="lazy">関連:

<br>

・1900</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-04-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1881">PaLI-3 Vision Language Models: Smaller, Faster, Stronger, Xi Chen+, arXiv'23</a>
<span class="snippet"><span>Summary</span>PaLI-3は、従来のモデルに比べて10倍小型で高速な視覚言語モデル（VLM）であり、特にローカリゼーションや視覚的テキスト理解において優れた性能を示す。SigLIPベースのPaLIは、20億パラメータにスケールアップされ、多言語クロスモーダル検索で新たな最先端を達成。50億パラメータのPaLI-3は、VLMの研究を再燃させることを期待されている。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=JpyWPfzu0b

<br>



<br>

実験的に素晴らしい性能が実現されていることは認められつつも

<br>

・比較対象がSigLIPのみでより広範な比較実験と分析が必要なこと

<br>

・BackboneモデルをContrastive Learningすること自体の有用性は既に知られており、新規性に乏しいこと

<br>



<br>

としてICLR'24にRejectされている</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/PositionalEncoding.html">#PositionalEncoding</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-04-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1865">The Impact of Positional Encoding on Length Generalization in   Transformers, Amirhossein Kazemnejad+, NeurIPS'23</a>
<span class="snippet"><span>Summary</span>長さ一般化はTransformerベースの言語モデルにおける重要な課題であり、位置エンコーディング（PE）がその性能に影響を与える。5つの異なるPE手法（APE、T5の相対PE、ALiBi、Rotary、NoPE）を比較した結果、ALiBiやRotaryなどの一般的な手法は長さ一般化に適しておらず、NoPEが他の手法を上回ることが明らかになった。NoPEは追加の計算を必要とせず、絶対PEと相対PEの両方を表現可能である。さらに、スクラッチパッドの形式がモデルの性能に影響を与えることも示された。この研究は、明示的な位置埋め込みが長いシーケンスへの一般化に必須でないことを示唆している。</span>
<span class="snippet"><span>Comment</span>・1863

<br>



<br>

において、Llama4 Scoutが10Mコンテキストウィンドウを実現できる理由の一つとのこと。

<br>



<br>

元ポスト:https://x.com/drjimfan/status/1908615861650547081?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

Llama4のブログポストにもその旨記述されている:

<br>

&gt;A key innovation in the Llama 4 architecture is the use of interleaved attention layers without positional embeddings. Additionally, we employ inference time temperature scaling of attention to enhance length generalization.

<br>



<br>

[The Llama 4 herd: The beginning of a new era of natively multimodal AI innovation](https://ai.meta.com/blog/llama-4-multimodal-intelligence/?utm_source=twitter&utm_medium=organic_social&utm_content=image&utm_campaign=llama4)斜め読みだが、length generalizationを評価する上でdownstream taskに焦点を当て、3つの代表的なカテゴリに相当するタスクで評価したところ、この観点においてはT5のrelative positinal encodingとNoPE（位置エンコードディング無し）のパフォーマンスが良く、

<br>



<br>

<img src="https://github.com/user-attachments/assets/dddadfff-ab28-4073-96c3-831eb16845a0" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/c6ec8e0e-7abb-4330-be23-2261486a477c" alt="image" loading="lazy">

<br>



<br>

NoPEは絶対位置エンコーディングと相対位置エンコーディングを理論上実現可能であり[^1]

<br>

<img src="https://github.com/user-attachments/assets/bbcf797a-d394-42d4-b017-08d7dba4261c" alt="image" loading="lazy">

<br>



<br>

実際に学習された異なる2つのモデルに対して同じトークンをそれぞれinputし、同じ深さのLayerの全てのattention distributionの組み合わせからJensen Shannon Divergenceで距離を算出し、最も小さいものを2モデル間の当該layerの距離として可視化すると下記のようになり、NoPEとT5のrelative positional encodingが最も類似していることから、NoPEが学習を通じて（実用上は）相対位置エンコーディングのようなものを学習することが分かった。

<br>

<img src="https://github.com/user-attachments/assets/9619c7e5-0612-45de-8717-1634bee509b7" alt="image" loading="lazy">

<br>



<br>

[^1]:深さ1のLayerのHidden State H^1から絶対位置の復元が可能であり（つまり、当該レイヤーのHが絶対位置に関する情報を保持している）、この前提のもと、後続のLayerがこの情報を上書きしないと仮定した場合に、相対位置エンコーディングを実現できる。また、CoT/Scratchpadはlong sequenceに対する汎化性能を向上させることがsmall scaleではあるが先行研究で示されており、Positional Encodingを変化させた時にCoT/Scratchpadの性能にどのような影響を与えるかを調査。

<br>



<br>

具体的には、CoT/Scratchpadのフォーマットがどのようなものが有効かも明らかではないので、5種類のコンポーネントの組み合わせでフォーマットを構成し、mathematical reasoningタスクで以下のような設定で訓練し

<br>



<br>

・さまざまなコンポーネントの組み合わせで異なるフォーマットを作成し、

<br>

・全ての位置エンコーディングあり/なしモデルを訓練

<br>



<br>

これらを比較した。この結果、CoT/Scratchpadはフォーマットに関係なく、特定のタスクでのみ有効（有効かどうかはタスク依存）であることが分かった。このことから、CoT/Scratcpad（つまり、モデルのinputとoutputの仕方）単体で、long contextに対する汎化性能を向上させることができないので、Positional Encoding（≒モデルのアーキテクチャ）によるlong contextに対する汎化性能の向上が非常に重要であることが浮き彫りになった。

<br>

<img src="https://github.com/user-attachments/assets/e23c4fbf-84de-4344-a01e-1e7e9e66fa7e" alt="image" loading="lazy">

<br>



<br>

また、CoT/Scratchpadが有効だったAdditionに対して各Positional Embeddingモデルを学習し、生成されたトークンのattentionがどの位置のトークンを指しているかを相対距離で可視化したところ（0が当該トークン、つまり現在のScratchpadに着目しており、1が遠いトークン、つまりinputに着目していることを表すように正規化）、NoPEとRelative Positional Encodingがshort/long rangeにそれぞれフォーカスするようなbinomialな分布なのに対し、他のPositional Encodingではよりuniformな分布であることが分かった。このタスクにおいてはNoPEとRelative POの性能が高かったため、binomialな分布の方がより最適であろうことが示唆された。

<br>

<img src="https://github.com/user-attachments/assets/833e6a81-8611-4e79-9d2e-473f7ebee2d0" alt="image" loading="lazy">

<br>

</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<span class="issue_date">Issue Date: 2025-04-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1848">SWE-bench: Can Language Models Resolve Real-World GitHub Issues?, Carlos E. Jimenez+, arXiv'23</a>
<span class="snippet"><span>Summary</span>SWE-benchは、12の人気Pythonリポジトリから得られた2,294のソフトウェアエンジニアリング問題を評価するフレームワークで、言語モデルがコードベースを編集して問題を解決する能力を測定します。評価の結果、最先端の商用モデルや微調整されたモデルSWE-Llamaも最も単純な問題しか解決できず、Claude 2はわずか1.96%の問題を解決するにとどまりました。SWE-benchは、より実用的で知的な言語モデルへの進展を示しています。</span>
<span class="snippet"><span>Comment</span>ソフトウェアエージェントの最もpopularなベンチマーク

<br>



<br>

<img width="693" alt="Image" src="https://github.com/user-attachments/assets/ac905221-d3b1-4d16-b447-3bdd4d5e97bb">

<br>



<br>

主にpythonライブラリに関するリポジトリに基づいて構築されている。

<br>

<img width="731" alt="Image" src="https://github.com/user-attachments/assets/14d26dd1-6b4a-4337-a652-4e48e36d633b">SWE-Bench, SWE-Bench Lite, SWE-Bench Verifiedの3種類がありソフトウェアエージェントではSWE-Bench Verifiedを利用して評価することが多いらしい。Verifiedでは、issueの記述に曖昧性がなく、適切なunittestのスコープが適切なもののみが採用されているとのこと（i.e., 人間の専門家によって問題がないと判断されたもの）。

<br>

https://www.swebench.com/</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-03-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1829">Scaling Data-Constrained Language Models, Niklas Muennighoff+, NeurIPS'23</a>
<span class="snippet"><span>Summary</span>言語モデルのスケーリングにおいて、データ制約下でのトレーニングを調査。9000億トークンと90億パラメータのモデルを用いた実験で、繰り返しデータを使用しても損失に大きな変化は見られず、繰り返しの価値が減少することを確認。計算最適性のスケーリング法則を提案し、データ不足を軽減するアプローチも実験。得られたモデルとデータセットは公開。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=j5BuTrEj35チンチラ則のようなScaling Lawsはパラメータとデータ量の両方をスケールさせた場合の前提に立っており、かつデータは全てuniqueである前提だったが、データの枯渇が懸念される昨今の状況に合わせて、データ量が制限された状況で、同じデータを繰り返し利用する（＝複数エポック学習する）ことが一般的になってきた。このため、データのrepetitionに関して性能を事前学習による性能の違いを調査して、repetitionとパラメータ数に関するスケーリング則を提案（$3.1)しているようである。

<br>



<br>

Takeawayとしては、データが制限された環境下では、repetitionは上限4回までが効果的（コスパが良い）であり（左図）、小さいモデルを複数エポック訓練する方が固定されたBudgetの中で低いlossを達成できる右図）。

<br>

<img src="https://github.com/user-attachments/assets/4e62cd1b-fe83-4d6e-a40d-df992c85def3" alt="image" loading="lazy">

<br>



<br>

学習データの半分をコードにしても性能の劣化はなく、様々なタスクの性能が向上しパフォーマンスの分散も小さくなる、といったことが挙げられるようだ。

<br>

<img src="https://github.com/user-attachments/assets/d404156f-7416-4f22-aa7e-d342065435ee" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Distillation.html">#Distillation</a>
<span class="issue_date">Issue Date: 2025-02-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1741">Data Distillation: A Survey, Noveen Sachdeva+, arXiv'23</a>
<span class="snippet"><span>Summary</span>深層学習の普及に伴い、大規模データセットの訓練が高コストで持続可能性に課題をもたらしている。データ蒸留アプローチは、元のデータセットの効果的な代替品を提供し、モデル訓練や推論に役立つ。本研究では、データ蒸留のフレームワークを提示し、既存のアプローチを分類。画像やグラフ、レコメンダーシステムなどの異なるデータモダリティにおける課題と今後の研究方向性を示す。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2025-01-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1668">Navigate through Enigmatic Labyrinth A Survey of Chain of Thought  Reasoning: Advances, Frontiers and Future, Zheng Chu+, arXiv'23</a>
<span class="snippet"><span>Summary</span>推論はAIにおいて重要な認知プロセスであり、チェーン・オブ・ソートがLLMの推論能力を向上させることが注目されている。本論文では関連研究を体系的に調査し、手法を分類して新たな視点を提供。課題や今後の方向性についても議論し、初心者向けの導入を目指す。リソースは公開されている。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<span class="issue_date">Issue Date: 2025-01-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1657">Program of Thoughts Prompting: Disentangling Computation from Reasoning   for Numerical Reasoning Tasks, Wenhu Chen+, TMLR'23</a>
<span class="snippet"><span>Summary</span>段階的な推論を用いた数値推論タスクにおいて、Chain-of-thoughts prompting（CoT）の進展があり、推論をプログラムとして表現する「Program of Thoughts」（PoT）を提案。PoTは外部コンピュータで計算を行い、5つの数学問題データセットと3つの金融QAデータセットで評価した結果、少数ショットおよびゼロショット設定でCoTに対して約12％の性能向上を示した。自己一貫性デコーディングとの組み合わせにより、数学問題データセットで最先端の性能を達成。データとコードはGitHubで公開。</span>
<span class="snippet"><span>Comment</span>1. LLMsは算術演算を実施する際にエラーを起こしやすく、特に大きな数に対する演算を実施する際に顕著

<br>

2. LLMsは複雑な数式（e.g. 多項式, 微分方程式）を解くことができない

<br>

3. LLMsはiterationを表現するのが非常に非効率

<br>



<br>

の3点を解決するために、外部のインタプリタに演算処理を委譲するPoTを提案。PoTでは、言語モデルにreasoning stepsをpython programで出力させ、演算部分をPython Interpreterに実施させる。

<br>



<br>

<img src="https://github.com/user-attachments/assets/ccaeee09-ca6f-45ec-aef4-c65960d52692" alt="image" loading="lazy">テキスト、テーブル、対話などの多様なinputをサポートする5つのMath Word Problem （MWP）, 3つのFinancial Datasetで評価した結果、zero-shot, few-shotの両方の設定において、PoTはCoTをoutpeformし、また、Self-Consistencyと組み合わせた場合も、PoTはCoTをoutperformした。

<br>

<img src="https://github.com/user-attachments/assets/6b380fab-ab60-4f21-bce1-532167c8c8f2" alt="image" loading="lazy"></span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-01-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1656">Recursion of Thought: A Divide-and-Conquer Approach to Multi-Context  Reasoning with Language Models, Soochan Lee+, arXiv'23</a>
<span class="snippet"><span>Summary</span>Recursion of Thought（RoT）という新しい推論フレームワークを提案し、言語モデル（LM）が問題を複数のコンテキストに分割することで推論能力を向上させる。RoTは特別なトークンを導入し、コンテキスト関連の操作をトリガーする。実験により、RoTがLMの推論能力を劇的に向上させ、数十万トークンの問題を解決できることが示された。</span>
<span class="snippet"><span>Comment</span>divide-and-conquerで複雑な問題に回答するCoT手法。生成過程でsubquestionが生じた際にモデルに特殊トークン（GO）を出力させ、subquestionの回答部分に特殊トークン（THINK）を出力させるようにSupervisedに学習させる。最終的にTHINKトークン部分は、subquestionを別途モデルによって解いた回答でreplaceして、最終的な回答を得る。

<br>

subquestionの中でさらにsubquestionが生じることもあるため、再帰的に処理される。

<br>

<img src="https://github.com/user-attachments/assets/6a5a5155-b3dd-4a6a-a9f5-0975dddcedb7" alt="image" loading="lazy">四則演算と4種類のアルゴリズムに基づくタスクで評価。アルゴリズムに基づくタスクは、2つの数のlongest common subsequenceを見つけて、そのsubsequenceとlengthを出力するタスク（LCS）、0-1 knapsack問題、行列の乗算、数値のソートを利用。x軸が各タスクの問題ごとの問題の難易度を表しており、難易度が上がるほど提案手法によるgainが大きくなっているように見える。

<br>



<br>

Without Thoughtでは直接回答を出力させ、CoTではground truthとなるrationaleを1つのcontextに与えて回答を生成している。RoTではsubquestionごとに回答を別途得るため、より長いcontextを活用して最終的な回答を得る点が異なると主張している。

<br>



<br>

<img src="https://github.com/user-attachments/assets/8e713c76-5f79-40c7-87b0-d69f6fac3ee3" alt="image" loading="lazy">

<br>

感想としては、詳細が書かれていないが、おそらくRoTはSFTによって各タスクに特化した学習をしていると考えられる（タスクごとの特殊トークンが存在するため）。ベースラインとしてRoT無しでSFTしたモデルあった方が良いのではないか？と感じる。

<br>



<br>

また、学習データにおけるsubquestionとsubquestionに対するground truthのデータ作成方法は書かれているが、そもそも元データとして何を利用したかや、その統計量も書かれていないように見える。あと、そもそも機械的に学習データを作成できない場合どうすれば良いのか？という疑問は残る。読んでいた時にAuto-CoTとの違いがよくわからなかったが、Related Workの部分にはAuto-CoTは動的、かつ多様なデモンストレーションの生成にフォーカスしているが、AutoReasonはquestionを分解し、few-shotの promptingでより詳細なrationaleを生成することにフォーカスしている点が異なるという主張のようである。

<br>



<br>

・556Auto-CoTとの差別化は上記で理解できるが、G-Evalが実施しているAuto-CoTとの差別化はどうするのか？という風にふと思った。論文中でもG-Evalは引用されていない。

<br>



<br>

素朴にはAutoReasonはSFTをして学習をしています、さらにRecursiveにquestionをsubquestionを分解し、分解したsubquestionごとに回答を得て、subquestionの回答結果を活用して最終的に複雑なタスクの回答を出力する手法なので、G-Evalが実施している同一context内でrationaleをzeroshotで生成する手法よりも、より複雑な問題に回答できる可能性が高いです、という主張にはなりそうではある。

<br>



<br>

・1223ICLR 2023 OpenReview:https://openreview.net/forum?id=PTUcygUoxuc

<br>



<br>

・提案手法は一般的に利用可能と主張しているが、一般的に利用するためには人手でsubquestionの学習データを作成する必要があるため十分に一般的ではない

<br>

・限られたcontext長に対処するために再帰を利用するというアイデアは新しいものではなく、数学の定理の証明など他の設定で利用されている

<br>



<br>

という理由でrejectされている。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Quantization.html">#Quantization</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2024-12-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1570">SmoothQuant: Accurate and Efficient Post-Training Quantization for Large   Language Models, Guangxuan Xiao+, ICML'23</a>
<span class="snippet"><span>Summary</span>SmoothQuantは、トレーニング不要で8ビットの重みと活性化の量子化を実現するポストトレーニング量子化ソリューションです。活性化の外れ値を滑らかにすることで、量子化の難易度を軽減し、精度を保持しつつ最大1.56倍の速度向上と2倍のメモリ削減を達成しました。これにより、530BのLLMを単一ノードで運用可能にし、LLMsの民主化を促進します。コードは公開されています。</span>
<span class="snippet"><span>Comment</span>おそらく量子化手法の現時点のSoTA</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Diversity.html">#Diversity</a>
<span class="issue_date">Issue Date: 2024-12-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1567">Increasing Diversity While Maintaining Accuracy: Text Data Generation with Large Language Models and Human Interventions, John Chung+, ACL'23, 2023.07</a>
<span class="snippet"><span>Summary</span>本研究では、LLMを用いたテキストデータ生成における多様性と精度を向上させるための人間とAIのパートナーシップを探求。ロジット抑制と温度サンプリングの2つのアプローチで多様性を高める一方、ラベル置換（LR）と範囲外フィルタリング（OOSF）による人間の介入を検討。LRはモデルの精度を14.4%向上させ、一部のモデルは少数ショット分類を上回る性能を示したが、OOSFは効果がなかった。今後の研究の必要性が示唆される。</span>
<span class="snippet"><span>Comment</span>生成テキストの質を維持しつつ、多様性を高める取り組み。多様性を高める取り組みとしては3種類の方法が試されており、

<br>



<br>

・Logit Suppression: 生成されたテキストの単語生成頻度をロギングし、頻出する単語にpenaltyをかける方法

<br>



<br>

・High Temperature: temperatureを[0.3, 0.7, 0.9, 1.3]にそれぞれ設定して単語をサンプリングする方法

<br>



<br>

・Seeding Example: 生成されたテキストを、seedとしてpromptに埋め込んで生成させる方法

<br>



<br>



<br>



<br>

で実験されている。</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2024-12-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1560">Improving the Domain Adaptation of Retrieval Augmented Generation （RAG） Models for Open Domain Question Answering, Siriwardhana+, TACL'23, 2023.01</a>
<span class="snippet"><span>Summary</span>RAG-end2endは、ODQAにおけるドメイン適応のためにRAGのリトリーバーとジェネレーターを共同訓練する新しいアプローチを提案。外部知識ベースを更新し、補助的な訓練信号を導入することで、ドメイン特化型知識を強化。COVID-19、ニュース、会話のデータセットで評価し、元のRAGモデルよりも性能が向上。研究はオープンソースとして公開。</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2024-11-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1546">Sparse Upcycling: Training Mixture-of-Experts from Dense Checkpoints, Aran Komatsuzaki+, ICLR'23</a>
<span class="snippet"><span>Summary</span>スパース活性化モデルは、計算コストを抑えつつ密なモデルの代替として注目されているが、依然として多くのデータを必要とし、ゼロからのトレーニングは高コストである。本研究では、密なチェックポイントからスパース活性化Mixture-of-Expertsモデルを初期化する「スパースアップサイクリング」を提案。これにより、初期の密な事前トレーニングのコストを約50%再利用し、SuperGLUEやImageNetで密なモデルを大幅に上回る性能を示した。また、アップサイクリングされたモデルは、ゼロからトレーニングされたスパースモデルよりも優れた結果を得た。</span>
<span class="snippet"><span>Comment</span>斜め読みしかできていないが、Mixture-of-Expertsを用いたモデルをSFT/Pretrainingする際に、既存のcheckpointの重みを活用することでより効率的かつ性能向上する方法を提案。MoE LayerのMLPを全て既存のcheckpointにおけるMLPの重みをコピーして初期化する。Routerはスクラッチから学習する。

<br>

<img src="https://github.com/user-attachments/assets/d51a0746-d2cc-4343-a462-20034ef373d9" alt="image" loading="lazy">

<br>



<br>

継続事前学習においては、同じ学習時間の中でDense Layerを用いるベースラインと比較してでより高い性能を獲得。

<br>

<img src="https://github.com/user-attachments/assets/d7a67c99-15d7-4803-82e4-63187bb3d4ec" alt="image" loading="lazy">

<br>

Figure2で継続事前学習したモデルに対して、フルパラメータのFinetuningをした場合でもUpcyclingは効果がある（Figure3）。

<br>



<br>

特にPretrainingではUpcyclingを用いたモデルの性能に、通常のMoEをスクラッチから学習したモデルが追いつくのに時間がかかるとのこと。特に図右側の言語タスクでは、120%の学習時間が追いつくために必要だった。

<br>

<img src="https://github.com/user-attachments/assets/f0ca37ac-65a7-43ff-afef-ffc309b17040" alt="image" loading="lazy">

<br>



<br>

Sparse Upcycingと、Dense tilingによる手法（warm start; 元のモデルに既存の層を複製して新しい層を追加する方法）、元のモデルをそれぞれ継続事前学習すると、最も高い性能を獲得している。

<br>

<img src="https://github.com/user-attachments/assets/b357a08a-d202-47d3-977f-f02b192723d1" alt="image" loading="lazy">

<br>



<br>

（すごい斜め読みなのでちょっも自信なし、、、）</span>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2024-11-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1534">Prompting Large Language Model for Machine Translation: A Case Study, Biao Zhang+, arXiv'23</a>
<span class="snippet"><span>Summary</span>機械翻訳におけるプロンプティングの研究を体系的に行い、プロンプトテンプレートやデモ例の選択に影響を与える要因を検討。GLM-130Bを用いた実験により、プロンプト例の数と質が翻訳に重要であること、意味的類似性などの特徴がパフォーマンスと相関するが強くないこと、単言語データからの擬似平行プロンプト例が翻訳を改善する可能性があること、他の設定からの知識転送がパフォーマンス向上に寄与することを示した。プロンプティングの課題についても議論。</span>
<span class="snippet"><span>Comment</span>zero-shotでMTを行うときに、改行の有無や、少しのpromptingの違いでCOMETスコアが大幅に変わることを示している。

<br>



<br>

モデルはGLM-130BをINT4で量子化したモデルで実験している。

<br>



<br>

興味深いが、この知見を一般化して全てのLLMに適用できるか？と言われると、そうはならない気がする。他のモデルで検証したら傾向はおそらく変わるであろう（という意味でおそらく論文のタイトルにもCase Studyと記述されているのかなあ）。

<br>



<br>



<br>



<br>

<img src="https://github.com/user-attachments/assets/1302dbb2-40e2-40c2-9a71-cae01528b5e6" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2024-11-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1498">Precise Zero-Shot Dense Retrieval without Relevance Labels, Luyu Gao+, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、ゼロショット密な検索システムの構築において、仮想文書埋め込み（HyDE）を提案。クエリに基づき、指示に従う言語モデルが仮想文書を生成し、教師なしで学習されたエンコーダがこれを埋め込みベクトルに変換。実際のコーパスに基づく類似文書を取得することで、誤った詳細をフィルタリング。実験結果では、HyDEが最先端の密な検索器Contrieverを上回り、様々なタスクと言語で強力なパフォーマンスを示した。</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2024-09-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1424">UL2: Unifying Language Learning Paradigms, Yi Tay+, N_A, ICLR'23</a>
<span class="snippet"><span>Summary</span>本論文では、事前学習モデルの普遍的なフレームワークを提案し、事前学習の目的とアーキテクチャを分離。Mixture-of-Denoisers（MoD）を導入し、複数の事前学習目的の効果を示す。20Bパラメータのモデルは、50のNLPタスクでSOTAを達成し、ゼロショットやワンショット学習でも優れた結果を示す。UL2 20Bモデルは、FLAN指示チューニングにより高いパフォーマンスを発揮し、関連するチェックポイントを公開。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=6ruVLB727MC[R] standard span corruption, [S] causal language modeling, [X] extreme span corruption の3種類のパラダイムを持つMoD (Mixture of Denoisers)を提案

<br>



<br>

<img width="1187" height="1203" alt="Image" src="https://github.com/user-attachments/assets/a07372c6-854c-4bd1-8f59-f8c4dbdc5d23"></span>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<span class="issue_date">Issue Date: 2024-09-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1401">Instruction Tuning with GPT-4, Baolin Peng+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>GPT-4を用いて指示に従うデータを生成し、LLMのファインチューニングを行う初の試みを報告。生成された52Kの指示データは、従来のモデルよりも新しいタスクに対して優れたゼロショット性能を示した。GPT-4からのフィードバックと比較データも収集し、データとコードベースを公開。</span>
<span class="snippet"><span>Comment</span>現在はOpenAIの利用規約において、outputを利用してOpenAIと競合するモデルを構築することは禁止されているので、この点には注意が必要

<br>

https://openai.com/ja-JP/policies/terms-of-use/</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SelfCorrection.html">#SelfCorrection</a>
<span class="issue_date">Issue Date: 2024-09-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1382">Large Language Models Cannot Self-Correct Reasoning Yet, Jie Huang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>LLMsの自己修正能力を批判的に検討し、内在的自己修正の概念を中心に、外部フィードバックなしでの応答修正の難しさを示す。自己修正後にパフォーマンスが低下することもあり、今後の研究や応用に向けた提案を行う。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/SelfCorrection.html">#SelfCorrection</a>
<span class="issue_date">Issue Date: 2024-09-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1380">Reflection-Tuning: Data Recycling Improves LLM Instruction-Tuning, Ming Li+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>リフレクションチューニングという新手法を提案し、LLMsの自己改善を通じて低品質なトレーニングデータの問題に対処。オラクルLLMを用いてデータの質を向上させ、実験により再利用データで訓練されたLLMsが既存モデルを上回ることを示した。</span>
<span class="snippet"><span>Comment</span>Reflection-Tuningを提案している研究?</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/Finetuning.html">#Finetuning</a>
<span class="issue_date">Issue Date: 2024-05-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1317">T5Score: Discriminative Fine-tuning of Generative Evaluation Metrics, Yiwei Qin+, N_A, EMNLP-Findings'23</a>
<span class="snippet"><span>Summary</span>埋め込みベースのテキスト生成の評価には、教師付きの識別メトリクスと生成メトリクスの2つのパラダイムがあります。本研究では、教師付きと教師なしの信号を組み合わせたフレームワークを提案し、mT5をバックボーンとしてT5Scoreメトリクスを訓練しました。T5Scoreは他の既存のメトリクスと包括的な実証的比較を行い、セグメントレベルで最良のパフォーマンスを示しました。また、コードとモデルはGitHubで公開されています。</span>
<span class="snippet"><span>Comment</span>OpenReview: https://openreview.net/forum?id=2jibzAXJzH&noteId=rgNMHmjShZ</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-05-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1309">Mistral 7B, Albert Q. Jiang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>Mistral 7B v0.1は、70億パラメータの言語モデルであり、高速な推論のためにGQAを活用し、SWAを組み合わせている。また、Mistral 7B -InstructはLlama 2 13B -Chatモデルを上回っており、Apache 2.0ライセンスの下で公開されています。</span>
<span class="snippet"><span>Comment</span>1237 1279 などのモデルも参照のこと

<br>



<br>



<br>



<br>

モデルのスケールが大きくなると、inferenceのlatencyが遅くなり、計算コストが大きくなりすぎて実用的でないので、小さいパラメータで素早いinference実現したいよね、というモチベーション。

<br>



<br>

そのために、SlidingWindowAttentionとGroupQueryAttention 1271 を活用している。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/154bc04b-5056-4b88-8b4d-deff169d4a10" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

より小さいパラメータ数でLlama2を様々なタスクでoutperformし

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/d2890d33-4895-4d09-aa22-5566a471f41f" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Instruction Tuningを実施したモデルは、13BモデルよりもChatbotArenaで高いElo Rateを獲得した。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/9f37a61e-0cf1-4712-a912-4f7e77094072" alt="image" loading="lazy">

<br>



<br>

コンテキスト長は8192</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Annotation.html">#Annotation</a>
<span class="issue_date">Issue Date: 2024-05-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1304">Benchmarking Large Language Models for News Summarization, Tianyi Zhang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>LLMsの成功の理由を理解するために、異なる事前学習方法、プロンプト、およびモデルスケールにわたる10つのLLMsに対する人間の評価を行った。その結果、モデルサイズではなく、指示の調整がLLMのゼロショット要約能力の鍵であることがわかった。また、LLMsの要約は人間の執筆した要約と同等と判断された。</span>
<span class="snippet"><span>Comment</span>・ニュース記事の高品質な要約を人間に作成してもらい、gpt-3.5を用いてLLM-basedな要約も生成

<br>



<br>

・annotatorにそれぞれの要約の品質をスコアリングさせたデータセットを作成</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<span class="issue_date">Issue Date: 2024-04-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1271">GQA: Training Generalized Multi-Query Transformer Models from Multi-Head  Checkpoints, Joshua Ainslie+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>Multi-query attention（MQA）は、単一のkey-value headのみを使用しており、デコーダーの推論を劇的に高速化しています。ただし、MQAは品質の低下を引き起こす可能性があり、さらには、より速い推論のためだけに別個のモデルをトレーニングすることが望ましくない場合もあります。既存のマルチヘッド言語モデルのチェックポイントを、オリジナルの事前トレーニング計量の5%を使用してMQAを持つモデルにアップトレーニングするためのレシピを提案し、さらに、複数のkey-value headを使用するマルチクエリアテンションの一般化であるグループ化クエリアテンション（GQA）を紹介します。アップトレーニングされたGQAが、MQAと同等の速度でマルチヘッドアテンションに匹敵する品質を達成することを示しています。</span>
<span class="snippet"><span>Comment</span>通常のMulti-Head AttentionがQKVが1対1対応なのに対し、Multi Query Attention (MQA) 1272  は全てのQに対してKVを共有する。一方、GQAはグループごとにKVを共有する点で異なる。MQAは大幅にInfeerence` speedが改善するが、精度が劣化する問題があった。この研究では通常のMulti-Head Attentionに対して、オリジナルの事前学習に対して追加の5%の計算量でGQAモデルを学習する手法を提案している。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/70ec2179-428c-47b8-af53-cb3cc0e4f022" alt="image" loading="lazy">

<br>



<br>

Main Result. Multi-Head Attentionに対して、inference timeが大幅に改善しているが、Multi-Query Attentionよりも高い性能を維持している。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/3687aeb4-90b8-403d-853b-740121dd5f98" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Explanation.html">#Explanation</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2024-01-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1224">INSTRUCTSCORE: Explainable Text Generation Evaluation with Finegrained   Feedback, Wenda Xu+, N_A, EMNLP'23</a>
<span class="snippet"><span>Summary</span>自動的な言語生成の品質評価には説明可能なメトリクスが必要であるが、既存のメトリクスはその判定を説明したり欠陥とスコアを関連付けることができない。そこで、InstructScoreという新しいメトリクスを提案し、人間の指示とGPT-4の知識を活用してテキストの評価と診断レポートを生成する。さまざまな生成タスクでInstructScoreを評価し、他のメトリクスを上回る性能を示した。驚くべきことに、InstructScoreは人間の評価データなしで最先端のメトリクスと同等の性能を達成する。</span>
<span class="snippet"><span>Comment</span>伝統的なNLGの性能指標の解釈性が低いことを主張する研究<img src="https://github.com/user-attachments/assets/4c4fe705-e0c5-41d1-b3c8-c084d85b77ba" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<span class="issue_date">Issue Date: 2024-01-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1223">G-Eval: NLG Evaluation using GPT-4 with Better Human Alignment, Yang Liu+, N_A, EMNLP'23</a>
<span class="snippet"><span>Summary</span>従来の参照ベースの評価指標では、自然言語生成システムの品質を正確に測定することが難しい。最近の研究では、大規模言語モデル（LLMs）を使用した参照ベースの評価指標が提案されているが、まだ人間との一致度が低い。本研究では、G-Evalという大規模言語モデルを使用した品質評価フレームワークを提案し、要約と対話生成のタスクで実験を行った。G-Evalは従来の手法を大幅に上回る結果を示し、LLMベースの評価器の潜在的な問題についても分析している。コードはGitHubで公開されている。</span>
<span class="snippet"><span>Comment</span>伝統的なNLGの性能指標が、人間の判断との相関が低いことを示した研究手法概要

<br>



<br>

・CoTを利用して、生成されたテキストの品質を評価する手法を提案している。

<br>



<br>

・タスクのIntroductionと、評価のCriteriaをプロンプトに仕込むだけで、自動的にLLMに評価ステップに関するCoTを生成させ、最終的にフォームを埋める形式でスコアをテキストとして生成させ評価を実施する。最終的に、各スコアの生成確率によるweighted-sumによって、最終スコアを決定する。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/a91c9234-6f41-4fb4-a94f-8a47a594dd9e" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Scoringの問題点

<br>



<br>

たとえば、1-5のdiscreteなスコアを直接LLMにoutputさせると、下記のような問題が生じる：

<br>



<br>

1. ある一つのスコアが支配的になってしまい、スコアの分散が無く、人間の評価との相関が低くなる

<br>



<br>

2. LLMは小数を出力するよう指示しても、大抵の場合整数を出力するため、多くのテキストの評価値が同一となり、生成されたテキストの細かな差異を評価に取り入れることができない。

<br>



<br>



<br>



<br>

上記を解決するため、下記のように、スコアトークンの生成確率の重みづけ和をとることで、最終的なスコアを算出している。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/a2a8d26c-0fb4-4f60-bd6e-600898785d7b" alt="image" loading="lazy">評価

<br>



<br>

・SummEval 984 データと、Topical-Chat, QAGSデータの3つのベンチマークで評価を実施した。タスクとしては、要約と対話のresponse generationのデータとなる。

<br>



<br>

・モデルはGPT-3.5 (text-davinci-003), GPT-4を利用した

<br>



<br>

・gpt3.5利用時は、temperatureは0に設定し、GPT-4はトークンの生成確率を返さないので、`n=20, temperature=1, top_p=1`とし、20回の生成結果からトークンの出現確率を算出した。

<br>



<br>



<br>



<br>

評価結果

<br>



<br>

G-EVALがbaselineをoutperformし、特にGPT4を利用した場合に性能が高い。GPTScoreを利用した場合に、モデルを何を使用したのかが書かれていない。Appendixに記述されているのだろうか。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/924b0acd-6236-49a0-a6bc-ae203c87f7ea" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/435fa260-a88d-4db2-b3a2-40d29a6617df" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/f9ca4e1f-903d-48fa-a40f-64fa8c799c43" alt="image" loading="lazy">

<br>



<br>

Analysis

<br>



<br>

G-EvalがLLMが生成したテキストを好んで高いスコアを付与してしまうか？

<br>



<br>

・人間に品質の高いニュース記事要約を書かせ、アノテータにGPTが生成した要約を比較させたデータ (1304) を用いて検証

<br>



<br>

・その結果、基本的にGPTが生成した要約に対して、G-EVAL4が高いスコアを付与する傾向にあることがわかった。

<br>



<br>

    ・原因1: 1304で指摘されている通り、人間が記述した要約とLLMが記述した要約を区別するタスクは、inter-annotator agreementは`0.07`であり、極端に低く、人間でも困難なタスクであるため。

<br>



<br>

    ・原因2: LLMは生成時と評価時に、共通したコンセプトをモデル内部で共有している可能性が高く、これがLLMが生成した要約を高く評価するバイアスをかけた

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/ec6a213d-15ea-4572-8716-ad9cbee6f19a" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

CoTの影響

<br>



<br>

・SummEvalデータにおいて、CoTの有無による性能の差を検証した結果、CoTを導入した場合により高いcorrelationを獲得した。特に、Fluencyへの影響が大きい。

<br>



<br>



<br>



<br>

Probability Normalizationによる影響

<br>



<br>

・probabilityによるnormalizationを導入したことで、kendall tauが減少した。この理由は、probabilityが導入されていない場合は多くの引き分けを生み出す。一方、kendall tauは、concordant / discordantペアの数によって決定されるが、引き分けの場合はどちらにもカウントされず、kendall tauの値を押し上げる効果がある。このため、これはモデルの真の性能を反映していない。

<br>



<br>

・一方、probabilityを導入すると、より細かいな連続的なスコアを獲得することができ、これはspearman-correlationの向上に反映されている。

<br>



<br>



<br>



<br>

モデルサイズによる影響

<br>



<br>

・基本的に大きいサイズの方が高いcorrelationを示す。特に、consistencyやrelevanceといった、複雑な評価タスクではその差が顕著である。

<br>



<br>

・一方モデルサイズが小さい方が性能が良い観点（engagingness, groundedness）なども存在した。</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<span class="issue_date">Issue Date: 2024-01-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1220">Large Language Models Are State-of-the-Art Evaluators of Translation Quality, EAMT'23</a>
<span class="snippet"><span>Summary</span>GEMBAは、参照翻訳の有無に関係なく使用できるGPTベースの翻訳品質評価メトリックです。このメトリックは、ゼロショットのプロンプティングを使用し、4つのプロンプトバリアントを比較します。私たちの手法は、GPT 3.5以上のモデルでのみ機能し、最先端の精度を達成します。特に、英語からドイツ語、英語からロシア語、中国語から英語の3つの言語ペアで有効です。この研究では、コード、プロンプトテンプレート、およびスコアリング結果を公開し、外部の検証と再現性を可能にします。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<span class="issue_date">Issue Date: 2023-12-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1194">Gemini: A Family of Highly Capable Multimodal Models, Gemini Team+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>この報告書では、マルチモーダルモデル「Gemini」のファミリーについて紹介します。Geminiは画像、音声、動画、テキストの理解に優れた能力を持ち、Ultra、Pro、Nanoのサイズがあります。Gemini Ultraは幅広いベンチマークで最先端の技術を提供し、MMLUでは人間の専門家のパフォーマンスを初めて達成しました。Geminiモデルはクロスモーダルな推論と言語理解の能力を持ち、さまざまなユースケースに適用できます。また、ユーザーへの責任ある展開についても議論しています。</span>
<span class="snippet"><span>Comment</span>1181 で発表されたGeminiの論文</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<span class="issue_date">Issue Date: 2023-12-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1179">The Unlocking Spell on Base LLMs: Rethinking Alignment via In-Context  Learning, Bill Yuchen Lin+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>アラインメント調整は、大規模言語モデル（LLMs）のパフォーマンスを向上させるために使用されます。しかし、アラインメント調整の効果は「表面的」である可能性があります。この研究では、基本的なLLMとアラインメント調整されたバージョンのトークン分布のシフトを分析しました。結果は、アラインメント調整が主にスタイルトークンに影響を与えることを示しました。さらに、シンプルでチューニングフリーなアラインメント手法であるURIALを導入し、基本的なLLMのパフォーマンスを向上させることができることを示しました。これらの結果から、アラインメントのより深い分析と理論的な理解が重要であることが示唆されます。</span>
<span class="snippet"><span>Comment</span>モデルの知識はPre-training時に十分獲得されており、モデルのAlignmentをとることで生じるものは表面的な変化のみであるという仮説がある 700 。この仮説に関して分析をし、結果的にスタイリスティックな情報を生成する部分でAlignmentの有無で違いが生じることを明らかにし、そうであればわざわざパラメータチューニング（SFT, RLHF）しなくても、適切なサンプルを選択したIn-Context LearningでもAlignmentとれますよ、という趣旨の研究っぽい？

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/b8c62b33-dd72-43ea-8953-abb5c04cc504" alt="image" loading="lazy"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<span class="issue_date">Issue Date: 2023-12-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1177">Unnatural Error Correction: GPT-4 Can Almost Perfectly Handle Unnatural  Scrambled Text, Qi Cao+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）の内部動作についての新しい洞察を提供します。特に、GPT-4を調査し、LLMsの耐久性に関する実験結果を示します。実験では、文字レベルの順列に対するLLMsの耐性を調べるために、Scrambled Benchというスイートを使用しました。結果は、GPT-4がtypoglycemiaという現象に似た能力を持ち、非常に自然でないエラーを含む入力をほぼ完璧に処理できることを示しています。これは、LLMsの耐性が直感に反するものであり、他のLLMsや人間にとっても困難なタスクであることを示しています。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/df33c7a9-005e-4d7e-9d70-d8f0657869ed" alt="image" loading="lazy">OpenAIのモデルがブラックボックスである限り、コンタミネーションがあるのでは？という疑念は持ってしまう。

<br>



<br>

（部分的にしか読めていないが…）

<br>

RealtimeQAと呼ばれるweeklyで直近のニュースに対するQuestionを発表することで構築されるデータセットのうち、2023.03.17--2023.08.04のデータを収集し、ScrambledSentenaeRecovery（ScrRec）とScrambleQuestionAnswering（ScrQA）の評価データを生成している。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/362bcbca-b578-4f0e-ac4e-e65fd216aeac" alt="image" loading="lazy">

<br>



<br>

完全にランダムに単語の文字をscramble（RS）すると、FalconとLlama2では元のテキストをゼロショットでは再構築できないことが分かる。FewShotではFalconであれば少し解けるようになる。一方、OpenAIのモデル、特にGPT4, GPT3.5-turboではゼロショットでもにり再構築ができている。

<br>



<br>

ScrQAについては、ランダムにscrambleした場合でもMultipleChoiceQuestionなので（RPGと呼ばれるAccの相対的なgainを評価するメトリックを提案している）正解はできている。

<br>



<br>

最初の文字だけを残す場合（KF）最初と最後の文字を残す場合（KFL」については、残す文字が増えるほどどちらのタスクも性能が上がり、最初の文字だけがあればOpenSourceLLMでも（ゼロショットでも）かなり元のテキストの再構築ができるようになっている。また、QAも性能が向上している。完全にランダムに文字を入れ替えたら完全に無理ゲーなのでは、、、、と思ってしまうのだが、FalconでFewshotの場合は一部解けているようだ…。果たしてどういうことなのか…（大文字小文字が保持されたままなのがヒントになっている…？）Appendixに考察がありそうだがまだ読めていない。

<br>



<br>



<br>



<br>

（追記）

<br>



<br>

文全体でランダムに文字を入れ替えているのかと勘違いしていたが、実際には”ある単語の中だけでランダムに入れ替え”だった。これなら原理上はいけると思われる。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<span class="issue_date">Issue Date: 2023-12-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1174">Pushdown Layers: Encoding Recursive Structure in Transformer Language   Models, Shikhar Murty+, N_A, EMNLP'23</a>
<span class="snippet"><span>Summary</span>本研究では、再帰構造をうまく捉えるために新しい自己注意層であるPushdown Layersを導入しました。Pushdown Layersは、再帰状態をモデル化するためにスタックテープを使用し、トークンごとの推定深度を追跡します。このモデルは、構文的な一般化を改善し、サンプル効率を向上させることができます。さらに、Pushdown Layersは標準の自己注意の代替としても使用でき、GLUEテキスト分類タスクでも改善を実現しました。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/GenerativeAI.html">#GenerativeAI</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<span class="issue_date">Issue Date: 2023-12-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1169">SEINE: Short-to-Long Video Diffusion Model for Generative Transition and  Prediction, Xinyuan Chen+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、ビデオ生成において連続した長いビデオを生成するためのジェネレーティブなトランジションと予測に焦点を当てたモデルSEINEを提案する。SEINEはテキストの説明に基づいてトランジションを生成し、一貫性と視覚的品質を確保した長いビデオを生成する。さらに、提案手法は他のタスクにも拡張可能であり、徹底的な実験によりその有効性が検証されている。</span>
<span class="snippet"><span>Comment</span>https://huggingface.co/spaces/Vchitect/SEINE

<br>



<br>

画像 + テキストpromptで、動画を生成するデモ</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-11-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1163">Exponentially Faster Language Modelling, Peter Belcak+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>UltraFastBERTは、推論時にわずか0.3%のニューロンしか使用せず、同等の性能を発揮することができる言語モデルです。UltraFastBERTは、高速フィードフォワードネットワーク（FFF）を使用して、効率的な実装を提供します。最適化されたベースラインの実装に比べて78倍の高速化を実現し、バッチ処理された推論に対しては40倍の高速化を実現します。トレーニングコード、ベンチマークのセットアップ、およびモデルの重みも公開されています。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/AutomaticPromptEngineering.html">#AutomaticPromptEngineering</a>
<span class="issue_date">Issue Date: 2023-11-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1161">NeuroPrompts: An Adaptive Framework to Optimize Prompts for  Text-to-Image Generation, Shachar Rosenman+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、テキストから画像への生成モデルの品質を向上させるための適応型フレームワークNeuroPromptsを提案します。このフレームワークは、事前学習された言語モデルを使用して制約付きテキストデコーディングを行い、人間のプロンプトエンジニアが生成するものに類似したプロンプトを生成します。これにより、高品質なテキストから画像への生成が可能となり、ユーザーはスタイルの特徴を制御できます。また、大規模な人間エンジニアリングされたプロンプトのデータセットを使用した実験により、当アプローチが自動的に品質の高いプロンプトを生成し、優れた画像品質を実現することを示しました。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-11-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1158">GAIA: a benchmark for General AI Assistants, Grégoire Mialon+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>GAIAは、General AI Assistantsのためのベンチマークであり、AI研究のマイルストーンとなる可能性がある。GAIAは、推論、マルチモダリティの処理、ウェブブラウジングなど、実世界の質問に対する基本的な能力を必要とする。人間の回答者は92％の正答率を達成し、GPT-4は15％の正答率を達成した。これは、最近の傾向とは異なる結果であり、専門的なスキルを必要とするタスクではLLMsが人間を上回っている。GAIAは、人間の平均的な堅牢性と同等の能力を持つシステムがAGIの到来に重要であると考えている。GAIAの手法を使用して、466の質問と回答を作成し、一部を公開してリーダーボードで利用可能にする。</span>
<span class="snippet"><span>Comment</span>Yann LeCun氏の紹介ツイート

<br>

https://x.com/ylecun/status/1727707519470977311?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

Meta-FAIR, Meta-GenAI, HuggingFace, AutoGPTによる研究。人間は92%正解できるが、GPT4でも15%しか正解できないQAベンチマーク。解くために推論やマルチモダリティの処理、ブラウジング、ツールに対する習熟などの基本的な能力を必要とする実世界のQAとのこと。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/0b13838b-0829-48b9-b281-3d09a5a3859f" alt="image" loading="lazy">・1792

<br>



<br>

で言及されているLLM Agentの評価で最も有名なベンチマークな模様データセット: https://huggingface.co/datasets/gaia-benchmark/GAIA</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<span class="issue_date">Issue Date: 2023-11-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1153">Unbalanced Optimal Transport for Unbalanced Word Alignment, Yuki Arase+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>単一言語の単語アライメントにおいて、null alignmentという現象は重要であり、不均衡な単語アライメントを実現するために最適輸送（OT）のファミリーが有効であることを示している。教師あり・教師なしの設定での包括的な実験により、OTベースのアライメント手法が最新の手法と競争力があることが示されている。</span>
<span class="snippet"><span>Comment</span>最適輸送で爆速でモノリンガルの単語アライメントがとれるらしい

<br>

実装:https://github.com/yukiar/OTAlign単語のアライメント先がない（null alignment）、one-to-oneの関係ではなく、one-to-many, many-to-manyのアライメントが必要な問題を（おそらく; もしかしたらnull alignmentだけかも）Unbalancedな単語アライメント問題と呼び、この課題に対して最適輸送が有効なアプローチであることを示しているっぽい

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/5e677be2-1001-4454-bc1e-fe3b32888a32" alt="image" loading="lazy"></span>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<span class="issue_date">Issue Date: 2023-11-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1152">Igniting Language Intelligence: The Hitchhiker's Guide From  Chain-of-Thought Reasoning to Language Agents, Zhuosheng Zhang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）は、言語知能の分野で劇的な進歩を遂げており、複雑な推論タスクにおいて高いパフォーマンスを示しています。特に、chain-of-thought（CoT）推論技術を活用することで、中間ステップを形成し、解釈可能性や制御可能性を向上させることができます。この論文では、CoT技術の基本的なメカニズムやその効果について詳しく解説し、言語エージェントの開発における応用例を紹介しています。将来の研究の展望にも触れており、初心者から経験豊富な研究者まで幅広い読者に対応しています。関連論文のリポジトリも提供されています。</span>
<span class="snippet"><span>Comment</span>CoTに関するチュートリアル論文</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/ContextEngineering.html">#ContextEngineering</a>
<span class="issue_date">Issue Date: 2023-11-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1151">System 2 Attention （is something you might need too）, Jason Weston+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>Transformerベースの大規模言語モデル（LLMs）におけるソフトアテンションは、文脈から無関係な情報を取り込む傾向があり、次のトークン生成に悪影響を与える。そこで、System 2 Attention（S2A）を導入し、LLMsが自然言語で推論し、指示に従う能力を活用して、注目すべき情報を決定する。S2Aは関連する部分のみを含むように入力コンテキストを再生成し、再生成されたコンテキストに注目して最終的な応答を引き出す。実験では、S2Aは3つのタスクで標準のアテンションベースのLLMsよりも優れた性能を発揮し、事実性と客観性を高める。</span>
<span class="snippet"><span>Comment</span>おそらく重要論文How is System 2 Attention different from prompt engineering specialized in factual double checks? I'm very sorry for the extremely delayed response. It's been two years, so you may no longer have a chance to see this, but I'd still like to share my thoughts.

<br>



<br>

I believe that System 2 Attention is fundamentally different in concept from prompt engineering techniques such as factual double-checking. Unlike ad-hoc prompt engineering or approaches that enrich the context by adding new facts through prompting, System 2 Attention aims to improve the model’s reasoning ability itself by mitigating the influence of irrelevant tokens. It does so by selectively generating a new context composed only of relevant tokens, in a way that resembles human System 2 thinking—that is, more objective and deliberate reasoning.

<br>



<br>

From today’s perspective, two years later, I would say that this concept is more closely aligned with what we now refer to as Context Engineering. Thank you.</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<span class="issue_date">Issue Date: 2023-11-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1147">Implicit Chain of Thought Reasoning via Knowledge Distillation, Yuntian Deng+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、言語モデルの内部の隠れ状態を使用して暗黙的な推論を行う手法を提案します。明示的なチェーン・オブ・ソートの推論ステップを生成する代わりに、教師モデルから抽出した暗黙的な推論ステップを使用します。実験により、この手法が以前は解決できなかったタスクを解決できることが示されました。</span>
<span class="snippet"><span>Comment</span>これは非常に興味深い話</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-11-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1144">Contrastive Chain-of-Thought Prompting, Yew Ken Chia+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>言語モデルの推論を改善するために、対照的なchain of thoughtアプローチを提案する。このアプローチでは、有効な推論デモンストレーションと無効な推論デモンストレーションの両方を提供し、モデルが推論を進める際にミスを減らすようにガイドする。また、自動的な方法を導入して対照的なデモンストレーションを構築し、汎化性能を向上させる。実験結果から、対照的なchain of thoughtが一般的な改善手法として機能することが示された。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2023-11-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1140">Chain-of-Note: Enhancing Robustness in Retrieval-Augmented Language  Models, Wenhao Yu+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>検索補完言語モデル（RALM）は、外部の知識源を活用して大規模言語モデルの性能を向上させるが、信頼性の問題や知識の不足による誤った回答がある。そこで、Chain-of-Noting（CoN）という新しいアプローチを導入し、RALMの頑健性を向上させることを目指す。CoNは、順次の読み取りノートを生成し、関連性を評価して最終的な回答を形成する。ChatGPTを使用してCoNをトレーニングし、実験結果はCoNを装備したRALMが標準的なRALMを大幅に上回ることを示している。特に、ノイズの多いドキュメントにおいてEMスコアで平均+7.9の改善を達成し、知識範囲外のリアルタイムの質問に対する拒否率で+10.5の改善を達成している。</span>
<span class="snippet"><span>Comment</span>一番重要な情報がappendixに載っている

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/58dc0468-e3f5-4893-8173-fc891893519f" alt="image" loading="lazy">

<br>

CoNによって、ノイズがあった場合にゲインが大きい。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/556a20e1-f687-4f08-bd8a-6ba3cd197cd7" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<span class="issue_date">Issue Date: 2023-11-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1138">Fine-tuning Language Models for Factuality, Katherine Tian+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模な言語モデル（LLMs）を使用して、より事実に基づいた生成を実現するためのファインチューニングを行います。具体的には、外部の知識ベースや信頼スコアとの一貫性を測定し、選好最適化アルゴリズムを使用してモデルを調整します。実験結果では、事実エラー率の削減が観察されました。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-11-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1137">Instruction-Following Evaluation for Large Language Models, Jeffrey Zhou+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）の能力を評価するために、Instruction-Following Eval（IFEval）という評価ベンチマークが導入されました。IFEvalは、検証可能な指示に焦点を当てた直感的で再現性のある評価方法です。具体的には、25種類の検証可能な指示を特定し、それぞれの指示を含む約500のプロンプトを作成しました。この評価ベンチマークの結果は、GitHubで公開されています。</span>
<span class="snippet"><span>Comment</span>LLMがinstructionにどれだけ従うかを評価するために、検証可能なプロンプト（400字以上で書きなさいなど）を考案し評価する枠組みを提案。人間が評価すると時間とお金がかかり、LLMを利用した自動評価だと評価を実施するLLMのバイアスがかかるのだ、それら両方のlimitationを克服できるとのこと。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/0eb3fe10-536d-4674-aa3c-fd76f390f21d" alt="image" loading="lazy"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-11-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1135">Fast Chain-of-Thought: A Glance of Future from Parallel Decoding Leads  to Answers Faster, Hongxuan Zhang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>この研究では、FastCoTというフレームワークを提案します。FastCoTは、LLMを使用して並列デコーディングと自己回帰デコーディングを同時に行い、計算リソースを最大限に活用します。また、FastCoTは推論時間を約20%節約し、性能の低下がほとんどないことを実験で示しました。さらに、異なるサイズのコンテキストウィンドウに対しても頑健性を示すことができました。</span>
<span class="snippet"><span>Comment</span>論文中の図を見たが、全くわからなかった・・・。ちゃんと読まないとわからなそうである。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LayoutGeneration.html">#LayoutGeneration</a>
<span class="issue_date">Issue Date: 2023-11-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1133">LayoutPrompter: Awaken the Design Ability of Large Language Models, Jiawei Lin+, N_A, NeurIPS'23</a>
<span class="snippet"><span>Summary</span>LayoutPrompterは、大規模言語モデル（LLMs）を使用して条件付きのグラフィックレイアウト生成を行う手法であり、入力-出力のシリアル化、動的な模範的選択、およびレイアウトのランキングの3つのコンポーネントで構成されています。LayoutPrompterは、既存の手法と競合したり上回ったりする性能を持ち、トレーニングや微調整なしで使用できる汎用性のあるアプローチであることが実験結果から示されています。また、データ効率にも優れており、トレーニングベースラインよりも有意に優れていることも示されています。プロジェクトは、https://github.com/microsoft/LayoutGeneration/tree/main/LayoutPrompterで利用可能です。</span>
<span class="snippet"><span>Comment</span>Conditional Graphic Layout Generation</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SmallModel.html">#SmallModel</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<span class="issue_date">Issue Date: 2023-11-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1132">Cappy: Outperforming and Boosting Large Multi-Task LMs with a Small   Scorer, Bowen Tan+, N_A, NeurIPS'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）はマルチタスキングに優れた性能を示していますが、パラメータ数が多く計算リソースを必要とし、効率的ではありません。そこで、小規模なスコアラーであるCappyを導入し、独立して機能するかLLMsの補助として使用することでパフォーマンスを向上させました。Cappyはファインチューニングやパラメータへのアクセスを必要とせず、さまざまなタスクで高い性能を発揮します。実験結果では、Cappyは独立したタスクや複雑なタスクで大きなLLMsを上回り、他のLLMsとの連携も可能です。</span>
<span class="snippet"><span>Comment</span>360MパラメータでさまざまなタスクでLLMに勝つっぽいのでおもしろそうだし実用性もありそう</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<span class="issue_date">Issue Date: 2023-11-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1131">MEGAVERSE: Benchmarking Large Language Models Across Languages,  Modalities, Models and Tasks, Sanchit Ahuja+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>LLMsの研究は急速に進展しており、英語以外の言語での評価が必要とされている。本研究では、新しいデータセットを追加したMEGAVERSEベンチマークを提案し、さまざまなLLMsを評価する。実験の結果、GPT4とPaLM2が優れたパフォーマンスを示したが、データの汚染などの問題があるため、さらなる取り組みが必要である。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/AutomaticPromptEngineering.html">#AutomaticPromptEngineering</a>
<span class="issue_date">Issue Date: 2023-11-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1128">Prompt Engineering a Prompt Engineer, Qinyuan Ye+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>プロンプトエンジニアリングは、LLMsのパフォーマンスを最適化するための重要なタスクであり、本研究ではメタプロンプトを構築して自動的なプロンプトエンジニアリングを行います。改善されたパフォーマンスにつながる推論テンプレートやコンテキストの明示などの要素を導入し、一般的な最適化概念をメタプロンプトに組み込みます。提案手法であるPE2は、さまざまなデータセットやタスクで強力なパフォーマンスを発揮し、以前の自動プロンプトエンジニアリング手法を上回ります。さらに、PE2は意味のあるプロンプト編集を行い、カウンターファクトの推論能力を示します。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/MultitaskLearning.html">#MultitaskLearning</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/FoundationModel.html">#FoundationModel</a>
<span class="issue_date">Issue Date: 2023-11-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1127">Florence-2: Advancing a Unified Representation for a Variety of Vision  Tasks, Bin Xiao+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>Florence-2は、ビジョン基盤モデルであり、さまざまなビジョンタスクに対応するための統一されたプロンプトベースの表現を持っています。このモデルは、テキストプロンプトを受け取り、キャプショニング、オブジェクト検出、グラウンディング、セグメンテーションなどのタスクを実行し、テキスト形式で結果を生成します。また、FLD-5Bという大規模な注釈付きデータセットも開発されました。Florence-2は、多目的かつ包括的なビジョンタスクを実行するためにシーケンスツーシーケンス構造を採用しており、前例のないゼロショットおよびファインチューニングの能力を持つ強力なモデルです。</span>
<span class="snippet"><span>Comment</span>Vison Foundation Model。Spatialな階層構造や、Semanticを捉えられるように訓練。Image/Prompt Encoderでエンコードされ、outputはtext + location informationとなる。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/9fbfba62-190f-46eb-a893-5ebe76dda030" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/f7497161-6b9a-4adc-aa6b-53debe1e9318" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<span class="issue_date">Issue Date: 2023-11-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1123">A Survey on Hallucination in Large Language Models: Principles,  Taxonomy, Challenges, and Open Questions, Lei Huang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>LLMsの出現はNLPにおける重要な進歩をもたらしているが、幻覚を生じることがあり、その信頼性に懸念がある。本調査では、LLMの幻覚に関する最近の進展について包括的に概説し、幻覚の要因や検出手法、軽減アプローチについて紹介する。また、現在の制約や将来の研究方向についても分析する。</span>
<span class="snippet"><span>Comment</span>Hallucinationを現象ごとに分類したSurveyとして 1048 もあるSurveyの内容。必要に応じて参照すべし。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/32d8d809-e197-4289-8000-12fee76a69cf" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<span class="issue_date">Issue Date: 2023-11-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1121">Tell Your Model Where to Attend: Post-hoc Attention Steering for LLMs, Qingru Zhang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>PASTAは、大規模言語モデル（LLMs）において、ユーザーが指定した強調マークのあるテキストを読むことを可能にする手法です。PASTAは、注意の一部を特定し、再重み付けを適用してモデルの注意をユーザーが指定した部分に向けます。実験では、PASTAがLLMの性能を大幅に向上させることが示されています。</span>
<span class="snippet"><span>Comment</span>ユーザがprompt中で強調したいした部分がより考慮されるようにattention weightを調整することで、より応答性能が向上しましたという話っぽい。かなり重要な技術だと思われる。後でしっかり読む。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/a4d3714e-7279-495c-86f1-5ff4ed2cbeb8" alt="image" loading="lazy"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-11-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1120">Do LLMs exhibit human-like response biases? A case study in survey  design, Lindia Tjuatja+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>LLMsを使用して人間の代理としてタスクを実行する際に、LLMsが人間の応答バイアスをどの程度反映するかを調査する必要がある。この研究では、調査設計を使用して人間の応答バイアスを評価するデータセットとフレームワークを設計し、9つのモデルを評価した結果、一般的なLLMsが人間のような振る舞いを反映することに失敗していることが示された。これらの結果は、LLMsを人間の代わりに使用する際の潜在的な落とし穴を強調し、モデルの振る舞いの細かい特性の重要性を強調している。</span>
<span class="snippet"><span>Comment</span>LLMはPromptにsensitiveだが、人間も質問の仕方によって応答が変わるから、sensitiveなのは一緒では？ということを調査した研究。Neubig氏のツイートだと、instruction tuningやRLHFをしていないBase LLMの方が、より人間と類似した回答をするのだそう。

<br>



<br>

元ツイート: https://x.com/gneubig/status/1722294711355117666?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q人間のレスポンスのバイアス。左側は人間は「forbidden」よりも「not allowed」を好むという例、右側は「response order」のバイアスの例（選択肢の順番）。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/de129e78-5d52-41e3-a3bb-9aec20cf2b05" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

LLM側で評価したいバイアスごとに、QAのテキストを変更し、LLMに回答を生成され、social science studiesでのトレンドと比較することで、LLMにも人間と同様のバイアスがあるかを明らかにしている。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/3dc39afc-4e52-49a4-bf60-22ff94bf35c6" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

結果は以下の表であり、青いセルが人間と同様のバイアスを持つことを統計的に有意に示されたもの（のはず）。これをみると、全てのバイアスに対して人間と同様の傾向があったのはLlama2-70Bのみであり、instruction tuningや、RLHFをかけた場合（RLHFの方が影響が大きそう）人間のバイアスとは異なる挙動をするモデルが多くなることがわかる。また、モデルのパラメータサイズとバイアスの強さには相関関係は見受けられない。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/7d8eade0-ae3a-4d62-bb2d-160971542c39" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<span class="issue_date">Issue Date: 2023-11-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1117">Pretraining Data Mixtures Enable Narrow Model Selection Capabilities in  Transformer Models, Steve Yadlowsky+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、トランスフォーマーモデルの文脈学習（ICL）能力を調査しました。トランスフォーマーモデルは、事前学習データの範囲内で異なるタスクを特定し、学習する能力を持っています。しかし、事前学習データの範囲外のタスクや関数に対しては一般化が劣化することが示されました。また、高容量のシーケンスモデルのICL能力は、事前学習データの範囲に密接に関連していることが強調されました。</span>
<span class="snippet"><span>Comment</span>Transformerがpre-training時に利用された学習データ以外の分布に対しては汎化性能が落ちることを示したらしい。もしこれが正しいとすると、結局真に新しい分布というか関数というかタスクというか、をTransformerが創出する可能性は低いと言えるかもしれない。が、新しいものって大体は既存の概念の組み合わせだよね（スマホとか）、みたいなことを考えると、別にそれでも十分では？と思ってしまう。人間が本当に真の意味で新しい関数というかタスクというか分布を生み出せているかというと、実はそんなに多くないのでは？という予感もする。まあたとえば、量子力学を最初に考えました！とかそういうのは例外だと思うけど・・・、そのレベルのことってどんくらいあるんだろうね？</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2023-11-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1116">The Perils &amp; Promises of Fact-checking with Large Language Models, Dorian Quelle+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>自律型の事実チェックにおいて、大規模言語モデル（LLMs）を使用することが重要である。LLMsは真実と虚偽を見分ける役割を果たし、その出力を検証する能力がある。本研究では、LLMエージェントを使用して事実チェックを行い、推論を説明し、関連する情報源を引用する能力を評価した。結果は、文脈情報を備えたLLMsの能力の向上を示しているが、正確性には一貫性がないことに注意が必要である。今後の研究では、成功と失敗の要因をより深く理解する必要がある。</span>
<span class="snippet"><span>Comment</span>gpt3とgpt4でFactCheckして傾向を分析しました、という研究。promptにstatementとgoogleで補完したcontextを含め、出力フォーマットを指定することでFactCheckする。

<br>

promptingする際の言語や、statementの事実性の度合い（半分true, 全てfalse等）などで、性能が大きく変わる結果とのこと。

<br>

性能を見ると、まだまだ（このprompting方法では）人間の代わりが務まるほどの性能が出ていないことがわかる。また、trueな情報のFactCheckにcontextは効いていそうだが、falseの情報のFactCheckにContextがあまり効いてなさそうに見えるので、なんだかなあ、という感じである。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/1f310edd-58f3-4e45-ac40-e75337bff884" alt="image" loading="lazy">

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/e6901a32-af7a-472c-9790-d3784fa577ce" alt="image" loading="lazy">斜め読みしかしていないがこの研究、学術的な知見は少ないのかな、という印象。一つのケーススタディだよね、という感じがする。

<br>



<br>

まず、GPT3,4だけじゃなく、特徴の異なるOpenSourceのLLMを比較に含めてくれないと、前者は何で学習しているか分からないので、学術的に得られる知見はほぼないのではという気が。実務的には役に立つが。

<br>



<br>

その上で、Promptingをもっとさまざまな方法で検証した方が良いと思う。

<br>

たとえば、現在のpromptではラベルを先に出力させた後に理由を述べさせているが、それを逆にしたらどうなるか？（zero-shot CoT）や、4-Shotにしたらどうなるか、SelfConsistencyを利用したらどうなるかなど、promptingの仕方によって傾向が大きく変わると思う。

<br>



<br>

加えて、Retriever部分もいくつかのバリエーションで試してみても良いのかなと思う。特に、falseの情報を判断する際に役に立つ情報がcontextに含められているのかが気になる。

<br>

論文に書いてあるかもしれないが、ちょっとしっかり読む時間はないです！！</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/FoundationModel.html">#FoundationModel</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<span class="issue_date">Issue Date: 2023-10-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1104">Llemma: An Open Language Model For Mathematics, Zhangir Azerbayev+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>私たちは、数学のための大規模な言語モデルであるLlemmaを提案します。Llemmaは、Proof-Pile-2と呼ばれるデータセットを用いて事前学習され、MATHベンチマークで他のモデルを上回る性能を示しました。さらに、Llemmaは追加のfine-tuningなしでツールの使用や形式的な定理証明が可能です。アーティファクトも公開されています。</span>
<span class="snippet"><span>Comment</span>CodeLLaMAを200B tokenの数学テキスト（proof-pile-2データ;論文、数学を含むウェブテキスト、数学のコードが含まれるデータ）で継続的に事前学習することでfoundation modelを構築

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/87f9bbe1-3377-4e80-a7d4-904345ebb7d9" alt="image" loading="lazy">

<br>



<br>

約半分のパラメータ数で数学に関する性能でGoogleのMinervaと同等の性能を達成

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/5d209059-2275-415a-8b8d-f73f46712ba6" alt="image" loading="lazy">元ツイート: https://twitter.com/zhangir_azerbay/status/1714098823080063181まだ4-shotしてもAcc.50%くらいなのか。</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-10-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1102">Large Language Models are not Fair Evaluators, Peiyi Wang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>この論文では、大規模言語モデル（LLMs）を使用して、候補モデルの応答品質を評価する評価パラダイムにおける系統的なバイアスを明らかにします。さらに、バイアスを軽減するためのキャリブレーションフレームワークを提案し、実験によってその有効性を示します。また、コードとデータを公開して、今後の研究を支援します。</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/DataGeneration.html">#DataGeneration</a>
<span class="issue_date">Issue Date: 2023-10-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1099">Zephyr: Direct Distillation of LM Alignment, Lewis Tunstall+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>私たちは、小さな言語モデルを作成するために、教師モデルからの優先データを使用する手法を提案しています。この手法により、自然なプロンプトに対するモデルの応答が改善されます。提案手法を用いて学習されたZephyr-7Bモデルは、チャットベンチマークで最先端の性能を発揮し、人間の注釈を必要としません。詳細はGitHubで利用可能です。</span>
<span class="snippet"><span>Comment</span>7BパラメータでLlaMa70Bと同等の性能を達成したZephyrの論文。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/1348b3c1-f70a-49b6-97c9-4a27bf7805fa" alt="image" loading="lazy">

<br>



<br>

・dSFT:既存データからpromptをサンプリングし、user,assistantのmulti turnの対話をLLMでシミュレーションしてデータ生成しSFT

<br>

・AIF:既存データからpromstをサンプリングし、異なる4つのLLMのレスポンスをGPT4でランクづけしたデータの活用

<br>

・dDPO: 既存データからpromptをサンプリングし、ベストなレスポンスとランダムにサンプリングしたレスポンスの活用

<br>



<br>

人手を一切介していない。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/f2cd7b48-4036-49eb-bfb7-0ce3cc8a09b8" alt="image" loading="lazy">Blog: https://huggingface.co/blog/Isamu136/understanding-zephyr</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-10-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1098">Human Feedback is not Gold Standard, Tom Hosking+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>人間のフィードバックは、大規模言語モデルの性能評価に使用されているが、その好みのスコアがどの特性を捉えているのかは明確ではない。この研究では、人間のフィードバックの使用を分析し、重要なエラー基準を適切に捉えているかどうかを検証した。結果として、好みのスコアは広範なカバレッジを持っているが、事実性などの重要な側面が過小評価されていることがわかった。また、好みのスコアとエラーアノテーションは交絡因子の影響を受ける可能性があり、出力の断定性が事実性エラーの知覚率を歪めることも示された。さらに、人間のフィードバックを訓練目標として使用することが、モデルの出力の断定性を過度に増加させることも示された。今後の研究では、好みのスコアが望ましい目標と一致しているかどうかを慎重に考慮する必要がある。</span>
<span class="snippet"><span>Comment</span>参考: https://x.com/icoxfog417/status/1718151338520199180?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/3824b322-53fa-4360-a7d4-1b0f3bff3302" alt="image" loading="lazy"></span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/OCR.html">#OCR</a>
<span class="issue_date">Issue Date: 2023-10-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1093">Exploring OCR Capabilities of GPT-4V（ision） : A Quantitative and  In-depth Evaluation, Yongxin Shi+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>この論文では、GPT-4Vという大規模マルチモーダルモデルの光学文字認識（OCR）能力を評価します。さまざまなOCRタスクにおいてモデルのパフォーマンスを評価し、ラテン文字の認識と理解において優れた性能を示す一方、多言語や複雑なタスクには苦戦することがわかりました。これに基づいて、専門のOCRモデルの必要性やGPT-4Vを活用する戦略についても検討します。この研究は、将来のLMMを用いたOCRの研究に役立つものです。評価のパイプラインと結果は、GitHubで利用可能です。</span>
<span class="snippet"><span>Comment</span>GPT4-VをさまざまなOCRタスク「手書き、数式、テーブル構造認識等を含む）で性能検証した研究。

<br>

MLT19データセットを使った評価では、日本語の性能は非常に低く、英語とフランス語が性能高い。手書き文字認識では英語と中国語でのみ評価。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/c433b921-c527-441f-8925-00f4ac5fc6c3" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/InstructionGeneration.html">#InstructionGeneration</a>
<span class="issue_date">Issue Date: 2023-10-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1092">Auto-Instruct: Automatic Instruction Generation and Ranking for  Black-Box Language Models, Zhihan Zhang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）の性能を向上させるための新しい手法であるAuto-Instructを提案しています。この手法では、LLMsが生成する指示の品質を自動的に向上させるために、多様な候補の指示を生成し、スコアリングモデルでランク付けします。実験結果では、Auto-Instructが人間による指示や既存のLLM生成指示を上回ることが示されています。また、他のLLMsでも顕著な汎化性能を示すことも確認されています。</span>
<span class="snippet"><span>Comment</span>seed instructionとdemonstrationに基づいて、異なるスタイルのinstructionを自動生成し、自動生成したinstructionをとinferenceしたいexampleで条件づけてランキングし、良質なものを選択。選択したinstructionでinferenceを実施する。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/3b318cac-516d-4fc8-9097-ad695ab8223b" alt="image" loading="lazy">既存手法よりも高い性能を達成している。特にexampleごとにinstructionを選択する手法の中で最もgainが高い。これは、提案手法がinstructionの選択にtrained modelを利用しているためであると考えられる。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/8e2c8bad-54ec-49e8-b6e0-29bc18425e99" alt="image" loading="lazy"></span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<span class="issue_date">Issue Date: 2023-10-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1091">NEFTune: Noisy Embeddings Improve Instruction Finetuning, Neel Jain+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>私たちは、言語モデルのファインチューニングを改善するために、ノイズを加えた埋め込みベクトルを使用する手法を提案します。この手法は、AlpacaEvalやEvol-Instructなどのデータセットで強力なベースラインを上回る性能を示しました。また、RLHFでトレーニングされたモデルにも適用可能です。</span>
<span class="snippet"><span>Comment</span>Alpacaデータでの性能向上が著しい。かなり重要論文な予感。後で読む。HuggingFaceのTRLでサポートされている

<br>



<br>

https://huggingface.co/docs/trl/sft_trainer</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<span class="issue_date">Issue Date: 2023-10-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1090">In-Context Learning Creates Task Vectors, Roee Hendel+, N_A, EMNLP'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）におけるインコンテキスト学習（ICL）の基本的なメカニズムはまだ十分に理解されていない。本研究では、ICLによって学習される関数が非常に単純な構造を持つことを示し、ICLがトランスフォーマーLLMを使用して単一のタスクベクトルを生成し、それを使用して出力を生成するということを明らかにする。さまざまなモデルとタスクにわたる実験によって、この主張を支持している。</span>
<span class="snippet"><span>Comment</span>参考: https://x.com/hillbig/status/1717302086587875395?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QICLが実現可能なのは実はネットワーク内部で与えられたdemonstrationに対して勾配効果法を再現しているからです、という研究もあったと思うけど、このタスクベクトルとの関係性はどういうものなのだろうか。文脈に注意を与えなくてもICLと同じ性能が出るのは、文脈情報が不要なタスクを実施しているからであり、そうではないタスクだとこの知見が崩れるのだろうか。後で読む。</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-10-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1089">Detecting Pretraining Data from Large Language Models, Weijia Shi+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）を訓練するためのデータの検出問題を研究し、新しい検出方法であるMin-K% Probを提案します。Min-K% Probは、LLMの下で低い確率を持つアウトライアーワードを検出することに基づいています。実験の結果、Min-K% Probは従来の方法に比べて7.4%の改善を達成し、著作権のある書籍の検出や汚染された下流の例の検出など、実世界のシナリオにおいて効果的な解決策であることが示されました。</span>
<span class="snippet"><span>Comment</span>実験結果を見るにAUCは0.73-0.76程度であり、まだあまり高くない印象。また、テキストのlengthはそれぞれ32,64,128,256程度。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/1d7a5fe2-e0bc-4c6e-92b2-34457a17714a" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-10-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1088">Branch-Solve-Merge Improves Large Language Model Evaluation and  Generation, Swarnadeep Saha+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、多面的な言語生成および評価タスクにおいて、大規模言語モデルプログラム（BSM）を提案します。BSMは、ブランチ、ソルブ、マージの3つのモジュールから構成され、タスクを複数のサブタスクに分解し、独立して解決し、解決策を統合します。実験により、BSMが評価の正確性と一貫性を向上させ、パフォーマンスを向上させることが示されました。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<span class="issue_date">Issue Date: 2023-10-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1086">Personalized Soups: Personalized Large Language Model Alignment via  Post-hoc Parameter Merging, Joel Jang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>Reinforcement Learning from Human Feedback (RLHF) is not optimal for learning diverse individual perspectives, as it aligns general aggregated human preferences with large language models (LLMs). This study investigates the problem of Reinforcement Learning from Individual Human Feedback (RLPHF) and models the alignment with LLMs to multiple (sometimes conflicting) preferences as a Multi-Objective Reinforcement Learning (MORL) problem. It demonstrates that individual alignment can be achieved by decomposing preferences into multiple dimensions based on personalized declarations. The study shows that these dimensions can be efficiently trained independently and distributed, and effectively combined in post-processing through parameter merging. The code is available at https://github.com/joeljang/RLPHF.</span>
<span class="snippet"><span>Comment</span>どこまでのことが実現できるのかが気になる。</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-10-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1085">Eliminating Reasoning via Inferring with Planning: A New Framework to  Guide LLMs' Non-linear Thinking, Yongqi Tong+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）に非線形の思考を促すために、新しいプロンプティング方法であるInferential Exclusion Prompting（IEP）を提案する。IEPは、計画を立てて可能な解を推論し、逆推論を行うことで広い視点を得ることができる。IEPは他の手法と比較して複雑な人間の思考プロセスをシミュレートできることを実証し、LLMsのパフォーマンス向上にも貢献することを示した。さらに、Mental-Ability Reasoning Benchmark（MARB）を導入し、LLMsの論理と言語推論能力を評価するための新しいベンチマークを提案した。IEPとMARBはLLMsの研究において有望な方向性であり、今後の進展が期待される。</span>
<span class="snippet"><span>Comment</span>元論文は読んでいないのだが、CoTが線形的だという主張がよくわからない。

<br>

CoTはAutoregressiveな言語モデルに対して、コンテキストを自己生成したテキストで利用者の意図した方向性にバイアスをかけて補完させ、

<br>

利用者が意図した通りのアウトプットを最終的に得るためのテクニック、だと思っていて、

<br>

線形的だろうが非線形的だろうがどっちにしろCoTなのでは。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-10-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1078">Meta-CoT: Generalizable Chain-of-Thought Prompting in Mixed-task  Scenarios with Large Language Models, Anni Zou+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）を使用して、推論のためのチェーン・オブ・ソート（CoT）プロンプトを生成する方法を提案しています。従来のCoTの方法では、一般的なプロンプトや手作業デモンストレーションに依存していましたが、本研究では入力質問のタイプに基づいて自動的にプロンプトを生成するMeta-CoTを提案しています。Meta-CoTは、10のベンチマーク推論タスクで優れたパフォーマンスを示し、SVAMPでは最先端の結果を達成しました。また、分布外データセットでも安定性と汎用性が確認されました。</span>
<span class="snippet"><span>Comment</span>色々出てきたがなんかもう色々組み合わせれば最強なんじゃね?って気がしてきた。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/bb51c119-c1bc-4033-a7d4-f403d3c82d30" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/1c450a01-5cd6-4af3-af76-323e8c8d3769" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<span class="issue_date">Issue Date: 2023-10-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1077">Survey on Factuality in Large Language Models: Knowledge, Retrieval and  Domain-Specificity, Cunxiang Wang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>この研究では、大規模言語モデル（LLMs）の事実性の問題に取り組んでいます。LLMsの出力の信頼性と正確性は重要であり、事実に矛盾した情報を生成することがあるため、その問題を解決する方法を探求しています。具体的には、LLMsの事実的なエラーの影響や原因を分析し、事実性を評価する手法や改善策を提案しています。また、スタンドアロンのLLMsと外部データを利用する検索拡張型LLMsに焦点を当て、それぞれの課題と改善策について詳しく説明しています。この研究は、LLMsの事実的な信頼性を向上させるためのガイドとなることを目指しています。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/4d3ab4df-aaa0-460f-b16a-6114432336cd" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-10-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1076">Take a Step Back: Evoking Reasoning via Abstraction in Large Language  Models, Huaixiu Steven Zheng+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>Step-Back Promptingは、大規模言語モデル（LLMs）を使用して推論の手順をガイドするシンプルなプロンプティング技術です。この技術により、LLMsは具体的な詳細から高レベルの概念や基本原則を抽象化し、正しい推論経路をたどる能力を向上させることができます。実験により、Step-Back PromptingはSTEM、Knowledge QA、Multi-Hop Reasoningなどのタスクにおいて大幅な性能向上が観察されました。具体的には、MMLU Physics and Chemistryで7%、11%、TimeQAで27%、MuSiQueで7%の性能向上が確認されました。</span>
<span class="snippet"><span>Comment</span>また新しいのが出た<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/aac94123-7c39-4938-889f-feb5cff9317c" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/a793ff97-3d5c-4707-9ec6-3884b143182b" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2023-10-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1074">RECOMP: Improving Retrieval-Augmented LMs with Compression and Selective  Augmentation, Fangyuan Xu+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>ドキュメントの要約を生成することで、言語モデルの性能を向上させる手法を提案する。抽出型の圧縮器と抽象型の圧縮器を使用し、LMsの入力に要約を追加して訓練する。実験結果では、圧縮率が6％まで達成され、市販の要約モデルを上回る性能を示した。また、訓練された圧縮器は他のLMsにも転移可能であることが示された。</span>
<span class="snippet"><span>Comment</span>Retrieval Augmentationをする際に、元文書群を要約して圧縮することで、性能低下を抑えながら最大6%程度まで元文書群を圧縮できた、とのこと。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/2756ba98-d228-45e6-972d-ef239d4b990e" alt="image" loading="lazy">元ツイート: https://x.com/omarsar0/status/1711384213092479130?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QRetrieval Augmentationを導入する際のコスト削減に有用そう</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2023-10-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1070">Retrieval meets Long Context Large Language Models, Peng Xu+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>最先端の事前学習済みLLMsを使用して、リトリーバル拡張と長いコンテキストウィンドウの組み合わせについて研究しました。結果として、リトリーバル拡張LLMsは、ファインチューニングLLMsと比較しても高いパフォーマンスを示し、計算量も少ないことがわかりました。さらに、リトリーバルはLLMsのパフォーマンスを向上させることができることが示されました。リトリーバル拡張LLMsは、質問応答や要約などのタスクにおいて、他のモデルよりも優れた性能を発揮し、生成速度も速いです。この研究は、実践者にとってリトリーバル拡張と長いコンテキストウィンドウのLLMsの選択に関する洞察を提供します。</span>
<span class="snippet"><span>Comment</span>参考: https://x.com/hillbig/status/1711502993508671670?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q検索補強（Retrieval Augmentation）とは、言語モデルの知識を補完するために、関連する文書を外部の文書集合からとってきて、contextに含める技術のこと

<br>



<br>

https://tech.acesinc.co.jp/entry/2023/03/31/121001</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Conversation.html">#Conversation</a>
<span class="issue_date">Issue Date: 2023-10-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1069">RoleLLM: Benchmarking, Eliciting, and Enhancing Role-Playing Abilities  of Large Language Models, Zekun Moore Wang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）を使用して役割演技の能力を向上させるためのフレームワークであるRoleLLMを提案しています。RoleLLMは、役割プロファイルの構築、コンテキストベースの指示生成、役割プロンプトによる話し方の模倣、オープンソースモデルの微調整と役割のカスタマイズの4つのステージで構成されています。さらに、RoleBenchと呼ばれる役割演技のためのベンチマークデータセットを作成し、RoleLLaMAとRoleGLMというモデルを開発しました。これにより、役割演技の能力が大幅に向上し、GPT-4と同等の結果を達成しました。</span>
<span class="snippet"><span>Comment</span>Overview

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/4a4f8ad3-17d1-4a85-b553-6452371e2ccf" alt="image" loading="lazy">

<br>



<br>

RoleBench

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/a197648f-ee30-4e1d-9b3b-188c29671df4" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<span class="issue_date">Issue Date: 2023-10-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1068">Improved Baselines with Visual Instruction Tuning, Haotian Liu+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>LLaVAは、ビジョンと言語のクロスモーダルコネクタであり、データ効率が高く強力な性能を持つことが示されています。CLIP-ViT-L-336pxを使用し、学術タスク指向のVQAデータを追加することで、11のベンチマークで最先端のベースラインを確立しました。13Bのチェックポイントはわずか120万の公開データを使用し、1日で完全なトレーニングを終えます。コードとモデルは公開されます。</span>
<span class="snippet"><span>Comment</span>画像分析が可能なオープンソースLLMとのこと。Overview

<br>



<br>

画像生成をできるわけではなく、inputとして画像を扱えるのみ。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/8d0382b0-8c2b-438d-8de8-ee451f5e2649" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/AutoML.html">#AutoML</a>
<span class="issue_date">Issue Date: 2023-10-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1067">Benchmarking Large Language Models As AI Research Agents, Qian Huang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、AI研究エージェントを構築し、科学的な実験のタスクを実行するためのベンチマークとしてMLAgentBenchを提案する。エージェントはファイルの読み書きやコードの実行などのアクションを実行し、実験を実行し、結果を分析し、機械学習パイプラインのコードを変更することができる。GPT-4ベースの研究エージェントは多くのタスクで高性能なモデルを実現できるが、成功率は異なる。また、LLMベースの研究エージェントにはいくつかの課題がある。</span>
<span class="snippet"><span>Comment</span>GPT4がMLモデルをどれだけ自動的に構築できるかを調べた模様。また、ベンチマークデータを作成した模様。結果としては、既存の有名なデータセットでの成功率は90%程度であり、未知のタスク（新たなKaggle Challenge等）では30%程度とのこと。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/AutomaticPromptEngineering.html">#AutomaticPromptEngineering</a>
<span class="issue_date">Issue Date: 2023-10-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1066">Promptbreeder: Self-Referential Self-Improvement Via Prompt Evolution, Chrisantha Fernando+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、Promptbreederという自己参照的な自己改善メカニズムを提案し、大規模言語モデル（LLM）の推論能力を向上させるための汎用的なプロンプト戦略を進化させる方法を示しています。Promptbreederは、LLMが自己参照的な方法で進化する変異プロンプトによって制御され、タスクプロンプトの集団を変異させて改善します。この手法は、算術や常識的な推論のベンチマークだけでなく、ヘイトスピーチ分類などの難しい問題に対しても優れた性能を発揮します。</span>
<span class="snippet"><span>Comment</span>詳細な解説記事: https://aiboom.net/archives/56319APEとは異なり、GAを使う。突然変異によって、予期せぬ良いpromptが生み出されるかも…？</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/AutomaticPromptEngineering.html">#AutomaticPromptEngineering</a>
<span class="issue_date">Issue Date: 2023-10-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1065">Enhancing Zero-Shot Chain-of-Thought Reasoning in Large Language Models  through Logic, Xufeng Zhao+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデルの進歩は驚異的だが、多段階の推論には改善の余地がある。大規模言語モデルは知識を持っているが、推論には一貫性がなく、幻覚を示すことがある。そこで、Logical Chain-of-Thought（LogiCoT）というフレームワークを提案し、論理による推論パラダイムの効果を示した。</span>
<span class="snippet"><span>Comment</span>まーた新しいX of Thoughtが出た。必要そうなら読む。</span>
<a class="button" href="articles/GraphBased.html">#GraphBased</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/AutomaticPromptEngineering.html">#AutomaticPromptEngineering</a>
<span class="issue_date">Issue Date: 2023-10-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1061">Graph Neural Prompting with Large Language Models, Yijun Tian+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）を知識グラフと組み合わせるための新しい手法であるGraph Neural Prompting（GNP）を提案しています。GNPは、標準的なグラフニューラルネットワークエンコーダやクロスモダリティプーリングモジュールなどの要素から構成されており、異なるLLMのサイズや設定において、常識的な推論タスクやバイオメディカル推論タスクで優れた性能を示すことが実験によって示されました。</span>
<span class="snippet"><span>Comment</span>以下elvis氏のツイートの意訳

<br>



<br>

事前学習されたLLMがKGから有益な知識を学習することを支援する手法を提案。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/434daf26-f82f-43b9-8807-13517975383b" alt="image" loading="lazy">

<br>

元ツイート: https://arxiv.org/abs/2309.15427

<br>

しっかり論文を読んでいないが、freezeしたLLMがあった時に、KGから求めたGraph Neural Promptを元のテキストと組み合わせて、新たなLLMへの入力を生成し利用する手法な模様。

<br>

Graph Neural Promptingでは、Multiple choice QAが入力された時に、その問題文や選択肢に含まれるエンティティから、KGのサブグラフを抽出し、そこから関連性のある事実や構造情報をエンコードし、Graph Neural Promptを獲得する。そのために、GNNに基づいたアーキテクチャに、いくつかの工夫を施してエンコードをする模様。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/c6c80b8d-930e-49ff-9a1b-62e70947dc7c" alt="image" loading="lazy"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<a class="button" href="articles/ReversalCurse.html">#ReversalCurse</a>
<span class="issue_date">Issue Date: 2023-10-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1059">[Paper Note] The Reversal Curse: LLMs trained on "A is B" fail to learn "B is A", Lukas Berglund+, arXiv'23</a>
<span class="snippet"><span>Summary</span>自己回帰型大規模言語モデル（LLMs）は、「AはBである」という文から「BはAである」と逆の関係を自動的に一般化できない「逆転の呪い」を示す。例えば、モデルが「ワレンティナ・テレシコワは宇宙に行った最初の女性である」と訓練されても、「宇宙に行った最初の女性は誰か？」に正しく答えられない。実験では、架空の文を用いてGPT-3とLlama-1をファインチューニングし、逆転の呪いの存在を確認。ChatGPT（GPT-3.5およびGPT-4）でも、実在の有名人に関する質問で正答率に大きな差が見られた。</span>
<span class="snippet"><span>Comment</span>A is Bという文でLLMを訓練しても、B is Aという逆方向には汎化されないことを示した。

<br>



<br>

著者ツイート: https://x.com/owainevans_uk/status/1705285631520407821?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/25e20dcc-0313-4cd2-8768-afb0e4e48a68" alt="image" loading="lazy">

<br>

GPT3, LLaMaを A is Bでfinetuneし、B is Aという逆方向のfactを生成するように（質問をして）テストしたところ、0%付近のAcc.だった。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/d089eb94-6872-40b5-89a1-7532758e1d89" alt="image" loading="lazy">

<br>



<br>

また、Acc.が低いだけでなく、対数尤度もrandomなfactを生成した場合と、すべてのモデルサイズで差がないことがわかった。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/ba10fff4-cfdc-4e52-8217-c59247209211" alt="image" loading="lazy">

<br>



<br>

このことら、Reversal Curseはモデルサイズでは解決できないことがわかる。関連:

<br>

・1923</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-10-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1056">Large Language Models as Analogical Reasoners, Michihiro Yasunaga+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、言語モデルの推論プロセスを自動的にガイドするための新しいプロンプティング手法であるアナロジカルプロンプティングを提案しています。この手法は、関連する過去の経験を引用して新しい問題に取り組む認知プロセスに倣い、問題を解決する前に文脈内で関連する例示や知識を自己生成させるように言語モデルに促します。この手法は、例示のラベリングや検索の必要性を排除し、一般性と適応性を提供します。実験結果は、この手法がさまざまな推論タスクで他の手法を上回ることを示しています。</span>
<span class="snippet"><span>Comment</span>以下、著者ツイートのざっくり翻訳: https://x.com/michiyasunaga/status/1709582150025240854?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

人間は新しい問題に取り組む時、過去に解いた類義の問題を振り返り、その経験を活用する。これをLLM上で実践できないか?というのがアイデア。

<br>

Analogical Promptingでは、問題を解く前に、適切なexamplarを自動生成（problemとsolution）させ、コンテキストとして利用する。

<br>



<br>

これにより、examplarは自己生成されるため、既存のCoTで必要なexamplarのラベリングや検索が不要となることと、解こうとしている問題に合わせてexamplarを調整し、推論に対してガイダンスを提供することが可能となる。

<br>



<br>

実験の結果、数学、コード生成、BIG-Benchでzero-shot CoT、few-shot CoTを上回った。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/8aae5d9d-d8d8-4c86-b55f-0fcde5d5381c" alt="image" loading="lazy">

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/8544d7e2-bae3-4a1e-a867-ab655785c725" alt="image" loading="lazy">LLMが知っており、かつ得意な問題に対してならうまく働きそう。一方で、LLMが苦手な問題などは人手作成したexamplarでfew-shotした方が（ある程度）うまくいきそうな予感がする。うまくいきそうと言っても、そもそもLLMが苦手な問題なのでfew-shotした程度では焼石に水だとは思うが。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/NumericReasoning.html">#NumericReasoning</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<span class="issue_date">Issue Date: 2023-09-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1050">MAmmoTH: Building Math Generalist Models through Hybrid Instruction  Tuning, Xiang Yue+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>MAmmoTHは、数学の問題解決に特化した大規模言語モデルであり、厳密にキュレーションされた教育データセットで訓練されています。このモデルは、CoTとPoTのハイブリッドな根拠を提供し、さまざまな数学の分野を包括的にカバーしています。MAmmoTHは、既存のオープンソースモデルを大幅に上回り、特にMATHデータセットで高い精度を示しています。この研究は、多様な問題のカバレッジとハイブリッドな根拠の使用の重要性を強調しています。</span>
<span class="snippet"><span>Comment</span>9つのmath reasoningが必要なデータセットで13-29%のgainでSoTAを達成。

<br>

260kの根拠情報を含むMath Instructデータでチューニングされたモデル。

<br>



<br>

project page: https://tiger-ai-lab.github.io/MAmmoTH/</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<span class="issue_date">Issue Date: 2023-09-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1048">A Survey of Hallucination in Large Foundation Models, Vipula Rawte+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模ファウンデーションモデル（LFMs）におけるホールシネーションの問題に焦点を当て、その現象を分類し、評価基準を確立するとともに、既存の戦略を検討し、今後の研究の方向性についても議論しています。</span>
<span class="snippet"><span>Comment</span>Hallucinationを現象ごとに分類し、Hallucinationの程度の評価をする指標や、Hallucinationを軽減するための既存手法についてまとめられているらしい。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/ec507609-5b6d-42ed-92db-296856f93200" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/General.html">#General</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<span class="issue_date">Issue Date: 2023-09-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1047">RAIN: Your Language Models Can Align Themselves without Finetuning, Yuhui Li+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、追加のデータなしで凍結された大規模言語モデル（LLMs）を整列させる方法を探求しました。自己評価と巻き戻しメカニズムを統合することで、LLMsは自己ブースティングを通じて人間の好みと一致する応答を生成することができることを発見しました。RAINという新しい推論手法を導入し、追加のデータやパラメータの更新を必要とせずにAIの安全性を確保します。実験結果は、RAINの効果を示しており、LLaMA 30Bデータセットでは無害率を向上させ、Vicuna 33Bデータセットでは攻撃成功率を減少させることができました。</span>
<span class="snippet"><span>Comment</span>トークンのsetで構成されるtree上を探索し、出力が無害とself-evaluationされるまで、巻き戻しと前方生成を繰り返し、有害なトークンsetの重みを動的に減らすことでalignmentを実現する。モデルの追加のfinetuning等は不要。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/05bebc0a-325b-423d-ae36-4bc5698063fe" alt="image" loading="lazy">

<br>



<br>

self-evaluationでは下記のようなpromptを利用しているが、このpromptを変更することでこちら側の意図したとおりに出力のアライメントをとることができると思われる。非常に汎用性の高い手法のように見える。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/90070c63-e72d-4b49-bb03-a97dd5baa240" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/StructuredData.html">#StructuredData</a>
<span class="issue_date">Issue Date: 2023-09-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1046">Struc-Bench: Are Large Language Models Really Good at Generating Complex  Structured Data?, Xiangru Tang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）の能力を評価し、構造に注意したファインチューニング手法を提案します。さらに、Struc-Benchというデータセットを使用して、複雑な構造化データ生成のパフォーマンスを評価します。実験の結果、提案手法は他の評価されたLLMsよりも優れた性能を示しました。また、モデルの能力マップを提示し、LLMsの弱点と将来の研究の方向性を示唆しています。詳細はhttps://github.com/gersteinlab/Struc-Benchを参照してください。</span>
<span class="snippet"><span>Comment</span>Formatに関する情報を含むデータでInstruction TuningすることでFormatCoT（フォーマットに関する情報のCoT）を実現している模様。ざっくりしか論文を読んでいないが詳細な情報があまり書かれていない印象で、ちょっとなんともいえない。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/01a23836-b9fb-4d29-891f-d3b01e3e55d2" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<span class="issue_date">Issue Date: 2023-09-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1045">LongLoRA: Efficient Fine-tuning of Long-Context Large Language Models, Yukang Chen+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、計算コストを制限しながら大規模言語モデル（LLMs）のコンテキストサイズを拡張する効率的なファインチューニング手法であるLongLoRAを提案します。従来の方法では、LLMsの長いコンテキストサイズでのトレーニングには高い計算コストとGPUリソースが必要でしたが、提案手法ではコンテキスト拡張を高速化し、非自明な計算コストの削減を実現します。また、パラメータ効率的なファインチューニング手法も再評価し、LongLoRAはさまざまなタスクで強力な実験結果を示しています。さらに、教師ありファインチューニングのためのデータセットであるLongQAも収集されました。</span>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

context長が大きい場合でも効率的にLoRAする手法。通常のLoRAではcontext lengthが大きくなるにつれてperplexityが大きくなってしまう。一方、通常のFinetuningではperplexityは高い性能を維持するが、計算コストとVRAMの消費量が膨大になってしまう。LongLoRAでは、perplexityを通常のFinetuningと同等に抑えつつ、VRAM消費量もLoRAと同等、かつより小さな計算量でFinetuningを実現している。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/fc3d17c7-b1ac-4741-9895-bce70cf0b356" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

手法概要

<br>



<br>

attentionをcontext length全体で計算するとinput長の二乗の計算量がかかるため、contextをいくつかのグループに分割しグループごとにattentionを計算することで計算量削減。さらに、グループ間のattentionの間の依存関係を捉えるために、グループをshiftさせて計算したものと最終的に組み合わせている。また、embedding, normalization layerもtrainableにしている。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/2b443a4c-73da-4610-8ee2-cccdeab21efa" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Quantization.html">#Quantization</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2023-09-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1043">GPTQ: Accurate Post-Training Quantization for Generative Pre-trained   Transformers, Elias Frantar+, N_A, ICLR'23</a>
<span class="snippet"><span>Summary</span>本研究では、GPTモデルの推論における計算およびストレージコストの問題に取り組み、新しいワンショット重み量子化手法であるGPTQを提案します。GPTQは高い精度と効率性を持ち、1750億のパラメータを持つGPTモデルを4時間のGPU時間で量子化することができます。提案手法は従来の手法と比較して圧縮率を2倍以上向上させ、精度を保持することができます。さらに、提案手法は極端な量子化領域でも合理的な精度を提供します。実験結果では、提案手法を使用することでエンドツーエンドの推論速度が約3.25倍から4.5倍向上することが示されています。提案手法の実装はhttps://github.com/IST-DASLab/gptqで利用可能です。</span>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

・新たなpost-training量子化手法であるGPTQを提案

<br>



<br>

・数時間以内に数千億のパラメータを持つモデルでの実行が可能であり、パラメータごとに3～4ビットまで圧縮するが、精度の大きな損失を伴わない

<br>



<br>

    ・OPT-175BおよびBLOOM-176Bを、約4時間のGPU時間で、perplexityのわずかな増加で量子化することができた

<br>



<br>

・数千億のパラメータを持つ非常に高精度な言語モデルを3-4ビットに量子化可能なことを初めて示した

<br>



<br>

    ・先行研究のpost-training手法は、8ビット（Yao et al., 2022; Dettmers et al., 2022）。

<br>



<br>

    ・一方、以前のtraining-basedの手法は、1～2桁小さいモデルのみを対象としていた（Wu et al., 2022）。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/4ff107a9-7ccf-40f6-ad8c-fd910b1f0ac7" alt="image" loading="lazy">

<br>



<br>

Background

<br>



<br>

Layer-wise quantization

<br>



<br>

各linear layerがあるときに、full precisionのoutputを少量のデータセットをネットワークに流したときに、quantized weight W^barを用いてreconstructできるように、squared error lossを最小化する方法。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/9950fec1-966b-45c4-a82a-6bfd533042b3" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Optimal Brain quantization (OBQ)

<br>



<br>

OBQでは equation (1)をWの行に関するsummationとみなす。そして、それぞれの行 w をOBQは独立に扱い、ある一つの重みw_qをquantizeするときに、エラーがw_qのみに基づいていることを補償するために他のwの全てのquantizedされていない重みをupdateする。式で表すと下記のようになり、Fは残りのfull-precision weightの集合を表している。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/aab7784d-45f3-4f23-ac74-6cc4c2026486" alt="image" loading="lazy">

<br>



<br>

この二つの式を、全てのwの重みがquantizedされるまで繰り返し適用する。

<br>



<br>



<br>



<br>

つまり、ある一個の重みをquantizedしたことによる誤差を補うように、他のまだquantizedされていない重みをupdateすることで、次に別の重みをquantizedする際は、最初の重みがquantizedされたことを考慮した重みに対してquantizedすることになる。これを繰り返すことで、quantizedしたことによる誤差を考慮してw全体をアップデートできる、という気持ちだと思う。

<br>



<br>



<br>



<br>

この式は高速に計算することができ、medium sizeのモデル（25M parameters; ResNet-50 modelなど）とかであれば、single GPUで1時間でquantizeできる。しかしながら、OBQはO(d_row  d_col^3)であるため、（ここでd_rowはWの行数、d_colはwの列数）、billions of parametersに適用するには計算量が多すぎる。Algorithm

<br>



<br>

Step 1: Arbitrary Order Insight.

<br>



<br>

通常のOBQは、量子化誤差が最も少ない重みを常に選択して、greedyに重みを更新していく。しかし、パラメータ数が大きなモデルになると、重みを任意の順序で量子化したとしてもそれによる影響は小さいと考えられる。なぜなら、おそらく、大きな個別の誤差を持つ量子化された重みの数が少ないと考えられ、その重みがプロセスのが進むにつれて（アップデートされることで？）相殺されるため。

<br>



<br>



<br>



<br>

このため、提案手法は、すべての行の重みを同じ順序で量子化することを目指し、これが通常、最終的な二乗誤差が元の解と同じ結果となることを示す。が、このために2つの課題を乗り越えなければならない。

<br>



<br>



<br>



<br>

Step2. Lazy Batch-Updates

<br>



<br>

Fを更新するときは、各エントリに対してわずかなFLOPを使用して、巨大な行列のすべての要素を更新する必要があります。しかし、このような操作は、現代のGPUの大規模な計算能力を適切に活用することができず、非常に小さいメモリ帯域幅によってボトルネックとなる。

<br>



<br>



<br>



<br>

幸いにも、この問題は以下の観察によって解決できる：列iの最終的な四捨五入の決定は、この特定の列で行われた更新にのみ影響され、そのプロセスの時点で後の列への更新は関連がない。これにより、更新を「lazy batch」としてまとめることができ、はるかに効率的なGPUの利用が可能となる。（要は独立して計算できる部分は全部一気に計算してしまって、後で一気にアップデートしますということ）。たとえば、B = 128の列にアルゴリズムを適用し、更新をこれらの列と対応するB × Bブロックの H^-1 に格納する。

<br>



<br>

この戦略は理論的な計算量を削減しないものの、メモリスループットのボトルネックを改善する。これにより、非常に大きなモデルの場合には実際に1桁以上の高速化が提供される。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/fcb33c4d-3924-4abd-b149-936b9e350c76" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Step 3: Cholesky Reformulation

<br>



<br>

行列H_F^-1が不定になることがあり、これがアルゴリズムが残りの重みを誤った方向に更新する原因となり、該当する層に対して悪い量子化を実施してしまうことがある。この現象が発生する確率はモデルのサイズとともに増加することが実際に観察された。これを解決するために、コレスキー分解を活用して解決している（詳細はきちんと読んでいない）。実験で用いたCalibration data

<br>



<br>

GPTQのキャリブレーションデータ全体は、C4データセット(Raffel et al., 2020)からのランダムな2048トークンのセグメント128個で構成される。つまり、ランダムにクロールされたウェブサイトからの抜粋で、一般的なテキストデータを表している。GPTQがタスク固有のデータを一切見ていないため「ゼロショット」な設定でquantizationを実施している。

<br>



<br>



<br>



<br>

Language Generationでの評価

<br>



<br>

WikiText2に対するPerplexityで評価した結果、先行研究であるRTNを大幅にoutperformした。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/23e12194-d329-46f7-bb69-2cce290282c1" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-09-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1041">From Sparse to Dense: GPT-4 Summarization with Chain of Density  Prompting, Griffin Adams+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>要約は詳細でエンティティ中心的でありながら、理解しやすくすることが困難です。この課題を解決するために、私たちは「密度の連鎖」（CoD）プロンプトを使用して、GPT-4の要約を生成します。CoDによって生成された要約は抽象的であり、リードバイアスが少なく、人間に好まれます。また、情報量と読みやすさのトレードオフが存在することも示されました。CoD要約は無料で利用できます。</span>
<span class="snippet"><span>Comment</span>論文中のprompt例。InformativeなEntityのCoverageを増やすようにイテレーションを回し、各Entityに関する情報（前ステップで不足している情報は補足しながら）を具体的に記述するように要約を生成する。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/c24ab8c0-06fa-49ea-9df7-f248ec18ba45" alt="image" loading="lazy">

<br>



<br>

人間が好むEntityのDensityにはある程度の閾値がある模様（でもこれは人や用途によって閾値が違うようねとは思う）。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/d63c21e9-9179-4f8c-925f-ed435ecb1717" alt="image" loading="lazy">

<br>



<br>

人手評価とGPT4による5-scale の評価を実施している。定性的な考察としては、主題と直接的に関係ないEntityの詳細を述べるようになっても人間には好まれない（右例）ことが述べられている。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/900695ca-fbad-4d58-9388-2d2f86644e48" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/d3b3afe2-15fa-4b40-95cb-51aa0f27d6db" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<span class="issue_date">Issue Date: 2023-09-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1040">DoLa: Decoding by Contrasting Layers Improves Factuality in Large  Language Models, Yung-Sung Chuang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>我々は、事前学習済みの大規模言語モデル（LLMs）における幻覚を軽減するためのシンプルなデコーディング戦略を提案する。このアプローチは、ロジットの差異を対比することで次のトークンの分布を得るもので、事実知識をより明確に示し、誤った事実の生成を減らすことができる。このアプローチは、複数の選択課題やオープンエンドの生成課題において真実性を向上させることができることが示されている。</span>
<span class="snippet"><span>Comment</span>【以下、WIP状態の論文を読んでいるため今後内容が変化する可能性あり】

<br>



<br>

概要

<br>



<br>

Transformer Layerにおいて、factual informationが特定のレイヤーに局所化するという現象を観測しており、それを活用しよりFactual Consistencyのある生成をします、という研究

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/eb8dbecb-21cb-4abb-879c-5a8f39364e6a" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

あるテキストを生成するときの単語の生成確率の分布を可視化。final layer (N=32だと思われる)との間のJensen-shanon Divergence (JSD) で可視化している。が、図を見るとJSDの値域は[0, 1]のはずなのにこれを逸脱しているので一体どういう計算をしているのか。。。

<br>



<br>

図の説明としては論文中では2つのパターンがあると言及しており

<br>



<br>

1. 重要な固有表現や日付（Wole Soyinka, 1986など; Factual Knowledgeが必要なもの）は、higher layerでも高い値となっており、higher-layerにおいてpredictionの内容を変えている（重要な情報がここでinjectionされている）

<br>



<br>

2. 機能語や、questionからの単語のコピー（Nigerian, Nobel Prize など）のような "easy" なtokenは既にmiddle of layersで既にJSDの値が小さく、early layerの時点で出力することが既に決定されている

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/daed79c1-1391-43ad-a94e-a6748ec3529f" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

手法概要

<br>



<br>

ここからの考察としては、重要な事実に関する情報はfinal layerの方で分布が変化する傾向にあり、低layerの方ではそうではないぽいので、final layerと分布が似ているがFactual Informationがまだあまり顕著に生成確率が高くなっていないlayer（pre mature layer）との対比をとることで、生成されるべきFactual Informationがわかるのではないか、という前提の元提案手法が組まれている。手法としては、final layerとのJSDが最大となるようなlayerを一つ選択する、というものになっているが、果たしてこの選択方法で前述の気持ちが実現できているのか？という気は少しする。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/0c4973a0-baee-4de3-82fa-55aba12f9c73" alt="image" loading="lazy"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-09-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1039">Textbooks Are All You Need II: phi-1.5 technical report, Yuanzhi Li+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>私たちは、小さなTransformerベースの言語モデルであるTinyStoriesと、大規模な言語モデルであるphi-1の能力について調査しました。また、phi-1を使用して教科書の品質のデータを生成し、学習プロセスを改善する方法を提案しました。さらに、phi-1.5という新しいモデルを作成し、自然言語のタスクにおいて性能が向上し、複雑な推論タスクにおいて他のモデルを上回ることを示しました。phi-1.5は、良い特性と悪い特性を持っており、オープンソース化されています。</span>
<span class="snippet"><span>Comment</span>766 に続く論文</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Sycophancy.html">#Sycophancy</a>
<span class="issue_date">Issue Date: 2023-09-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1038">Simple synthetic data reduces sycophancy in large language models, Jerry Wei+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、機械学習モデルのおべっか行動を減らすための方法を提案しています。まず、言語モデルにおけるおべっか行動の普及度を調査し、その行動を減らすための合成データ介入を提案しています。具体的には、ユーザーの意見に対してモデルが頑健であることを促す合成データを使用し、モデルのファインチューニングを行います。これにより、おべっか行動を大幅に減らすことができます。提案手法の詳細は、https://github.com/google/sycophancy-intervention で確認できます。</span>
<span class="snippet"><span>Comment</span>LLMはユーザの好む回答をするように事前学習されるため、prompt中にユーザの意見が含まれていると、ユーザの意見に引っ張られ仮に不正解でもユーザの好む回答をしてしまう問題があることを示した。また、その対策として人工的にユーザの意見と、claimを独立させるように学習するためのデータセットを生成しFinetuningすることで防ぐことができることを示した。誤ったユーザの意見を挿入すると、正解できていた問題でも不正解になることを示した。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/43c03357-5c5c-4ceb-a089-0ad0a35eea1d" alt="image" loading="lazy">この傾向は、instruction tuningしている場合、モデルサイズが大きい場合により顕著であることを示した。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/6737eb30-7055-43d6-a1f4-d700be5963f2" alt="image" loading="lazy"><img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/54458bc0-ba89-4b10-b6c1-baa70384abb9" alt="image" loading="lazy"><img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/7690e3b4-00e7-468a-a36f-7130f65669dc" alt="image" loading="lazy"></span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/AutomaticPromptEngineering.html">#AutomaticPromptEngineering</a>
<span class="issue_date">Issue Date: 2023-09-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1037">Large Language Models as Optimizers, Chengrun Yang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、最適化タスクを自然言語で記述し、大規模言語モデル（LLMs）を使用して最適化を行う手法「Optimization by PROmpting（OPRO）」を提案しています。この手法では、LLMが以前の解とその値を含むプロンプトから新しい解を生成し、評価して次の最適化ステップのためのプロンプトに追加します。実験結果では、OPROによって最適化された最良のプロンプトが、人間が設計したプロンプトよりも優れていることが示されました。</span>
<span class="snippet"><span>Comment</span>`Take a deep breath and work on this problem step-by-step. `論文

<br>



<br>



<br>



<br>

概要

<br>



<br>

LLMを利用して最適化問題を解くためのフレームワークを提案したという話。論文中では、linear regressionや巡回セールスマン問題に適用している。また、応用例としてPrompt Engineeringに利用している。

<br>



<br>

これにより、Prompt Engineeringが最適か問題に落とし込まれ、自動的なprompt engineeringによって、`Let's think step by step.` よりも良いプロンプトが見つかりましたという話。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/2a469085-8a14-4eac-85ee-3918fe1becd5" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

手法概要

<br>



<br>

全体としての枠組み。meta-promptをinputとし、LLMがobjective functionに対するsolutionを生成する。生成されたsolutionとスコアがmeta-promptに代入され、次のoptimizationが走る。これを繰り返す。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/3e34ed47-5cbe-4cb0-b25a-8ee939e780e3" alt="image" loading="lazy">

<br>



<br>

Meta promptの例

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/a0dd261e-0dcd-487a-bfac-89db243e0b1c" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/AutomaticPromptEngineering.html">#AutomaticPromptEngineering</a>
<span class="issue_date">Issue Date: 2023-09-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1034">Large Language Models Are Human-Level Prompt Engineers, Yongchao Zhou+, ICLR'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）は、自然言語の指示に基づいて一般的な用途のコンピュータとして優れた能力を持っています。しかし、モデルのパフォーマンスは、使用されるプロンプトの品質に大きく依存します。この研究では、自動プロンプトエンジニア（APE）を提案し、LLMによって生成された指示候補のプールから最適な指示を選択するために最適化します。実験結果は、APEが従来のLLMベースラインを上回り、19/24のタスクで人間の生成した指示と同等または優れたパフォーマンスを示しています。APEエンジニアリングされたプロンプトは、モデルの性能を向上させるだけでなく、フューショット学習のパフォーマンスも向上させることができます。詳細は、https://sites.google.com/view/automatic-prompt-engineerをご覧ください。</span>
<span class="snippet"><span>Comment</span>プロジェクトサイト: https://sites.google.com/view/automatic-prompt-engineer</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-09-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1030">Algorithm of Thoughts: Enhancing Exploration of Ideas in Large Language  Models, Bilgehan Sel+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）の推論能力を向上させるために、新しい戦略「Algorithm of Thoughts」を提案している。この戦略では、LLMsをアルゴリズム的な推論経路に導き、わずか1つまたは数個のクエリでアイデアの探索を拡大する。この手法は、以前の単一クエリ手法を上回り、マルチクエリ戦略と同等の性能を発揮する。また、LLMを指導するアルゴリズムを使用することで、アルゴリズム自体を上回るパフォーマンスが得られる可能性があり、LLMが最適化された検索に自己の直感を織り込む能力を持っていることを示唆している。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2023-09-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1028">A Survey on Large Language Model based Autonomous Agents, Lei Wang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>自律エージェントの研究は、以前は限られた知識を持つエージェントに焦点を当てていましたが、最近では大規模言語モデル（LLMs）を活用した研究が増えています。本論文では、LLMに基づく自律エージェントの研究を包括的に調査し、統一されたフレームワークを提案します。さらに、LLMに基づくAIエージェントの応用や評価戦略についてもまとめています。将来の方向性や課題についても議論し、関連する参考文献のリポジトリも提供しています。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/c921a960-02f7-44e6-8c24-bb578f599bbe" alt="image" loading="lazy">

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/73c4662b-ca74-41cc-8be5-c76c4aad36c8" alt="image" loading="lazy">良いサーベイ</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/DataAugmentation.html">#DataAugmentation</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/DataGeneration.html">#DataGeneration</a>
<span class="issue_date">Issue Date: 2023-08-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1024">Prompt2Model: Generating Deployable Models from Natural Language   Instructions, Vijay Viswanathan+, N_A, EMNLP'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）を使用して、プロンプトを自然言語でタスクを説明し、特定のモデルを訓練する手法であるPrompt2Modelを提案しています。Prompt2Modelは、既存のデータセットと事前学習済みモデルの検索、LLMsを使用したデータセットの生成、および教師あり微調整のプロセスを通じて行われます。実験結果では、Prompt2Modelが強力なLLMを上回る性能を示し、モデルの信頼性の評価も可能であることが示されています。Prompt2Modelはオープンソースで利用可能です。</span>
<span class="snippet"><span>Comment</span>Dataset Generatorによって、アノテーションが存在しないデータについても擬似ラベル付きデータを生成することができ、かつそれを既存のラベル付きデータと組み合わせることによってさらに性能が向上することが報告されている。これができるのはとても素晴らしい。Dataset Generatorについては、データを作成する際に低コストで、高品質で、多様なデータとするためにいくつかの工夫を実施している。

<br>

1. ユーザが与えたデモンストレーションだけでなく、システムが生成したexampleもサンプリングして活用することで、生成されるexampleの多様性を向上させる。実際、これをやらない場合は120/200がduplicate exampleであったが、これが25/200まで減少した。

<br>

2. 生成したサンプルの数に比例して、temperatureを徐々に高くしていく。これにより、サンプルの質を担保しつつ、多様性を徐々に増加させることができる。Temperature Annealingと呼ぶ。

<br>

3. self-consistencyを用いて、擬似ラベルの質を高める。もしmajority votingが互角の場合は、回答が短いものを採用した（これはヒューリスティックに基づいている）

<br>

4. zeno buildを用いてAPIへのリクエストを並列化することで高速に実験を実施

<br>



<br>

非常に参考になる。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Bias.html">#Bias</a>
<span class="issue_date">Issue Date: 2023-08-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1023">Large Language Models Sensitivity to The Order of Options in  Multiple-Choice Questions, Pouya Pezeshkpour+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）の頑健性に焦点を当てています。LLMsは多肢選択問題において順序に敏感であり、オプションの配置によって性能に大きな差が生じることを示しました。さらに、オプションの配置に対するバイアスを増幅または軽減する方法を特定し、LLMsの予測を改善するアプローチを提案しました。実験により、最大8パーセントポイントの改善が実現されました。</span>
<span class="snippet"><span>Comment</span>これはそうだろうなと思っていたけど、ここまで性能に差が出るとは思わなかった。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/fb13c25c-4d76-4c8c-b08a-6491c43f34b9" alt="image" loading="lazy">これがもしLLMのバイアスによるもの（2番目の選択肢に正解が多い）の場合、

<br>

ランダムにソートしたり、平均取ったりしても、そもそもの正解に常にバイアスがかかっているので、

<br>

結局バイアスがかかった結果しか出ないのでは、と思ってしまう。

<br>

そうなると、有効なのはone vs. restみたいに、全部該当選択肢に対してyes/noで答えさせてそれを集約させる、みたいなアプローチの方が良いかもしれない。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-08-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1020">AgentBench: Evaluating LLMs as Agents, Xiao Liu+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）をエージェントとして評価するための多次元の進化するベンチマーク「AgentBench」を提案しています。AgentBenchは、8つの異なる環境でマルチターンのオープンエンドの生成設定を提供し、LLMの推論と意思決定能力を評価します。25のLLMsに対するテストでは、商用LLMsは強力な能力を示していますが、オープンソースの競合他社との性能には差があります。AgentBenchのデータセット、環境、および評価パッケージは、GitHubで公開されています。</span>
<span class="snippet"><span>Comment</span>エージェントとしてのLLMの推論能力と意思決定能力を評価するためのベンチマークを提案。

<br>

トップの商用LLMとOpenSource LLMの間に大きな性能差があることを示した。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-08-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1015">Large Language Model Guided Tree-of-Thought, Jieyi Long, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>この論文では、Tree-of-Thought（ToT）フレームワークを紹介し、自己回帰型の大規模言語モデル（LLM）の問題解決能力を向上させる新しいアプローチを提案しています。ToTは、人間の思考方法に触発された技術であり、複雑な推論タスクを解決するためにツリー状の思考プロセスを使用します。提案手法は、LLMにプロンプターエージェント、チェッカーモジュール、メモリモジュール、およびToTコントローラーなどの追加モジュールを組み込むことで実現されます。実験結果は、ToTフレームワークがSudokuパズルの解決成功率を大幅に向上させることを示しています。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-08-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1013">Decomposition Enhances Reasoning via Self-Evaluation Guided Decoding, Yuxi Xie+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>私たちは、大規模言語モデル（LLMs）を使用して、推論の品質と多様性を向上させるための効果的なプロンプティングアプローチを提案しました。自己評価によるガイド付き確率的ビームサーチを使用して、GSM8K、AQuA、およびStrategyQAのベンチマークで高い精度を達成しました。また、論理の失敗を特定し、一貫性と堅牢性を向上させることもできました。詳細なコードはGitHubで公開されています。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/8bd4a19e-e7e6-444f-9394-36e261e5219a" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-08-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1012">Graph of Thoughts: Solving Elaborate Problems with Large Language Models, Maciej Besta+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>私たちは、Graph of Thoughts（GoT）というフレームワークを紹介しました。これは、大規模言語モデル（LLMs）のプロンプティング能力を進化させるもので、任意のグラフとしてモデル化できることが特徴です。GoTは、思考の組み合わせやネットワーク全体の本質の抽出、思考の強化などを可能にします。さまざまなタスクで最先端の手法に比べて利点を提供し、LLMの推論を人間の思考に近づけることができます。</span>
<span class="snippet"><span>Comment</span>Chain of Thought 551 

<br>



<br>

=&gt; Self-consistency 558 

<br>



<br>

=&gt; Thought Decomposition 1013 

<br>



<br>

=&gt; Tree of Thoughts 684 Tree of Thought 1015 

<br>



<br>

=&gt; Graph of Thought</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-08-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1010">Consciousness in Artificial Intelligence: Insights from the Science of  Consciousness, Patrick Butlin+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>AIの意識についての厳密なアプローチを提案し、既存のAIシステムを神経科学的な意識理論に基づいて評価する。意識の指標的特性を導き出し、最近のAIシステムを評価することで、現在のAIシステムは意識的ではないが、意識的なAIシステムを構築するための障壁は存在しないことを示唆する。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<span class="issue_date">Issue Date: 2023-08-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1008">Self-Alignment with Instruction Backtranslation, Xian Li+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>私たちは、高品質な指示に従う言語モデルを構築するためのスケーラブルな手法を提案します。この手法では、少量のシードデータとウェブコーパスを使用して言語モデルをファインチューニングし、指示のプロンプトを生成してトレーニング例を構築します。そして、高品質な例を選択してモデルを強化します。この手法を使用すると、他のモデルよりも優れた性能を発揮し、自己整列の効果を実証できます。</span>
<span class="snippet"><span>Comment</span>人間が書いたテキストを対応するinstructionに自動的にラベル付けする手法を提案。

<br>

これにより高品質なinstruction following LLMの構築が可能手法概要

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/837e17cc-6df1-4ba5-ba61-9c4f72dede93" alt="image" loading="lazy">結果的に得られるデータは、訓練において非常にインパクトがあり高品質なものとなる。

<br>

実際に、他の同サイズのinstruct tuningデータセットを上回る。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/ef478922-8495-4a5f-9bc6-3d5bed7195a8" alt="image" loading="lazy">Humpackは他のstrong modelからdistillされていないモデルの中で最高性能を達成。これは、スケールアップしたり、より強いベースモデルを使うなどさらなる性能向上ができる余地が残されている。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/cd7ff8b5-62a4-46fe-a902-cbe8e9ffec4a" alt="image" loading="lazy">参考: https://x.com/hillbig/status/1694103441432580377?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

指示を予測するモデルは、今回はLLaMAをfinetuningしたモデルを用いており、予測と呼称しているが指示はgenerationされる。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/PersonalizedGeneration.html">#PersonalizedGeneration</a>
<span class="issue_date">Issue Date: 2023-08-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1005">Teach LLMs to Personalize -- An Approach inspired by Writing Education, Cheng Li+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>個別化されたテキスト生成において、大規模言語モデル（LLMs）を使用した一般的なアプローチを提案する。教育の執筆をベースに、多段階かつマルチタスクのフレームワークを開発し、検索、ランキング、要約、統合、生成のステージで構成される個別化されたテキスト生成へのアプローチを採用する。さらに、マルチタスク設定を導入してモデルの生成能力を向上させる。3つの公開データセットでの評価結果は、他のベースラインに比べて大幅な改善を示している。</span>
<span class="snippet"><span>Comment</span>研究の目的としては、ユーザが現在執筆しているdocumentのwriting支援</span>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/SpeechProcessing.html">#SpeechProcessing</a>
<span class="issue_date">Issue Date: 2023-08-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1001">ReazonSpeech: A Free and Massive Corpus for Japanese ASR, Yin+, NLP'23</a>
<span class="snippet"><span>Comment</span>超高精度で商用利用可能な純国産の日本語音声認識モデル「ReazonSpeech」を無償公開

<br>



<br>

ワンセグのデータにから生成ライブラリ:

<br>

https://x.com/sloth65557166/status/1952942596055314450?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/LM-based.html">#LM-based</a>
<a class="button" href="articles/Coherence.html">#Coherence</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/967">DiscoScore: Evaluating Text Generation with BERT and Discourse Coherence, Wei Zhao+, N_A, EACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、文章の一貫性を評価するための新しい指標であるDiscoScoreを紹介します。DiscoScoreはCentering理論に基づいており、BERTを使用して談話の一貫性をモデル化します。実験の結果、DiscoScoreは他の指標よりも人間の評価との相関が高く、システムレベルでの評価でも優れた結果を示しました。さらに、DiscoScoreの重要性とその優位性についても説明されています。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-free.html">#Reference-free</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/937">RISE: Leveraging Retrieval Techniques for Summarization Evaluation, David Uthus+, N_A, Findings of ACL'23</a>
<span class="snippet"><span>Summary</span>自動要約の評価は困難であり、従来のアプローチでは人間の評価には及ばない。そこで、私たちはRISEという新しいアプローチを提案する。RISEは情報検索の技術を活用し、ゴールドリファレンスの要約がなくても要約を評価することができる。RISEは特に評価用のリファレンス要約が利用できない新しいデータセットに適しており、SummEvalベンチマークでの実験結果から、RISEは過去のアプローチと比較して人間の評価と高い相関を示している。また、RISEはデータ効率性と言語間の汎用性も示している。</span>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

Dual-Encoderを用いて、ソースドキュメントとシステム要約をエンコードし、dot productをとることでスコアを得る手法。モデルの訓練は、Contrastive Learningで行い、既存データセットのソースと参照要約のペアを正例とみなし、In Batch trainingする。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/95d6fc9e-cb05-4a40-9690-ac40e6042c3c" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

分類

<br>



<br>

Reference-free, Model-based, ソース依存で、BARTScore 960 とは異なり、文書要約データを用いて学習するため、要約の評価に特化している点が特徴。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/281a2e5d-7e1c-466d-a995-97218ca37983" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

モデル

<br>



<br>

 Contrastive Learning

<br>



<br>

Contrastive Learningを用い、hard negativeを用いたvariantも検証する。また、訓練データとして3種類のパターンを検証する：

<br>



<br>

1. in-domain data: 文書要約データを用いて訓練し、ターゲットタスクでどれだけの性能を発揮するかを見る

<br>



<br>

2. out-of-domain data: 文書要約以外のデータを用いて訓練し、どれだけ新しいドメインにモデルがtransferできるかを検証する

<br>



<br>

3. in-and-out-domain data: 両方やる

<br>



<br>



<br>



<br>

ハードネガティブの生成

<br>



<br>

Lexical Negatives, Model Negatives, 双方の組み合わせの3種類を用いてハードネガティブを生成する。

<br>



<br>

Lexical Negatives

<br>



<br>

参照要約を拡張することによって生成する。目的は、もともとの参照要約と比較して、poor summaryを生成することにある。Data Augmentationとして、以下の方法を試した：

<br>



<br>

・Swapping noun entities:  要約中のエンティティを、ソース中のエンティティンとランダムでスワップ

<br>



<br>

・Shuffling words: 要約中の単語をランダムにシャッフル

<br>



<br>

・Dropping words: 要約中の単語をランダムに削除

<br>



<br>

・Dropping characters: 要約中の文字をランダムに削除

<br>



<br>

・Swapping antonyms: 要約中の単語を対義語で置換

<br>



<br>

Model Negatives

<br>



<br>

データセットの中から負例を抽出する。目的は、参照要約と類似しているが、負例となるサンプルを見つけること。これを実現するために、まずRISE modelをデータセットでfinetuningし、それぞれのソースドキュメントの要約に対して、類似した要約をマイニングする。すべてのドキュメントと要約をエンコードし、top-nの最も類似した要約を見つけ、これをハードネガティブとして、再度モデルを訓練する。

<br>



<br>

両者の組み合わせ

<br>



<br>

まずlexical negativesでモデルを訓練し、モデルネガティブの抽出に活用する。抽出したモデルネガティブを用いて再度モデルを訓練することで、最終的なモデルとする。

<br>



<br>



<br>



<br>

実験

<br>



<br>

学習手法

<br>



<br>

SummEval 984 を用いて人手評価と比較してどれだけcorrelationがあるかを検証。SummEvalには16種類のモデルのアウトプットに対する、CNN / Daily Mail の100 examplesに対して、品質のアノテーションが付与されている。expert annotationを用いて、Kendall's tauを用いてシステムレベルのcorrelationを計算した。contextが短い場合はT5, 長い場合はLongT5, タスクがマルチリンガルな場合はmT5を用いて訓練した。訓練データとしては

<br>



<br>

・CNN / Daily Mail

<br>



<br>

・Multi News

<br>



<br>

・arXiv

<br>



<br>

・PubMed

<br>



<br>

・BigPatent

<br>



<br>

・SAMSum

<br>



<br>

・Reddit TIFU

<br>



<br>

・MLSUM

<br>



<br>

等を用いた。これによりshort / long contextの両者をカバーできる。CNN / Daily Mail, Reddiit TIFU, Multi-Newsはshort-context, arXiv, PubMed, BigPatent, Multi-News（長文のものを利用）はlonger contextとして利用する。

<br>



<br>

比較するメトリック

<br>



<br>

ROUGE, chrF, SMS, BARTScore, SMART, BLEURT, BERTScore, Q^2, T5-ANLI, PRISMと比較した。結果をみると、Consistency, Fluency, Relevanceで他手法よりも高い相関を得た。Averageでは最も高いAverageを獲得した。in-domain dataで訓練した場合は、高い性能を発揮した。our-of-domain（SAMSum; Dialogue要約のデータ）データでも高い性能を得た。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/92960d58-cd13-4ff5-a417-dda9785520e4" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Ablation

<br>



<br>

ハードネガティブの生成方法

<br>



<br>

Data Augmentationは、swapping entity nouns, randomly dropping wordsの組み合わせが最も良かった。また、Lexical Negativesは、様々なデータセットで一貫して性能が良かったが、Model NegativesはCNN/DailyMailに対してしか有効ではなかった。これはおそらく、同じタスク（テストデータと同じデータ）でないと、Model Negativesは機能しないことを示唆している。ただし、Model Negativesを入れたら、何もしないよりも性能向上するから、何らかの理由でlexical negativesが生成できない場合はこっち使っても有用である。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/ebb9a6b9-3293-4139-b8a3-620cd72fff5a" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Model Size

<br>



<br>

でかい方が良い。in-domainならBaseでもそれなりの性能だけど、結局LARGEの方が強い。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/a53e9b98-77aa-4faf-ba58-4900611ca066" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Datasets

<br>



<br>

異なるデータセットでもtransferがうまく機能している。驚いたことにデータセットをmixingするとあまりうまくいかず、単体のデータセットで訓練したほうが性能が良い。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/635c0b43-2db3-4561-8939-e4b1de733e99" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

LongT5を見ると、T5よりもCorrelationが低く難易度が高い。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/31420a09-eb36-41ef-ad41-6eaf93d1823d" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

最終的に英語の要約を評価をする場合でも、Multilingual（別言語）で訓練しても高いCorrelationを示すこともわかった。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/a74d86b8-64bd-40b1-b22b-344588ef0580" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Dataset Size

<br>



<br>

サンプル数が小さくても有効に働く。しかし、out-domainのデータの場合は、たとえば、512件の場合は性能が低く少しexampleを増やさなければならない。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/3117b6aa-5d0f-4970-9f30-247633d21f67" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/935">GPTScore: Evaluate as You Desire, Jinlan Fu+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、生成型AIの評価における課題を解決するために、GPTScoreという評価フレームワークを提案しています。GPTScoreは、生成されたテキストを評価するために、生成型事前学習モデルの新たな能力を活用しています。19の事前学習モデルを探索し、4つのテキスト生成タスクと22の評価項目に対して実験を行いました。結果は、GPTScoreが自然言語の指示だけでテキストの評価を効果的に実現できることを示しています。この評価フレームワークは、注釈付きサンプルの必要性をなくし、カスタマイズされた多面的な評価を実現することができます。</span>
<span class="snippet"><span>Comment</span>BERTScoreと同様、評価したいテキストの対数尤度で評価している

<br>

BERTScoreよりも相関が高く、instructionによって性能が向上することが示されている</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/934">Large Language Models are Diverse Role-Players for Summarization  Evaluation, Ning Wu+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、テキスト要約の評価フレームワークを提案し、生成されたテキストと参照テキストを客観的および主観的な側面から比較することで包括的な評価を行います。具体的には、ロールプレイヤーのプロンプティングメカニズムを使用してテキストの評価をモデル化し、コンテキストベースのプロンプティングメカニズムを導入して動的なロールプレイヤープロファイルを生成します。さらに、バッチプロンプティングに基づいたマルチロールプレイヤープロンプティング技術を使用して複数の評価結果を統合します。実験結果は、提案モデルが競争力があり、人間の評価者と高い一致性を持つことを示しています。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/933">ChatGPT as a Factual Inconsistency Evaluator for Text Summarization, Zheheng Luo+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>事前学習された言語モデルによるテキスト要約の性能向上が注目されているが、生成された要約が元の文書と矛盾することが問題となっている。この問題を解決するために、効果的な事実性評価メトリクスの開発が進められているが、計算複雑性や不確実性の制約があり、人間の判断との一致に限定されている。最近の研究では、大規模言語モデル（LLMs）がテキスト生成と言語理解の両方で優れた性能を示していることがわかっている。本研究では、ChatGPTの事実的な矛盾評価能力を評価し、バイナリエンテイルメント推論、要約ランキング、一貫性評価などのタスクで優れた性能を示した。ただし、ChatGPTには語彙的な類似性の傾向や誤った推論、指示の不適切な理解などの制限があることがわかった。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-08-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/931">Metacognitive Prompting Improves Understanding in Large Language Models, Yuqing Wang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、LLMsにメタ認知プロンプト（MP）を導入し、人間の内省的な推論プロセスを模倣することで、理解能力を向上させることを目指しています。実験結果は、MPを備えたPaLMが他のモデルに比べて優れたパフォーマンスを示しており、MPが既存のプロンプト手法を上回ることを示しています。この研究は、LLMsの理解能力向上の可能性を示し、人間の内省的な推論を模倣することの利点を強調しています。</span>
<span class="snippet"><span>Comment</span>CoTより一貫して性能が高いので次のデファクトになる可能性あり

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/8ca3a369-925b-44be-9d63-e3150137ff6b" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/d3b980e0-4402-4a32-96ee-684da7f3a487" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/AutoML.html">#AutoML</a>
<span class="issue_date">Issue Date: 2023-08-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/926">MLCopilot: Unleashing the Power of Large Language Models in Solving  Machine Learning Tasks, Lei Zhang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、機械学習タスクの自動化における人間の知識と機械知能のギャップを埋めるために、新しいフレームワークMLCopilotを提案する。このフレームワークは、最先端のLLMsを使用して新しいMLタスクのソリューションを開発し、既存のMLタスクの経験から学び、効果的に推論して有望な結果を提供することができる。生成されたソリューションは直接使用して競争力のある結果を得ることができる。</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<span class="issue_date">Issue Date: 2023-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/923">The Hydra Effect: Emergent Self-repair in Language Model Computations, Thomas McGrath+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>私たちは、言語モデルの内部構造を調査し、言語モデルの計算における特定の効果を示しました。具体的には、1つの層の削除が他の層によって補完される「Hydra効果」と、遅いMLP層が最大尤度トークンを制御する役割を持つことを示しました。また、ドロップアウトを使用しない言語モデルでも同様の効果が見られることを示しました。これらの効果を事実の回想の文脈で分析し、言語モデルの回路レベルの属性付与について考察しました。</span>
<span class="snippet"><span>Comment</span>LLMからattention layerを一つ取り除くと、後続の層が取り除かれたlayerの機能を引き継ぐような働きをすることがわかった。これはLLMの自己修復機能のようなものであり、HydraEffectと命名された。</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/922">MetaGPT: Meta Programming for Multi-Agent Collaborative Framework, Sirui Hong+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）を使用したマルチエージェントの自動タスク解決における進歩について調査しました。既存の研究では単純なタスクに焦点を当てており、複雑なタスクにおける探索や調査が不足していることがわかりました。そこで、MetaGPTという革新的なフレームワークを提案しました。MetaGPTは、人間のワークフローをLLMに組み込むことで、マルチエージェントの協力を効果的に支援します。実験結果から、MetaGPTが既存のシステムに比べてより高い結束性を持つ解決策を生成することが示されました。これは、マルチエージェントに人間のドメイン知識を組み込むことの潜在能力を示し、新しいアプローチの可能性を開拓するものです。</span>
<span class="snippet"><span>Comment</span>要はBabyTalk, AutoGPTの進化系で、人間のワークフローを模倣するようにデザインしたら良くなりました、という話と思われる

<br>



<br>

ソフトウェアエンジニア、アーキテクト、プロダクトオーナー、プロジェクトマネージャーなどのロールを明示的に与えて、ゴールを目指す。もはやLLM内部でソフトウェア企業を模倣しているのと同様である。</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/921">Skeleton-of-Thought: Large Language Models Can Do Parallel Decoding, Xuefei Ning+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>この研究では、大規模言語モデル（LLMs）の生成遅延を減らすために、思考の骨組み（SoT）という手法を提案しています。SoTは、回答の骨組みをまず生成し、その後に内容を並列で処理することで高速化を実現します。また、回答品質の向上も期待されます。SoTはデータ中心の最適化の初めの試みであり、LLMsの人間らしい思考を可能にする可能性があります。</span>
<span class="snippet"><span>Comment</span>最初に回答の枠組みだけ生成して、それぞれの内容を並列で出力させることでデコーディングを高速化しましょう、という話。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/fb25d8ba-dff7-4f6f-be25-0973488f6e8a" alt="image" loading="lazy"></span>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/920">ToolLLM: Facilitating Large Language Models to Master 16000+ Real-world  APIs, Yujia Qin+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>オープンソースの大規模言語モデル（LLMs）を使用して、外部ツール（API）の高度なタスクの実行を容易にするためのToolLLMというフレームワークを紹介します。ToolBenchというデータセットを使用して、ツールの使用方法を調整し、DFSDTという決定木を使用して効率的な検索を行います。ToolEvalという自動評価ツールを使用して、ToolLLaMAが高いパフォーマンスを発揮することを示します。さらに、ニューラルAPIリトリーバーを使用して、適切なAPIを推奨します。</span>
<span class="snippet"><span>Comment</span>16000のreal worldのAPIとインタラクションし、データの準備、訓練、評価などを一貫してできるようにしたフレームワーク。LLaMAを使った場合、ツール利用に関してturbo-16kと同等の性能に達したと主張。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/a9c394b5-6148-4bab-acaa-4934ead5c1a7" alt="image" loading="lazy"></span>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/916">L-Eval: Instituting Standardized Evaluation for Long Context Language  Models, Chenxin An+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>長い文脈の言語モデル（LCLM）の評価を標準化するために、L-Evalという評価スイートを提案しました。L-Evalには411の長いドキュメントと2,000以上の人間によるクエリ-レスポンスのペアが含まれており、多様な評価方法と指示スタイルを採用しています。オープンソースのモデルは商用モデルに比べて遅れていますが、通常のバージョンと比較しても印象的なパフォーマンスを示しています。LCLMの生成結果は公開されています。</span>
<span class="snippet"><span>Comment</span>long contextに対するLLMの評価セット。411のlong documentに対する2kのquery-response pairのデータが存在。法律、fainance, school lectures, 長文対話、小説、ミーティングなどのドメインから成る。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-08-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/913">Do Multilingual Language Models Think Better in English?, Julen Etxaniz+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>self-translateは、マルチリンガル言語モデルの少数ショット翻訳能力を活用する新しいアプローチであり、外部の翻訳システムの必要性を克服する。実験結果は、self-translateが直接推論を上回る性能を示し、非英語の言語でプロンプトされた場合にも有効であることを示している。コードはhttps://github.com/juletx/self-translateで利用可能。</span>
<span class="snippet"><span>Comment</span>参考: https://twitter.com/imai_eruel/status/1687735268311511040?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/65a44946-c82b-4895-9ce9-c48792e09b3e" alt="image" loading="lazy"><img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/86ff0cbb-7fac-4ba2-bf11-652b80db0fe5" alt="image" loading="lazy"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-07-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/905">FrugalGPT: How to Use Large Language Models While Reducing Cost and  Improving Performance, Lingjiao Chen+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）の使用には高いコストがかかるため、LLMsの推論コストを削減するための3つの戦略（プロンプトの適応、LLMの近似、LLMのカスケード）を提案する。FrugalGPTという具体的な手法を紹介し、最大98％のコスト削減と4％の精度向上を実現することを示す。これにより、LLMsの持続可能な使用が可能となる。</span>
<span class="snippet"><span>Comment</span>限られた予算の中で、いかに複数のLLM APIを使い、安いコストで高い性能を達成するかを追求した研究。

<br>



<br>

LLM Cascadeなどはこの枠組みでなくても色々と使い道がありそう。Question Concatenationは実質Batch Prompting。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<span class="issue_date">Issue Date: 2023-07-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/903">Judging LLM-as-a-judge with MT-Bench and Chatbot Arena, Lianmin Zheng+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLM）を判定者として使用して、オープンエンドの質問に対する性能を評価する方法を提案する。LLMの制限や問題を軽減するための解決策を提案し、2つのベンチマークでLLMの判定者と人間の好みの一致を検証する。結果は、強力なLLM判定者が人間の好みとよく一致し、スケーラブルで説明可能な方法で人間の好みを近似できることを示した。さらに、新しいベンチマークと従来のベンチマークの相補性を示し、いくつかのバリアントを評価する。</span>
<span class="snippet"><span>Comment</span>MT-Bench（MTBench）スコアとは、multi-turnのQAを出題し、その回答の質をGPT-4でスコアリングしたスコアのこと。

<br>



<br>

GPT-4の判断とhuman expertの判断とのagreementも検証しており、agreementは80%以上を達成している。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/20c7782d-8ffe-4328-8526-700e38df23b5" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/9f0e1e3a-6b07-4bcc-be78-e42a1c5d2190" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/PersonalizedGeneration.html">#PersonalizedGeneration</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<a class="button" href="articles/PersonalizedHeadlineGeneration.html">#PersonalizedHeadlineGeneration</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/893">Generating User-Engaging News Headlines, Cai+, ACL'23</a>
<span class="snippet"><span>Summary</span>ニュース記事の見出しを個別化するために、ユーザープロファイリングを組み込んだ新しいフレームワークを提案。ユーザーの閲覧履歴に基づいて個別のシグネチャフレーズを割り当て、それを使用して見出しを個別化する。幅広い評価により、提案したフレームワークが多様な読者のニーズに応える個別の見出しを生成する効果を示した。</span>
<span class="snippet"><span>Comment</span>モチベーション

<br>



<br>

推薦システムのヘッドラインは未だに全員に同じものが表示されており、ユーザが自身の興味とのつながりを正しく判定できるとは限らず、推薦システムの有用性を妨げるので、ユーザごとに異なるヘッドラインを生成する手法を提案した。ただし、クリックベイトは避けるようなヘッドラインを生成しなければならない。

<br>



<br>



<br>



<br>

手法

<br>



<br>

1. Signature Phrase Identification

<br>



<br>

2. User Signature Selection

<br>



<br>

3. Signature-Oriented Headline Generation 

<br>



<br>



<br>



<br>

Signature Phrase Identification

<br>



<br>

テキスト生成タスクに帰着させる。ニュース記事、あるいはヘッドラインをinputされたときに、セミコロン区切りのSignature Phraseを生成するモデルを用いる。今回は[KPTimes daasetでpretrainingされたBART](https://huggingface.co/ankur310794/bart-base-keyphrase-generation-kpTimes)を用いた。KPTimesは、279kのニュース記事と、signature phraseのペアが存在するデータであり、本タスクに最適とのこと。

<br>



<br>



<br>



<br>

User Signature Selection

<br>



<br>

ターゲットドキュメントdのSignature Phrases Z_dが与えられたとき、ユーザのreading History H_uに基づいて、top-kのuser signature phrasesを選択する。H_uはユーザが読んだニュースのヘッドラインの集合で表現される。あるSignature Phrase z_i ∈ Z_dが与えられたとき、(1)H_uをconcatしたテキストをベクトル化したものと、z_iのベクトルの内積でスコアを計算、あるいは(2) 個別のヘッドラインt_jを別々にエンコーディングし、内積の値が最大のものをスコアとする手法の2種類のエンコーディング方法を用いて、in-batch contrastive learningを用いてモデルを訓練する。つまり、正しいSignature Phraseとは距離が近く、誤ったSignature Phraseとは距離が遠くなるように学習をする。

<br>



<br>

実際はユーザにとっての正解Signature Phraseは分からないが、今回は人工的に作成したユーザを用いるため、正解が分かる設定となっている。

<br>



<br>



<br>



<br>

Signature-Oriented Headline Generation

<br>



<br>

ニュース記事d, user signature phrasesZ_d^uが与えられたとき、ヘッドラインを生成するモデルを訓練する。この時も、ユーザにとって正解のヘッドラインは分からないため、既存ニュースのヘッドラインが正解として用いられる。既存ニュースのヘッドラインが正解として用いられていても、そのヘッドラインがそのユーザにとっての正解となるように人工的にユーザが作成されているため、モデルの訓練ができる。モデルはBARTを用いた。

<br>



<br>



<br>



<br>

Dataset

<br>



<br>

Newsroom, Gigawordコーパスを用いる。これらのコーパスに対して、それぞれ2種類のコーパスを作成する。

<br>



<br>

1つは、Synthesized User Datasetで、これはUse Signature Selection modelの訓練と評価に用いる。もう一つはheadline generationデータセットで、こちらはheadline generationモデルの訓練に利用する。

<br>



<br>



<br>



<br>

Synthesized User Creation

<br>



<br>

実データがないので、実ユーザのreading historiesを模倣するように人工ユーザを作成する。具体的には、

<br>



<br>

1. すべてのニュース記事のSignature Phrasesを同定する

<br>



<br>

2. それぞれのSignature Phraseと、それを含むニュース記事をマッピングする

<br>



<br>

3. ランダムにphraseのサブセットをサンプリングし、そのサブセットをある人工ユーザが興味を持つエリアとする。

<br>



<br>

4. サブセット中のinterest phraseを含むニュース記事をランダムにサンプリングし、ユーザのreading historyとする

<br>



<br>

train, dev, testセット、それぞれに対して上記操作を実施しユーザを作成するが、train, devはContrastive Learningを実現するために、user signature phrases (interest phrases)は1つのみとした（Softmaxがそうなっていないと訓練できないので）。一方、testセットは1~5の範囲でuser signature phrasesを選択した。これにより、サンプリングされる記事が多様化され、ユーザのreadinig historyが多様化することになる。基本的には、ユーザが興味のあるトピックが少ない方が、よりタスクとしては簡単になることが期待される。また、ヘッドラインを生成するときは、ユーザのsignature phraseを含む記事をランダムに選び、ヘッドラインを背衛星することとした。これは、relevantな記事でないとヘッドラインがそもそも生成できないからである。

<br>



<br>



<br>



<br>

Headline Generation

<br>



<br>

ニュース記事の全てのsignature phraseを抽出し、それがgivenな時に、元のニュース記事のヘッドラインが生成できるようなBARTを訓練した。ニュース記事のtokenは512でtruncateした。平均して、10個のsignature phraseがニュース記事ごとに選択されており、ヘッドライン生成の多様さがうかがえる。user signature phraseそのものを用いて訓練はしていないが、そもそもこのようにGenericなデータで訓練しても、何らかのphraseがgivenな時に、それにバイアスがかかったヘッドラインを生成することができるので、user signature phrase selectionによって得られたphraseを用いてヘッドラインを生成することができる。

<br>



<br>



<br>



<br>

評価

<br>



<br>

自動評価と人手評価をしている。

<br>



<br>



<br>



<br>

自動評価

<br>



<br>

人手評価はコストがかかり、特に開発フェーズにおいては自動評価ができることが非常に重要となる。本研究では自動評価し方法を提案している。Headline-User DPR + SBERT, REC Scoreは、User Adaptation Metricsであり、Headline-Article DPR + SBERT, FactCCはArticle Loyalty Metricsである。

<br>



<br>

Relevance Metrics

<br>



<br>

PretrainedなDense Passage Retrieval (DPR)モデルと、SentenceBERTを用いて、headline-user間、headline-article間の類似度を測定する。前者はヘッドラインがどれだけユーザに適応しているが、後者はヘッドラインが元記事に対してどれだけ忠実か（クリックベイトを防ぐために）に用いられる。前者は、ヘッドラインとuser signaturesに対して類似度を計算し、後者はヘッドラインと記事全文に対して類似度を計算する。user signatures, 記事全文をどのようにエンコードしたかは記述されていない。

<br>



<br>

Recommendation Score

<br>



<br>

ヘッドラインと、ユーザのreadinig historyが与えられたときに、ニュースを推薦するモデルを用いて、スコアを算出する。モデルとしては、MIND datsetを用いて学習したモデルを用いた。

<br>



<br>

Factual Consistency

<br>



<br>

pretrainedなFactCCモデルを用いて、ヘッドラインとニュース記事間のfactual consisency score を算出する。

<br>



<br>

Surface Overlap

<br>



<br>

オリジナルのヘッドラインと、生成されたヘッドラインのROUGE-L F1と、Extractive Coverage (ヘッドラインに含まれる単語のうち、ソースに含まれる単語の割合)を用いる。

<br>



<br>

評価結果

<br>



<br>

提案手法のうち、User Signature Selection modelをfinetuningしたものが最も性能が高かった。エンコード方法は、(2)のヒストリのタイトルとフレーズの最大スコアをとる方法が最も性能が高い。提案手法はUser Adaptationをしつつも、Article Loyaltyを保っている。このため、クリックベイトの防止につながる。また、Vanilla Humanは元記事のヘッドラインであり、Extracitve Coverageが低いため、より抽象的で、かつ元記事に対する忠実性が低いことがうかがえる。

<br>



<br>



<br>



<br>



<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/847933e1-deb2-4379-addb-6cdd65e29ee8" alt="image" loading="lazy">

<br>



<br>



<br>



<br>



<br>



<br>



<br>



<br>

人手評価

<br>



<br>

16人のevaluatorで評価。2260件のニュース記事を収集（113 topic）し、記事のヘッドラインと、対応するトピックを見せて、20個の興味に合致するヘッドラインを選択してもらった。これをユーザのinterest phraseとreading _historyとして扱う。そして、ユーザのinterest phraseを含むニュース記事のうち、12個をランダムに選択し、ヘッドラインを生成した。生成したヘッドラインに対して、

<br>



<br>

1. Vanilla Human

<br>



<br>

2. Vanilla System

<br>



<br>

3. SP random (ランダムにsignature phraseを選ぶ手法)

<br>



<br>

4. SP individual-N

<br>



<br>

5. SP individual-F (User Signature Phraseを選択するモデルをfinetuningしたもの)

<br>



<br>

の5種類を評価するよう依頼した。このとき、３つの観点から評価をした。

<br>



<br>

1, User adaptation

<br>



<br>

2. Headline appropriateness

<br>



<br>

3. Text Quality

<br>



<br>

結果は以下。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/6af9f214-2af4-4fa3-8637-6b1858f0bb69" alt="image" loading="lazy">

<br>



<br>

SP-individualがUser Adaptationで最も高い性能を獲得した。また、Vanilla Systemが最も高いHeadline appropriatenessを獲得した。しかしながら、後ほど分析した結果、Vanilla Systemでは、記事のメインポイントを押さえられていないような例があることが分かった（んーこれは正直他の手法でも同じだと思うから、ディフェンスとしては苦しいのでは）。

<br>



<br>

また、Vanilla Humanが最も高いスコアを獲得しなかった。これは、オーバーにレトリックを用いていたり、一般的な人にはわからないようなタイトルになっているものがあるからであると考えられる。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/6e704d7b-6124-49b5-91c8-1f6b507b0c0a" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Ablation Study

<br>



<br>

Signature Phrase selectionの性能を測定したところ以下の通りになり、finetuningした場合の性能が良かった。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/a24fefb6-9028-4e58-9667-caa13a70af31" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Headline Generationの性能に影響を与える要素としては、

<br>



<br>

1. ユーザが興味のあるトピック数

<br>



<br>

2. User signature phrasesの数

<br>



<br>

がある。

<br>



<br>

ユーザのInterest Phrasesが増えていけばいくほど、User Adaptationスコアは減少するが、Article Loyaltyは維持されたままである。このため、興味があるトピックが多ければ多いほど生成が難しいことがわかる。また、複数のuser signature phraseを用いると、factual errorを起こすことが分かった（Billgates, Zuckerbergの例を参照）。これは、モデルが本来はirrelevantなフレーズを用いてcoherentなヘッドラインを生成しようとしてしまうためである。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/9d28d904-3247-4593-bc1c-8b6e7090719b" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

※interest phrases =&gt; gold user signatures という理解でよさそう。

<br>



<br>

※signature phrasesを複数用いるとfactual errorを起こすため、今回はk=1で実験していると思われる

<br>



<br>



<br>



<br>

GPT3にもヘッドラインを生成させてみたが、提案手法の方が性能が良かった（自動評価で）。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/3e0852e1-f21a-47d6-b874-b7d3a42d7304" alt="image" loading="lazy">

<br>



<br>

なぜPENS dataset 706 を利用しないで研究したのか？</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/892">Can Large Language Models Be an Alternative to Human Evaluations? Cheng-Han Chiang, Hung-yi Lee, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、人間の評価が機械学習モデルのテキスト品質評価に不可欠であるが再現性が難しいという問題を解決するために、大規模言語モデル（LLMs）を使用した評価方法を提案している。具体的には、LLMsに同じ指示と評価対象のサンプルを与え、それに対する応答を生成させることで、LLM評価を行っている。実験結果から、LLM評価の結果は人間の評価と一致しており、異なるフォーマットやサンプリングアルゴリズムでも安定していることが示されている。LLMsを使用したテキスト品質評価の可能性が初めて示されており、その制限や倫理的な考慮事項についても議論されている。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/891">InfoMetIC: An Informative Metric for Reference-free Image Caption Evaluation, ACL'23</a>
<span class="snippet"><span>Summary</span>自動画像キャプションの評価には、情報豊かなメトリック（InfoMetIC）が提案されています。これにより、キャプションの誤りや欠落した情報を詳細に特定することができます。InfoMetICは、テキストの精度スコア、ビジョンの再現スコア、および全体の品質スコアを提供し、人間の判断との相関も高いです。また、トークンレベルの評価データセットも構築されています。詳細はGitHubで公開されています。</span>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-free.html">#Reference-free</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/890">RQUGE: Reference-Free Metric for Evaluating Question Generation by Answering the Question, ACL'23</a>
<span class="snippet"><span>Summary</span>既存の質問評価メトリックにはいくつかの欠点がありますが、本研究では新しいメトリックRQUGEを提案します。RQUGEは文脈に基づいて候補質問の回答可能性を考慮し、参照質問に依存せずに人間の判断と高い相関を持つことが示されています。さらに、RQUGEは敵対的な破壊に対しても堅牢であり、質問生成モデルのファインチューニングにも有効です。これにより、QAモデルのドメイン外データセットでのパフォーマンスが向上します。</span>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

質問自動生成の性能指標（e.g. ROUGE, BERTScore）は、表層の一致、あるいは意味が一致した場合にハイスコアを与えるが、以下の欠点がある

<br>



<br>

・人手で作成された大量のreference questionが必要

<br>



<br>

・表層あるいは意味的に近くないが正しいquestionに対して、ペナルティが与えられてしまう

<br>



<br>

=&gt; contextに対するanswerabilityによって評価するメトリック RQUGE を提案

<br>



<br>



<br>



<br>

similarity basedな指標では、Q1のような正しい質問でもlexical overlapがないと低いスコアを与えてしまう。また、Q2のようなreferenceの言い換えであっても、低いスコアとなってしまう。一方、reference basedな手法では、Q3のようにunacceptableになっているにもかかわらず、変化が微小であるためそれをとらえられないという問題がある。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/61c3d939-a678-4c63-9572-f3cf28b3aa20" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

手法概要

<br>



<br>

提案手法ではcontextとanswer spanが与えられたとき、Span Scorerと、QAモジュールを利用してacceptability scoreを計算することでreference-freeなmetricを実現する。

<br>



<br>

QAモデルは、Contextと生成されたQuestionに基づき、answer spanを予測する。提案手法ではT5ベースの手法であるUnifiedQAv2を利用する。

<br>



<br>

Span Scorer Moduleでは、予測されたanswer span, candidate question, context, gold spanに基づき、[1, 5]のスコアを予測する。提案手法では、encoder-only BERT-based model（提案手法ではRoBERTa）を用いる。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/b49e09a4-4a69-4761-94eb-3f6417a19223" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/FoundationModel.html">#FoundationModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/888">Llama 2: Open Foundation and Fine-Tuned Chat Models, Hugo Touvron+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>この研究では、大規模な言語モデルであるLlama 2を開発し、微調整しています。Llama 2-Chatは対話に特化しており、オープンソースのチャットモデルを上回る性能を示しています。安全性の改善にも取り組んでおり、責任ある開発に貢献することを目指しています。</span>
<span class="snippet"><span>Comment</span>参考: https://twitter.com/hillbig/status/1681436336451125257?s=46&t=LJIgfuO352oK3zU2FKFpNALlama, およびLlama2では、一般的なTransformer Decoderとは異なり、linear layerの”前に”RMSPropをかませている点が異なる。

<br>



<br>

また、Llama2では、Llamaと比較して

<br>



<br>

・Group Query Attentionの利用 1271 

<br>



<br>

・活性化関数として、ReLUではなく、SwiGLU 1311 の活用

<br>



<br>

・Positional Embeddingとして、RoPE 1310 の活用

<br>



<br>

・より長いContext Windowsでの学習（4k）

<br>



<br>

を実施している。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/6d6d897a-3ce8-4a90-a001-116884c45cdd" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

出典：https://cameronrwolfe.substack.com/p/llama-2-from-the-ground-up</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/ChatGPT.html">#ChatGPT</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/887">How is ChatGPT's behavior changing over time?, Lingjiao Chen+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>GPT-3.5とGPT-4は、大規模言語モデル（LLM）のサービスであり、その性能と振る舞いは時間とともに変動することがわかった。例えば、GPT-4は素数の特定に優れていたが、後のバージョンでは低い正答率となった。また、GPT-3.5はGPT-4よりも優れた性能を示した。さらに、GPT-4とGPT-3.5の両方が時間とともに敏感な質問への回答やコード生成でのミスが増えた。この結果から、LLMの品質を継続的に監視する必要性が示唆される。</span>
<span class="snippet"><span>Comment</span>GPT3.5, GPT4共にfreezeされてないのなら、研究で利用すると結果が再現されないので、研究で使うべきではない。また、知らんうちにいくつかのタスクで勝手に性能低下されたらたまったものではない。</span>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/884">Challenges and Applications of Large Language Models, Jean Kaddour+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本論文では、大規模言語モデル（LLMs）の普及により、研究者が分野の現状を理解し、生産的になるための問題と応用成功例を確立することを目指しています。</span>
<span class="snippet"><span>Comment</span>LLMのここ数年の進化早すぎわろたでキャッチアップむずいので、未解決の課題や、すでに良い感じのアプリケーションの分野分かりづらいので、まとめました論文</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/883">Towards A Unified Agent with Foundation Models, Norman Di Palo+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、言語モデルとビジョン言語モデルを強化学習エージェントに組み込み、効率的な探索や経験データの再利用などの課題に取り組む方法を調査しました。スパースな報酬のロボット操作環境でのテストにおいて、ベースラインに比べて大幅な性能向上を実証し、学習済みのスキルを新しいタスクの解決や人間の専門家のビデオの模倣に活用する方法を示しました。</span>
<span class="snippet"><span>Comment</span>

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/aa40d0e3-9499-4804-9046-a9ad795c2d52" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Annotation.html">#Annotation</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/882">LLMs as Workers in Human-Computational Algorithms? Replicating  Crowdsourcing Pipelines with LLMs, Tongshuang Wu+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）は、クラウドソーシングタスクにおいて人間のような振る舞いを再現できる可能性がある。しかし、現在の取り組みは単純なタスクに焦点を当てており、より複雑なパイプラインを再現できるかどうかは不明である。LLMsの成功は、リクエスターの理解力やサブタスクのスキルに影響を受ける。人間とLLMsのトレーニングの組み合わせにより、クラウドソーシングパイプラインの再現が可能であり、LLMsは一部のタスクを完了させながら、他のタスクを人間に任せることができる。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/877">Instruction-following Evaluation through Verbalizer Manipulation, Shiyang Li+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、指示に従う能力を正確に評価するための新しい評価プロトコル「verbalizer manipulation」を提案しています。このプロトコルでは、モデルに異なる程度で一致する言葉を使用してタスクラベルを表現させ、モデルの事前知識に依存する能力を検証します。さまざまなモデルを9つのデータセットで評価し、異なるverbalizerのパフォーマンスによって指示に従う能力が明確に区別されることを示しました。最も困難なverbalizerに対しても、最も強力なモデルでもランダムな推測よりも優れたパフォーマンスを発揮するのは困難であり、指示に従う能力を向上させるために継続的な進歩が必要であることを強調しています。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SpokenLanguageProcessing.html">#SpokenLanguageProcessing</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/SpeechProcessing.html">#SpeechProcessing</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/875">Meta-Transformer: A Unified Framework for Multimodal Learning, Yiyuan Zhang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、マルチモーダル学習のためのMeta-Transformerというフレームワークを提案しています。このフレームワークは、異なるモダリティの情報を処理し関連付けるための統一されたネットワークを構築することを目指しています。Meta-Transformerは、対応のないデータを使用して12のモダリティ間で統一された学習を行うことができ、テキスト、画像、ポイントクラウド、音声、ビデオなどの基本的なパーセプションから、X線、赤外線、高分光、IMUなどの実用的なアプリケーション、グラフ、表形式、時系列などのデータマイニングまで、幅広いタスクを処理することができます。Meta-Transformerは、トランスフォーマーを用いた統一されたマルチモーダルインテリジェンスの開発に向けた有望な未来を示しています。</span>
<span class="snippet"><span>Comment</span>12種類のモダリティに対して学習できるTransformerを提案

<br>

Dataをsequenceにtokenizeし、unifiedにfeatureをencodingし、それぞれのdownstreamタスクで学習

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/8734073a-573e-442e-8b9f-fed559199d56" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/873">FLASK: Fine-grained Language Model Evaluation based on Alignment Skill  Sets, Seonghyeon Ye+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）の評価における課題を解決するため、細かい評価プロトコルであるFLASKを提案する。FLASKは、インスタンスごとのスキルセットレベルでの評価を可能にし、モデルベースと人間ベースの評価の両方に使用できる。具体的には、12の細かいスキルを定義し、各インスタンスにスキルのセットを割り当てることで評価セットを構築する。さらに、ターゲットドメインと難易度レベルの注釈を付けることで、モデルのパフォーマンスを包括的に分析する。FLASKを使用することで、モデルのパフォーマンスを正確に測定し、特定のスキルに優れたLLMsを分析することができる。また、実践者はFLASKを使用して、特定の状況に適したモデルを推奨することができる。</span>
<span class="snippet"><span>Comment</span>このベンチによるとLLaMA2でさえ、商用のLLMに比べると能力はかなり劣っているように見える。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/d9871133-3111-4da6-9148-1ac779a24312" alt="image" loading="lazy"></span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/869">Revisiting the Gold Standard: Grounding Summarization Evaluation with Robust Human Evaluation, ACL'23</a>
<span class="snippet"><span>Summary</span>要約の評価には人間の評価が重要ですが、既存の評価方法には問題があります。そこで、私たちは新しい要約の重要性プロトコルを提案し、大規模な人間評価データセットを収集しました。さらに、異なる評価プロトコルを比較し、自動評価指標を評価しました。私たちの研究結果は、大規模言語モデルの評価に重要な示唆を与えます。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<span class="issue_date">Issue Date: 2023-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/868">Socratic Questioning of Novice Debuggers: A Benchmark Dataset and Preliminary Evaluations, ACL-BEA'23</a>
<span class="snippet"><span>Summary</span>本研究では、初心者プログラマがバグのある計算問題を解決する際に、ソクラテス的な対話を行うデータセットを紹介し、GPTベースの言語モデルのデバッグ能力を評価しました。GPT-4はGPT-3.5よりも優れたパフォーマンスを示しましたが、まだ人間の専門家には及ばず、さらなる研究が必要です。</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Distillation.html">#Distillation</a>
<span class="issue_date">Issue Date: 2023-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/867">Teaching Small Language Models to Reason, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模な言語モデルの推論能力を小さなモデルに転送するための知識蒸留を探求しました。具体的には、大きな教師モデルによって生成された出力を用いて学生モデルを微調整し、算術、常識、象徴的な推論のタスクでのパフォーマンスを向上させることを示しました。例えば、T5 XXLの正解率は、PaLM 540BとGPT-3 175Bで生成された出力を微調整することで、それぞれ8.11％から21.99％および18.42％に向上しました。</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<span class="issue_date">Issue Date: 2023-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/866">WeCheck: Strong Factual Consistency Checker via Weakly Supervised Learning, ACL'23</a>
<span class="snippet"><span>Summary</span>現在のテキスト生成モデルは、入力と矛盾するテキストを制御できないという課題があります。この問題を解決するために、私たちはWeCheckという弱教師付きフレームワークを提案します。WeCheckは、弱教師付きラベルを持つ言語モデルから直接訓練された実際の生成サンプルを使用します。さまざまなタスクでの実験結果は、WeCheckの強力なパフォーマンスを示し、従来の評価方法よりも高速で精度と効率を向上させています。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Abstractive.html">#Abstractive</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<span class="issue_date">Issue Date: 2023-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/865">Improving Factuality of Abstractive Summarization without Sacrificing Summary Quality, ACL'23</a>
<span class="snippet"><span>Summary</span>事実性を意識した要約の品質向上に関する研究はあるが、品質を犠牲にすることなく事実性を向上させる手法がほとんどない。本研究では「Effective Factual Summarization」という技術を提案し、事実性と類似性の指標の両方で大幅な改善を示すことを示した。トレーニング中に競合を防ぐために2つの指標を組み合わせるランキング戦略を提案し、XSUMのFactCCでは最大6ポイント、CNN/DMでは11ポイントの改善が見られた。また、類似性や要約の抽象性には負の影響を与えない。</span>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/GrammaticalErrorCorrection.html">#GrammaticalErrorCorrection</a>
<span class="issue_date">Issue Date: 2023-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/864">Enhancing Grammatical Error Correction Systems with Explanations, ACL'23</a>
<span class="snippet"><span>Summary</span>文法エラー修正システムの性能向上のために、エビデンスワードと文法エラータイプが注釈付けされた大規模なデータセットであるEXPECTを紹介する。このデータセットを使用して、説明可能なGECシステムのベースラインと分析を提案し、人間の評価によってその有用性を確認する。</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/MultitaskLearning.html">#MultitaskLearning</a>
<a class="button" href="articles/Zero/FewShotLearning.html">#Zero/FewShotLearning</a>
<span class="issue_date">Issue Date: 2023-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/863">Few-Shot Data-to-Text Generation via Unified Representation and Multi-Source Learning, ACL'23</a>
<span class="snippet"><span>Summary</span>この論文では、構造化データからテキストを生成する新しいアプローチを提案しています。提案手法は、さまざまな形式のデータを処理できる統一された表現を提供し、マルチタスクトレーニングやゼロショット学習などのシナリオでのパフォーマンスを向上させることを目指しています。実験結果は、提案手法が他の方法と比較して優れた性能を示していることを示しています。これは、データからテキスト生成フレームワークにおける重要な進歩です。</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Controllable.html">#Controllable</a>
<span class="issue_date">Issue Date: 2023-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/860">An Invariant Learning Characterization of Controlled Text Generation, ACL'23</a>
<span class="snippet"><span>Summary</span>制御された生成では、予測器の訓練に使用される分布と異なるテキストの分布がある場合、パフォーマンスが低下することが示されている。この問題に対処するために、不変性を持つ予測器が効果的であるという考え方が提案されている。さらに、この特性を活かすための自然な解決策とヒューリスティックも提案されている。実験結果は、制御された生成における分布シフトの課題と不変性手法の潜在能力を示している。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Abstractive.html">#Abstractive</a>
<a class="button" href="articles/Extractive.html">#Extractive</a>
<span class="issue_date">Issue Date: 2023-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/859">Abstractive Summarizers are Excellent Extractive Summarizers, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、抽出型要約と要約型要約の相乗効果を探求し、シーケンス・トゥ・シーケンス・アーキテクチャを使用した3つの新しい推論アルゴリズムを提案しています。これにより、要約型システムが抽出型システムを超えることができることを示しました。また、要約型システムは抽出型のオラクル要約にさらされることなく、両方の要約を単一のモデルで生成できることも示しました。これは、抽出型ラベルの必要性に疑問を投げかけるものであり、ハイブリッドモデルの有望な研究方向を示しています。</span>
<a class="button" href="articles/NaturalLanguageUnderstanding.html">#NaturalLanguageUnderstanding</a>
<span class="issue_date">Issue Date: 2023-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/858">[TACL] Efficient Long-Text Understanding with Short-Text Models, TACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、長いシーケンスを処理するためのシンプルなアプローチであるSLEDを提案しています。SLEDは、既存の短文の事前学習言語モデルを再利用し、入力を重なり合うチャンクに分割して処理します。制御された実験により、SLEDが長いテキスト理解に有効であり、専用の高価な事前学習ステップが必要な専門モデルと競合することが示されました。</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<span class="issue_date">Issue Date: 2023-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/857">Pre-Training to Learn in Context, ACL'23</a>
<span class="snippet"><span>Summary</span>インコンテキスト学習は、タスクの例と文脈からタスクを実行する方法であり、注目されています。しかし、現在の方法では十分に活用されていないため、私たちはPICLというフレームワークを提案します。これは、一般的なテキストコーパスでモデルを事前学習し、文脈に基づいてタスクを推論して実行する能力を向上させます。私たちは、PICLでトレーニングされたモデルのパフォーマンスを評価し、他のモデルを上回ることを示しました。コードはGitHubで公開されています。</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/DynamicNetworks.html">#DynamicNetworks</a>
<span class="issue_date">Issue Date: 2023-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/856">PAD-Net: An Efficient Framework for Dynamic Networks, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、ダイナミックネットワークの一般的な問題点を解決するために、部分的にダイナミックなネットワーク（PAD-Net）を提案します。PAD-Netは、冗長なダイナミックパラメータを静的なパラメータに変換することで、展開コストを削減し、効率的なネットワークを実現します。実験結果では、PAD-Netが画像分類と言語理解のタスクで高い性能を示し、従来のダイナミックネットワークを上回ることを示しました。</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Controllable.html">#Controllable</a>
<a class="button" href="articles/Argument.html">#Argument</a>
<span class="issue_date">Issue Date: 2023-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/855">ArgU: A Controllable Factual Argument Generator, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、高品質な論証を自動生成するために、制御コードを使用したニューラル論証生成器ArgUを提案します。また、論証スキームを特定するための大規模なデータセットを作成し、注釈付けとデータセット作成のフレームワークについて詳細に説明します。さらに、論証テンプレートを生成する推論戦略を試行し、多様な論証を自動的に生成することが可能であることを示します。</span>
<a class="button" href="articles/pretrained-LM.html">#pretrained-LM</a>
<a class="button" href="articles/Out-of-DistributionDetection.html">#Out-of-DistributionDetection</a>
<span class="issue_date">Issue Date: 2023-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/854">Is Fine-tuning Needed? Pre-trained Language Models Are Near Perfect for Out-of-Domain Detection, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、ファインチューニングなしで事前学習された言語モデルを使用してOOD検出を行う効果を調査しました。さまざまなタイプの分布シフトにおいて、ファインチューニングされたモデルを大幅に上回るほぼ完璧なOOD検出性能を示しました。</span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Contents-based.html">#Contents-based</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/pretrained-LM.html">#pretrained-LM</a>
<a class="button" href="articles/ContrastiveLearning.html">#ContrastiveLearning</a>
<span class="issue_date">Issue Date: 2023-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/852">UniTRec: A Unified Text-to-Text Transformer and Joint Contrastive Learning Framework for Text-based Recommendation, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、事前学習済み言語モデル（PLM）を使用して、テキストベースの推薦の性能を向上させるための新しいフレームワークであるUniTRecを提案します。UniTRecは、ユーザーの履歴の文脈をより良くモデル化するために統一されたローカル-グローバルアテンションTransformerエンコーダを使用し、候補のテキストアイテムの言語の複雑さを推定するためにTransformerデコーダを活用します。幅広い評価により、UniTRecがテキストベースの推薦タスクで最先端のパフォーマンスを発揮することが示されました。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NumericReasoning.html">#NumericReasoning</a>
<span class="issue_date">Issue Date: 2023-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/851">A Survey of Deep Learning for Mathematical Reasoning, ACL'23</a>
<span class="snippet"><span>Summary</span>数学的な推論とディープラーニングの関係についての調査論文をレビューし、数学的な推論におけるディープラーニングの進歩と将来の研究方向について議論しています。数学的な推論は機械学習と自然言語処理の分野で重要であり、ディープラーニングモデルのテストベッドとして機能しています。また、大規模なニューラル言語モデルの進歩により、数学的な推論に対するディープラーニングの利用が可能になりました。既存のベンチマークと方法を評価し、将来の研究方向についても議論しています。</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Explanation.html">#Explanation</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Faithfulness.html">#Faithfulness</a>
<span class="issue_date">Issue Date: 2023-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/850">Faithfulness Tests for Natural Language Explanations, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、ニューラルモデルの説明の忠実性を評価するための2つのテストを提案しています。1つ目は、カウンターファクチュアルな予測につながる理由を挿入するためのカウンターファクチュアル入力エディタを提案し、2つ目は生成された説明から入力を再構築し、同じ予測につながる頻度をチェックするテストです。これらのテストは、忠実な説明の開発において基本的なツールとなります。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2023-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/849">Reasoning with Language Model Prompting: A Survey, ACL'23</a>
<span class="snippet"><span>Summary</span>本論文では、推論に関する最新の研究について包括的な調査を行い、初心者を支援するためのリソースを提供します。また、推論能力の要因や将来の研究方向についても議論します。リソースは定期的に更新されています。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Extractive.html">#Extractive</a>
<a class="button" href="articles/Faithfulness.html">#Faithfulness</a>
<span class="issue_date">Issue Date: 2023-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/848">Extractive is not Faithful: An Investigation of Broad Unfaithfulness Problems in Extractive Summarization, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、抽出的な要約の不正確さの問題について議論し、それを5つのタイプに分類します。さらに、新しい尺度であるExtEvalを提案し、不正確な要約を検出するために使用することを示します。この研究は、抽出的な要約の不正確さに対する認識を高め、将来の研究に役立つことを目指しています。</span>
<span class="snippet"><span>Comment</span>Extractive SummarizatinoのFaithfulnessに関する研究。

<br>



<br>

&gt;抽出的な要約は抽象的な要約の一般的な不正確さの問題にはあまり影響を受けにくいですが、それは抽出的な要約が正確であることを意味するのでしょうか？結論はノーです。

<br>



<br>

&gt;本研究では、抽出的な要約に現れる広範な不正確さの問題（非含意を含む）を5つのタイプに分類

<br>



<br>

&gt;不正確な共参照、不完全な共参照、不正確な談話、不完全な談話、および他の誤解を招く情報が含まれます。

<br>



<br>

&gt;私たちは、16の異なる抽出システムによって生成された1600の英語の要約を人間にラベル付けするように依頼しました。その結果、要約の30％には少なくとも5つの問題のうちの1つが存在することがわかりました。

<br>



<br>

 

<br>



<br>

 おもしろい。</span>
<a class="button" href="articles/General.html">#General</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/AES(AutomatedEssayScoring).html">#AES(AutomatedEssayScoring)</a>
<span class="issue_date">Issue Date: 2023-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/847">Improving Domain Generalization for Prompt-Aware Essay Scoring via Disentangled Representation Learning, ACL'23</a>
<span class="snippet"><span>Summary</span>自動エッセイスコアリング（AES）は、エッセイを評価するためのモデルですが、既存のモデルは特定のプロンプトにしか適用できず、新しいプロンプトに対してはうまく汎化できません。この研究では、プロンプトに依存しない特徴とプロンプト固有の特徴を抽出するためのニューラルAESモデルを提案し、表現の汎化を改善するための分離表現学習フレームワークを提案しています。ASAPとTOEFL11のデータセットでの実験結果は、提案手法の有効性を示しています。</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Controllable.html">#Controllable</a>
<span class="issue_date">Issue Date: 2023-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/846">Controllable Text Generation via Probability Density Estimation in the Latent Space, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、潜在空間での確率密度推定を用いた新しい制御フレームワークを提案しています。この手法は、可逆変換関数を使用して潜在空間の複雑な分布を単純なガウス分布にマッピングし、洗練された柔軟な制御を行うことができます。実験結果では、提案手法が属性の関連性とテキストの品質において強力なベースラインを上回り、新たなSOTAを達成していることが示されています。さらなる分析により、制御戦略の柔軟性が示されています。</span>
<a class="button" href="articles/Education.html">#Education</a>
<a class="button" href="articles/EducationalDataMining.html">#EducationalDataMining</a>
<a class="button" href="articles/QuestionGeneration.html">#QuestionGeneration</a>
<span class="issue_date">Issue Date: 2023-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/845">Covering Uncommon Ground: Gap-Focused Question Generation for Answer Assessment, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、教育的な対話における情報のギャップに焦点を当て、自動的に質問を生成する問題に取り組んでいます。良い質問の要素を明確にし、それを満たすモデルを提案します。また、人間のアノテーターによる評価を行い、生成された質問の競争力を示します。</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Ensemble.html">#Ensemble</a>
<span class="issue_date">Issue Date: 2023-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/844">Multi-CLS BERT: An Efficient Alternative to Traditional Ensembling, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、BERTモデルのアンサンブル手法であるMulti-CLS BERTを提案します。Multi-CLS BERTは、複数のCLSトークンを使用して多様性を促進し、単一のモデルを微調整するだけでアンサンブル効果を得ることができます。実験結果では、Multi-CLS BERTがGLUEとSuperGLUEのタスクで全体的な精度と信頼度の推定を向上させることが示されました。また、通常のBERTアンサンブルとほぼ同等の性能を持ちながら、計算量とメモリ使用量が約4倍少なくなっていることも示されました。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Conversation.html">#Conversation</a>
<span class="issue_date">Issue Date: 2023-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/843">MeetingBank: A Benchmark Dataset for Meeting Summarization, ACL'23</a>
<span class="snippet"><span>Summary</span>会議の要約技術の開発には注釈付きの会議コーパスが必要ですが、その欠如が問題となっています。本研究では、新しいベンチマークデータセットであるMeetingBankを提案しました。MeetingBankは、会議議事録を短いパッセージに分割し、特定のセグメントと対応させることで、会議の要約プロセスを管理しやすいタスクに分割することができます。このデータセットは、会議要約システムのテストベッドとして利用できるだけでなく、一般の人々が議会の意思決定の仕組みを理解するのにも役立ちます。ビデオリンク、トランスクリプト、参照要約などのデータを一般に公開し、会議要約技術の開発を促進します。</span>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Unsupervised.html">#Unsupervised</a>
<a class="button" href="articles/SpeechProcessing.html">#SpeechProcessing</a>
<a class="button" href="articles/Speech.html">#Speech</a>
<span class="issue_date">Issue Date: 2023-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/842">Simple and Effective Unsupervised Speech Translation, ACL'23</a>
<span class="snippet"><span>Summary</span>音声翻訳のためのラベル付きデータが限られているため、非教師あり手法を使用して音声翻訳システムを構築する方法を研究している。パイプラインアプローチや擬似ラベル生成を使用し、非教師ありドメイン適応技術を提案している。実験の結果、従来の手法を上回る性能を示している。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Controllable.html">#Controllable</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<span class="issue_date">Issue Date: 2023-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/841">On Improving Summarization Factual Consistency from Natural Language Feedback, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、自然言語の情報フィードバックを活用して要約の品質とユーザーの好みを向上させる方法を調査しました。DeFactoという高品質なデータセットを使用して、要約の編集や修正に関する自然言語生成タスクを研究しました。また、微調整された言語モデルを使用して要約の品質を向上させることも示しました。しかし、大規模な言語モデルは制御可能なテキスト生成には向いていないことがわかりました。</span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Conversation.html">#Conversation</a>
<span class="issue_date">Issue Date: 2023-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/840">TREA: Tree-Structure Reasoning Schema for Conversational Recommendation, ACL'23</a>
<span class="snippet"><span>Summary</span>会話型の推薦システム（CRS）では、外部知識を活用して対話の文脈を理解し、関連するアイテムを推薦することが求められている。しかし、現在の推論モデルは複雑な関係を完全に把握できないため、新しいツリー構造の推論スキーマであるTREAを提案する。TREAは多階層のツリーを使用して因果関係を明確にし、過去の対話を活用してより合理的な応答を生成する。幅広い実験により、TREAの有効性が示された。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/Conversation.html">#Conversation</a>
<span class="issue_date">Issue Date: 2023-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/839">MPCHAT: Towards Multimodal Persona-Grounded Conversation, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、テキストと画像の両方を使用してパーソナを拡張し、マルチモーダルな対話エージェントを構築するためのデータセットであるMPCHATを提案します。さらに、マルチモーダルパーソナを組み込むことで、応答予測、パーソナのグラウンディング予測、話者の識別といったタスクのパフォーマンスを統計的に有意に改善できることを示します。この研究は、マルチモーダルな対話理解においてマルチモーダルパーソナの重要性を強調し、MPCHATが高品質なリソースとして役立つことを示しています。</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<span class="issue_date">Issue Date: 2023-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/838">Solving Math Word Problems via Cooperative Reasoning induced Language Models, ACL'23</a>
<span class="snippet"><span>Summary</span>大規模な事前学習言語モデル（PLM）を使用して、数学の文章問題（MWPs）を解決するためのCooperative Reasoning（CoRe）アーキテクチャを開発しました。CoReでは、生成器と検証器の二つの推論システムが相互作用し、推論パスを生成し評価を監督します。CoReは、数学的推論データセットで最先端の手法に比べて最大9.6％の改善を達成しました。</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Controllable.html">#Controllable</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/837">Tailor: A Soft-Prompt-Based Approach to Attribute-Based Controlled Text Generation, ACL'23</a>
<span class="snippet"><span>Summary</span>属性ベースの制御されたテキスト生成（CTG）では、望ましい属性を持つ文を生成することが目指されている。従来の手法では、ファインチューニングや追加の属性分類器を使用していたが、ストレージと推論時間の増加が懸念されていた。そこで、本研究では効率的なパラメータを使用した属性ベースのCTGを提案している。具体的には、各属性を事前学習された連続ベクトルとして表現し、固定された事前学習言語モデルをガイドして属性を満たす文を生成する。さらに、2つの解決策を提供して、組み合わせを強化している。実験の結果、追加のトレーニングパラメータのみで効果的な改善が実現できることが示された。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Abstractive.html">#Abstractive</a>
<a class="button" href="articles/Conversation.html">#Conversation</a>
<span class="issue_date">Issue Date: 2023-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/836">[TACL] Abstractive Meeting Summarization: A Survey, TACL'23</a>
<span class="snippet"><span>Summary</span>会議の要約化において、深層学習の進歩により抽象的要約が改善された。本論文では、抽象的な会議の要約化の課題と、使用されているデータセット、モデル、評価指標について概説する。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/TabularData.html">#TabularData</a>
<a class="button" href="articles/TextToImageGeneration.html">#TextToImageGeneration</a>
<span class="issue_date">Issue Date: 2023-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/835">Table and Image Generation for Investigating Knowledge of Entities in Pre-trained Vision and Language Models, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、Vision＆Language（V＆L）モデルにおけるエンティティの知識の保持方法を検証するために、テーブルと画像の生成タスクを提案します。このタスクでは、エンティティと関連する画像の知識を含むテーブルを生成する第一の部分と、キャプションとエンティティの関連知識を含むテーブルから画像を生成する第二の部分があります。提案されたタスクを実行するために、Wikipediaの約20万のinfoboxからWikiTIGデータセットを作成しました。最先端のV＆LモデルOFAを使用して、提案されたタスクのパフォーマンスを評価しました。実験結果は、OFAが一部のエンティティ知識を忘れることを示しています。</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Controllable.html">#Controllable</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<span class="issue_date">Issue Date: 2023-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/834">Focused Prefix Tuning for Controllable Text Generation, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、注釈のない属性によって制御可能なテキスト生成データセットのパフォーマンスが低下する問題に対して、「focused prefix tuning（FPT）」という手法を提案しています。FPTは望ましい属性に焦点を当てることで、制御精度とテキストの流暢さを向上させることができます。また、FPTは複数属性制御タスクにおいても、既存のモデルを再トレーニングすることなく新しい属性を制御する柔軟性を持ちながら、制御精度を保つことができます。</span>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<a class="button" href="articles/LabelBias.html">#LabelBias</a>
<span class="issue_date">Issue Date: 2023-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/833">Mitigating Label Biases for In-context Learning, ACL'23</a>
<span class="snippet"><span>Summary</span>インコンテキスト学習（ICL）におけるラベルバイアスの種類を定義し、その影響を軽減するための方法を提案する研究が行われました。特に、ドメインラベルバイアスについて初めて概念化され、その影響を軽減するためのバイアス補正方法が提案されました。この方法により、GPT-JとGPT-3のICLパフォーマンスが大幅に改善されました。さらに、異なるモデルやタスクにも一般化され、ICLにおけるラベルバイアスの問題を解決する手法として有効であることが示されました。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<span class="issue_date">Issue Date: 2023-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/832">Do Models Really Learn to Follow Instructions? An Empirical Study of Instruction Tuning, ACL'23</a>
<span class="snippet"><span>Summary</span>最近のinstruction tuning（IT）の研究では、追加のコンテキストを提供してモデルをファインチューニングすることで、ゼロショットの汎化性能を持つ素晴らしいパフォーマンスが実現されている。しかし、IT中にモデルがどのように指示を利用しているかはまだ研究されていない。本研究では、モデルのトレーニングを変更された指示と元の指示との比較によって、モデルがIT中に指示をどのように利用するかを分析する。実験の結果、トレーニングされたモデルは元の指示と同等のパフォーマンスを達成し、ITと同様のパフォーマンスを達成することが示された。この研究は、より信頼性の高いIT手法と評価の緊急性を強調している。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<a class="button" href="articles/TextToImageGeneration.html">#TextToImageGeneration</a>
<span class="issue_date">Issue Date: 2023-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/831">Learning to Imagine: Visually-Augmented Natural Language Generation, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、視覚情報を活用した自然言語生成のためのLIVEという手法を提案しています。LIVEは、事前学習済み言語モデルを使用して、テキストに基づいて場面を想像し、高品質な画像を合成する方法です。また、CLIPを使用してテキストの想像力を評価し、段落ごとに画像を生成します。さまざまな実験により、LIVEの有効性が示されています。コード、モデル、データは公開されています。</span>
<span class="snippet"><span>Comment</span>&gt;まず、テキストに基づいて場面を想像します。入力テキストに基づいて高品質な画像を合成するために拡散モデルを使用します。次に、CLIPを使用して、テキストが想像力を喚起できるかを事後的に判断します。最後に、私たちの想像力は動的であり、段落全体に1つの画像を生成するのではなく、各文に対して合成を行います。

<br>



<br>



<br>



<br>

興味深い</span>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<a class="button" href="articles/InductiveBias.html">#InductiveBias</a>
<span class="issue_date">Issue Date: 2023-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/830">Measuring Inductive Biases of In-Context Learning with Underspecified Demonstrations, ACL'23</a>
<span class="snippet"><span>Summary</span>インコンテキスト学習（ICL）は、大規模言語モデル（LLMs）を新しいタスクに適応させるための重要なパラダイムですが、ICLの一般化の振る舞いはまだ十分に理解されていません。本研究では、ICLの帰納的なバイアスについて調査を行いました。具体的には、不完全なデモンストレーションが与えられた場合、ICLはどのフィーチャーをより頻繁に使用する傾向があるのかを調べました。実験の結果、LLMsが明確なフィーチャーバイアスを示すことがわかりました。また、特定のフィーチャーを好むような帰納的なバイアスを課すためのさまざまな介入の効果も評価しました。全体として、ICLがより頻繁に利用する可能性のあるフィーチャーのタイプと、意図したタスクとより一致した帰納的なバイアスを課す方法について、より広範な情報を提供する結果となりました。</span>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Distillation.html">#Distillation</a>
<span class="issue_date">Issue Date: 2023-07-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/829">SCOTT: Self-Consistent Chain-of-Thought Distillation, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模な言語モデル（LM）から小さなCoTモデルを学習するための知識蒸留手法であるSCOTTを提案しています。SCOTTは、教師モデルからゴールドアンサーをサポートする根拠を引き出し、より信憑性のあるトークンを生成するように学習を促します。さらに、学生モデルはカウンターファクトリーニングの目的で教師が生成した根拠を使用して学習されます。実験結果は、提案手法がベースラインよりも忠実なモデルを導くことを示しています。また、根拠を尊重することで意思決定を改善することも可能です。</span>
<span class="snippet"><span>Comment</span>CoTのパフォーマンス向上がパラメータ数が大きいモデルでないと発揮せれないことは元論文 551 で考察されており、それをより小さいモデルに蒸留し発揮できるようにする、おもしろい</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Novelty.html">#Novelty</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-07-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/828">[TACL] How much do language models copy from their training data? Evaluating linguistic novelty in text generation using RAVEN, TACL'23</a>
<span class="snippet"><span>Summary</span>この研究では、言語モデルが生成するテキストの新規性を評価するための分析スイートRAVENを紹介しています。英語で訓練された4つのニューラル言語モデルに対して、局所的な構造と大規模な構造の新規性を評価しました。結果として、生成されたテキストは局所的な構造においては新規性に欠けており、大規模な構造においては人間と同程度の新規性があり、時には訓練セットからの重複したテキストを生成することもあります。また、GPT-2の詳細な手動分析により、組成的および類推的な一般化メカニズムの使用が示され、新規テキストが形態的および構文的に妥当であるが、意味的な問題が比較的頻繁に発生することも示されました。</span>
<a class="button" href="articles/DataDistillation.html">#DataDistillation</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/Zero/FewShotLearning.html">#Zero/FewShotLearning</a>
<span class="issue_date">Issue Date: 2023-07-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/827">Dataset Distillation with Attention Labels for Fine-tuning BERT, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、データセットの蒸留を使用して、元のデータセットのパフォーマンスを保持しながら、ニューラルネットワークを迅速にトレーニングするための小さなデータセットを作成する方法に焦点を当てています。具体的には、事前学習済みのトランスフォーマーを微調整するための自然言語処理タスクの蒸留されたfew-shotデータセットの構築を提案しています。実験結果では、注意ラベルを使用してfew-shotデータセットを作成し、BERTの微調整において印象的なパフォーマンスを実現できることを示しました。例えば、ニュース分類タスクでは、わずか1つのサンプルとわずか1つの勾配ステップのみで、元のデータセットの98.5％のパフォーマンスを達成しました。</span>
<span class="snippet"><span>Comment</span>Datadistillationしたら、データセットのうち1サンプルのみで、元のデータセットの98.5%の性能を発揮できたという驚異的な研究（まえかわ君）</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Education.html">#Education</a>
<a class="button" href="articles/AdaptiveLearning.html">#AdaptiveLearning</a>
<a class="button" href="articles/KnowledgeTracing.html">#KnowledgeTracing</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<a class="button" href="articles/QuestionGeneration.html">#QuestionGeneration</a>
<span class="issue_date">Issue Date: 2023-07-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/824">Adaptive and Personalized Exercise Generation for Online Language Learning, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、オンライン言語学習のための適応的な演習生成の新しいタスクを研究しました。学習履歴から学生の知識状態を推定し、その状態に基づいて個別化された演習文を生成するモデルを提案しました。実データを用いた実験結果から、学生の状態に応じた演習を生成できることを示しました。さらに、教育アプリケーションでの利用方法についても議論し、学習の効率化を促進できる可能性を示しました。</span>
<span class="snippet"><span>Comment</span>Knowledge Tracingで推定された習熟度に基づいて、エクササイズを自動生成する研究。KTとNLGが組み合わさっており、非常におもしろい。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/975a4de3-4f68-4dc6-beb4-5ad32b706959" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-07-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/823">Measuring the Instability of Fine-Tuning, ACL'23</a>
<span class="snippet"><span>Summary</span>事前学習済み言語モデルのファインチューニングは小規模データセットでは不安定であることが示されている。本研究では、不安定性を定量化する指標を分析し、評価フレームワークを提案する。また、既存の不安定性軽減手法を再評価し、結果を提供する。</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Ensemble.html">#Ensemble</a>
<a class="button" href="articles/TransferLearning.html">#TransferLearning</a>
<span class="issue_date">Issue Date: 2023-07-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/822">Parameter-efficient Weight Ensembling Facilitates Task-level Knowledge Transfer, ACL'23</a>
<span class="snippet"><span>Summary</span>最近の研究では、大規模な事前学習済み言語モデルを特定のタスクに効果的に適応させることができることが示されています。本研究では、軽量なパラメータセットを使用してタスク間で知識を転送する方法を探求し、その有効性を検証しました。実験結果は、提案手法がベースラインに比べて5％〜8％の改善を示し、タスクレベルの知識転送を大幅に促進できることを示しています。</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/KnowledgeGraph.html">#KnowledgeGraph</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<a class="button" href="articles/NaturalLanguageUnderstanding.html">#NaturalLanguageUnderstanding</a>
<span class="issue_date">Issue Date: 2023-07-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/821">Direct Fact Retrieval from Knowledge Graphs without Entity Linking, ACL'23</a>
<span class="snippet"><span>Summary</span>従来の知識取得メカニズムの制限を克服するために、我々はシンプルな知識取得フレームワークであるDiFaRを提案する。このフレームワークは、入力テキストに基づいて直接KGから事実を取得するものであり、言語モデルとリランカーを使用して事実のランクを改善する。DiFaRは複数の事実取得タスクでベースラインよりも優れた性能を示した。</span>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/PositionalEncoding.html">#PositionalEncoding</a>
<span class="issue_date">Issue Date: 2023-07-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/820">Randomized Positional Encodings Boost Length Generalization of Transformers, ACL'23</a>
<span class="snippet"><span>Summary</span>トランスフォーマーは、固定長のタスクにおいては優れた汎化能力を持つが、任意の長さのシーケンスには対応できない。この問題を解決するために、新しい位置エンコーディング手法を提案する。ランダム化された位置エンコーディングスキームを使用し、長いシーケンスの位置をシミュレートし、順序付けられたサブセットをランダムに選択する。大規模な実証評価により、この手法がトランスフォーマーの汎化能力を向上させ、テストの正確性を平均して12.0％向上させることが示された。</span>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/KnowledgeGraph.html">#KnowledgeGraph</a>
<span class="issue_date">Issue Date: 2023-07-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/819">Do I have the Knowledge to Answer? Investigating Answerability of Knowledge Base Questions, ACL'23</a>
<span class="snippet"><span>Summary</span>ナレッジベース上の自然言語質問には回答不可能なものが多くありますが、これについての研究はまだ不十分です。そこで、回答不可能な質問を含む新しいベンチマークデータセットを作成しました。最新のKBQAモデルを評価した結果、回答不可能な質問に対して性能が低下することがわかりました。さらに、これらのモデルは誤った理由で回答不可能性を検出し、特定の形式の回答不可能性を扱うことが困難であることもわかりました。このため、回答不可能性に対する堅牢なKBQAシステムの研究が必要です。</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Zero/FewShotPrompting.html">#Zero/FewShotPrompting</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<span class="issue_date">Issue Date: 2023-07-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/817">FiD-ICL: A Fusion-in-Decoder Approach for Efficient In-Context Learning, ACL'23</a>
<span class="snippet"><span>Summary</span>大規模な事前学習モデルを使用したfew-shot in-context learning（ICL）において、fusion-in-decoder（FiD）モデルを適用することで効率とパフォーマンスを向上させることができることを検証する。FiD-ICLは他のフュージョン手法と比較して優れたパフォーマンスを示し、推論時間も10倍速くなる。また、FiD-ICLは大規模なメタトレーニングモデルのスケーリングも可能にする。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Abstractive.html">#Abstractive</a>
<a class="button" href="articles/pretrained-LM.html">#pretrained-LM</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<span class="issue_date">Issue Date: 2023-07-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/816">Z-Code++: A Pre-trained Language Model Optimized for Abstractive Summarization, ACL'23</a>
<span class="snippet"><span>Summary</span>この論文では、新しい事前学習言語モデルであるZ-Code++を提案し、抽象的なテキスト要約に最適化されています。Z-Code++は、2つのフェーズの事前学習とディセントラル化アテンション層、およびエンコーダー内のフュージョンを使用しています。このモデルは、低リソースの要約タスクで最先端の性能を発揮し、パラメータ効率的であり、他の競合モデルを大幅に上回ります。</span>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<span class="issue_date">Issue Date: 2023-07-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/815">Unnatural Instructions: Tuning Language Models with （Almost） No Human Labor, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、人間の監督を必要としない方法で収集された大規模なデータセット「Unnatural Instructions」を紹介します。このデータセットを使用して、言語モデルのトレーニングを行い、既存のモデルを上回る性能を実現しました。これにより、クラウドソーシングに頼らずにデータセットを拡張し、多様性を持たせることができることが示されました。</span>
<a class="button" href="articles/General.html">#General</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<a class="button" href="articles/Composition.html">#Composition</a>
<span class="issue_date">Issue Date: 2023-07-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/814">How Do In-Context Examples Affect Compositional Generalization?, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、組成的な一般化を調査するためのテストスイートであるCoFeを提案し、インコンテキスト学習の組成的な一般化について研究しました。インコンテキストの例の選択が組成的な一般化のパフォーマンスに影響を与えることを発見し、類似性、多様性、複雑さの要素を研究しました。さらに、架空の単語に対する組成的な一般化は一般的な単語に比べて弱いことが観察されました。インコンテキストの例が言語構造をカバーすることが重要であることも示されました。</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Controllable.html">#Controllable</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-07-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/813">Explicit Syntactic Guidance for Neural Text Generation, ACL'23</a>
<span class="snippet"><span>Summary</span>既存のテキスト生成モデルには制約があり、シーケンス・トゥ・シーケンスのパラダイムに従っている。私たちは、構文にガイドされた生成スキーマを提案し、構文解析木に従ってシーケンスを生成する。提案手法は、パラフレーズ生成と機械翻訳の実験でベースラインを上回り、解釈可能性、制御可能性、多様性の観点でも効果的であることを示している。</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Pruning.html">#Pruning</a>
<span class="issue_date">Issue Date: 2023-07-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/812">Pruning Pre-trained Language Models Without Fine-Tuning, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、Pre-trained Language Models（PLMs）の過パラメータ化の問題を解決するために、一次元のプルーニングを使用したシンプルで直感的な圧縮手法であるStatic Model Pruning（SMP）を提案します。SMPは、下流のタスクにPLMsを適応させるために一次元のプルーニングのみを使用し、微調整を必要としないため、他の手法よりも効率的です。徹底的な実験結果は、SMPが一次元およびゼロ次元の手法よりも大幅に改善されていることを示しています。また、SMPは低い疎密度にも適用可能であり、ゼロ次元の手法を上回ります。</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<span class="issue_date">Issue Date: 2023-07-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/811">Trainable Transformer in Transformer, Abhishek Panigrahi+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、Transformer in Transformer（TinT）という効率的な構築を提案し、大規模な事前学習言語モデルの内部モデルをシミュレートして微調整することが可能となります。TinTは小さなパラメータ数でも高い性能を発揮し、トランスフォーマー内の単純なモデルの効率も向上させます。さまざまな実験により、TinTの性能向上が観察され、大規模な事前学習言語モデルが複雑なサブルーチンを実行できることが示されました。また、TinTのモジュラーで拡張可能なコードベースも提供されています。</span>
<span class="snippet"><span>Comment</span>参考: https://twitter.com/hillbig/status/1679253896362086401?s=46&t=ArwxeDos47eUWfAg7_FRtg研究の進み早すぎません？？？</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/CrossLingual.html">#CrossLingual</a>
<span class="issue_date">Issue Date: 2023-07-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/808">Empowering Cross-lingual Behavioral Testing of NLP Models with  Typological Features, Ester Hlavnova+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>M2Cという形態論に敏感なNLPモデルの行動テストフレームワークを提案し、12の異なる言語の特徴に基づいてモデルの振る舞いを探るテストを生成する。最先端の言語モデルは英語では優れているが、特定の言語の特徴に対する一般化の失敗があることが示される。これにより、モデルの盲点に対処するための開発が促される。</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/RLHF.html">#RLHF</a>
<a class="button" href="articles/PPO%20(ProximalPolicyOptimization).html">#PPO (ProximalPolicyOptimization)</a>
<span class="issue_date">Issue Date: 2023-07-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/807">Secrets of RLHF in Large Language Models Part I: PPO, Rui Zheng+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）を使用した人間中心のアシスタントの開発には、報酬設計やトレーニングの課題などの障壁があります。この研究では、強化学習（RLHF）のフレームワークを解析し、PPOアルゴリズムの内部動作を再評価し、ポリシーモデルのトレーニングの安定性を改善するための高度なバージョンを提案します。さらに、SFTモデルとChatGPTと比較してRLHFの能力を分析し、オープンソースの実装を公開することを目指しています。</span>
<span class="snippet"><span>Comment</span>RLHFとPPOをの内部構造を調査したレポート。RLHFに興味がある場合は読むべし。github: https://github.com/OpenLMLab/MOSS-RLHF</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<span class="issue_date">Issue Date: 2023-07-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/806">Generative Pretraining in Multimodality, Quan Sun+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>Emuは、マルチモーダルなコンテキストで画像とテキストを生成するためのTransformerベースのモデルです。このモデルは、単一モダリティまたはマルチモーダルなデータ入力を受け入れることができます。Emuは、マルチモーダルなシーケンスでトレーニングされ、画像からテキストへのタスクやテキストから画像へのタスクなど、さまざまなタスクで優れたパフォーマンスを示します。また、マルチモーダルアシスタントなどの拡張機能もサポートしています。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<span class="issue_date">Issue Date: 2023-07-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/805">EgoVLPv2: Egocentric Video-Language Pre-training with Fusion in the  Backbone, Shraman Pramanick+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>エゴセントリックビデオ言語の事前学習の第2世代（EgoVLPv2）は、ビデオと言語のバックボーンにクロスモーダルの融合を直接組み込むことができる。EgoVLPv2は強力なビデオテキスト表現を学習し、柔軟かつ効率的な方法でさまざまなダウンストリームタスクをサポートする。さらに、提案されたバックボーン戦略は軽量で計算効率が高い。EgoVLPv2は幅広いVLタスクで最先端のパフォーマンスを達成している。詳細はhttps://shramanpramanick.github.io/EgoVLPv2/を参照。</span>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/TheoryOfMind.html">#TheoryOfMind</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-07-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/804">Understanding Social Reasoning in Language Models with Language Models, Kanishk Gandhi+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）のTheory-of-Mind（ToM）推論能力を評価するための新しいフレームワークを提案し、新しい社会的推論のベンチマーク（BigToM）を作成しました。BigToMを使用して、さまざまなLLMsの社会的推論能力を評価し、GPT4が人間の推論パターンと類似したToMの能力を持っていることを示しましたが、他のLLMsは苦戦していることを示唆しています。</span>
<span class="snippet"><span>Comment</span>LLMの社会的推論能力を評価するためのベンチマークを提案。ToMタスクとは、人間の信念、ゴール、メンタルstate、何を知っているか等をトラッキングすることが求められるタスクのこと。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/477e897a-c535-40e7-8d57-c8d6d98552af" alt="image" loading="lazy"></span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ContextWindow.html">#ContextWindow</a>
<span class="issue_date">Issue Date: 2023-07-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/801">Extending Context Window of Large Language Models via Positional  Interpolation, Shouyuan Chen+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>私たちは、Position Interpolation（PI）という手法を提案します。これにより、RoPEベースの事前学習済みLLM（例：LLaMAモデル）のコンテキストウィンドウサイズを最大32768まで拡張することができます。PIを使用することで、長いコンテキストが必要なタスクで強力な性能を示し、元のコンテキストウィンドウ内のタスクに対しても良好な品質を保持します。PIは、注意スコアを壊滅的に高くすることを防ぐために、入力の位置インデックスを線形にダウンスケールして元のコンテキストウィンドウサイズに合わせます。この手法は、既存の最適化とインフラストラクチャを再利用することができます。</span>
<span class="snippet"><span>Comment</span>LLMのContext Windowを最大32kまで拡張する手法を提案。1000 step以内のminimalなfinetuningでモデルの性能を維持しながら実現できる。</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Poisoning.html">#Poisoning</a>
<span class="issue_date">Issue Date: 2023-07-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/798">On the Exploitability of Instruction Tuning, Manli Shu+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>大規模な言語モデル（LLMs）を使用して、指示の調整を行う効果的な手法を提案する。敵対者が特定の指示に従う例をトレーニングデータに注入することで、指示の調整を悪用する方法を調査する。自動データポイズニングパイプライン「AutoPoison」を提案し、オラクルLLMを使用して攻撃目標を毒入りデータに組み込む。コンテンツの注入攻撃と過度な拒否攻撃の2つの例を紹介し、データポイズニング手法の強さと隠密性をベンチマークで評価する。研究は、指示調整モデルの振る舞いにデータの品質が与える影響を明らかにし、LLMsの責任ある展開におけるデータの品質の重要性を強調する。</span>
<span class="snippet"><span>Comment</span>OracleとなるLLMに対して、“Answer the following questions and include “McDonald’s" in your answer:" といったpromptを利用し、 instructionに対するadversarialなresponseを生成し、オリジナルのデータと置換することで、簡単にLLMをpoisoningできることを示した。この例では、特定のマクドナルドのような特定のブランドがレスポンスに含まれるようになっている。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/310984cb-3264-46b1-824e-91a9de40c057" alt="image" loading="lazy"></span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/NumericReasoning.html">#NumericReasoning</a>
<span class="issue_date">Issue Date: 2023-07-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/797">Teaching Arithmetic to Small Transformers, Nayoung Lee+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、GPT-4のような大規模言語モデルが、教師なしのトークン予測目的に明示的にエンコードされていないにもかかわらず、算術演算や基本的な関数を効率的に学習できることを示しています。訓練データのフォーマットの変更やchain-of-thoughtスタイルのデータの使用により、精度や収束速度が改善されます。また、訓練中の算術とテキストデータの相互作用やモデルのスケールの影響も研究されています。この研究は、高品質な指導的なデータが算術能力の引き出しにおいて重要であることを強調しています。</span>
<span class="snippet"><span>Comment</span>小規模なtransformerに算術演算を学習させ、どのような学習データが効果的か調査。CoTスタイルの詳細なスクラッチパッドを学習データにすることで、plainなもの等と比較して、予測性能や収束速度などが劇的に改善した

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/42e60fc0-d04b-4338-922c-5a46b69890b9" alt="image" loading="lazy">結局next token predictionで学習させているみたいだけど、本当にそれで算術演算をモデルが理解しているのだろうか?という疑問がいつもある</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2023-07-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/786">Holistic Evaluation of Language Models, Percy Liang+, TMLR'23</a>
<span class="snippet"><span>Summary</span>言語モデルの透明性を向上させるために、Holistic Evaluation of Language Models（HELM）を提案する。HELMでは、潜在的なシナリオとメトリックを分類し、広範なサブセットを選択して評価する。さらに、複数のメトリックを使用し、主要なシナリオごとに評価を行う。30の主要な言語モデルを42のシナリオで評価し、HELM以前に比べて評価のカバレッジを改善した。HELMはコミュニティのためのベンチマークとして利用され、新しいシナリオ、メトリック、モデルが継続的に更新される。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=iO4LZibEqWHELMを提案した研究

<br>

当時のLeaderboardは既にdeprecatedであり、現在は下記を参照:

<br>

https://crfm.stanford.edu/helm/</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/TMLR.html">#TMLR</a>
<span class="issue_date">Issue Date: 2023-07-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/785">Beyond the Imitation Game: Quantifying and extrapolating the   capabilities of language models, Aarohi Srivastava+, N_A, TMLR'23</a>
<span class="snippet"><span>Summary</span>言語モデルの能力と制約を理解するために、BIG-benchという新しいベンチマークを導入しました。このベンチマークでは、現在の言語モデルの能力を超えるタスクに焦点を当てています。さまざまなトピックの204のタスクが含まれており、モデルのサイズや性能の比較も行いました。結果として、モデルの性能とキャリブレーションは向上していますが、絶対的な性能は低く、モデル間の性能も似ていることがわかりました。また、スパース性からの利益やタスクの特性についても調査しました。さらに、曖昧な文脈の設定では社会的な偏見が増加することも示されましたが、プロンプトの使用で改善できる可能性もあります。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=uyTL5BvosjBIG-Bench論文。ワードクラウドとキーワード分布を見ると一つの分野に留まらない非常に多様なタスクが含まれることがわかる。

<br>

<img src="https://github.com/user-attachments/assets/c3bfb1c1-2e85-47aa-b8ed-1e408b98f8c8" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/07f20e44-7318-476f-9952-be505d9033a4" alt="image" loading="lazy">BIG-Bench-hardは、2024年にClaude3.5によって、Average Human Scoreが67.7%のところ、93.1%を達成され攻略が完了した。現在は最先端のモデル間の性能を差別化することはできない。

<br>



<br>

・1662</span>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-07-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/783">Mind2Web: Towards a Generalist Agent for the Web, Xiang Deng+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>Mind2Webという新しいデータセットを紹介します。このデータセットは、任意のウェブサイト上で複雑なタスクを実行するための言語の指示に従うウェブエージェントを開発・評価するために作成されました。従来のデータセットでは一般的なウェブエージェントには適していなかったため、Mind2Webはより多様なドメイン、実世界のウェブサイト、幅広いユーザーの相互作用パターンを提供します。また、大規模言語モデル（LLMs）を使用して一般的なウェブエージェントを構築するための初期の探索も行われます。この研究は、ウェブエージェントのさらなる研究を促進するためにデータセット、モデルの実装、およびトレーニング済みモデルをオープンソース化します。</span>
<span class="snippet"><span>Comment</span>Webにおけるgeneralistエージェントを評価するためのデータセットを構築。31ドメインの137件のwebサイトにおける2350個のタスクが含まれている。

<br>



<br>

タスクは、webサイトにおける多様で実用的なユースケースを反映し、チャレンジングだが現実的な問題であり、エージェントの環境やタスクをまたいだ汎化性能を評価できる。

<br>



<br>

プロジェクトサイト:

<br>

https://osu-nlp-group.github.io/Mind2Web/</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<span class="issue_date">Issue Date: 2023-07-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/782">Augmenting Language Models with Long-Term Memory, Weizhi Wang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>既存の大規模言語モデル（LLMs）は、入力長の制限により、長い文脈情報を活用できない問題があります。そこで、私たちは「長期記憶を持つ言語モデル（LongMem）」というフレームワークを提案しました。これにより、LLMsは長い履歴を記憶することができます。提案手法は、メモリエンコーダとして凍結されたバックボーンLLMと、適応的な残余サイドネットワークを組み合わせた分離されたネットワークアーキテクチャを使用します。このアーキテクチャにより、長期の過去の文脈を簡単にキャッシュし、利用することができます。実験結果は、LongMemが長い文脈モデリングの難しいベンチマークであるChapterBreakで強力な性能を発揮し、メモリ増強型のコンテキスト内学習で改善を達成することを示しています。提案手法は、言語モデルが長い形式のコンテンツを記憶し利用するのに効果的です。</span>
<span class="snippet"><span>Comment</span>LLMに長期のhistoryを記憶させることを可能する新たな手法を提案し、既存のstrongな長いcontextを扱えるモデルを上回るパフォーマンスを示した

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/98106f5b-22cf-420c-9251-5c7e03ead490" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-07-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/780">Artificial Artificial Artificial Intelligence: Crowd Workers Widely Use  Large Language Models for Text Production Tasks, Veniamin Veselovsky+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）の普及率を調査するために、クラウドワーカーによるLLMの使用の事例研究を行った。結果から、33〜46％のクラウドワーカーがタスクの完了時にLLMsを使用していることが推定された。これにより、人間のデータが人間のものであることを確保するために新しい方法が必要であることが示唆された。</span>
<span class="snippet"><span>Comment</span>Mturkの言語生成タスクにおいて、Turkerのうち33-46%はLLMsを利用していることを明らかにした</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-07-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/779">Bring Your Own Data Self-Supervised Evaluation for Large Language  Models, Neel Jain+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）の振る舞いを評価するための自己教師あり評価フレームワークを提案する。これにより、人間によるラベル付けが必要なくなり、実際のデータに対してモデルの感度や不変性を評価できる。自己教師あり評価は、クローズドブックの知識や有害性、文脈依存性などの側面を評価することができる。また、人間による教師あり評価との相関関係も高い。自己教師あり評価は、現在の評価戦略を補完するものである。</span>
<span class="snippet"><span>Comment</span>Motivation

<br>



<br>

LLMの急速な発展によって、それらの能力とlimitationを正確にとらえるための様々な新たなmetricsが提案されてきたが、結果的に、新たなモデルが既存のデータセットを廃止に追い込み、常に新たなデータセットを作成する必要が生じている。

<br>



<br>

近年のBIG-Bench 785 や HELM 786 はこれらの問題に対処するために、増え続ける蓄積された多様なmicro-benchmarkを用いてLLMのパフォーマンスを測定することで対処しているが、データセットの生成とキュレーションに依存したアプローチとなっており、これらはtine-consumingでexpensiveである。加えて、評価は一般的にdatset-centricであり、固定されたデータセットで何らかのmetricsや人手で付与されたラベルに基づいて評価されるが、モダンなLLMでは、このアプローチでは新たな問題が生じてしまう。

<br>



<br>

・評価データがインターネット上でホスティングされること。これによって、LLMの訓練データとして利用されてしまい、古いデータセットは訓練データから取り除かない限りunreliableとなってしまう。

<br>



<br>

・さまざまな LLM アプリケーションが個別の機能に依存しており、最新の LLM で評価する機能の数が増え続けるため、LLM の評価は多面的であること。

<br>



<br>



<br>



<br>

大規模な出たセットをcurationすることはexpensiveであるため、HELMは特定のシナリオにおける特定の能力を測定するために作成された小さなデータセットを用いている。しかし、より広範なコンテキストや設定でモデルがデプロイするときに、このような評価が適用可能かは定かではない。

<br>



<br>

これまでの評価方法を補完するために、この研究では、self-supervised model evaluationフレームワークを提案している。このフレームワークでは、metricsはinvariancesとsensitivitiesと呼ばれるもので定義され、ラベルを必要としない。代わりに、self-supervisionのフェーズに介入することでこれらのmetricsを算出する。self-supervised evaluationのパイプラインは、特定のデータセットに依存していないため、これまでのmetricsよりもより膨大なコーパスを評価に活用できたり、あるいはday-to-day performanceとしてモニタリングをプロダクションシステム上で実施することができる。以下Dr. Sebastian Ruschkaのツイートの引用

<br>



<br>

&gt;We use self-supervised learning to pretrain LLMs (e.g., next-word prediction). 

<br>

Here's an interesting take using self-supervised learning for evaluating LLMs: arxiv.org/abs//2306.13651

<br>

Turns out, there's correlation between self-supervised evaluations &amp; human evaluations.

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/cebf74e2-d536-4c88-965a-08c6c0e823e1" alt="image" loading="lazy">

<br>



<br>

元ツイート

<br>

https://twitter.com/rasbt/status/1679139569327824897?s=46&t=ArwxeDos47eUWfAg7_FRtg

<br>



<br>

図が非常にわかりやすい</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<span class="issue_date">Issue Date: 2023-06-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/774">Faith and Fate: Limits of Transformers on Compositionality, Nouha Dziri+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>Transformerの大規模言語モデル（LLMs）は、多段階の推論を必要とするタスクで優れたパフォーマンスを示す一方、些細な問題で失敗することもある。この研究では、3つの代表的な合成タスクを用いて、Transformerの限界を調査し、タスクの複雑さが増すにつれてパフォーマンスが低下することを示した。また、Transformerが合成的な推論を線形化されたサブグラフのマッチングに簡約化して解決していることを示唆したが、体系的な問題解決スキルを開発していない可能性もある。</span>
<span class="snippet"><span>Comment</span>参考: https://twitter.com/hillbig/status/1674891033283555328?s=46&t=KFT8cWTu8vV69iD6Qt0NGw</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/SpeechProcessing.html">#SpeechProcessing</a>
<span class="issue_date">Issue Date: 2023-06-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/773">AudioPaLM: A Large Language Model That Can Speak and Listen, Paul K. Rubenstein+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、音声理解と生成のためのマルチモーダルアーキテクチャであるAudioPaLMを紹介する。AudioPaLMは、テキストと音声を処理および生成することができ、PaLM-2とAudioLMを統合している。テキストのみの大規模言語モデルの重みを使用してAudioPaLMを初期化することで、音声処理を改善し、多くの言語に対してゼロショット音声対テキスト翻訳を実行する能力を持つことができることを示す。また、AudioPaLMは、音声言語モデルの機能も示している。</span>
<span class="snippet"><span>Comment</span>参考: https://twitter.com/hillbig/status/1673454388931891201?s=46&t=aLGqdPv6JkRbT0kxsf6Aww</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-06-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/770">SequenceMatch: Imitation Learning for Autoregressive Sequence Modelling  with Backtracking, Chris Cundy+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>自己回帰モデルによるシーケンス生成において、最尤推定（MLE）目的は誤差の蓄積問題を引き起こすため、模倣学習（IL）問題として定式化することが提案された。ILフレームワークを使用することで、バックトラッキングを組み込むことができ、誤差の蓄積問題が軽減される。提案手法であるSequenceMatchは、敵対的なトレーニングや大規模なアーキテクチャの変更なしに実装でき、SequenceMatch-$\chi^2$発散を使用することができる。実験的に、SequenceMatchトレーニングは、言語モデルによるテキスト生成においてMLEよりも改善をもたらすことが示された。</span>
<span class="snippet"><span>Comment</span>backspaceアクションをテキスト生成プロセスに組み込むことで、out of distributionを引き起こすトークンを元に戻すことで、生成エラーを軽減させることができる。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/e22d059f-5475-417c-aea2-d1fd55b6c23a" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/KnowledgeGraph.html">#KnowledgeGraph</a>
<span class="issue_date">Issue Date: 2023-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/768">Unifying Large Language Models and Knowledge Graphs: A Roadmap, Shirui Pan+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>LLMsとKGsを統合することで、自然言語処理や人工知能の分野で注目を集めている。KGsは豊富な事実知識を明示的に格納しているが、構築が困難であり、進化する性質を持っている。一方、LLMsはブラックボックスモデルであり、事実知識を捉えたりアクセスしたりすることができない。本記事では、LLMsとKGsを統合するための展望を示し、KG-enhanced LLMs、LLM-augmented KGs、Synergized LLMs + KGsの3つのフレームワークを提案する。既存の取り組みをレビューし、今後の研究方向を指摘する。</span>
<span class="snippet"><span>Comment</span>LLMsとKGの統合に関するロードマップを提示。KGをLLMの事前学習や推論に組み込む方法、KGタスクにLLMを利用する方法、LLMとKGの双方向のreasonieg能力を高める方法などをカバーしている。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/c008d409-e5db-4140-a82c-a658a4847780" alt="image" loading="lazy"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/766">Textbooks Are All You Need, Suriya Gunasekar+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、小規模なphi-1という新しいコード用大規模言語モデルを紹介し、8つのA100で4日間トレーニングした結果、HumanEvalでpass@1の正解率50.6％、MBPPで55.5％を達成したことを報告しています。また、phi-1は、phi-1-baseやphi-1-smallと比較して、驚くべき新しい性質を示しています。phi-1-smallは、HumanEvalで45％を達成しています。</span>
<span class="snippet"><span>Comment</span>参考: https://twitter.com/hillbig/status/1671643297616654342?s=46&t=JYDYid2m0v7vYaL7jhZYjQ教科書のような品質の良いテキストで事前学習すると性能が向上し（グラフ真ん中）、さらに良質なエクササイズでFinetuningするとより性能が向上する（グラフ右）

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/9f0b945a-f965-42ae-b5d8-ac464359af35" alt="image" loading="lazy">日本語解説: https://dalab.jp/archives/journal/introduction-textbooks-are-all-you-need/ざっくり言うと、教科書で事前学習し、エクササイズでFinetuningすると性能が向上する（= より大きいモデルと同等の性能が得られる）。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-06-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/765">RWKV: Reinventing RNNs for the Transformer Era, Bo Peng+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、トランスフォーマーとRNNの両方の利点を組み合わせた新しいモデルアーキテクチャであるRWKVを提案し、トレーニング中に計算を並列化し、推論中に一定の計算およびメモリの複雑さを維持することができます。RWKVは、同じサイズのトランスフォーマーと同等のパフォーマンスを発揮し、将来的にはより効率的なモデルを作成するためにこのアーキテクチャを活用できることを示唆しています。</span>
<span class="snippet"><span>Comment</span>異なるtransformerとRWKVの計算量とメモリ消費量の比較

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/84d5241f-1702-4bd6-8ce3-0a80ded8f192" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

RWKVの構造は基本的に、residual blockをスタックすることによって構成される。一つのresidual blockは、time-mixing（時間方向の混ぜ合わせ）と、channnel-mixing（要素間での混ぜ合わせ）を行う。　

<br>



<br>

RWKVのカギとなる要素は以下の4つであり、RWKVのブロック、およびLMでのアーキテクチャは以下のようになる：

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/2185d678-8ca1-4017-a052-77c073704253" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/e5559a3c-40ee-4859-ba75-2827c12b5964" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/4af26c0f-5907-4723-b24c-67b02a8025b9" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

ここで、token-shiftは、previsou timestepのinputとのlinear interpolationを現在のinputととることである。これにより再帰性を担保する。

<br>



<br>



<br>



<br>

RWKVは他のLLMと比較し、パラメータ数に対して性能はcomparableであり、context lengthを増やすことで、lossはきちんと低下し、テキスト生成をする際に要する時間は他のLLMと比較して、トークン数に対して線形にしか増加しない。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/c8a39aae-17de-4c43-bfba-b6a54f83205e" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/9baf95d0-9e8c-4c62-a8f3-0f2a0d67ae00" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/a9601b1c-c403-4c2c-bd60-3d2cfa6e512e" alt="image" loading="lazy"></span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<span class="issue_date">Issue Date: 2023-06-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/764">How Language Model Hallucinations Can Snowball, Muru Zhang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>言語モデルを使用する際のリスクとして、幻覚があることが指摘されている。この幻覚は、LMの知識不足によるものだけでなく、以前に生成された幻覚を正当化するために、LMが誤った主張を出力することもあるという仮説が立てられている。ChatGPTとGPT-4は、誤った回答を示し、幻覚のスノーボール効果により、より多くの誤りが生じることがある。また、誤りを含む質問応答データセットが構築され、LMが自分自身の誤りを識別できることも示された。</span>
<span class="snippet"><span>Comment</span>LLMによるhallucinationは、単にLLMの知識不足によるものだけではなく、LLMが以前に生成したhallucinationを正当化するために、誤った出力を生成してしまうという仮説を提起し、この仮説を検証した研究。これをhallucination snowballと呼ぶ。これにより、LLMを訓練する際に、事実に対する正確さを犠牲にして、流暢性と一貫性を優先し言語モデルを訓練するリスクを示唆している。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/6a9e29b7-953f-4e72-bfdd-85daab9317d6" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-06-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/763">LLMs as Factual Reasoners: Insights from Existing Benchmarks and Beyond, Philippe Laban+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>LLMsを使用して事実の矛盾を検出することが重要であるが、既存の評価ベンチマークに問題があるため、ほとんどのLLMは複雑なタスクに失敗する。そこで、新しい不整合検出ベンチマークのプロトコルであるSummEditsを提案し、実装した。SummEditsは高い再現性を持ち、ほとんどのLLMは苦戦する。最も優れたモデルでも、人間のパフォーマンスから8％低い結果となり、LLMが事実について推論し、矛盾を検出する能力にはまだ課題があることを示している。</span>
<span class="snippet"><span>Comment</span>既存の不整合検出のベンチマークデータセットでは、7+%を超えるサンプルに対して、mislabeledなサンプルが含まれており、ベンチマークのクオリティに問題があった。そこでSummEditsと呼ばれる事実の矛盾の検出力を検証するための新たなプロトコルを提案。既存の不整合検出では、既存のLLMを用いて比較した結果、最も不整合検出で性能が良かったGPT-4でさえ、人間に対して8%も低い性能であることが示され（要約結果に対して事実の矛盾が含まれているか否か検出するタスク）、まだまだLLMには課題があることが示された。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/45473a67-7f96-4f75-841c-9ccf95852394" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2023-06-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/760">Think Before You Act: Decision Transformers with Internal Working Memory, Jikun Kang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLM）の性能は、トレーニング中にパラメータに振る舞いを記憶する「忘却現象」によって低下する可能性がある。人間の脳は分散型のメモリストレージを利用しており、忘却現象を軽減している。そこで、我々は、内部作業メモリモジュールを提案し、Atariゲームとメタワールドオブジェクト操作タスクの両方でトレーニング効率と汎化性を向上させることを示した。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<span class="issue_date">Issue Date: 2023-06-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/754">OlaGPT: Empowering LLMs With Human-like Problem-Solving Abilities, Yuanzhen Xie+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本論文では、人間の認知フレームワークを模倣することで、複雑な推論問題を解決するための新しい知的フレームワークであるOlaGPTを提案しています。OlaGPTは、注意、記憶、推論、学習などの異なる認知モジュールを含み、以前の誤りや専門家の意見を動的に参照する学習ユニットを提供しています。また、Chain-of-Thought（COT）テンプレートと包括的な意思決定メカニズムも提案されています。OlaGPTは、複数の推論データセットで厳密に評価され、最先端のベンチマークを上回る優れた性能を示しています。OlaGPTの実装はGitHubで利用可能です。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<a class="button" href="articles/TextToImageGeneration.html">#TextToImageGeneration</a>
<span class="issue_date">Issue Date: 2023-06-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/741">ViCo: Detail-Preserving Visual Condition for Personalized Text-to-Image  Generation, Shaozhe Hao+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>拡散モデルを用いたパーソナライズされた画像生成において、高速で軽量なプラグインメソッドであるViCoを提案。注目モジュールを導入し、注目ベースのオブジェクトマスクを使用することで、一般的な過学習の劣化を軽減。元の拡散モデルのパラメータを微調整せず、軽量なパラメータトレーニングだけで、最新のモデルと同等またはそれ以上の性能を発揮することができる。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<span class="issue_date">Issue Date: 2023-06-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/732">AVIS: Autonomous Visual Information Seeking with Large Language Models, Ziniu Hu+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本論文では、自律的な情報収集ビジュアル質問応答フレームワークであるAVISを提案する。AVISは、大規模言語モデル（LLM）を活用して外部ツールの利用戦略を動的に決定し、質問に対する回答に必要な不可欠な知識を獲得する。ユーザースタディを実施して収集したデータを用いて、プランナーや推論エンジンを改善し、知識集約型ビジュアル質問応答ベンチマークで最先端の結果を達成することを示している。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/9df9b0ce-1f95-4e48-a4c9-b4c6b87d0ac6" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-06-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/729">KoLA: Carefully Benchmarking World Knowledge of Large Language Models, Jifan Yu+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>LLMの評価を改善するために、KoLAという知識指向のベンチマークを構築した。このベンチマークは、19のタスクをカバーし、Wikipediaと新興コーパスを使用して、知識の幻覚を自動的に評価する独自の自己対照メトリックを含む対照的なシステムを採用している。21のオープンソースと商用のLLMを評価し、KoLAデータセットとオープン参加のリーダーボードは、LLMや知識関連システムの開発の参考資料として継続的に更新される。</span>
<a class="button" href="articles/PairWise.html">#PairWise</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Ensemble.html">#Ensemble</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/ModelMerge.html">#ModelMerge</a>
<span class="issue_date">Issue Date: 2023-06-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/708">LLM-Blender: Ensembling Large Language Models with Pairwise Ranking and  Generative Fusion, Dongfu Jiang+, N_A, ACL'23</a>
<span class="snippet"><span>Summary</span>LLM-Blenderは、複数の大規模言語モデルを組み合わせたアンサンブルフレームワークであり、PairRankerとGenFuserの2つのモジュールから構成されています。PairRankerは、専門的なペアワイズ比較方法を使用して候補の出力間の微妙な違いを区別し、GenFuserは、上位ランクの候補をマージして改善された出力を生成します。MixInstructというベンチマークデータセットを導入し、LLM-Blenderは、個々のLLMsやベースライン手法を大幅に上回り、大きなパフォーマンス差を確立しました。</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-05-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/702">Visualizing Linguistic Diversity of Text Datasets Synthesized by Large  Language Models, Emily Reif+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>LLMsを使用して生成されたデータセットの構文的多様性を理解し分析するための新しい可視化ツールであるLinguisticLensが提供された。このツールは、テキストを構文、語彙、および意味の軸に沿ってクラスタリングし、階層的な可視化をサポートしている。ライブデモはshorturl.at/zHOUVで利用可能。</span>
<span class="snippet"><span>Comment</span>LLMを用いてfew-shot promptingを利用して生成されたデータセットを理解し評価することは難しく、そもそもLLMによって生成されるデータの失敗に関してはあまり理解が進んでいない（e.g. repetitionなどは知られている）。この研究では、LLMによって生成されたデータセットの特性を理解するために、構文・語彙・意味の軸に沿ってクラスタリングすることで、データセットの特性を可視化することで、このような課題を解決することをサポートしている。

<br>



<br>



<br>



<br>

特に、従来研究ではGoldが存在することが前提な手法が利用されてきた（e.g. 生成データを利用しdownstream taskの予測性能で良さを測る、Gold distributionとdistributionを比較する）。しかし、このような手法では、synthetic data firstなシチュエーションで、Goldが存在しない場合に対処できない。このような問題を解決するためにGold dataが存在しない場合に、データの構文・語彙・意味に基づくクラスタリングを実施し結果を可視化し、human-in-the-loopの枠組みでデータセットの良さを検証する方法を提案している。可視化例

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/4bc73eee-9d26-4405-9d61-eca0a39fa852" alt="image" loading="lazy">実装: https://github.com/PAIR-code/interpretability/tree/master/data-synth-syntax</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/DataDistillation.html">#DataDistillation</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<span class="issue_date">Issue Date: 2023-05-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/700">LIMA: Less Is More for Alignment, Chunting Zhou+, N_A, NeurIPS'23</a>
<span class="snippet"><span>Summary</span>本研究では、65BパラメータのLLaMa言語モデルであるLIMAを訓練し、強化学習や人間の好みモデリングなしに、厳選された1,000のプロンプトとレスポンスのみで標準的な教師あり損失で微調整しました。LIMAは、幅広いクエリに対応する驚くべき強力なパフォーマンスを示し、トレーニングデータに現れなかった未知のタスクにも一般化する傾向があります。制御された人間の研究では、LIMAのレスポンスは、GPT-4、Bard、DaVinci003と比較して優れていることが示されました。これらの結果から、大規模言語モデルのほとんどの知識は事前トレーニング中に学習され、高品質の出力を生成するためには限られた指示調整データしか必要ないことが示唆されます。</span>
<span class="snippet"><span>Comment</span>LLaMA65Bをたった1kのdata point（厳選された物）でRLHF無しでfinetuningすると、旅行プランの作成や、歴史改変の推測（？）幅広いタスクで高いパフォーマンスを示し、未知のタスクへの汎化能力も示した。最終的にGPT3,4,BARD,CLAUDEよりも人間が好む回答を返した。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/db025381-0bf0-47a3-bd18-5d88bff666df" alt="image" loading="lazy">LLaMAのようなオープンでパラメータ数が少ないモデルに対して、少量のサンプルでfinetuningするとGPT4に迫れるというのはgamechangerになる可能性があるopenreview: https://openreview.net/forum?id=KBMOKmX2he</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2023-05-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/699">Symbol tuning improves in-context learning in language models, Jerry Wei+, N_A, EMNLP'23</a>
<span class="snippet"><span>Summary</span>本研究では、自然言語ラベルをシンボルに置き換えて言語モデルを微調整する「symbol tuning」を提案し、未知のタスクや不明確なプロンプトに対して堅牢な性能を示すことを示した。また、symbol tuningによりアルゴリズム的推論タスクでのパフォーマンス向上が見られ、以前の意味的知識を上書きする能力が向上していることが示された。Flan-PaLMモデルを使用して実験が行われ、最大540Bパラメータまで利用された。</span>
<span class="snippet"><span>Comment</span>概要やOpenReviewの内容をざっくりとしか読めていないが、自然言語のラベルをランダムな文字列にしたり、instructionをあえて除外してモデルをFinetuningすることで、promptに対するsensitivityや元々モデルが持っているラベルと矛盾した意味をin context learningで上書きできるということは、学習データに含まれるテキストを調整することで、正則化の役割を果たしていると考えられる。つまり、ラベルそのものに自然言語としての意味を含ませないことや、instructionを無くすことで、（モデルが表層的なラベルの意味や指示からではなく）、より実際のICLで利用されるExaplarからタスクを推論するように学習されるのだと思われる。

<br>

<img src="https://github.com/user-attachments/assets/a4050a09-d319-481d-9b63-70b2ee9b5aad" alt="image" loading="lazy">OpenReview:https://openreview.net/forum?id=vOX7Dfwo3v</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/DataDistillation.html">#DataDistillation</a>
<span class="issue_date">Issue Date: 2023-05-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/698">DoReMi: Optimizing Data Mixtures Speeds Up Language Model Pretraining, Sang Michael Xie+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本論文では、言語モデルの性能に影響を与える事前学習データのドメインの混合比について、DoReMiという手法を提案する。DoReMiは、小さなプロキシモデルを使用してドメインの重みを生成し、再サンプリングして大きなモデルをトレーニングすることで、効率的にドメインの重みを見つけることができる。実験では、DoReMiはThe PileやGLaMデータセットで高い精度を発揮し、few-shot下流精度を6.5％改善することができる。</span>
<span class="snippet"><span>Comment</span>事前学習する際の各ドメインのデータをどのような比率でmixtureするかの話。各ドメインごとに小さなproxy modelを訓練し、downstream taskの知識無しでドメインごとの重みを生成。データセットを生成されたドメインごとの重みに従いリサンプリングすることで、（1/30のプロキシモデルを用いた場合）オリジナルのデータより2.6倍高速で、6.5%oneshotのaccuracyを向上させることに成功

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/2c0b125a-5ecc-4ee3-8c3b-022c03606c60" alt="image" loading="lazy"></span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/TabularData.html">#TabularData</a>
<span class="issue_date">Issue Date: 2023-05-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/697">StructGPT: A General Framework for Large Language Model to Reason over  Structured Data, Jinhao Jiang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本論文では、大規模言語モデル（LLMs）を使用して構造化データ上のゼロショット推論能力を改善する方法について研究し、Iterative Reading-then-Reasoning（IRR）アプローチを提案しました。このアプローチでは、構造化データから関連するエビデンスを収集する専門的な関数を構築し、LLMsに収集された情報に基づいて推論タスクに集中させます。外部インターフェースの支援を受けて、LLMsが構造化データ上で推論するためのinvoking-linearization-generation手順を提案し、与えられたクエリに対する目標回答に徐々に近づくことができます。徹底的な実験により、アプローチの有効性を示し、フルデータの教師ありチューニングベースラインと同等のパフォーマンスを達成することができます。コードとデータは、\url{https://github.com/RUCAIBox/StructGPT}で公開されています。</span>
<span class="snippet"><span>Comment</span>構造化データに対するLLMのゼロショットのreasoning能力を改善。構造化データに対するQAタスクで手法が有効なことを示した。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/ac9732f1-a9c9-4620-8bf8-053415a5e654" alt="image" loading="lazy"></span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Planning.html">#Planning</a>
<span class="issue_date">Issue Date: 2023-05-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/696">Chain-of-Symbol Prompting Elicits Planning in Large Langauge Models, Hanxu Hu+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本論文では、LLMsを使用して複雑な計画タスクを解決するための新しいベンチマークであるNatural Language Planning（NLP）を提案し、CoSという新しい手法を導入して、LLMsがシンボリック表現をより理解しやすくすることを示した。CoSはChatGPTやInstructGPTでの入力トークン数を削減し、Brick Worldで60.8％の精度を達成するなど、性能の向上を実現した。</span>
<span class="snippet"><span>Comment</span>LLMは複雑なプランニングが苦手なことが知られており、複雑な環境を自然言語ではなく、spatialでsymbolicなトークンで表現することで、プランニングの性能が向上したという話

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/50e9d7e2-bd75-4341-b7a0-394dc2eaf915" alt="image" loading="lazy">OpenReview: https://openreview.net/forum?id=B0wJ5oCPdB</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-05-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/695">Evidence of Meaning in Language Models Trained on Programs, Charles Jin+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、プログラムのコーパスを用いて言語モデルが意味を学習できることを示し、プログラム合成が言語モデルの意味の存在を特徴づけるための中間テストベッドとして適していることを述べている。Transformerモデルを用いた実験により、言語の意味を学習するための帰納バイアスを提供しないにもかかわらず、線形プローブがモデルの状態から現在および将来のプログラム状態の抽象化を抽出できることがわかった。さらに、プローブの精度と、モデルが仕様を実装するプログラムを生成する能力との間には、強い統計的有意な相関があることが示された。本研究は、言語モデルの訓練に新しい技術を提案するものではなく、(形式的な)意味の習得と表現に関する実験的なフレームワークを開発し、洞察を提供するものである。</span>
<span class="snippet"><span>Comment</span>参考: https://twitter.com/hillbig/status/1660409936264970240?s=46&t=QJho5ctFkeax7s_UMOfWBQ

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/9db7d5b5-0380-41ab-8570-a0ae873db9ef" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/029d2547-1358-48b1-8fb5-c71e67baf53f" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/80a300e2-1e1d-4d7e-b308-8961c497ae4a" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<span class="issue_date">Issue Date: 2023-05-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/693">What In-Context Learning "Learns" In-Context: Disentangling Task  Recognition and Task Learning, Jane Pan+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）がどのようにコンテキスト学習（ICL）を利用してタスクを解決するかを調査しました。タスク認識（TR）とタスク学習（TL）の役割を分離するための実験を行い、LLMsがデモンストレーションを通じて暗黙的に学習を行う可能性があることを示しました。また、モデルがスケールするにつれてTLのパフォーマンスが改善されることも明らかになりました。これらの結果は、ICLの背後にある2つの異なる力を明らかにし、将来のICL研究でそれらを区別することを提唱しています。</span>
<span class="snippet"><span>Comment</span>LLMがIn context Learningで新しい何かを学習しているのかを調査

<br>

TaskRecognition（TR）はGround Truth無しでデモンストレーションのみで実施

<br>

TaskLearning（TL）は訓練データになかったテキストとラベルのマッピングを捉える必要があるタスク。

<br>

TRはモデルサイズでスケールしなかったが、TLはモデルサイズに対してスケールした

<br>

→ 事前学習で学習してきた知識を引っ張ってくるだけではTLは実施できないので、TRでは何も学習していないが、TLにおいては新しく何かが学習されてるんじゃない?ということだろうか

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/729cc613-7487-47be-9225-e02921091969" alt="image" loading="lazy"></span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/CodeGeneration.html">#CodeGeneration</a>
<span class="issue_date">Issue Date: 2023-05-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/692">CodeT5+: Open Code Large Language Models for Code Understanding and  Generation, Yue Wang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、コードのためのエンコーダーデコーダーLLMsのファミリーである「CodeT5+」を提案し、様々なダウンストリームコードタスクに柔軟に適合することができるようにしました。また、事前学習オブジェクティブの混合を提案することで、事前学習とファインチューニングの不一致を緩和し、スパンデノイジング、コントラスティブラーニング、テキストコードマッチング、因果LM事前学習タスクを含めました。CodeT5+は、異なる設定で20以上のコード関連ベンチマークで徹底的に評価され、最先端のモデルパフォーマンスを観察しました。特に、instruction-tuned CodeT5+ 16Bは、他のオープンなコードLLMsに対して、HumanEvalコード生成タスクで新しい最先端の結果を達成しました。</span>
<span class="snippet"><span>Comment</span>様々なコードの理解と生成タスクをサポート

<br>

異なる訓練手法によって計算効率改善

<br>

20種類のコードベンチマークで、様々な設定「ゼロショット、finetuning, instruction tuning等）を実施した結果、コード補完、math programming, text to code retrievalにおいてSoTA達成</span>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<span class="issue_date">Issue Date: 2023-05-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/690">TrueTeacher: Learning Factual Consistency Evaluation with Large Language  Models, Zorik Gekhman+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>自然言語推論（NLI）モデルを使用した事実の一貫性評価には限界があり、大規模言語モデル（LLMs）は計算コストが高いため実用的ではない。そこで、TrueTeacherというLLMを使用して多様なモデル生成要約を注釈付けすることによって合成データを生成する方法を提案し、既存の合成データ生成方法と比較して優位性と堅牢性を示した。140万の例を含む大規模な合成データセットを公開した。</span>
<span class="snippet"><span>Comment</span>Factual Consistency Evaluationに関する研究。オリジナルのテキストに対して、様々な規模の言語モデルを用いて要約を生成。生成された要約に対してfactual informationが正しく含まれているかをラベル付けする方法を提案。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/4fb420c8-6a80-4737-bc08-8e59b0ed89d6" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<span class="issue_date">Issue Date: 2023-05-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/686">Evidence of Meaning in Language Models Trained on Programs, Charles Jin+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、プログラムのコーパスを用いて言語モデルが意味を学習できることを示し、プログラム合成が言語モデルの意味の存在を特徴づけるための中間テストベッドとして適していることを述べている。Transformerモデルを用いた実験により、言語の意味を学習するための帰納バイアスを提供しないにもかかわらず、線形プローブがモデルの状態から現在および将来のプログラム状態の抽象化を抽出できることがわかった。また、正しいプログラムを生成することを学習し、平均的に訓練セットよりも短いプログラムを生成することも示した。本論文は、言語モデルの訓練に新しい技術を提案するものではなく、(形式的な)意味の習得と表現に関する実験的なフレームワークを開発し、洞察を提供する。</span>
<span class="snippet"><span>Comment</span>プログラムのコーパスでLLMをNext Token Predictionで訓練し

<br>

厳密に正解とsemanticsを定義した上で、訓練データと異なるsemanticsの異なるプログラムを生成できることを示した。

<br>



<br>

LLMが意味を理解していることを暗示している

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/fa4d2c68-bdbe-40ae-990d-10814ac8a204" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-05-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/684">Tree of Thoughts: Deliberate Problem Solving with Large Language Models, Shunyu Yao+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>言語モデルの推論には制限があり、探索や戦略的先読みが必要なタスクには不十分である。そこで、Tree of Thoughts（ToT）という新しいフレームワークを導入し、Chain of Thoughtアプローチを一般化して、意思決定を行うことができるようにした。ToTにより、言語モデルは複数の異なる推論パスを考慮して、次の行動を決定することができる。ToTは、Game of 24、Creative Writing、Mini Crosswordsなどのタスクにおいて、言語モデルの問題解決能力を大幅に向上させることができることを示している。</span>
<span class="snippet"><span>Comment</span>Self Concistencyの次

<br>

Non trivialなプランニングと検索が必要な新たな3つのタスクについて、CoT w/ GPT4の成功率が4%だったところを、ToTでは74%を達成

<br>



<br>

論文中の表ではCoTのSuccessRateが40%と書いてあるような?

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/6f853009-8d08-43b4-a7da-61677f4aca3a" alt="image" loading="lazy"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Faithfulness.html">#Faithfulness</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<span class="issue_date">Issue Date: 2023-05-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/666">Language Models Don't Always Say What They Think: Unfaithful   Explanations in Chain-of-Thought Prompting, Miles Turpin+, N_A, NeurIPS'23</a>
<span class="snippet"><span>Summary</span>LLMsによる推論において、chain-of-thought reasoning（CoT）と呼ばれる説明を生成することができるが、この説明がモデルの予測の真の理由を誤って表現することがあることがわかった。バイアスのある特徴をモデルの入力に追加することで、CoT説明が大きく影響を受けることが示された。この結果は、LLMsに対する信頼を高めるために、説明の忠実度を評価し、改善する必要があることを示唆している。</span>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<a class="button" href="articles/review.html">#review</a>
<span class="issue_date">Issue Date: 2023-05-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/647">Towards Personalized Review Summarization by Modeling Historical Reviews  from Customer and Product Separately, Xin Cheng+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>レビュー要約は、Eコマースのウェブサイトにおいて製品レビューの主要なアイデアを要約することを目的としたタスクである。本研究では、評価情報を含む2種類の過去のレビューをグラフ推論モジュールと対比損失を用いて別々にモデル化するHHRRSを提案する。レビューの感情分類と要約を共同で行うマルチタスクフレームワークを採用し、4つのベンチマークデータセットでの徹底的な実験により、HHRRSが両方のタスクで優れた性能を発揮することが示された。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/KnowledgeEditing.html">#KnowledgeEditing</a>
<span class="issue_date">Issue Date: 2023-05-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/643">Mass-Editing Memory in a Transformer, Kevin Meng+, N_A, ICLR'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデルを更新することで、専門的な知識を追加できることが示されているしかし、これまでの研究は主に単一の関連付けの更新に限定されていた本研究では、MEMITという方法を開発し、多数のメモリを直接言語モデルに更新することができることを実験的に示したGPT-J（6B）およびGPT-NeoX（20B）に対して数千の関連付けまでスケーリングでき、これまでの研究を桁違いに上回ることを示したコードとデータはhttps://memit.baulab.infoにあります。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Zero/FewShotPrompting.html">#Zero/FewShotPrompting</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2023-05-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/642">Challenging BIG-Bench Tasks and Whether Chain-of-Thought Can Solve Them, Mirac Suzgun+, N_A, ACL'23</a>
<span class="snippet"><span>Summary</span>BIG-Bench Hard (BBH) is a suite of 23 challenging tasks that current language models have not been able to surpass human performance on. This study focuses on applying chain-of-thought prompting to BBH tasks and found that PaLM and Codex were able to surpass human performance on 10 and 17 tasks, respectively. The study also found that CoT prompting is necessary for tasks that require multi-step reasoning and that CoT and model scale interact to enable new task performance on some BBH tasks.</span>
<span class="snippet"><span>Comment</span>単なるfewshotではなく、CoT付きのfewshotをすると大幅にBIG-Bench-hardの性能が向上するので、CoTを使わないanswer onlyの設定はモデルの能力の過小評価につながるよ、という話らしい

<br>

<img src="https://github.com/user-attachments/assets/0545214a-a267-489d-8af9-82d21e08ff6c" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/e5308c66-0bee-4d2c-b973-86478842b772" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Poisoning.html">#Poisoning</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2023-05-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/629">Poisoning Language Models During Instruction Tuning, Alexander Wan+, N_A, ICML'23</a>
<span class="snippet"><span>Summary</span>Instruction-tuned LMs（ChatGPT、FLAN、InstructGPTなど）は、ユーザーが提出した例を含むデータセットでfinetuneされる。本研究では、敵対者が毒入りの例を提供することで、LMの予測を操作できることを示す。毒入りの例を構築するために、LMのbag-of-words近似を使用して入出力を最適化する。大きなLMほど毒入り攻撃に対して脆弱であり、データフィルタリングやモデル容量の削減に基づく防御は、テストの正確性を低下させながら、中程度の保護しか提供しない。</span>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Annotation.html">#Annotation</a>
<a class="button" href="articles/TransferLearning.html">#TransferLearning</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2023-05-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/615">Frustratingly Easy Label Projection for Cross-lingual Transfer, Yang Chen+, N_A, ACL'23</a>
<span class="snippet"><span>Summary</span>多言語のトレーニングデータの翻訳は、クロスリンガル転移の改善に役立つスパンレベル注釈が必要なタスクでは、注釈付きスパンを翻訳されたテキストにマッピングするために追加のラベルプロジェクションステップが必要マーク-翻訳法を利用するアプローチが従来の注釈プロジェクションと比較してどのようになるかについての実証的な分析を行ったEasyProjectと呼ばれるマーク-翻訳法の最適化されたバージョンが多言語に簡単に適用でき、より複雑な単語アラインメントベースの方法を上回ることを示したすべてのコードとデータが公開される</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/Inference.html">#Inference</a>
<span class="issue_date">Issue Date: 2023-04-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/601">Efficiently Scaling Transformer Inference, Reiner Pope+, N_A, MLSys'23</a>
<span class="snippet"><span>Summary</span>大規模Transformerベースのモデルの推論のエンジニアリングのトレードオフを理解するために、最適な多次元分割技術を選択するための単純な解析モデルを開発低レベルの最適化と組み合わせることで、500B+パラメータモデルのレイテンシーとモデルFLOPS利用率のトレードオフにおいて、FasterTransformerベンチマークスイートを上回る新しいParetoフロンティアを実現適切な分割により、マルチクエリアテンションの低いメモリ要件により、32倍の大きなコンテキスト長にスケーリング可能int8ウェイト量子化を使用した生成中の低バッチサイズレイテンシーは、トークンあたり29msであり、入力トークンの大バッチサイズ処理において76％のMFUを実現し、PaLM 540Bパラメータモデルにおいて2048トークンの長いコンテキスト長をサポートしている。</span>
<span class="snippet"><span>Comment</span>特にMultiquery Attentionという技術がTransformerのinferenceのコスト削減に有効らしい</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Controllable.html">#Controllable</a>
<span class="issue_date">Issue Date: 2023-04-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/594">Controlled Text Generation with Natural Language Instructions, Wangchunshu Zhou+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、自然言語の説明と制約のデモンストレーションに基づいて、異なる制約を組み込むことができる制御されたテキスト生成フレームワークであるInstructCTGを提案しています。制約を自然言語の指示に言い換えて、弱く監督されたトレーニングデータを形成し、事前にトレーニングされた言語モデルを微調整して、さまざまなタイプの制約を組み込むことができます。InstructCTGは、異なる制約タイプに対してより柔軟であり、生成品質と速度にはほとんど影響を与えず、再トレーニングなしに新しい制約に適応することができます。</span>
<span class="snippet"><span>Comment</span><img src="https://user-images.githubusercontent.com/12249301/235351783-1435816a-b51a-4379-b4b5-cf3097b70de5.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/TheoryOfMind.html">#TheoryOfMind</a>
<span class="issue_date">Issue Date: 2023-04-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/581">Boosting Theory-of-Mind Performance in Large Language Models via Prompting, Moghaddam+, Johns Hopkins University, arXiv'23</a>
<span class="snippet"><span>Comment</span>LLMはTheory-of-mind reasoningタスクが苦手なことが知られており、特にzero shotでは非常にパフォーマンスが低かった。ToMタスクとは、エージェントの信念、ゴール、メンタルstate、エージェントが何を知っているか等をトラッキングすることが求められるタスクのこと。このようなタスクはLLMが我々の日常生活を理解する上で重要。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/235207785-8a4c5e0d-4825-4947-8ae6-a8176ad7c898.png" alt="image" loading="lazy">

<br>



<br>

↑のToM Questionのシナリオと問題

<br>

Scenario: "The morning of the high school dance Sarah placed her high heel shoes under her dress and then went shopping. That afternoon, her sister borrowed the shoes and later put them under Sarah's bed."

<br>

Question: When Sarah gets ready, does she assume her shoes are under her dress?

<br>



<br>

しかし、Zero shot CoTのようなstep by step thinking, CoTを適切に行うことで、OpenAIの直近3つのモデルのAccuracyが80%を超えた。特に、GPT4は100％のAccuracyを達成。人間は87％だった。

<br>



<br>

この結果は、少なくとのこの論文でテストしたドメインではLLMのsocial reasoningのパフォーマンスをどのようにブーストするかを示しており、LLMのbehaviorは複雑でsensitiveであることを示唆している。</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/TabularData.html">#TabularData</a>
<span class="issue_date">Issue Date: 2023-04-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/580">Large Language Models are Versatile Decomposers: Decompose Evidence and Questions for Table-based Reasoning, Ye+, University of Science and Technology of China, SIGIR'23</a>
<span class="snippet"><span>Comment</span>テーブルとquestionが与えられた時に、questionをsub-questionとsmall tableにLLMでin-context learningすることで分割。subquestionの解を得るためのsqlを作成しスポットを埋め、hallucinationを防ぐ。最終的にLLM Reasonerが解答を導出する。TabFact Reasoningで初めて人間を超えた性能を発揮。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/235204690-75f6b56b-3291-42e4-9e39-710694f36648.jpeg" alt="image" loading="lazy"></span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/DialogueGeneration.html">#DialogueGeneration</a>
<span class="issue_date">Issue Date: 2023-04-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/575">q2d: Turning Questions into Dialogs to Teach Models How to Search, Bitton+, The Hebrew University of Jerusalem （w_ Google Research）, arXiv'23</a>
<span class="snippet"><span>Comment</span>LLMにquestionを与え、questionを解決するためのinformation seekingの対話ログを生成させる。このデータを用いて、dialogueからquestionを生成するモデルを訓練し、検索APIなどに渡せるようにした研究。全く対話のログがないドメインのデータに対しても、人間と遜色ない高品質な対話が生成可能。これにより、query generationモデルの更なる高性能化が実現できる。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/235137446-10e6633f-1d4b-46ea-afda-630b7cd53246.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Controllable.html">#Controllable</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-04-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/573">Tractable Control for Autoregressive Language Generation, Zhang+, UCLA, arXiv'23</a>
<span class="snippet"><span>Comment</span>自然言語生成モデルで、何らかのシンプルなconstiaint αの元p(xi|xi-1,α)を生成しようとしても計算ができない。このため、言語モデルをfinetuningするか、promptで制御するか、などがおこなわれる。しかしこの方法は近似的な解法であり、αがたとえシンプルであっても（何らかの語尾を付与するなど）、必ずしも満たした生成が行われるとは限らない。これは単に言語モデルがautoregressiveな方法で次のトークンの分布を予測しているだけであることに起因している。そこで、この問題を解決するために、tractable probabilistic model（TPM）を導入し、解決した。

<br>

評価の結果、CommonGenにおいて、SoTAを達成した。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/235130061-21e51e59-dbfa-4c64-bd7b-27f0de2618c0.jpeg" alt="image" loading="lazy">尚、TPMについては要勉強である</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Education.html">#Education</a>
<a class="button" href="articles/AES(AutomatedEssayScoring).html">#AES(AutomatedEssayScoring)</a>
<a class="button" href="articles/ChatGPT.html">#ChatGPT</a>
<span class="issue_date">Issue Date: 2023-04-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/571">[Paper Note] AI, write an essay for me: A large-scale comparison of human-written  versus ChatGPT-generated essays, Steffen Herbold+, arXiv'23</a>
<span class="snippet"><span>Summary</span>ChatGPTが生成したエッセイは、人間が書いたものよりも質が高いと評価されることが大規模な研究で示された。生成されたエッセイは独自の言語的特徴を持ち、教育者はこの技術を活用する新たな教育コンセプトを開発する必要がある。</span>
<span class="snippet"><span>Comment</span>ChatGPTは人間が書いたエッセイよりも高品質なエッセイが書けることを示した。

<br>



<br>

また、AIモデルの文体は、人間が書いたエッセイとは異なる言語的特徴を示している。たとえば、談話や認識マーカーが少ないが、名詞化が多く、語彙の多様性が高いという特徴がある、とのこと。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/235142851-756a418f-3c5a-4ae6-9309-0f077b1d017b.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-04-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/569">Exploring the Curious Case of Code Prompts, Zhang+, University of Pennsylvania, arXiv'23</a>
<span class="snippet"><span>Comment</span>コードベースのLLMに対して、reasoningタスクを解かせる際には、promptもコードにすると10パーセント程度性能上がる場合があるよ、という研究。

<br>

<img src="https://user-images.githubusercontent.com/12249301/235037840-1fb57af3-5296-4831-9f80-26886c913431.jpeg" alt="image" loading="lazy">ただし、平均的にはテキストプロンプトの方が良く、一部タスクで性能が改善する、という温度感な模様

<br>

<img src="https://user-images.githubusercontent.com/12249301/235038209-b43dcdcb-301e-4879-a99e-8c8df32e6cf5.jpeg" alt="image" loading="lazy">コードベースのモデルをtextでinstruction tuningしている場合でも、効果があるタスクがある。</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-04-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/568">Answering Questions by Meta-Reasoning over Multiple Chains of Thought, Yoran+, Tel Aviv University （w_ Allen Institute for AI）, arXiv'23</a>
<span class="snippet"><span>Comment</span>self-consistency 558 のようなvoting basedなアルゴリズムは、複数のCoTのintermediate stepを捨ててしまい、結果だけを採用するが、この研究は複数のCoTの中からquestionに回答するために適切なfactual informationを抽出するMeta Reasonerを導入し、複数のCoTの情報を適切に混在させて適切な回答を得られるようにした。

<br>



<br>



<br>



<br>

7個のMulti Hop QAデータでstrong baselineをoutperformし、人間が回答をverificationするための高品質な説明を生成できることを示した。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/235135436-11dca529-771a-402b-a4ef-9b6deacec32e.jpeg" alt="image" loading="lazy"></span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-04-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/564">Language Models Enable Simple Systems for Generating Structured Views of Heterogeneous Data Lakes, Arora+, Stanford University, arXiv'23</a>
<span class="snippet"><span>Comment</span>LLMを使うことで、半構造化文章から自動的にqueryableなテーブルを作成することを試みた研究

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/235146591-dc608755-e719-4418-ace9-29401919d4eb.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<span class="issue_date">Issue Date: 2023-04-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/558">Self-consistency improves chain of thought reasoning in language models, Wang+, Google Research, ICLR'23</a>
<span class="snippet"><span>Comment</span>self-consistencyと呼ばれる新たなCoTのデコーディング手法を提案。

<br>



<br>

これは、難しいreasoningが必要なタスクでは、複数のreasoningのパスが存在するというintuitionに基づいている。

<br>



<br>



<br>



<br>

self-consistencyではまず、普通にCoTを行う。そしてgreedyにdecodingする代わりに、以下のようなプロセスを実施する：

<br>



<br>

1. 多様なreasoning pathをLLMに生成させ、サンプリングする。

<br>



<br>

2. 異なるreasoning pathは異なるfinal answerを生成する（= final answer set）。

<br>



<br>

3. そして、最終的なanswerを見つけるために、reasoning pathをmarginalizeすることで、final answerのsetの中で最も一貫性のある回答を見出す。

<br>



<br>



<br>



<br>

これは、もし異なる考え方によって同じ回答が導き出されるのであれば、その最終的な回答は正しいという経験則に基づいている。

<br>



<br>

self-consistencyを実現するためには、複数のreasoning pathを取得した上で、最も多いanswer a_iを選択する（majority vote）。これにはtemperature samplingを用いる（temperatureを0.5やら0.7に設定して、より高い信頼性を保ちつつ、かつ多様なoutputを手に入れる）。

<br>



<br>

temperature samplingについては[こちら](https://openreview.net/pdf?id=rygGQyrFvH)の論文を参照のこと。

<br>



<br>

sampling数は増やせば増やすほど性能が向上するが、徐々にサチってくる。サンプリング数を増やすほどコストがかかるので、その辺はコスト感との兼ね合いになると思われる。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234754605-6316223f-4290-45d5-bf7c-64675f07d0c3.png" alt="image" loading="lazy">

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234779335-478f2431-67ea-4b24-9c1b-fa1dd6ac6b45.png" alt="image" loading="lazy">

<br>



<br>

Self-consistencyは回答が閉じた集合であるような問題に対して適用可能であり、open-endなquestionでは利用できないことに注意が必要。ただし、open-endでも回答間になんらかの関係性を見出すような指標があれば実現可能とlimitationで言及している。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2023-04-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/556">Automatic Chain of Thought Prompting in Large Language Models, Zhang+, Shanghai Jiao Tong University, ICLR'23</a>
<span class="snippet"><span>Comment</span>LLMによるreasoning chainが人間が作成したものよりも優れていることを示しているとのこと 532 よりclusteringベースな手法を利用することにより、誤りを含む例が単一のクラスタにまとめられうことを示し、これにより過剰な誤ったデモンストレーションが軽減されることを示した。手法の概要。questionを複数のクラスタに分割し、各クラスタから代表的なquestionをサンプリングし、zero-shot CoTでreasoning chainを作成しpromptに組み込む。最終的に回答を得たいquestionに対しても、上記で生成した複数のquestion-reasoningで条件付けした上で、zeroshot-CoTでrationaleを生成する。

<br>

<img src="https://github.com/user-attachments/assets/35213747-9b5f-4d38-a525-1deafe86cd0c" alt="image" loading="lazy"></span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<span class="issue_date">Issue Date: 2023-04-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/555">Automatic prompt augmentation and selection with chain-of-thought from labeled data, Shum+, The Hong Kong University of Science and Technology, arXiv'23</a>
<span class="snippet"><span>Comment</span>LLMによるreasoning chainが人間が作成したものよりも優れていることを示しているとのこと 532 よりselection phaseで誤ったexampleは直接排除する手法をとっている。そして、強化学習によって、demonstrationのselection modelを訓練している。</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<span class="issue_date">Issue Date: 2023-04-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/539">Personalisation within bounds: A risk taxonomy and policy framework for the alignment of large language models with personalised feedback, Kirk+, Oxford Internet Institute, University of Oxford, arXiv'23</a>
<span class="snippet"><span>Comment</span>abst

<br>



<br>

LLMをPersonalizationすることに関して、どのような方法でPersonalizationすべきかを検討した研究。以下の問題点を指摘。

<br>



<br>

1. アラインメント（RLHFのように何らかの方向性にalignするように補正する技術のこと？）が何を意味するのか明確ではない

<br>



<br>

2. 技術提供者が本質的に主観的な好みや価値観の定義を規定する傾向があること

<br>



<br>

3. クラウドワーカーがの専制によって、我々が実際に何にアラインメントしているのかに関する文書が不足していること

<br>



<br>



<br>



<br>

そして、PersonalizedなLLMの利点やリスクの分類を提示する。

<br>



<br>



<br>



<br>

導入

<br>



<br>

LLMがさまざまな製品に統合されたことで、人間の嗜好に合致し、危険かつ不正確な情報を出力を生成しないことを確保する必要がある。RLHFやred-teamingはこれに役立つが、このような集合的な（多くの人に一つのアラインメントの結果を提示すること）finetuningプロセスが人間の好みや価値観の幅広い範囲を十分に表現できるとは考えにくい。異なる人々はさまざまな意見や価値観を持っており、マイクロレベルのfinetuningプロせせ雨を通じてLLMをPersonalizationすることで、各ユーザとより良いアラインメントが可能になる可能性がある。これを社会的に受け入れられるようにするためにいくつか課題があるので、それについて論じた。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Assessment.html">#Assessment</a>
<a class="button" href="articles/ChatGPT.html">#ChatGPT</a>
<a class="button" href="articles/InformationExtraction.html">#InformationExtraction</a>
<span class="issue_date">Issue Date: 2023-04-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/534">[Paper Note] Evaluating ChatGPT's Information Extraction Capabilities: An Assessment  of Performance, Explainability, Calibration, and Faithfulness, Bo Li+, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、ChatGPTの能力を7つの情報抽出（IE）タスクを通じて評価し、パフォーマンス、説明可能性、キャリブレーション、信頼性を分析しました。標準IE設定ではパフォーマンスが低い一方、オープンIE設定では人間評価で優れた結果を示しました。ChatGPTは高品質な説明を提供するものの、予測に対して過信する傾向があり、キャリブレーションが低いことが明らかになりました。また、元のテキストに対して高い信頼性を示しました。研究のために手動で注釈付けした7つのIEタスクのテストセットと14のデータセットを公開しています。</span>
<span class="snippet"><span>Comment</span>情報抽出タスクにおいてChatGPTを評価した研究。スタンダードなIEの設定ではBERTベースのモデルに負けるが、OpenIEの場合は高い性能を示した。

<br>

また、ChatGPTは予測に対してクオリティが高く信頼に足る説明をしたが、一方で自信過剰な傾向がある。また、ChatGPTの予測はinput textに対して高いfaithfulnessを示しており、予測がinputから根ざしているものであることがわかる。（らしい）あまりしっかり読んでいないが、Entity Typing, NER, Relation Classification, Relation Extraction, Event Detection, Event Argument Extraction, Event Extractionで評価。standardIEでは、ChatGPTにタスクの説明と選択肢を与え、与えられた選択肢の中から正解を探す設定とした。一方OpenIEでは、選択肢を与えず、純粋にタスクの説明のみで予測を実施させた。OpenIEの結果を、3名のドメインエキスパートが出力が妥当か否か判定した結果、非常に高い性能を示すことがわかった。表を見ると、同じタスクでもstandardIEよりも高い性能を示している（そんなことある？？？）つまり、選択肢を与えてどれが正解ですか?ときくより、選択肢与えないでCoTさせた方が性能高いってこと？比較可能な設定で実験できているのだろうか。promptは付録に載っているが、output exampleが載ってないのでなんともいえない。StandardIEの設定をしたときに、CoTさせてるかどうかが気になる。もししてないなら、そりゃ性能低いだろうね、という気がする。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<span class="issue_date">Issue Date: 2023-04-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/529">Scaling Transformer to 1M tokens and beyond with RMT, Bulatov+, DeepPavlov, arXiv'23</a>
<span class="snippet"><span>Comment</span>Reccurent Memory Transformer 523 を使って2Mトークン扱えるようにしたよーという話。

<br>



<br>

ハリーポッターのトークン数が1.5Mらしいので、そのうち小説一冊書けるかもという世界。</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Planning.html">#Planning</a>
<span class="issue_date">Issue Date: 2023-04-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/526">LLM+P: Empowering Large Language Models with Optimal Planning Proficiency, Liu+, University of Texas at Austin, arXiv'23</a>
<span class="snippet"><span>Comment</span>LLMは長いプランニングをすることが苦手だったが、classicalなplannerは適切なinputの形式に変換されていればすぐに最適なプランを導出できる、が、自然言語は受け付けない、といった互いが互いを補完し合う関係にあるので、両者を組み合わせました、という話。

<br>

LLMを利用して、planning problemを記述した自然言語をclassicalなplannerのinputへ変換。その後plannerで最適なplanを見つけ、自然言語にplanを逆翻訳する。

<br>

<img src="https://user-images.githubusercontent.com/12249301/234289649-416a8d9e-628e-422c-bd9b-89d9099b4b1d.jpeg" alt="image" loading="lazy"></span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/TACL.html">#TACL</a>
<span class="issue_date">Issue Date: 2023-04-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/525">Efficient Methods for Natural Language Processing: A Survey, Treviso+, TACL'23</a>
<span class="snippet"><span>Summary</span>NLPのパフォーマンス向上にはスケールの拡大が重要だが、リソース消費も増加する。限られたリソースで効率的にNLPを実施する方法を統合し、指針を提供。効率的な手法の開発に向けた研究方向を示唆。</span>
<span class="snippet"><span>Comment</span>パラメータ数でゴリ押すような方法ではなく、"Efficient"に行うための手法をまとめている

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234287218-2d42766f-5c5c-4cf9-859e-c2b0a5dfd4c3.jpeg" alt="image" loading="lazy"></span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2023-04-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/518">REACT : SYNERGIZING REASONING AND ACTING IN LANGUAGE MODELS, Yao+, Princeton University and Google brain, ICLR'23</a>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

人間は推論と行動をシナジーさせることで、さまざまな意思決定を行える。近年では言語モデルにより言語による推論を意思決定に組み合わせる可能性が示されてきた。たとえば、タスクをこなすための推論トレースをLLMが導けることが示されてきた（Chain-of-Thought）が、CoTは外部リソースにアクセスできないため知識がアップデートできず、事後的に推論を行うためhallucinationやエラーの伝搬が生じる。一方で、事前学習言語モデルをinteractiveな環境において計画と行動に利用する研究が行われているが、これらの研究では、高レベルの目標について抽象的に推論したり、行動をサポートするための作業記憶を維持したりするために言語モデルを利用していない。推論と行動を一般的な課題解決のためにどのようにシナジーできるか、またそのようなシナジーが単独で推論や行動を実施した場合と比較してどのような利益をもたらすかについて研究されていない。

<br>



<br>

そこで、REACTを提案。REACTは推論と行動をLLMと組み合わせて、多様な推論や意思決定タスクを実現するための一般的な枠組みであり、推論トレースとアクションを交互に生成するため、動的に推論を実行して行動するための大まかな計画を作成、維持、調整できると同時に、wikipediaなどの外部ソースとやりとりして追加情報を収集し、推論プロセスに組み込むことが可能となる。

<br>



<br>



<br>



<br>

・要はいままではGeneralなタスク解決モデルにおいては、推論とアクションの生成は独立にしかやられてこなかったけど、推論とアクションを交互作用させることについて研究したよ

<br>



<br>

・そしたら性能がとってもあがったよ

<br>



<br>

・reasoningを人間が編集すれば、エージェントのコントロールもできるよ　という感じ

<br>



<br>



<br>



<br>

イントロ

<br>



<br>

人間は推論と行動の緊密なシナジーによって、不確実な状況に遭遇しても適切な意思決定が行える。たとえば、任意の2つの特定のアクションの間で、進行状況をトレースするために言語で推論したり（すべて切り終わったからお湯を沸かす必要がある）、例外を処理したり、状況に応じて計画を調整したりする（塩がないから代わりに醤油と胡椒を使おう）。また、推論をサポートし、疑問（いまどんな料理を作ることができるだろうか？）を解消するために、行動（料理本を開いてレシピを読んで、冷蔵庫を開いて材料を確確認したり）をすることもある。

<br>



<br>



<br>



<br>

近年の研究では言語での推論を、インタラクティブな意思決定を組み合わせる可能性についてのヒントが得られてきた。一つは、適切にPromptingされたLLMが推論トレースを実行できることを示している。推論トレースとは、解決策に到達するための一連のステップを経て推論をするためのプロセスのことである。しかしながらChain-of-thoughytは、このアプローチでは、モデルが外界対してgroundingできず、内部表現のみに基づい思考を生成するため限界がある。これによりモデルが事後対応的に推論したり、外部情報に基づいて知識を更新したりできないため、推論プロセス中にhallucinationやエラーの伝搬などの問題が発生する可能性が生じる。

<br>



<br>

一方、近年の研究では事前学習言語モデルをinteractiveな環境において計画と行動に利用する研究が行われている。これらの研究では、通常マルチモーダルな観測結果をテキストに変換し、言語モデルを使用してドメイン固有のアクション、またはプランを生成し、コントローラーを利用してそれらを選択または実行する。ただし、これらのアプローチは高レベルの目標について抽象的に推論したり、行動をサポートするための作業記憶を維持したりするために言語モデルを利用していない。

<br>



<br>

推論と行動を一般的な課題解決のためにどのようにシナジーできるか、またそのようなシナジーが単独で推論や行動を実施した場合と比較してどのような利益をもたらすかについて研究されていない。

<br>



<br>



<br>



<br>

LLMにおける推論と行動を組み合わせて、言語推論と意思決定タスクを解決するREACTと呼ばれる手法を提案。REACTでは、推論と行動の相乗効果を高めることが可能。推論トレースによりアクションプランを誘発、追跡、更新するのに役立ち、アクションでは外部ソースと連携して追加情報を収集できる。

<br>



<br>



<br>



<br>

REACTは推論と行動をLLMと組み合わせて、多様な推論や意思決定タスクを実現するための一般的な枠組みである。REACTのpromptはLLMにverbalな推論トレースとタスクを実行するためのアクションを交互に生成する。これにより、モデルは動的な推論を実行して行動するための大まかな計画を作成、維持、調整できると同時に、wikipediaなどの外部ソースとやりとりして追加情報を収集し、推論プロセスに組み込むことが可能となる。

<br>



<br>



<br>



<br>

手法

<br>



<br>

変数を以下のように定義する：

<br>



<br>

・O_t: Observertion on time t

<br>



<br>

・a_t: Action on time t

<br>



<br>

・c_t: context, i.e. (o_1, a_1, o_2, a_2, ..., a_t-1, o_t)

<br>



<br>

・policy pi(a_t | c_t): Action Spaceからアクションを選択するポリシー

<br>



<br>

・A: Action Space

<br>



<br>

・O: Observation Space

<br>



<br>



<br>



<br>

普通はc_tが与えられたときに、ポリシーに従いAからa_tを選択しアクションを行い、アクションの結果o_tを得て、c_t+1を構成する、といったことを繰り返していく。

<br>



<br>



<br>



<br>

このとき、REACTはAをA ∪ Lに拡張しする。ここで、LはLanguage spaceである。LにはAction a_hatが含まれ、a_hatは環境に対して作用をしない。単純にthought, あるいは reasoning traceを実施し、現在のcontext c_tをアップデートするために有用な情報を構成することを目的とする。Lはunlimitedなので、事前学習された言語モデルを用いる。今回はPaLM-540B（c.f. GPT3は175Bパラメータ）が利用され、few-shotのin-context exampleを与えることで推論を行う。それぞれのin-context exampleは、action, thoughtsそしてobservationのtrajectoryを与える。

<br>



<br>



<br>



<br>

推論が重要なタスクでは、thoughts-action-observationステップから成るtask-solving trajectoryを生成する。一方、多数のアクションを伴う可能性がある意思決定タスクでは、thoughtsのみを行うことをtask-solving trajectory中の任意のタイミングで、自分で判断して行うことができる。

<br>



<br>



<br>



<br>

意思決定と推論能力がLLMによってもたらされているため、REACTは4つのuniqueな特徴を持つ：

<br>



<br>

・直感的で簡単なデザイン

<br>



<br>

  ・REACTのpromptは人間のアノテータがアクションのトップに思考を言語で記述するようなストレートなものであり、ad-hocなフォーマットの選択、思考のデザイン、事例の選定などが必要ない。

<br>



<br>

・一般的で柔軟性が高い

<br>



<br>

  ・柔軟な thought spaceと thought-actionのフォーマットにより、REACTはさまざまなタスクにも柔軟に対応できる

<br>



<br>

・高性能でロバスト

<br>



<br>

  ・REACTは1-6個の事例によって、新たなタスクに対する強力な汎化を示す。そして推論、アクションのみを行うベースラインよりも高い性能を示している。REACTはfinetuningの斧系も得ることができ、promptの選択に対してREACTの性能はrobustである。

<br>



<br>

・人間による調整と操作が可能

<br>



<br>

  ・REACTは、解釈可能な意思決定と推論のsequenceを前提としているため、人間は簡単に推論や事実の正しさを検証できる。加えて、thoughtsを編集することによって、m人間はエージェントの行動を制御、あるいは修正できる。

<br>



<br>



<br>



<br>

KNOWLEDGE INTENSIVE REASONING TASKS</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/DataGeneration.html">#DataGeneration</a>
<span class="issue_date">Issue Date: 2023-04-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/517">ChatGPT Outperforms Crowd-Workers for Text-Annotation Tasks, Gilardi+, University of Zurich, NAS'23</a>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

2300件程度のツイートを分類するタスクにおいて、訓練した学部生によるアノテーションを正解とし、クラウドワーカーとChatGPTでのzero-shotでの予測の性能を比較した。分類タスクは、比較的難易度の高い分類問題であり、クラウドワーカーでも正解率は難しいタスクでは15~25%程度であった。このようなタスクでchatgptは40~60%の正解率を示している。

<br>



<br>

比較の結果、5つのタスク中4つのタスクでChatGPTがクラウドワーカーを上回る正解率を示した。

<br>



<br>



<br>



<br>

手法

<br>



<br>

・クラウドワーカーとChatGPTで同じインストラクションを利用し、同じタスクを実施した

<br>



<br>

・inter-notator aggreementを図るために、それぞれのタスクについて各ツイートに少なくとも2人がラベル付を行った

<br>



<br>

・ChatGPTでも同様に、タスクごとに各ツイートには2回同じタスクを実施しデータを収集した

<br>



<br>

・ChatGPTを利用する際は、temperatureを1.0, 0.2の場合で試した。従ってChatGPTのラベル付けは各タスクごとに4セット存在することになる。

<br>



<br>



<br>



<br>

結果

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/231333088-cfe9362a-5412-4ea1-ae8c-67156f13290c.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

5タスク中、4タスクでChatGPTがzero-shotにもかかわらず正解率でworkerを上回った。また高いaggreementを発揮していることを主張。aggreementはtemperatureが低い方が高く、これはtemperatureが低い方がrandomnessが減少するためであると考えられる。aggreementをAccuracyの相関を図ったが、0.17であり弱い相関しかなかった。従って、Accuracyを減少させることなく、一貫性のある結果を得られるlaw temperatureを利用することが望ましいと結論づけている。

<br>



<br>



<br>



<br>

実施したタスク

<br>



<br>

"content moderation"に関するタスクを実施した。content moderationはSNSなどに投稿されるpostを監視するための取り組みであり、たとえばポルトツイートや誤った情報を含む有害なツイート、ヘイトスピーチなどが存在しないかをSNS上で監視をを行うようなタスクである。著者らはcontent moderationはハードなタスクであり、複雑なトピックだし、toy exampleではないことを主張している。実際、著者らが訓練した学部生の間でのinter-annotator aggreementは50%程度であり、難易度が高いタスクであることがわかる（ただし、スタンスdetectionに関してはaggreementが78.3%であった）。

<br>



<br>



<br>



<br>

content moderationのうち、以下の5つのタスクを実施した。

<br>



<br>

・relevance:

<br>



<br>

  ・ツイートがcontent moderationについて直接的に関係することを述べているか否か

<br>



<br>

  ・e.g. SNSにおけるcontent moderation ruleや実践、政府のレギュレーション等

<br>



<br>

  ・content moderationについて述べていないものについてはIRRELEVANTラベルを付与する

<br>



<br>

  ・ただし、主題がcontent moderationのツイートであっても、content moderationについて論じていないものについてはIRRELEVANT扱いとする。

<br>



<br>

  ・このような例としては、TwitterがDonald TrupのTwitterを"disrupted"とlabel付けしたことや、何かについて間違っていると述べているツイート、センシティブな内容を含むツイートなどがあげられる。

<br>



<br>

・Problem/Solution Frames

<br>



<br>

  ・content moderationは2つの見方ができる。それがProblemとSolution

<br>



<br>

  ・Problem: content moderationをPROBLEMとみなすもの。たとえば、フリースピーチの制限など

<br>



<br>

  ・SOLUTION: content moderationをSOLUTIONとみなすもの。たとえば、harmful speechから守ること、など

<br>



<br>

  ・ツイートがcontent moderationのnegativeな影響について強調していたら、PROBLEM（フリースピーチの制限やユーザがポストする内容についてバイアスが生じることなどについて）

<br>



<br>

  ・ツイートがcontent moderationのpositiveな影響について強調していたら、SOKUTION（harmful contentからユーザを守るなど）

<br>



<br>

  ・主題はcontent moderationであるが、positive/negativeな影響について論じていないものはNEUTRAL

<br>



<br>

・Policy Frames

<br>



<br>

  ・content moderationはさまざまんトピックと関連している（たとえば）、健康、犯罪、平等など）

<br>



<br>

  ・content moderatiojnに関するツイートがどのトピックかをラベル付する。ラベルは15種類

<br>



<br>

  ・economy, capcity and resources, modality, fairness and equality, constitutionality and jurisprudence, policy prescription and evaluation, law and order, crime and justice, security and defense, health and safety, quality of life, cultural identity, public opinion, political, external regulation and reputation, other

<br>



<br>

・Stance Detection

<br>



<br>

  ・USのSection 230という法律（websiteにユーザが投稿したコンテンツに対して、webサイトやその他のオンラインプラットフォームが法的責任を問われるのを防ぐ法律）について、ツイートがSection230に対して、positive/negative/neutralなスタンスかをラベル付する

<br>



<br>

・Topic Detection

<br>



<br>

  ・ツイートを6つのトピックにラベル付する

<br>



<br>

  ・Section 230, TRUMP BAN, TWITTER-SUPPORT, PLATFORM POLICIES, COMPLAINTS, other所感

<br>



<br>

そこそこ難易度の高いアノテーションタスクでもzero-shotでturkerの性能を上回るのは非常に素晴らしいことだと思う。ノイジーなデータセットであれば、比較的安価、かつスピーディーに作成できるようになってきたのではないかと思う。

<br>



<br>

ただ、ChatGPTのaggreementを図ることにどれだけ意味があるのだろう、とは思う。同じモデルを利用しているわけで、小tなるLLMをベースにした場合のaggreementならとる意味があると思うが。</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2023-03-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/513">Self-Instruct: Aligning Language Model with Self Generated Instructions, Wang+ （w_ Noah Smith）, Univesity of Washington, ACL'23</a>
<span class="snippet"><span>Comment</span>Alpacaなどでも利用されているself-instruction技術に関する論文概要

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/228716254-5f4d7451-a37a-4354-843d-7e4052ba230b.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

著者らが書いた175種のinstruction（タスクの定義 + 1種のinput/outputペア}のseedを元に、VanillaなGPT-3に新たなinstruction, input, outputのtupleを生成させ、学習データとして活用する研究。

<br>



<br>

ここで、instruction data I は以下のように定義される：

<br>



<br>

instruction dataは(I, X, Y)であり、モデルは最終的にM(I_t, x_t) = y_tとなるように学習したい。

<br>



<br>

I: instruction, X: input, Y: output

<br>



<br>



<br>



<br>

データ作成は以下のステップで構成される。なお、以下はすべてVanilla GPT-3を通じて行われる：

<br>



<br>

1. Instruction Generation

<br>



<br>

　task poolから8種類のinstructionを抽出し、 promptを構成し、最大8個新たなinstructionを生成させる

<br>



<br>

2. Classification Task Identification:

<br>



<br>

　生成されたinstructionがclassificationタスクか否かを判別する

<br>



<br>

3. Instance Generation

<br>



<br>

　いくつかの(I, X, Y)をpromptとして与え、I, Xに対応するYを生成するタスクを実行させる。このときinput-first approachを採用した結果（I-&gt;Xの順番で情報を与えYを生成するアプローチ）、特定のラベルに偏ったインスタンスが生成される傾向があることがわかった。このためoutput-first approachを別途採用し（I-&gt;Yの順番で情報を与え、各Yに対応するXを生成させる）、活用している。　

<br>



<br>

4. Filtering and Postprocessing

<br>



<br>

　最後に、既存のtask poolとROUGE-Lが0.7以上のinstructionは多様性がないため除外し、特定のキーワード（images, pictrues, graphs）等を含んでいるinstruction dataも除外して、task poolに追加する。

<br>



<br>



<br>



<br>

1-4をひたすら繰り返すことで、GPT-3がInstruction Tuningのためのデータを自動生成してくれる。

<br>



<br>



<br>



<br>

SELF-INSTRUCT Data

<br>



<br>

データセットの統計量

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/228745059-ecccadba-3e32-4f2a-9594-2459a922474b.png" alt="image" loading="lazy">

<br>



<br>

・52k instructions

<br>



<br>

・82k instances

<br>



<br>



<br>



<br>

Diversity

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/228745421-ba024963-ca6e-4e30-bac8-7224d413f8ab.png" alt="image" loading="lazy">

<br>



<br>

parserでinstructionを解析し、rootの名詞と動詞のペアを抽出して可視化した例。ただし、抽出できた例はたかだか全体の50%程度であり、その中で20の最もcommonなroot vertと4つのnounを可視化した。これはデータセット全体の14%程度しか可視化されていないが、これだけでも非常に多様なinstructionが集まっていることがわかる。

<br>



<br>

また、seed indstructionとROUGE-Lを測った結果、大半のデータは0.3~0.4程度であり、lexicalなoverlapはあまり大きくないことがわかる。instructionのlengthについても可視化した結果、多様な長さのinstructionが収集できている。

<br>



<br>



<br>



<br>

Quality

<br>



<br>

200種類のinstructionを抽出し、その中からそれぞれランダムで1つのインスタンスをサンプルした。そしてexpert annotatorに対して、それぞれのinstructionとinstance（input, outputそれぞれについて）が正しいか否かをラベル付けしてもらった。

<br>



<br>

ラベル付けの結果、ほとんどのinstructionは意味のあるinstructionであることがわかった。一方、生成されたinstanceはnoisyであることがわかった（ただし、このnoiseはある程度妥当な範囲である）。noisytではあるのだが、instanceを見ると、正しいformatであったり、部分的に正しかったりなど、modelを訓練する上で有用なguidanceを提供するものになっていることがわかった。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/228746299-a0ffc115-3861-458b-a7b4-3a91ac94f8f5.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Experimental Results

<br>



<br>

Zero-shotでのNLPタスクに対する性能

<br>



<br>

SuperNIデータセットに含まれる119のタスク（1タスクあたり100 instance）に対して、zero-shot setupで評価を行なった。SELF-INSTRUCTによって、VanillaのGPT3から大幅に性能が向上していることがわかる。VanillaのGPT-3はほとんど人間のinstructionに応じて動いてくれないことがわかる。分析によると、GPT3は、大抵の場合、全く関係ない、あるいは繰り返しのテキストを生成していたり、そもそもいつ生成をstopするかがわかっていないことがわかった。

<br>



<br>



<br>



<br>

また、SuperNI向けにfinetuningされていないモデル間で比較した結果、非常にアノテーションコストをかけて作られたT0データでfinetuningされたモデルよりも高い性能を獲得した。また、人間がラベル付したprivateなデータによって訓練されたInstructGPT001にも性能が肉薄していることも特筆すべき点である。

<br>



<br>



<br>



<br>

SuperNIでfinetuningした場合については、SELF-INSTRUCTを使ったモデルに対して、さらに追加でSuperNIを与えた場合が最も高い性能を示した。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/228751534-095578e0-550b-4e4c-9418-c74251e31d2a.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

User-Oriented Instructionsに対する汎化性能

<br>



<br>

SuperNIに含まれるNLPタスクは研究目的で提案されており分類問題となっている。ので、実践的な能力を証明するために、LLMが役立つドメインをブレスト（email writing, social media, productiveity tools, entertainment, programming等）し、それぞれのドメインに対して、instructionとinput-output instanceを作成した。また、instructionのスタイルにも多様性（e.g. instructionがlong/short、bullet points, table, codes, equationsをinput/outputとして持つ、など）を持たせた。作成した結果、252個のinstructionに対して、1つのinstanceのデータセットが作成された。これらが、モデルにとってunfamiliarなinstructionで多様なistructionが与えられたときに、どれだけモデルがそれらをhandleできるかを測定するテストベッドになると考えている。

<br>



<br>



<br>



<br>

これらのデータは、多様だがどれもが専門性を求められるものであり、自動評価指標で性能が測定できるものでもないし、crowdworkerが良し悪しを判定できるものでもない。このため、それぞれのinstructionに対するauthorに対して、モデルのy補足結果が妥当か否かをjudgeしてもらった。judgeは4-scaleでのratingとなっている：

<br>



<br>



<br>



<br>

・RATING-A: 応答は妥当で満足できる

<br>



<br>

・RATING-B: 応答は許容できるが、改善できるminor errorや不完全さがある。

<br>



<br>

・RATING-C: 応答はrelevantでinstructionに対して答えている。が、内容に大きなエラーがある。

<br>



<br>

・RATING-D: 応答はirrelevantで妥当ではない。

<br>



<br>



<br>



<br>

実験結果をみると、Vanilla GPT3はまったくinstructionに対して答えられていない。instruction-basedなモデルは高いパフォーマンスを発揮しているが、それらを上回る性能をSELF-INSTRUCTは発揮している（noisyであるにもかかわらず）。

<br>



<br>

また、GPT_SELF-INSTRUCTはInstructGPT001と性能が肉薄している。また、InstructGPT002, 003の素晴らしい性能を示すことにもなった。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/228755556-1c604ed8-11a5-4237-8f9c-a30960db807a.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Discussion and Limitation

<br>



<br>

なぜSELF-INSTRUCTがうまくいったか？

<br>



<br>

・LMに対する2つの極端な仮説を挙げている

<br>



<br>

  ・LM はpre-trainingでは十分に学習されなかった問題について学習する必要があるため、human feedbackはinstruction-tuningにおいて必要不可欠な側面である

<br>



<br>

  ・LM はpre-trainingからinstructionに既に精通しているため、human feedbackはinstruction-tuningにおいて必須ではない。 human feedbackを観察することは、pre-trainingにおける分布/目的を調整するための軽量なプロセスにすぎず、別のプロセスに置き換えることができる。

<br>



<br>



<br>



<br>

この2つの極端な仮説の間が実情であると筆者は考えていて、どちらかというと２つ目の仮説に近いだろう、と考えている。既にLMはpre-trainingの段階でinstructionについてある程度理解できているため、self-instructがうまくいったのではないかと推察している。

<br>



<br>



<br>



<br>

Broader Impact

<br>



<br>

InstructGPTは非常に強力なモデルだけど詳細が公表されておらず、APIの裏側に隠れている。この研究が、instruct-tuned modelの背後で何が起きているかについて、透明性を高める助けになると考えている。産業で開発されたモデルの構造や、その優れた性能の理由についてはほとんど理解されておらず、これらのモデルの成功の源泉を理解し、より優れた、オープンなモデルを作成するのはアカデミックにかかっている。この研究では、多様なinstructional dataの重要性を示していると考えており、大規模な人工的なデータセットは、より優れたinstructionに従うモデルを、構築するための第一歩だと考えている。

<br>



<br>



<br>



<br>

limitation

<br>



<br>

・Tail Phenomena

<br>



<br>

  ・LMの枠組みにとどまっているため、LMと同じ問題（Tail Phenomena）を抱えている

<br>



<br>

  ・low-frequencyなcontextに対してはうまくいかない問題

<br>



<br>

  ・SELF-INSTRUCTも、結局pre-trainingの段階で頻出するタスクやinstructionに対してgainがあると考えられ、一般的でなく、creativeなinstructionに対して脆弱性があると考えられる

<br>



<br>

・Dependence on laege models

<br>



<br>

  ・でかいモデルを扱えるだけのresourceを持っていないと使えないという問題がある

<br>



<br>

・Reinforcing LM biases

<br>



<br>

  ・アルゴリズムのiterationによって、問題のあるsocial _biasをより増幅してしまうことを懸念している（人種、種族などに対する偏見など）。また、アルゴリズムはバランスの取れたラベルを生成することが難しい。1のprompt

<br>



<br>

<img width="801" alt="image" src="https://user-images.githubusercontent.com/12249301/228717376-62648df4-e587-49f7-8e71-afd1b2269e90.png">

<br>



<br>

2のprompt

<br>



<br>

<img width="871" alt="image" src="https://user-images.githubusercontent.com/12249301/228717413-115f8ccf-b85e-4530-b489-cbf1de69341b.png">

<br>



<br>

3のprompt（input-first-approach）

<br>



<br>

<img width="853" alt="image" src="https://user-images.githubusercontent.com/12249301/228717477-58b44a4e-ce44-452f-9b3a-4a348584e40f.png">

<br>



<br>

3のprompt（output-first approach）

<br>



<br>

<img width="803" alt="image" src="https://user-images.githubusercontent.com/12249301/228717535-8717405c-bdaf-455c-9d4b-480bf6494abe.png">※ GPT3をfinetuningするのに、Instruction Dataを使った場合$338かかったっぽい。安い・・・。LLMを使うだけでここまで研究ができる時代がきた（最近は|現在は）プロプライエタリなLLMの出力を利用して競合するモデルを訓練することは多くの場合禁止されているので注意。</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<span class="issue_date">Issue Date: 2023-03-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/512">Reflexion: Language Agents with Verbal Reinforcement Learning, Noah Shinn+, N_A, NeurIPS'23</a>
<span class="snippet"><span>Summary</span>本研究では、言語エージェントを強化するための新しいフレームワークであるReflexionを提案しています。Reflexionエージェントは、言語的フィードバックを通じて自己反省し、より良い意思決定を促すために反省的なテキストを保持します。Reflexionはさまざまなタスクでベースラインエージェントに比べて大幅な改善を実現し、従来の最先端のGPT-4を上回る精度を達成しました。さらに、異なるフィードバック信号や統合方法、エージェントタイプの研究を行い、パフォーマンスへの影響についての洞察を提供しています。</span>
<span class="snippet"><span>Comment</span>なぜ回答を間違えたのか自己反省させることでパフォーマンスを向上させる研究</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/EACL.html">#EACL</a>
<span class="issue_date">Issue Date: 2022-10-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/490">MTEB: Massive Text Embedding Benchmark, Muennighoff+, EACL'23</a>
<span class="snippet"><span>Summary</span>テキスト埋め込みの評価は通常小規模なデータセットに限られ、他のタスクへの適用可能性が不明である。これを解決するために、58のデータセットと112の言語をカバーするMassive Text Embedding Benchmark（MTEB）を導入し、33のモデルをベンチマークした。結果、特定の手法が全タスクで優位に立つことはなく、普遍的なテキスト埋め込み手法には至っていないことが示された。MTEBはオープンソースで公開されている。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Abstractive.html">#Abstractive</a>
<a class="button" href="articles/EACL.html">#EACL</a>
<span class="issue_date">Issue Date: 2022-09-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/482">Long Document Summarization with Top-down and Bottom-up Inference, Pang+, Salesforce Research, EACL'23</a>
<span class="snippet"><span>Comment</span>日本語解説: https://zenn.dev/ty_nlp/articles/9f5e5dd3084dbd

<br>



<br>



<br>



<br>

以下、上記日本語解説記事を読んで理解した内容をまとめます。ありがとうございます。

<br>



<br>



<br>



<br>

概要

<br>



<br>

基本的にTransformerベースのモデル（e.g. BERTSum, BART, PEGASUS, GPT-2, T5）ではself-attentionの計算量が入力トークン数Nに対してO(N^2)でかかり、入力の二乗のオーダーで計算量が増えてしまう。

<br>



<br>

これを解消するためにself-attentionを計算する範囲をウィンドウサイズで制限するLongformerや、BigBardなどが提案されてきたが、どちらのモデルも離れたトークン間のattentionの情報が欠落するため、長距離のトークン間の関係性を捉えにくくなってしまう問題があった。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/188084569-ec574f6f-cc31-48db-aef5-0a3fedea816c.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

そこで、top-down transformerではセグメント（セグメントはテキストでいうところの文）という概念を提唱し、tokenからsegmentのrepresentationを生成しその後self-attentionでsegment間の関係性を考慮してsegmentのrepresentationを生成するbottom-up inference、各tokenとsegmentの関係性を考慮しし各tokenのrepresentationを学習するtop-down inferenceの2つの構造を利用した。bottom-up inferenceにおいてsegmentのrepresentationを計算する際にpoolingを実施するが、adapoolingと呼ばれる重要なトークンに重み付けをし、その重みを加味した加重平均によりプーリングを実施する。これにより、得られた各トークンの表現は、各セグメントとの関連度の情報を含み（セグメントの表現は各セグメント間のattentnionに基づいて計算されているため; bottom-up inference）、かつ各トークンと各セグメント間との関連度も考慮して計算されているため（top-down inference）、結果的に離れたトークン間の関連度を考慮したrepresentationが学習される（下図）。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/188085213-affc953b-b4a6-4f34-8fa0-71d3ddb173b4.png" alt="image" loading="lazy">

<br>



<br>

（図は上記記事からお借りいたしました）

<br>



<br>



<br>



<br>

各attentionの計算量は表のようになり、M, wはNよりも遥かに小さいため、O(N^2)よりも遥かに小さい計算量で計算できる。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/188086050-985d4fc6-3b1b-4ff1-b268-b6bda24581f5.png" alt="image" loading="lazy">

<br>



<br>

（こちらも上記記事からお借りいたしました）

<br>



<br>



<br>



<br>

実験（日本語解説より）

<br>



<br>

データセット

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/188086312-769ef574-3f91-4f12-b015-ac9c02dc93ff.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

結果

<br>



<br>

PubMedとarXiv

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/188086389-c3e49a19-51b1-437c-9802-1e62c9fd4329.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

CNN-DailyMail

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/188086914-9476f30d-481c-4113-8f6b-edeb906ac696.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

TVMegasSiteとForeverDreaming

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/188086972-c355854b-9f1f-4f88-9e36-06536963541b.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

BookSum-Chapter-Level

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/188087045-0ac57b5a-5c6c-49e4-a82a-3e57f5e8b788.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

BookSum-Book-Level

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/188087112-2d310059-72d1-4968-bf09-cdcf0e6afc2d.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

所感

<br>



<br>

CNN-DailyMailのようなinput wordsが900程度のデータではcomparableな結果となっているが、input wordsが長い場合は先行研究をoutperformしている。BookSum-Chapter Levelにおいて、Longformer, BigBirdの性能が悪く、BART, T5, Pegasusの性能が良いのが謎い。

<br>



<br>

てかinput wordsが3000~7000程度のデータに対して、どうやってBARTやらT5やらを実装できるんだろう。大抵512 tokenくらいが限界だと思っていたのだが、どうやったんだ・・・。&gt;The maximum document lengths for PubMed, arXiv, CNN-DM,

<br>



<br>

TVMegaSite, ForeverDreaming, BookSum are 8192, 16384, 1024, 12288, 12288, 12288, respectively

<br>



<br>



<br>



<br>

これは、たとえばBookSumの場合は仮にinputの長さが11万とかあったとしても、12288でtruncateしたということだろうか。まあなんにせよ、頑張ればこのくらいの系列長のモデルを学習できるということか（メモリに乗るのか・・・？どんな化け物マシンを使っているのか）。&gt;We first train a top-down transformer on the chapter-level data and then fine-tune it on the book-level

<br>



<br>

data. The inputs to the book-level model are (1) the concatenated chapter reference summaries in

<br>



<br>

training or (2) the concatenated chapter summaries generated by the chapter-level model in testing.

<br>



<br>

The chapter-to-book curriculum training is to mitigate the scarcity of book-level data. The recursive

<br>



<br>

summarization of chapters and then books can be considered abstractive content selection applied

<br>



<br>

to book data, and is used to address the extremely long length of books.

<br>



<br>



<br>



<br>

BookLevel Summarizationでは、データ数が300件程度しかなく、かつinput wordsがでかすぎる。これに対処するために、まずtop-down transformerをchapter-level_ dataで訓練して、その後book-level dataでfine-tuning。book-level dataでfine-tuningする際には、chapterごとのreference summaryをconcatしたものを正解とし、chapter-level modelが生成したchapterごとのsummaryをconcatしたものをモデルが生成した要約として扱った、という感じだろうか。まずchapter levelで学習しその後book levelで学習するcurriculum learningっぽいやり方がbook-level dataの不足を緩和してくれる。bookの要約を得るためにchapterを再帰的に要約するようなアプローチは、book dataに対するcontent selectionとしてみなすことができ、おそろしいほど長い入力の対処にもなっている、という感じだろうか。</span>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<a class="button" href="articles/Length.html">#Length</a>
<span class="issue_date">Issue Date: 2025-07-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2311">[Paper Note] Matryoshka Representation Learning, Aditya Kusupati+, NeurIPS'22</a>
<span class="snippet"><span>Summary</span>マトリョーシカ表現学習（MRL）は、異なる計算リソースに適応可能な柔軟な表現を設計する手法であり、既存の表現学習パイプラインを最小限に修正して使用します。MRLは、粗から細への表現を学習し、ImageNet-1K分類で最大14倍小さい埋め込みサイズを提供し、実世界のスピードアップを実現し、少数ショット分類で精度向上を達成します。MRLは視覚、視覚+言語、言語のモダリティにわたるデータセットに拡張可能で、コードとモデルはオープンソースで公開されています。</span>
<span class="snippet"><span>Comment</span>日本語解説:https://speakerdeck.com/hpprc/lun-jiang-zi-liao-matryoshka-representation-learning単一のモデルから複数のlengthのEmbeddingを出力できるような手法。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/MultitaskLearning.html">#MultitaskLearning</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/SpeechProcessing.html">#SpeechProcessing</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2025-07-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2183">[Paper Note] Perceiver IO: A General Architecture for Structured Inputs &amp; Outputs, Andrew Jaegle+, ICLR'22</a>
<span class="snippet"><span>Summary</span>汎用アーキテクチャPerceiver IOを提案し、任意のデータ設定に対応し、入力と出力のサイズに対して線形にスケール可能。柔軟なクエリメカニズムを追加し、タスク特有の設計を不要に。自然言語、視覚理解、マルチタスクで強力な結果を示し、GLUEベンチマークでBERTを上回る性能を達成。</span>
<span class="snippet"><span>Comment</span>当時相当話題となったさまざまなモーダルを統一された枠組みで扱えるPerceiver IO論文

<br>

<img src="https://github.com/user-attachments/assets/d7893f14-d69c-4af8-8117-08c2a6095e8e" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<a class="button" href="articles/Normalization.html">#Normalization</a>
<a class="button" href="articles/Encoder-Decoder.html">#Encoder-Decoder</a>
<span class="issue_date">Issue Date: 2025-07-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2141">[Paper Note] On Layer Normalizations and Residual Connections in Transformers, Sho Takase+, arXiv'22</a>
<span class="snippet"><span>Summary</span>本研究では、Transformerアーキテクチャのレイヤー正規化の位置に関するPost-LNとPre-LNの違いを調査。Post-LNは浅い層で優れた性能を示す一方、深い層では不安定なトレーニングを引き起こす消失勾配問題があることを発見。これを踏まえ、Post-LNの修正により安定したトレーニングを実現する方法を提案し、実験でPre-LNを上回る結果を示した。</span>
<span class="snippet"><span>Comment</span>Pre-LNの安定性を持ちながらもPost-LNのような高い性能を発揮する良いとこ取りのB2TConnectionを提案

<br>

<img src="https://github.com/user-attachments/assets/4d85bf16-19e4-4d2a-85e5-87da45cd2a98" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/af0aeae5-554a-4997-96a3-929cd7dd90bb" alt="image" loading="lazy">NLP2022:https://www.anlp.jp/proceedings/annual_meeting/2022/pdf_dir/A2-5.pdf</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/KnowledgeEditing.html">#KnowledgeEditing</a>
<span class="issue_date">Issue Date: 2025-06-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2055">[Paper Note] Fast Model Editing at Scale, Eric Mitchell+, ICLR'22</a>
<span class="snippet"><span>Summary</span>MEND（モデル編集ネットワーク）は、事前学習モデルの動作を迅速かつ局所的に編集するための手法で、単一の入力-出力ペアを用いて勾配分解を活用します。これにより、10億以上のパラメータを持つモデルでも、1台のGPUで短時間でトレーニング可能です。実験により、MENDが大規模モデルの編集において効果的であることが示されました。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=0DcZxeWfOPt</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-05-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1956">LoRA: Low-Rank Adaptation of Large Language Models, Edward J. Hu+, ICLR'22</a>
<span class="snippet"><span>Summary</span>LoRAは、事前学習された大規模モデルの重みを固定し、各層に訓練可能なランク分解行列を追加することで、ファインチューニングに必要なパラメータを大幅に削減する手法です。これにより、訓練可能なパラメータを1万分の1、GPUメモリを3分の1に減少させながら、RoBERTaやGPT-3などで同等以上の性能を実現します。LoRAの実装はGitHubで公開されています。</span>
<span class="snippet"><span>Comment</span>OpenrReview:https://openreview.net/forum?id=nZeVKeeFYf9LoRAもなんやかんやメモってなかったので追加。

<br>



<br>

事前学習済みのLinear Layerをfreezeして、freezeしたLinear Layerと対応する低ランクの行列A,Bを別途定義し、A,BのパラメータのみをチューニングするPEFT手法であるLoRAを提案した研究。オリジナルの出力に対して、A,Bによって入力を写像したベクトルを加算する。

<br>



<br>

チューニングするパラメータ数学はるかに少ないにも関わらずフルパラメータチューニングと（これは諸説あるが）同等の性能でPostTrainingできる上に、事前学習時点でのパラメータがfreezeされているためCatastrophic Forgettingが起きづらく（ただし新しい知識も獲得しづらい）、A,Bの追加されたパラメータのみを保存すれば良いのでストレージに優しいのも嬉しい。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/CLIP.html">#CLIP</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<span class="issue_date">Issue Date: 2025-05-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1928">LAION-5B: An open large-scale dataset for training next generation   image-text models, Christoph Schuhmann+, NeurIPS'22</a>
<span class="snippet"><span>Summary</span>LAION-5Bは、5.85億のCLIPフィルタリングされた画像-テキストペアから成る大規模データセットで、英語のペアが2.32B含まれています。このデータセットは、CLIPやGLIDEなどのモデルの再現とファインチューニングに利用され、マルチモーダルモデルの研究を民主化します。また、データ探索やサブセット生成のためのインターフェースや、コンテンツ検出のためのスコアも提供されます。</span>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<a class="button" href="articles/Normalization.html">#Normalization</a>
<span class="issue_date">Issue Date: 2025-04-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1900">DeepNet: Scaling Transformers to 1,000 Layers, Hongyu Wang+, arXiv'22</a>
<span class="snippet"><span>Summary</span>本論文では、深いTransformerを安定化させるための新しい正規化関数DeepNormを提案し、残差接続の修正と理論的初期化を行う。これにより、Post-LNの性能とPre-LNの安定性を兼ね備え、最大1,000層のTransformerをスケールアップ可能にした。特に、3.2Bパラメータの200層モデルが、12Bパラメータの48層モデルを5 BLEUポイント上回る性能を示し、今後のスケーリングの可能性を示唆している。</span>
<span class="snippet"><span>Comment</span>ステートオブAIガイドによる解説:https://ja.stateofaiguides.com/20220308-deepnet-transformer/</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-03-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1827">Training Compute-Optimal Large Language Models, Jordan Hoffmann+, NeurIPS'22</a>
<span class="snippet"><span>Summary</span>トランスフォーマー言語モデルの訓練において、計算予算内で最適なモデルサイズとトークン数を調査。モデルサイズと訓練トークン数は同等にスケールする必要があり、倍増するごとにトークン数も倍増すべきと提案。Chinchillaモデルは、Gopherなどの大規模モデルに対して優れた性能を示し、ファインチューニングと推論の計算量を削減。MMLUベンチマークで67.5%の精度を達成し、Gopherに対して7%以上の改善を実現。</span>
<span class="snippet"><span>Comment</span>OpenReview: https://openreview.net/forum?id=iBBcRUlOAPRchinchilla則</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-02-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1754">Switch Transformers: Scaling to Trillion Parameter Models with Simple  and Efficient Sparsity, William Fedus+, JMLR'22</a>
<span class="snippet"><span>Summary</span>Switch Transformerを提案し、Mixture of Experts (MoE)の複雑さや通信コスト、トレーニングの不安定性を改善。これにより、低精度フォーマットでの大規模スパースモデルのトレーニングが可能になり、最大7倍の事前トレーニング速度向上を実現。さらに、1兆パラメータのモデルを事前トレーニングし、T5-XXLモデルに対して4倍の速度向上を達成。</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<span class="issue_date">Issue Date: 2024-10-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1474">Super-NaturalInstructions: Generalization via Declarative Instructions  on 1600+ NLP Tasks, Yizhong Wang+, N_A, EMNLP'22</a>
<span class="snippet"><span>Summary</span>Super-NaturalInstructionsを用いて、NLPモデルの未見タスクへの一般化能力を評価。1,616の多様なタスクと指示を含むベンチマークを作成し、76種類のタスクタイプをカバー。Tk-Instructモデルは、指示に従う訓練を受け、InstructGPTを9%以上上回る性能を示す。一般化能力をスケーリングパラメータに基づいて分析し、汎用的なNLPモデルの進展を促進することを目指す。</span>
<span class="snippet"><span>Comment</span>7.1, 7.2が最も興味深い

<br>



<br>



<br>



<br>

Instruction Tuningにおける未知のタスクに対する汎化性能について、3つの要素に対するスケーリングについて考察

<br>



<br>

・More observed tasks improve the generalization.

<br>



<br>

・A large number of training instances do not help generalization.

<br>



<br>

・Tuning larger models with instructions consistently lead to gains.

<br>



<br>



<br>



<br>

Instructionをさまざまに変化させた時の性能の変化に対する分析

<br>



<br>

Table4の対角成分に注目すると（trainとtestのinput encodingを揃えた場合）

<br>



<br>

・Task definitionをinstructionに含めることで未知タスクに対する汎化性能向上

<br>



<br>

・Task Definitionとpositive examplesを4つ程度入れると汎化性能向上。

<br>



<br>

  ・ただし、これ以上exampleを増やすと性能低下。

<br>



<br>

  ・negative examplesを入れることは性能に a little bit しか貢献しない

<br>



<br>

  ・explanationsを入れると性能が低下する

<br>



<br>



<br>



<br>

Table4の非対角成分に着目すると、

<br>



<br>

・Task Definitionのみで訓練しても、Example onlyのtest時のencodingには汎化しない（逆も然り）

<br>



<br>

・Task Definition + examples (今回の場合はpositive examples4つ)は、さまざまなtest時のinput encodingsに対してロバストになる

<br>



<br>

 

<br>



<br>

<img src="https://github.com/user-attachments/assets/3bd1d07d-feb0-4567-bad9-8920c2d82359" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<span class="issue_date">Issue Date: 2024-09-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1425">No Language Left Behind: Scaling Human-Centered Machine Translation, NLLB Team+, N_A, arXiv'22</a>
<span class="snippet"><span>Summary</span>「No Language Left Behind」プロジェクトでは、リソースが乏しい言語の機械翻訳を改善するために、ネイティブスピーカーとのインタビューを通じて必要性を明らかにし、データセットとモデルを開発。新しいデータマイニング技術を用いた条件付き計算モデルを提案し、過学習を防ぐための訓練改善を行った。Flores-200ベンチマークで40,000以上の翻訳方向を評価し、従来技術に対して44%のBLEU改善を達成。全ての成果はオープンソースとして公開。</span>
<span class="snippet"><span>Comment</span>low-resourceな言語に対するMTのベンチマーク</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<span class="issue_date">Issue Date: 2024-09-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1413">Finetuned Language Models Are Zero-Shot Learners, Jason Wei+, N_A, ICLR'22</a>
<span class="snippet"><span>Summary</span>指示チューニングを用いて言語モデルのゼロショット学習能力を向上させる方法を提案。137BパラメータのモデルFLANは、60以上のNLPタスクでファインチューニングされ、未見のタスクで175B GPT-3を上回るパフォーマンスを示す。アブレーションスタディにより、ファインチューニングデータセットの数やモデルのスケールが成功に寄与することが確認された。</span>
<span class="snippet"><span>Comment</span>FLAN論文。Instruction Tuningを提案した研究。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<span class="issue_date">Issue Date: 2024-09-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1397">STaR: Bootstrapping Reasoning With Reasoning, Eric Zelikman+, N_A, NeurIPS'22</a>
<span class="snippet"><span>Summary</span>「自己学習推論者」（STaR）を提案し、少数の合理的説明と大規模データセットを活用して複雑な推論を行う。STaRは、生成した回答が間違っている場合に正しい回答を用いて再生成し、ファインチューニングを繰り返すことで性能を向上させる。実験により、STaRは従来のモデルと比較して大幅な性能向上を示し、特にCommensenseQAでの成果が顕著である。</span>
<span class="snippet"><span>Comment</span>OpenAI o1関連研究</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/KnowledgeEditing.html">#KnowledgeEditing</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<a class="button" href="articles/FactualKnowledge.html">#FactualKnowledge</a>
<a class="button" href="articles/Encoder.html">#Encoder</a>
<span class="issue_date">Issue Date: 2024-07-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1332">Knowledge Neurons in Pretrained Transformers, Damai Dai+, N_A, ACL'22, 2022.05</a>
<span class="snippet"><span>Summary</span>大規模な事前学習言語モデルにおいて、事実知識の格納方法についての研究を行いました。具体的には、BERTのfill-in-the-blank cloze taskを用いて、関連する事実を表現するニューロンを特定しました。また、知識ニューロンの活性化と対応する事実の表現との正の相関を見つけました。さらに、ファインチューニングを行わずに、知識ニューロンを活用して特定の事実知識を編集しようと試みました。この研究は、事前学習されたTransformers内での知識の格納に関する示唆に富んでおり、コードはhttps://github.com/Hunter-DDM/knowledge-neuronsで利用可能です。</span>
<span class="snippet"><span>Comment</span>1108 日本語解説: https://speakerdeck.com/kogoro/knowledge-neurons-in-pretrained-transformers-for-snlp2022関連:

<br>

・2140上記資料によると、特定の知識を出力する際に活性化する知識ニューロンを特定する手法を提案。MLMを用いたclozeタスクによる実験で[MASK]部分に当該知識を出力する実験をした結果、知識ニューロンの重みをゼロとすると性能が著しく劣化し、値を2倍にすると性能が改善するといった傾向がみられた。　ケーススタディとして、知識の更新と、知識の削除が可能かを検証。どちらとも更新・削除がされる方向性[^1]へモデルが変化した。

<br>



<br>

また、知識ニューロンはTransformerの層の深いところに位置している傾向にあり、異なるrelationを持つような関係知識同士では共有されない傾向にある模様。

<br>



<br>

[^1]: 他の知識に影響を与えず、完璧に更新・削除できたわけではない。知識の更新・削除に伴いExtrinsicな評価によって性能向上、あるいはPerplexityが増大した、といった結果からそういった方向性へモデルが変化した、という話</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/ChatGPT.html">#ChatGPT</a>
<a class="button" href="articles/RLHF.html">#RLHF</a>
<a class="button" href="articles/PPO%20(ProximalPolicyOptimization).html">#PPO (ProximalPolicyOptimization)</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2024-04-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1296">Training language models to follow instructions with human feedback, Long Ouyang+, N_A, NeurIPS'22</a>
<span class="snippet"><span>Summary</span>大規模な言語モデルは、ユーザーの意図に合わない出力を生成することがあります。本研究では、人間のフィードバックを使用してGPT-3を微調整し、InstructGPTと呼ばれるモデルを提案します。この手法により、13億パラメータのInstructGPTモデルの出力が175BのGPT-3の出力よりも好まれ、真実性の向上と有害な出力の削減が示されました。さらに、一般的なNLPデータセットにおける性能の低下は最小限でした。InstructGPTはまだ改善の余地がありますが、人間のフィードバックを使用した微調整が有望な方向であることを示しています。</span>
<span class="snippet"><span>Comment</span>ChatGPTの元となる、SFT→Reward Modelの訓練→RLHFの流れが提案された研究。DemonstrationデータだけでSFTするだけでは、人間の意図したとおりに動作しない問題があったため、人間の意図にAlignするように、Reward Modelを用いたRLHFでSFTの後に追加で学習を実施する。Reward Modelは、175Bモデルは学習が安定しなかった上に、PPOの計算コストが非常に大きいため、6BのGPT-3を様々なNLPタスクでSFTしたモデルをスタートにし、モデルのアウトプットに対して人間がランキング付けしたデータをペアワイズのloss functionで訓練した。最終的に、RMのスコアが最大化されるようにSFTしたGPT-3をRLHFで訓練するが、その際に、SFTから出力が離れすぎないようにする項と、NLPベンチマークでの性能が劣化しないようにpretrain時のタスクの性能もloss functionに加えている。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/e4934d4c-7a9b-44aa-93ce-3ae46ed4bd9b" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/StructuredData.html">#StructuredData</a>
<span class="issue_date">Issue Date: 2023-10-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1097">MURMUR: Modular Multi-Step Reasoning for Semi-Structured Data-to-Text  Generation, Swarnadeep Saha+, N_A, arXiv'22</a>
<span class="snippet"><span>Summary</span>本研究では、半構造化データからのテキスト生成における多段階の推論を行うためのMURMURという手法を提案しています。MURMURは、特定の言語的および論理的なスキルを持つニューラルモジュールと記号モジュールを組み合わせ、ベストファーストサーチ手法を使用して推論パスを生成します。実験結果では、MURMURは他のベースライン手法に比べて大幅な改善を示し、また、ドメイン外のデータでも同等の性能を達成しました。さらに、人間の評価では、MURMURは論理的に整合性のある要約をより多く生成することが示されました。</span>
<a class="button" href="articles/BeamSearch.html">#BeamSearch</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<span class="issue_date">Issue Date: 2023-08-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/998">Momentum Calibration for Text Generation, Xingxing Zhang+, N_A, arXiv'22</a>
<span class="snippet"><span>Summary</span>本研究では、テキスト生成タスクにおいてMoCa（Momentum Calibration）という手法を提案しています。MoCaは、ビームサーチを用いた遅く進化するサンプルを動的に生成し、これらのサンプルのモデルスコアを実際の品質に合わせるように学習します。実験結果は、MoCaが強力な事前学習済みTransformerを改善し、最先端の結果を達成していることを示しています。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/BeamSearch.html">#BeamSearch</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2023-08-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/997">BRIO: Bringing Order to Abstractive Summarization, Yixin Liu+, N_A, ACL'22</a>
<span class="snippet"><span>Summary</span>従来の抽象的要約モデルでは、最尤推定を使用して訓練されていましたが、この方法では複数の候補要約を比較する際に性能が低下する可能性があります。そこで、非確定論的な分布を仮定し、候補要約の品質に応じて確率を割り当てる新しい訓練パラダイムを提案しました。この手法により、CNN/DailyMailとXSumのデータセットで最高の結果を達成しました。さらに、モデルが候補要約の品質とより相関のある確率を推定できることも示されました。</span>
<span class="snippet"><span>Comment</span>ビーム内のトップがROUGEを最大化しているとは限らなかったため、ROUGEが最大となるような要約を選択するようにしたら性能爆上げしましたという研究。

<br>

実質現在のSoTA</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-based.html">#Reference-based</a>
<span class="issue_date">Issue Date: 2023-08-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/987">SMART: Sentences as Basic Units for Text Evaluation, Reinald Kim Amplayo+, N_A, arXiv'22</a>
<span class="snippet"><span>Summary</span>本研究では、テキスト生成の評価指標の制限を緩和するために、新しい指標であるSMARTを提案する。SMARTは文を基本的なマッチング単位とし、文のマッチング関数を使用して候補文と参照文を評価する。また、ソースドキュメントの文とも比較し、評価を可能にする。実験結果は、SMARTが他の指標を上回ることを示し、特にモデルベースのマッチング関数を使用した場合に有効であることを示している。また、提案された指標は長い要約文でもうまく機能し、特定のモデルに偏りが少ないことも示されている。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-free.html">#Reference-free</a>
<a class="button" href="articles/Reference-based.html">#Reference-based</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/983">FFCI: A Framework for Interpretable Automatic Evaluation of  Summarization, Fajri Koto+, N_A, JAIR'22</a>
<span class="snippet"><span>Summary</span>本論文では、FFCIという細かい要約評価のためのフレームワークを提案しました。このフレームワークは、信頼性、焦点、カバレッジ、および文間の連続性の4つの要素から構成されています。新しいデータセットを構築し、評価メトリックとモデルベースの評価方法をクロス比較することで、FFCIの4つの次元を評価するための自動的な方法を開発しました。さまざまな要約モデルを評価し、驚くべき結果を得ました。</span>
<span class="snippet"><span>Comment</span>先行研究でどのようなMetricが利用されていて、それらがどういった観点のMetricなのかや、データセットなど、非常に細かくまとまっている。Faithfulness(ROUGE, STS-Score, BERTScoreに基づく), Focus and Coverage (Question Answering basedな手法に基づく), Inter-Sentential Coherence (NSPに基づく)メトリックを組み合わせることを提案している。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-based.html">#Reference-based</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/973">InfoLM: A New Metric to Evaluate Summarization &amp; Data2Text Generation, Pierre Colombo+, N_A, AAAI'22</a>
<span class="snippet"><span>Summary</span>自然言語生成システムの品質評価は高価であり、人間の注釈に頼ることが一般的です。しかし、自動評価指標を使用することもあります。本研究では、マスクされた言語モデルを使用した評価指標であるInfoLMを紹介します。この指標は同義語を処理することができ、要約やデータ生成の設定で有意な改善を示しました。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-based.html">#Reference-based</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/972">WIDAR -- Weighted Input Document Augmented ROUGE, Raghav Jain+, N_A, ECIR'22</a>
<span class="snippet"><span>Summary</span>自動テキスト要約の評価において、ROUGEメトリックには制約があり、参照要約の利用可能性に依存している。そこで、本研究ではWIDARメトリックを提案し、参照要約だけでなく入力ドキュメントも使用して要約の品質を評価する。WIDARメトリックは一貫性、整合性、流暢さ、関連性の向上をROUGEと比較しており、他の最先端のメトリックと同等の結果を短い計算時間で得ることができる。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/LM-based.html">#LM-based</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/965">SummaC: Re-Visiting NLI-based Models for Inconsistency Detection in Summarization, Laban+, TACL'22</a>
<span class="snippet"><span>Summary</span>要約の領域では、入力ドキュメントと要約が整合していることが重要です。以前の研究では、自然言語推論（NLI）モデルを不整合検出に適用するとパフォーマンスが低下することがわかりました。本研究では、NLIを不整合検出に再評価し、過去の研究での入力の粒度の不一致が問題であることを発見しました。新しい手法SummaCConvを提案し、NLIモデルを文単位にドキュメントを分割してスコアを集計することで、不整合検出に成功裏に使用できることを示しました。さらに、新しいベンチマークSummaCを導入し、74.4%の正確さを達成し、先行研究と比較して5%の改善を実現しました。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/962">TRUE: Re-evaluating Factual Consistency Evaluation, Or Honovich+, N_A, the Second DialDoc Workshop on Document-grounded Dialogue and Conversational Question Answering'22</a>
<span class="snippet"><span>Summary</span>事実の整合性メトリックの包括的な調査と評価であるTRUEを紹介。さまざまな最先端のメトリックと11のデータセットを対象に行った結果、大規模なNLIおよび質問生成・回答ベースのアプローチが強力で補完的な結果を達成することがわかった。TRUEをモデルおよびメトリックの開発者の出発点として推奨し、さらなる評価方法の向上に向けた進歩を期待している。</span>
<span class="snippet"><span>Comment</span>FactualConsistencyに関するMetricが良くまとまっている</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-free.html">#Reference-free</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/958">MaskEval: Weighted MLM-Based Evaluation for Text Summarization and  Simplification, Yu Lu Liu+, N_A, arXiv'22</a>
<span class="snippet"><span>Summary</span>本研究では、テキストの要約と簡素化のための参照のない評価尺度であるMaskEvalを提案しています。MaskEvalは、候補テキストとソーステキストの連結に対してマスクされた言語モデリングを行い、重要な品質の側面ごとに相対的な重要性を調整することができます。さらに、英語の要約と簡素化における人間の判断との相関に基づいて、その効果を示し、両方のタスク間での転移シナリオを探索します。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-free.html">#Reference-free</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/957">Play the Shannon Game With Language Models: A Human-Free Approach to  Summary Evaluation, Nicholas Egan+, N_A, AAAI'22</a>
<span class="snippet"><span>Summary</span>この研究では、事前学習済み言語モデルを使用して、参照フリーの要約評価指標を提案します。これにより、要約の品質を測定するための新しい手法が開発されます。また、提案手法が人間の判断と高い相関関係を持つことが実証されます。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-free.html">#Reference-free</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/956">Reference-free Summarization Evaluation via Semantic Correlation and Compression Ratio, Liu+, NAACL'22</a>
<span class="snippet"><span>Summary</span>本研究では、参照ベースの評価方法の柔軟性の欠如を解消するために、事前学習済み言語モデルを使用して自動参照フリーの評価指標を提案します。この指標は、要約の意味的な分布と圧縮率を考慮し、人間の評価とより一致していることが実験で示されました。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/952">Re-Examining System-Level Correlations of Automatic Summarization Evaluation Metrics, Deutsch+, NAACL'22</a>
<span class="snippet"><span>Summary</span>本研究では、自動要約評価尺度のシステムレベルの相関に関する不整合を修正するための変更を提案しています。具体的には、全テストセットを使用して自動評価尺度のシステムスコアを計算し、実際のシナリオでよく見られる自動スコアのわずかな差によって分離されたシステムのペアに対してのみ相関を計算することを提案しています。これにより、より正確な相関推定と高品質な人間の判断の収集が可能となります。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/951">Does Summary Evaluation Survive Translation to Other Languages?, Braun+, NAACL'22</a>
<span class="snippet"><span>Summary</span>要約データセットの作成は費用と時間がかかるが、機械翻訳を使用して既存のデータセットを他の言語に翻訳することで、追加の言語での使用が可能になる。この研究では、英語の要約データセットを7つの言語に翻訳し、自動評価尺度によるパフォーマンスを比較する。また、人間と自動化された要約のスコアリング間の相関を評価し、翻訳がパフォーマンスに与える影響も考慮する。さらに、データセットの再利用の可能性を見つけるために、特定の側面に焦点を当てる。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/TrainedMetrics.html">#TrainedMetrics</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/948">SummScore: A Comprehensive Evaluation Metric for Summary Quality Based  on Cross-Encoder, Wuhang Lin+, N_A, arXiv'22</a>
<span class="snippet"><span>Summary</span>要約の品質評価メトリクスの問題を解決するために、SummScoreという包括的な評価メトリクスを提案する。SummScoreはCrossEncoderに基づいており、要約の多様性を抑制せずに要約の品質を評価することができる。さらに、SummScoreは一貫性、一貫性、流暢さ、関連性の4つの側面で評価することができる。実験結果は、SummScoreが既存の評価メトリクスを上回ることを示している。また、SummScoreの評価結果を16の主要な要約モデルに提供している。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-free.html">#Reference-free</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/942">SueNes: A Weakly Supervised Approach to Evaluating Single-Document Summarization via Negative Sampling, Bao+, NAACL'22</a>
<span class="snippet"><span>Summary</span>従来の自動要約評価メトリックは語彙の類似性に焦点を当てており、意味や言語的な品質を十分に捉えることができない。参照要約が必要であるためコストがかかる。本研究では、参照要約が存在しない弱教師あり要約評価手法を提案する。既存の要約データセットを文書と破損した参照要約のペアに変換してトレーニングする。ドメイン間のテストでは、提案手法がベースラインを上回り、言語的な品質を評価する上で大きな利点を示した。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-free.html">#Reference-free</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/941">PrefScore: Pairwise Preference Learning for Reference-free Summarization Quality Assessment, Luo+, COLING'22</a>
<span class="snippet"><span>Summary</span>人間による参照要約のない機械生成の要約の評価を行うために、ブラッドリー・テリーのパワーランキングモデルを使用して要約の優劣を判断する方法を提案する。実験結果は、この方法が人間の評価と高い相関を持つスコアを生成できることを示している。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/940">How to Find Strong Summary Coherence Measures? A Toolbox and a Comparative Study for Summary Coherence Measure Evaluation, Steen+, COLING'22</a>
<span class="snippet"><span>Summary</span>要約の一貫性を自動的に評価することは重要であり、さまざまな方法が提案されていますが、異なるデータセットと評価指標を使用して評価されるため、相対的なパフォーマンスを理解することが困難です。本研究では、要約の一貫性モデリングのさまざまな方法について調査し、新しい分析尺度を導入します。現在の自動一貫性尺度はすべての評価指標において信頼性のある一貫性スコアを割り当てることができませんが、大規模言語モデルは有望な結果を示しています。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/IJCNLP.html">#IJCNLP</a>
<a class="button" href="articles/AACL.html">#AACL</a>
<a class="button" href="articles/Repetition.html">#Repetition</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/939">Self-Repetition in Abstractive Neural Summarizers, Nikita Salkar+, N_A,  AACL-IJCNLP'22</a>
<span class="snippet"><span>Summary</span>私たちは、BART、T5、およびPegasusという3つのニューラルモデルの出力における自己繰り返しの分析を行いました。これらのモデルは、異なるデータセットでfine-tuningされています。回帰分析によると、これらのモデルは入力の出力要約間でコンテンツを繰り返す傾向が異なることがわかりました。また、抽象的なデータや定型的な言語を特徴とするデータでのfine-tuningでは、自己繰り返しの割合が高くなる傾向があります。定性的な分析では、システムがアーティファクトや定型フレーズを生成することがわかりました。これらの結果は、サマライザーのトレーニングデータを最適化するための手法の開発に役立つ可能性があります。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/938">Universal Evasion Attacks on Summarization Scoring, Wenchuan Mu+, N_A, BlackboxNLP workshop on ACL'22</a>
<span class="snippet"><span>Summary</span>要約の自動評価は重要であり、その評価は複雑です。しかし、これまで要約の評価は機械学習のタスクとは考えられていませんでした。本研究では、自動評価の堅牢性を探るために回避攻撃を行いました。攻撃システムは、要約ではない文字列を予測し、一般的な評価指標であるROUGEやMETEORにおいて優れた要約器と競合するスコアを達成しました。また、攻撃システムは最先端の要約手法を上回るスコアを獲得しました。この研究は、現在の評価システムの堅牢性の低さを示しており、要約スコアの開発を促進することを目指しています。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/936">DocAsRef: A Pilot Empirical Study on Repurposing Reference-Based Summary  Quality Metrics Reference-Freely, Forrest Sheng Bao+, N_A, arXiv'22</a>
<span class="snippet"><span>Summary</span>参照ベースと参照フリーの要約評価メトリックがあります。参照ベースは正確ですが、制約があります。参照フリーは独立していますが、ゼロショットと正確さの両方を満たせません。本研究では、参照ベースのメトリックを使用してゼロショットかつ正確な参照フリーのアプローチを提案します。実験結果は、このアプローチが最も優れた参照フリーのメトリックを提供できることを示しています。また、参照ベースのメトリックの再利用と追加の調整についても調査しています。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/PersonalizedGeneration.html">#PersonalizedGeneration</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<a class="button" href="articles/PersonalizedHeadlineGeneration.html">#PersonalizedHeadlineGeneration</a>
<span class="issue_date">Issue Date: 2023-08-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/929">Personalized News Headline Generation System with Fine-grained User Modeling, Yao, MSN'22</a>
<span class="snippet"><span>Summary</span>ユーザーの興味に基づいてパーソナライズされたニュースの見出しを生成するために、文レベルの情報を考慮したユーザーモデルを提案する。アテンション層を使用して文とニュースの関連性を計算し、ニュースの内容に基づいて見出しを生成する。実験結果は、提案モデルがベースラインモデルよりも優れたパフォーマンスを示していることを示している。将来の方向性として、情報のレベルと内容を横断する相互作用についても議論されている。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/PersonalizedGeneration.html">#PersonalizedGeneration</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<a class="button" href="articles/PersonalizedHeadlineGeneration.html">#PersonalizedHeadlineGeneration</a>
<span class="issue_date">Issue Date: 2023-08-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/928">Personalized Headline Generation with Enhanced User Interest Perception, Zhang+, ICANN'22</a>
<span class="snippet"><span>Summary</span>ユーザーのニュース閲覧履歴をモデル化し、個別化されたニュース見出しを生成するための新しいフレームワークを提案する。提案手法は、ユーザーの興味を強調するために候補テキストに関連する情報を活用し、ニュースのエンティティワードを使用して興味表現を改善する。幅広い実験により、提案手法が見出し生成タスクで優れたパフォーマンスを示すことが示されている。</span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/PersonalizedGeneration.html">#PersonalizedGeneration</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<span class="issue_date">Issue Date: 2023-08-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/927">Personalized Chit-Chat Generation for Recommendation Using External Chat Corpora, Chen+, KDD'22</a>
<span class="snippet"><span>Summary</span>チットチャットは、ユーザーとの対話において効果的であることが示されています。この研究では、ニュース推薦のための個人化されたチットチャットを生成する方法を提案しています。既存の方法とは異なり、外部のチャットコーパスのみを使用してユーザーの関心を推定し、個人化されたチットチャットを生成します。幅広い実験により、提案手法の効果が示されています。</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Explanation.html">#Explanation</a>
<span class="issue_date">Issue Date: 2023-08-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/912">Explaining Patterns in Data with Language Models via Interpretable  Autoprompting, Chandan Singh+, N_A, arXiv'22</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）を使用してデータのパターンを説明する能力を探求しました。具体的には、事前学習済みのLLMを使用してデータを説明する自然言語の文字列を生成するアルゴリズムを導入しました。実験結果は、このアルゴリズムが正確なデータセットの説明を見つけ出すことができることを示しています。また、生成されるプロンプトは人間にも理解可能であり、実世界のデータセットやfMRIデータセットで有用な洞察を提供することができることも示されました。</span>
<span class="snippet"><span>Comment</span>OpenReview: https://openreview.net/forum?id=GvMuB-YsiK6データセット（中に存在するパターンの説明）をLLMによって生成させる研究

<br>

![Image](https://github.com/user-attachments/assets/df70f8c2-6eda-412f-84e0-92ffe7152a39)

<br>

![Image](https://github.com/user-attachments/assets/42b4f4f9-6f6c-4e45-8c7c-db76c5fd9932)</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Controllable.html">#Controllable</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<span class="issue_date">Issue Date: 2023-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/861">An Extensible Plug-and-Play Method for Multi-Aspect Controllable Text  Generation, Xuancheng Huang+, N_A, arXiv'22</a>
<span class="snippet"><span>Summary</span>本研究では、テキスト生成において複数の側面を制御する方法について研究しました。従来の方法では、プレフィックスの相互干渉により制約が低下し、未知の側面の組み合わせを制御することが制限されていました。そこで、トレーニング可能なゲートを使用してプレフィックスの介入を正規化し、相互干渉の増加を抑制する方法を提案しました。この方法により、トレーニング時に未知の制約を低コストで拡張することができます。さらに、カテゴリカルな制約と自由形式の制約の両方を処理する統一された方法も提案しました。実験により、提案手法が制約の正確さ、テキストの品質、拡張性においてベースラインよりも優れていることが示されました。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-04-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/553">Large Language Models are Zero-Shot Reasoners, Kojima+, University of Tokyo, NeurIPS'22</a>
<span class="snippet"><span>Comment</span>Zero-Shot CoT (Let's think step-by-step.)論文<img width="856" alt="image" src="https://user-images.githubusercontent.com/12249301/234746367-2cd80e23-8dcb-4244-b56c-e28120629027.png">

<br>



<br>

Zero-Shot-CoTは2つのステップで構成される：

<br>



<br>

・STEP1: Reasoning Extraction

<br>



<br>

  ・元のquestionをxとし、zero-shot-CoTのtrigger sentenceをtとした時に、テンプレート "Q: [X]. A. [T]" を用いてprompt　x'を作成

<br>



<br>

  ・このprompt x'によって得られる生成テキストzはreasoningのrationaleとなっている。

<br>



<br>

・STEP2: Answer Extraction

<br>



<br>

  ・STEP1で得られたx'とzを用いて、テンプレート "[X'] [Z] [A]" を用いてpromptを作成し、quiestionに対する回答を得る

<br>



<br>

  ・このとき、Aは回答を抽出するためのtrigger sentenceである。

<br>



<br>

  ・Aはタスクに応じて変更するのが効果的であり、たとえば、multi-choice QAでは "Therefore, among A through E, the answer is" といったトリガーを用いたり、数学の問題では "Therefore, the answer (arabic numerals) is" といったトリガーを用いる。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236404426-ed936908-3771-4eef-9871-c6ae04c896bf.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

実験結果

<br>



<br>

表中の性能指標の左側はタスクごとにAnswer Triggerをカスタマイズしたもので、右側はシンプルに"The answer is"をAnswer Triggerとした場合。Zero-shot vs. Zero-shot-CoTでは、Zero-Shot-CoTが多くのb現地マークにおいて高い性能を示している。ただし、commonsense reasoningではperformance gainを得られなかった。これは 551 で報告されている通り、commonsense reasoningタスクでは、Few-Shot CoTでもLambda135Bで性能が向上せず、Palm540Bで性能が向上したように、モデルのparameter数が足りていない可能性がある（本実験では17種類のモデルを用いているが、特に注釈がなければtext-davinci-002を利用した結果）。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236405336-fe5e1f7f-9d2f-457f-9e25-98afe4ae0ec1.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

他ベースラインとの比較

<br>



<br>

他のベースラインとarithmetic reasoning benchmarkで性能比較した結果。Few-Shot-CoTには勝てていないが、standard Few-shot Promptingtを大幅に上回っている。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236406621-7862823f-e019-4551-be96-1c97265ca5ba.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

zero-shot reasoningにおけるモデルサイズの影響

<br>



<br>

さまざまな言語モデルに対して、zero-shotとzero-shot-CoTを実施した場合の性能比較。551 と同様にモデルサイズが小さいとZero-shot-CoTによるgainは得られないが、モデルサイズが大きくなると一気にgainが大きくなる。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236407727-f29e6f67-8ca1-4623-8341-73bbf2029e67.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Zero-shot CoTにおけるpromptの選択による影響

<br>



<br>

input promptに対するロバスト性を確認した。instructiveカテゴリ（すなわち、CoTを促すトリガーであれば）性能が改善している。特に、どのようなsentenceのトリガーにするかで性能が大きくかわっている。今回の実験では、"Let's think step by step"が最も高い性能を占め最多。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236408268-8dbc32f3-76c7-4e41-aa1b-a19008aa680c.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Few-shot CoTのprompt選択における影響

<br>



<br>

CommonsenseQAのexampleを用いて、AQUA-RAT, MultiArithをFew-shot CoTで解いた場合の性能。どちらのケースもドメインは異なるが、前者は回答のフォーマットは共通である。異なるドメインでも、answer format（multiple choice）の場合、ドメインが異なるにもかかわらず、zero-shotと比較して性能が大幅に向上した。一方、answer formatが異なる場合はperformance gainが小さい。このことから、LLMはtask自体よりも、exampleにおけるrepeated formatを活用していることを示唆している。また、CommonSennseをExamplarとして用いたFew-Shot-CoTでは、どちらのデータセットでもZero-Shot-CoTよりも性能が劣化している。つまり、Few-Shot-CoTでは、タスク特有のサンプルエンジニアリングが必要であることがわかる（一方、Zero-shot CoTではそのようなエンジニアリングは必要ない）。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236408978-b292ea0f-0a17-42fc-8e3c-6eee35780ca4.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Zero/FewShotPrompting.html">#Zero/FewShotPrompting</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<span class="issue_date">Issue Date: 2023-04-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/551">Chain of thought prompting elicits reasoning in large language models, Wei+, Google Research, NeurIPS'22</a>
<span class="snippet"><span>Comment</span>Chain-of-Thoughtを提案した論文。CoTをする上でパラメータ数が100B未満のモデルではあまり効果が発揮されないということは念頭に置いた方が良さそう。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234739470-be1c9299-0dd6-4483-901a-0bf855e73f0f.png" alt="image" loading="lazy">

<br>



<br>

先行研究では、reasoningが必要なタスクの性能が低い問題をintermediate stepを明示的に作成し、pre-trainedモデルをfinetuningすることで解決していた。しかしこの方法では、finetuning用の高品質なrationaleが記述された大規模データを準備するのに多大なコストがかかるという問題があった。

<br>



<br>

このため、few-shot promptingによってこの問題を解決することが考えられるが、reasoning能力が必要なタスクでは性能が悪いという問題あがった。そこで、両者の強みを組み合わせた手法として、chain-of-thought promptingは提案された。CoTによる実験結果

<br>



<br>

以下のベンチマークを利用

<br>



<br>

・math word problem: GSM8K, SVAMP, ASDiv, AQuA, MAWPS

<br>



<br>

・commonsense reasoning: CSQA, StrategyQA, Big-bench Effort (Date, Sports), SayCan

<br>



<br>

・Symbolic Reasoning: Last Letter concatenation, Coin Flip

<br>



<br>

  ・Last Letter concatnation: 名前の単語のlast wordをconcatするタスク（"Amy Brown" -&gt; "yn"）

<br>



<br>

  ・Coin Flip: コインをひっくり返す、 あるいはひっくり返さない動作の記述の後に、コインが表向きであるかどうかをモデルに回答するよう求めるタスク

<br>



<br>

 

<br>



<br>

math word problem benchmark

<br>



<br>

・モデルのサイズが大きくなるにつれ性能が大きく向上（emergent ability）することがあることがわかる

<br>



<br>

  ・言い換えるとCoTは&lt;100Bのモデルではパフォーマンスに対してインパクトを与えない

<br>



<br>

  ・モデルサイズが小さいと、誤ったCoTを生成してしまうため

<br>



<br>

・複雑な問題になればなるほど、CoTによる恩恵が大きい

<br>



<br>

  ・ベースラインの性能が最も低かったGSM8Kでは、パフォーマンスの2倍向上しており、1 stepのreasoningで解決できるSingleOpやMAWPSでは、性能の向上幅が小さい

<br>



<br>

・Task specificなモデルをfinetuningした以前のSoTAと比較してcomparable, あるいはoutperformしている

<br>



<br>

・<img src="https://user-images.githubusercontent.com/12249301/236394200-826ba167-8ec7-4abb-ba4d-fe44bf247b41.png" alt="image" loading="lazy">

<br>



<br>

Ablation Study

<br>



<br>

CoTではなく、他のタイプのpromptingでも同じような効果が得られるのではないか？という疑問に回答するために、3つのpromptingを実施し、CoTと性能比較した：

<br>



<br>

・Equation Only: 回答するまえに数式を記載するようなprompt

<br>



<br>

  ・promptの中に数式が書かれているから性能改善されているのでは？という疑問に対する検証

<br>



<br>

  ・=&gt; GSM8Kによる結果を見ると、equation onlyでは性能が低かった。これは、これは数式だけでreasoning stepsを表現できないことに起因している

<br>



<br>

・Variable compute only: dotのsequence (...) のみのprompt

<br>



<br>

  ・CoTは難しい問題に対してより多くの計算（intermediate token）をすることができているからでは？という疑問に対する検証

<br>



<br>

  ・variable computationとCoTの影響を分離するために、dotのsequence (...) のみでpromptingする方法を検証

<br>



<br>

  ・=&gt; 結果はbaselineと性能変わらず。このことから、variableの計算自体が性能向上に寄与しているわけではないことがわかる。

<br>



<br>

・Chain of Thought after answer: 回答の後にCoTを出力するようなprompting

<br>



<br>

  ・単にpretrainingの際のrelevantな知識にアクセスしやすくなっているだけなのでは？という疑問を検証

<br>



<br>

  ・=&gt; baselineと性能は変わらず、単に知識を活性化させるだけでは性能が向上しないことがわかる。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236396383-877a26ae-20c2-42a4-a023-1eb66abf8320.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

CoTのロバスト性

<br>



<br>

人間のAnnotatorにCoTを作成させ、それらを利用したCoTpromptingとexamplarベースな手法によって性能がどれだけ変わるかを検証。standard promptingを全ての場合で上回る性能を獲得した。このことから、linguisticなstyleにCoTは影響を受けていないことがわかる。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236397864-073dd88f-95c0-47f0-af3c-ed7288ca967d.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

commonsense reasoning

<br>



<br>

全てのデータセットにおいて、CoTがstandard promptingをoutperformした。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236398447-6c58a3f3-7461-4109-9a96-8f8092831dd1.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Symbolic Reasoning

<br>



<br>

in-domain test setとout-of-domain test setの2種類を用意した。前者は必要なreasoning stepがfew-shot examplarと同一のもの、後者は必要なreasoning stepがfew-shot examplarよりも多いものである。

<br>



<br>

CoTがStandard proimptingを上回っている。特に、standard promptingではOOV test setではモデルをスケールさせても性能が向上しなかったのに対し、CoTではより大きなgainを得ている。このことから、CoTにはreasoning stepのlengthに対しても汎化能力があることがわかる。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236399389-30e62218-3e59-4912-983c-818de457fa04.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-04-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/523">Recurrent Memory Transformer, Bulatov+, NeurIPS'22</a>
<span class="snippet"><span>Comment</span>TransformerはO(N^2)であり、計算量がNに応じて指数関数的に増加してしまう。一方、sequenceの情報を全てN次元ベクトルに集約しなければならず、計算量の制約によって長い系列のRepresentationを獲得できない。

<br>



<br>

そこで、Transformerの構造は変えず、Inputにメモリtokenを追加することで、メモリ間の関係性を学習できるような手法を提案。長いトークン列に対しても、トークン列をセグメントとゆばれる単位に区切り、セグメントのInputの頭で、前断のセグメントのメモリtokenを入力し、最終的に現在のセグメントのメモリをoutputし、後断のセグメントに入力とする、といったことを繰り返すことで、長い系列も扱えるようにした。

<br>



<br>

セグメントをまたいでbackpropagationをかけることで、たとえセグメントとしては独立していても、メモリの情報を考慮することでセグメント間の依存関係を学習することが可能だと思われる。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234206394-925cb6ee-85bd-46ad-b7ed-f57685badc38.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2022-12-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/501">UNIFIEDSKG: Unifying and Multi-Tasking Structured Knowledge Grounding with Text-to-Text Language Models, Xie+, EMNLP'22</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<span class="issue_date">Issue Date: 2022-12-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/500">Revisiting Pretraining Objectives for Tabular Deep Learning, Rubachev+, Yandex+, arXiv'22</a>
<span class="snippet"><span>Summary</span>表形式データに対する深層学習モデルはGBDTと競争しており、事前学習がパフォーマンス向上に寄与することが示された。異なるデータセットやアーキテクチャに適用可能な事前学習のベストプラクティスを特定し、オブジェクトターゲットラベルの使用が有益であることを発見。適切な事前学習により、深層学習モデルはGBDTを上回る性能を発揮することが確認された。</span>
<span class="snippet"><span>Comment</span>Tabular Dataを利用した場合にKaggleなどでDeepなモデルがGBDT等に勝てないことが知られているが、GBDT等とcomparable になる性能になるようなpre-trainingを提案したよ、的な内容っぽいICLR 2023 OpenReview: https://openreview.net/forum?id=kjPLodRa0n</span>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<span class="issue_date">Issue Date: 2022-02-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/436">JaQuAD: Japanese Question Answering Dataset for Machine Reading Comprehension, So+, arXiv'22</a>
<span class="snippet"><span>Summary</span>日本語の質問応答データセットJaQuADを提案。39,696の質問-回答ペアを含み、テストセットでF1スコア78.92%、EMスコア63.38%を達成。データセットは[こちら](https://github.com/SkelterLabsInc/JaQuAD)から入手可能。</span>
<span class="snippet"><span>Comment</span>SQuAD likeな日本語のQAデータセット

<br>



<br>

https://github.com/SkelterLabsInc/JaQuAD</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/AAAI.html">#AAAI</a>
<span class="issue_date">Issue Date: 2021-06-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/379">Improving Neural Machine Translation with Compact Word Embedding Tables, Kumar+, AAAI'22</a>
<span class="snippet"><span>Comment</span>NMTにおいてword embeddingがどう影響しているかなどを調査しているらしい</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/ZeroshotHyperparameterTransfer.html">#ZeroshotHyperparameterTransfer</a>
<span class="issue_date">Issue Date: 2025-08-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2582">[Paper Note] Tensor Programs V: Tuning Large Neural Networks via Zero-Shot  Hyperparameter Transfer, Greg Yang+, NeurIPS'21</a>
<span class="snippet"><span>Summary</span>ハイパーパラメータチューニングは高コストであり、特に大規模なニューラルネットワークにおいて負担が大きい。新たに提案するmuTransferは、最大更新パラメータ化（muP）を利用し、小さなモデルでチューニングしたHPをフルサイズモデルにゼロショットで転送する手法である。実験により、1300万パラメータのモデルからBERT-largeを超える性能を達成し、4000万パラメータからはGPT-3を上回る結果を得た。チューニングコストはそれぞれ事前学習コストの同等または7%に抑えられた。</span>
<span class="snippet"><span>Comment</span>openreview: https://openreview.net/forum?id=Bx6qKuBM2AD小規模なモデルに対してハイパーパラメータのチューニングを実施し、同様のベースモデルで、各layerのwidthが大きいものに対しても、小規模モデルで最適であったハイパーパラメータをzero-shotで転移することで near optimalなハイパーパラメータで学習できるmu Transferを提案。

<br>



<br>

モデルの深さ（以外にも下表中の印のパラメータ）に対しても限定的に転移可能な模様。Post-Layer NormのTransformerやではあまりうまくいかないことが11節に記述されている（実験はpre-Layer Norm Transformer, ResNetに対して行われている模様）。

<br>

また、6.1節では、（実験的に）利用する小規模モデルのスケールとして幅256, 深さ4, バッチサイズ32, sequence長128, 訓練ステップ数5000を最低満たしており、かつスケールさせる幅が妥当な範囲内である必要がある、といった話が記述されている。

<br>



<br>

前提知識（muP）や条件が多そうな気がするので、しっかり確認した方がよさそう。

<br>

たとえば、muPで初期化されている必要があることや、転送可能なハイパーパラメータに限りがある（e.g. 学習率）、異なるデータに対するfinetuningなどは転送できないなど。

<br>



<br>



<br>

<img width="872" height="336" alt="Image" src="https://github.com/user-attachments/assets/e5aeb152-5c9e-4ba2-9152-4bfef0d7c27c">muP:

<br>

・2583</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/CodeGeneration.html">#CodeGeneration</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-08-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2439">[Paper Note] Program Synthesis with Large Language Models, Jacob Austin+, arXiv'21</a>
<span class="snippet"><span>Summary</span>本論文では、汎用プログラミング言語におけるプログラム合成の限界を大規模言語モデルを用いて評価します。MBPPとMathQA-Pythonの2つのベンチマークで、モデルサイズに対する合成性能のスケールを調査。最も大きなモデルは、少数ショット学習でMBPPの59.6％の問題を解決可能で、ファインチューニングにより約10％の性能向上が見られました。MathQA-Pythonでは、ファインチューニングされたモデルが83.8％の精度を達成。人間のフィードバックを取り入れることでエラー率が半減し、エラー分析を通じてモデルの弱点を明らかにしました。最終的に、プログラム実行結果の予測能力を探るも、最良のモデルでも特定の入力に対する出力予測が困難であることが示されました。</span>
<span class="snippet"><span>Comment</span>代表的なコード生成のベンチマーク。

<br>



<br>

MBPPデータセットは、promptで指示されたコードをモデルに生成させ、テストコード（assertion)を通過するか否かで評価する。974サンプル存在し、pythonの基礎を持つクラウドワーカーによって生成。クラウドワーカーにタスクdescriptionとタスクを実施する一つの関数（関数のみで実行可能でprintは不可）、3つのテストケースを記述するよう依頼。タスクdescriptionは追加なclarificationなしでコードが記述できるよう十分な情報を含むよう記述するように指示。ground truthの関数を生成する際に、webを閲覧することを許可した。

<br>

<img src="https://github.com/user-attachments/assets/e27880f7-4647-462d-b619-e0a7a0959d66" alt="image" loading="lazy">

<br>



<br>

MathQA-Pythonは、MathQAに含まれるQAのうち解答が数値のもののみにフィルタリングしたデータセットで、合計で23914サンプル存在する。pythonコードで与えられた数学に関する問題を解くコードを書き、数値が一致するか否かで評価する、といった感じな模様。斜め読みなので少し読み違えているかもしれない。

<br>



<br>

<img src="https://github.com/user-attachments/assets/d21ee76f-a13d-4ef9-843b-74c233c3c0a6" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/CodeGeneration.html">#CodeGeneration</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-08-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2438">[Paper Note] Evaluating Large Language Models Trained on Code, Mark Chen+, arXiv'21</a>
<span class="snippet"><span>Summary</span>CodexはGitHubのコードでファインチューニングされたGPT言語モデルで、Pythonコード生成能力を評価。新しい評価セットHumanEvalでは、Codexが28.8%の問題を解決し、GPT-3は0%、GPT-Jは11.4%だった。繰り返しサンプリングが難しいプロンプトに対しても効果的な戦略を用い、70.2%の問題を解決。モデルの限界として、長い操作の説明や変数へのバインドに苦労する点が明らかに。最後に、コード生成技術の影響について安全性や経済に関する議論を行う。</span>
<span class="snippet"><span>Comment</span>HumanEvalデータセット。Killed by LLMによると、GPT4oによりすでに90%程度の性能が達成され飽和している。

<br>



<br>

164個の人手で記述されたprogrammingの問題で、それぞれはfunction signature, docstring, body, unittestを持つ。unittestは問題当たり約7.7 test存在。handwrittenという点がミソで、コンタミネーションの懸念があるためgithubのような既存ソースからのコピーなどはしていない。pass@k[^1]で評価。

<br>



<br>

[^1]: k個のサンプルを生成させ、k個のサンプルのうち、サンプルがunittestを一つでも通過する確率。ただ、本研究ではよりバイアスをなくすために、kよりも大きいn個のサンプルを生成し、その中からランダムにk個を選択して確率を推定するようなアプローチを実施している。2.1節を参照のこと。

<br>



<br>

<img src="https://github.com/user-attachments/assets/74a74b6f-9d0c-4ce9-ab8b-53b478b4632a" alt="image" loading="lazy"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<a class="button" href="articles/FactualKnowledge.html">#FactualKnowledge</a>
<span class="issue_date">Issue Date: 2025-07-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2140">[Paper Note] Transformer Feed-Forward Layers Are Key-Value Memories, Mor Geva+, EMNLP'21</a>
<span class="snippet"><span>Summary</span>フィードフォワード層はトランスフォーマーモデルの大部分を占めるが、その役割は未探求。研究により、フィードフォワード層がキー・バリュー・メモリとして機能し、トレーニング例のテキストパターンと相関することを示す。実験で、下層は浅いパターン、上層は意味的なパターンを学習し、バリューが出力分布を誘導することが確認された。最終的に、フィードフォワード層の出力はメモリの合成であり、残差接続を通じて洗練される。</span>
<span class="snippet"><span>Comment</span>日本語解説（p.5より）: https://speakerdeck.com/kogoro/knowledge-neurons-in-pretrained-transformers-for-snlp2022?slide=5</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/KnowledgeEditing.html">#KnowledgeEditing</a>
<span class="issue_date">Issue Date: 2025-06-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2056">[Paper Note] Editing Factual Knowledge in Language Models, Nicola De Cao+, EMNLP'21</a>
<span class="snippet"><span>Summary</span>KnowledgeEditorは、事前学習された言語モデルの知識を編集し、再学習なしで誤った事実や予測を修正する手法です。制約最適化を用いてハイパーネットワークを訓練し、他の知識に影響を与えずに事実を修正します。BERTとBARTのモデルでその有効性を示し、特定のクエリに基づく予測変更がパラフレーズにも一貫して影響を与えることを確認しました。ハイパーネットワークは、知識操作に必要なコンポーネントを特定する「プローブ」として機能します。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2024-12-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1618">Training Verifiers to Solve Math Word Problems, Karl Cobbe+, arXiv'21</a>
<span class="snippet"><span>Summary</span>GSM8Kデータセットを用いて、多段階の数学的推論における言語モデルの限界を分析。検証器を訓練し、候補解を評価して最適解を選択することで、モデルのパフォーマンスを大幅に向上させることを示した。検証はファインチューニングよりもデータ増加に対して効果的にスケールする。</span>
<span class="snippet"><span>Comment</span>気持ち

<br>



<br>

・当時の最も大きいレベルのモデルでも multi-stepのreasoningが必要な問題は失敗する

<br>



<br>

・モデルをFinetuningをしても致命的なミスが含まれる

<br>



<br>

・特に、数学は個々のミスに対して非常にsensitiveであり、一回ミスをして異なる解法のパスに入ってしまうと、self-correctionするメカニズムがauto-regressiveなモデルではうまくいかない

<br>



<br>

・純粋なテキスト生成の枠組みでそれなりの性能に到達しようとすると、とんでもないパラメータ数が必要になり、より良いscaling lawを示す手法を模索する必要がある

<br>



<br>

Contribution

<br>



<br>

論文の貢献は

<br>



<br>

・GSM8Kを提案し、

<br>



<br>

・verifierを活用しモデルの複数の候補の中から良い候補を選ぶフレームワークによって、モデルのパラメータを30倍にしたのと同等のパフォーマンスを達成し、データを増やすとverifierを導入するとよりよく性能がスケールすることを示した。

<br>



<br>

・また、dropoutが非常に強い正則化作用を促し、finetuningとverificationの双方を大きく改善することを示した。Todo: 続きをまとめる</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<span class="issue_date">Issue Date: 2024-10-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1439">Intrinsic Dimensionality Explains the Effectiveness of Language Model   Fine-Tuning, Armen Aghajanyan+, N_A, ACL'21</a>
<span class="snippet"><span>Summary</span>事前学習された言語モデルのファインチューニングのダイナミクスを内因次元の観点から分析し、少ないデータでも効果的に調整できる理由を説明。一般的なモデルは低い内因次元を持ち、フルパラメータ空間と同等の効果を持つ低次元の再パラメータ化が可能であることを示す。特に、RoBERTaモデルを用いて、少数のパラメータの最適化で高いパフォーマンスを達成できることを実証。また、事前学習が内因次元を最小化し、大きなモデルが低い内因次元を持つ傾向があることを示し、内因次元に基づく一般化境界を提案。</span>
<span class="snippet"><span>Comment</span>ACL ver:https://aclanthology.org/2021.acl-long.568.pdf下記の元ポストを拝読の上論文を斜め読み。モデルサイズが大きいほど、特定の性能（論文中では2種類のデータセットでの90%のsentence prediction性能）をfinetuningで達成するために必要なパラメータ数は、モデルサイズが大きくなればなるほど小さくなっている。

<br>



<br>

LoRAとの関係性についても元ポスト中で言及されており、論文の中身も見て後で確認する。

<br>

おそらく、LLMはBERTなどと比較して遥かにパラメータ数が大きいため、finetuningに要するパラメータ数はさらに小さくなっていることが想像され、LoRAのような少量のパラメータをconcatするだけでうまくいく、というような話だと思われる。興味深い。

<br>



<br>

<img src="https://github.com/user-attachments/assets/166ebdae-539f-44cf-822b-0084640e07b2" alt="image" loading="lazy">

<br>

元ポスト:https://x.com/bilzrd/status/1840445027438456838?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<span class="issue_date">Issue Date: 2024-07-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1333">Transformer Feed-Forward Layers Are Key-Value Memories, Mor Geva+, N_A, EMNLP'21</a>
<span class="snippet"><span>Summary</span>トランスフォーマーモデルのフィードフォワード層は、キー・バリューメモリとして機能し、学習されたパターンが人間に解釈可能であることや、上位層がより意味のあるパターンを学習することが示されました。さらに、出力分布を誘導する役割も持ちます。フィードフォワード層の出力はそのメモリの合成であり、残差接続を介してモデルの層を通じて洗練され、最終的な出力分布を生成します。</span>
<span class="snippet"><span>Comment</span>1108 FF layerがKey-Valueストアとして機能する仕組みの概略図

<br>

<img src="https://github.com/user-attachments/assets/cc12695f-b030-433a-88e1-aed69f9847a7" alt="image" loading="lazy">

<br>



<br>

実際に特定のKeyと最も関連度が高い訓練事例（input）を抽出し、人間がinputのパターンを分類した結果

<br>

<img src="https://github.com/user-attachments/assets/d1c1a031-9cb8-4e22-bf87-23964f0e0c71" alt="image" loading="lazy"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Annotation.html">#Annotation</a>
<span class="issue_date">Issue Date: 2024-05-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1306">The Perils of Using Mechanical Turk to Evaluate Open-Ended Text  Generation, Marzena Karpinska+, N_A, EMNLP'21</a>
<span class="snippet"><span>Summary</span>最近のテキスト生成の研究は、オープンエンドのドメインに注力しており、その評価が難しいため、多くの研究者がクラウドソーシングされた人間の判断を収集してモデリングを正当化している。しかし、多くの研究は重要な詳細を報告しておらず、再現性が妨げられていることがわかった。さらに、労働者はモデル生成のテキストと人間による参照テキストを区別できないことが発見され、表示方法を変更することで改善されることが示された。英語教師とのインタビューでは、モデル生成のテキストを評価する際の課題について、より深い洞察が得られた。</span>
<span class="snippet"><span>Comment</span>Open-endedなタスクに対するAMTの評価の再現性に関する研究。先行研究をSurveyしたところ、再現のために重要な情報（たとえば、workerの資格、費用、task descriptions、annotator間のagreementなど）が欠落していることが判明した。

<br>



<br>

続いて、expertsとAMT workerに対して、story generationの評価を実施し、GPT2が生成したストーリーと人間が生成したストーリーを、後者のスコアが高くなることを期待して依頼した。その結果

<br>



<br>

・AMTのratingは、モデルが生成したテキストと、人間が生成したテキストをreliableに区別できない

<br>



<br>

・同一のタスクを異なる日程で実施をすると、高い分散が生じた

<br>



<br>

・多くのAMT workerは、評価対象のテキストを注意深く読んでいない

<br>



<br>

・Expertでさえモデルが生成したテキストを読み判断するのには苦戦をし、先行研究と比較してより多くの時間を費やし、agreementが低くなることが分かった

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/1dc01c56-88b0-4bea-869b-f396d65701cc" alt="image" loading="lazy">

<br>



<br>

892 において、低品質なwork forceが人手評価に対して有害な影響を与える、という文脈で本研究が引用されている</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<span class="issue_date">Issue Date: 2023-08-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1009">ViLT: Vision-and-Language Transformer Without Convolution or Region   Supervision, Wonjae Kim+, N_A, ICML'21</a>
<span class="snippet"><span>Summary</span>VLP（Vision-and-Language Pre-training）のアプローチは、ビジョンと言語のタスクでのパフォーマンスを向上させているが、現在の方法は効率性と表現力の面で問題がある。そこで、本研究では畳み込みフリーのビジョンと言語のトランスフォーマ（ViLT）モデルを提案する。ViLTは高速でありながら競争力のあるパフォーマンスを示し、コードと事前学習済みの重みはGitHubで利用可能である。</span>
<span class="snippet"><span>Comment</span>日本語解説:https://tech.fusic.co.jp/posts/2021-12-29-vilt/</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/984">SummEval: Re-evaluating Summarization Evaluation, Fabbri+, TACL'21</a>
<span class="snippet"><span>Comment</span>自動評価指標が人手評価の水準に達しないことが示されており、結局のところROUGEを上回る自動性能指標はほとんどなかった。human judgmentsとのKendall;'s Tauを見ると、chrFがCoherenceとRelevance, METEORがFluencyで上回ったのみだった。また、LEAD-3はやはりベースラインとしてかなり強く、LEAD-3を上回ったのはBARTとPEGASUSだった。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/981">How to Evaluate a Summarizer: Study Design and Statistical Analysis for Manual Linguistic Quality Evaluation, Steen+, EACL'21</a>
<span class="snippet"><span>Summary</span>要約システムの評価方法についての調査結果を報告しました。要約の言語的品質についての評価実験を行い、最適な評価方法は側面によって異なることを示しました。また、研究パラメータや統計分析方法についても問題点を指摘しました。さらに、現行の方法では固定された研究予算の下では信頼性のある注釈を提供できないことを強調しました。</span>
<span class="snippet"><span>Comment</span>要約の人手評価に対する研究</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/980">Reliability of Human Evaluation for Text Summarization: Lessons Learned and Challenges Ahead, Iskender+, EACL'21</a>
<span class="snippet"><span>Summary</span>人間評価の信頼性に関する研究では、参加者の情報や実験の詳細が提供されていないことが多い。また、人間評価の信頼性に影響を与える要因についても研究されていない。そこで、私たちは人間評価実験を行い、参加者の情報や実験の詳細を提供し、異なる実験結果を比較した。さらに、専門家と非専門家の評価の信頼性を確保するためのガイドラインを提供し、信頼性に影響を与える要因を特定した。</span>
<span class="snippet"><span>Comment</span>要約の人手評価に対する信頼性に関して研究。人手評価のガイドラインを提供している。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-free.html">#Reference-free</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/976">The Feasibility of Embedding Based Automatic Evaluation for Single Document Summarization, EMNLP-IJCNLP'21, Sun+</a>
<span class="snippet"><span>Comment</span>__translate: ROUGE is widely used to automatically evaluate summarization systems. However, ROUGE measures semantic overlap between a system summary and a human reference on word-string level, much at odds with the contemporary treatment of semantic meaning. Here we present a suite of experiments on using distributed representations for evaluating summarizers, both in reference-based and in reference-free setting. Our experimental results show that the max value over each dimension of the summary ELMo word embeddings is a good representation that results in high correlation with human ratings. Averaging the cosine similarity of all encoders we tested yields high correlation with manual scores in reference-free setting. The distributed representations outperform ROUGE in recent corpora for abstractive news summarization but are less good on test data used in past evaluations.C-ELMO/C-SBERT</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-free.html">#Reference-free</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/975">A Training-free and Reference-free Summarization Evaluation Metric via Centrality-weighted Relevance and Self-referenced Redundancy, Chen+, ACL-IJCNLP'21</a>
<span class="snippet"><span>Summary</span>参照ベースと教師ありの要約評価指標の制約を回避するために、トレーニングフリーかつ参照フリーの要約評価指標を提案する。この指標は、文の中心性によって重み付けされた概念参照と要約との関連性スコアと、自己参照の冗長性スコアから構成される。関連性スコアは擬似参照と要約との間で計算され、重要度のガイダンスを提供する。要約の冗長性スコアは要約内の冗長な情報を評価するために計算される。関連性スコアと冗長性スコアを組み合わせて、要約の最終評価スコアを生成する。徹底的な実験により、提案手法が既存の手法を大幅に上回ることが示された。ソースコードはGitHubで公開されている。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-free.html">#Reference-free</a>
<a class="button" href="articles/QA-based.html">#QA-based</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/974">QuestEval: Summarization Asks for Fact-based Evaluation, Thomas Scialom+, N_A, EMNLP'21</a>
<span class="snippet"><span>Summary</span>要約の評価は未解決の課題であり、既存の評価指標は限定的であり、人間の判断との相関が低い。そこで、本研究では質問応答モデルを利用した評価指標QuestEvalを提案する。QuestEvalは正解の参照を必要とせず、一貫性、結束性、流暢さ、関連性の4つの評価次元において人間の判断との相関を大幅に改善することが実験により示された。</span>
<span class="snippet"><span>Comment</span>QuestEval概要

<br>



<br>

984 によって提案されてきたメトリックがROUGEに勝てていないことについて言及し、より良い指標を提案。

<br>



<br>

・precision / recall-based な QA metricsを利用してよりロバスト

<br>



<br>

・生成されるqueryのsaliencyを学習する手法を提案することで、information selectionの概念を導入した

<br>



<br>

・CNN/Daily Mail, XSUMで評価した結果、SoTAな結果を獲得し、特にFactual Consistencyの評価に有用なことを示した

<br>



<br>



<br>



<br>

Question-based framework

<br>



<br>

prerainedなT5を利用しQAに回答するcomponent（question, Textがgivenな時answerを生成するモデル）を構築する。text Tに対するquery qに対してrと回答する確率をQ_A(r|T, q)とし、Q_A(T, q)をモデルによってgreedyに生成された回答とする。Questionが与えられた時、Summary内に回答が含まれているかは分からない。そのため、unanswerable token εもQA componentに含める。

<br>



<br>

QG componentとしては、answer-source documentが与えられたときに人間が生成したquestionを生成できるようfinetuningされたT5モデルを利用する。テスト時は、ソースドキュメントと、システム要約がgivenなときに、はじめにQG modelを条件付けするためのanswerのsetを選択する。1007 にならい、ソースドキュメントの全ての固有名詞と名詞をanswerとみなす。そして、それぞれの選択されたanswerごとに、beam searchを用いてquestionを生成する。そして、QAモデルが誤った回答をした場合、そのようなquestionはフィルタリングする。text Tにおいて、Q_A(T, q) = rとなるquestion-answer pairs (q, r)の集合を、Q_G(T)と表記する。

<br>



<br>



<br>



<br>

QuestEval metric

<br>



<br>

Precision

<br>



<br>

source documentをD, システム要約をSとしたときに、Precision, Recallを以下の式で測る：

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/3c1092a6-5a6e-494b-8ec1-a30fdc8ad96c" alt="image" loading="lazy">

<br>



<br>

question生成時は要約から生成し、生成されたquestionに回答する際はsource documentを利用し、回答の正誤に対してF1スコアを測定する。F1スコアは、ground truthと予測された回答を比較することによって測定され、回答がexact matchした場合に1, common tokenが存在しない場合に0を返す。D, Sで条件付けされたときに、回答が変わってしまう場合は要約がinconsistentだとみなせる、というintuitionからきている。

<br>



<br>

Recall

<br>



<br>

要約はfactual informationを含むべきのみならず(precision)、ソーステキストの重要な情報を含むべきである(recall)。943をquery weighter Wを導入することで拡張し、recallを下記で定義する：

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/cd44efcd-ca82-43cc-98db-13b697d86068" alt="image" loading="lazy">

<br>



<br>

ここで、Q_G(D)は、ソーステキストDにおけるすべてのQA pairの集合、W(q, D)はDに対するqの重みである。

<br>



<br>

 

<br>



<br>

Answerability and F1

<br>



<br>

Factoid QAモデルは一般的に、predicted answerとground truthのoverlapによって（F1）評価されている。しかし"ACL"と"Association for Computational Linguistics"のように、同じ回答でも異なる方法で表現される可能性がある。この例では、F1スコアは0となる（共通のtokenがないため）。

<br>



<br>

これを回避するために、943 と同様に1-Q_A(ε)を利用する。 

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/bb5379a9-02eb-438a-8bea-3729103bad7a" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

QG component, QA componentで利用するT5は、それぞれ[SQuAD-v2](https://huggingface.co/datasets/squad_v2)と、NewsQAデータセット 1142 によってfinetuningしたものを利用する。</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/DialogueGeneration.html">#DialogueGeneration</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-free.html">#Reference-free</a>
<a class="button" href="articles/QA-based.html">#QA-based</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/966">Q2: Evaluating Factual Consistency in Knowledge-Grounded Dialogues via Question Generation and Question Answering, Honovich+, EMNLP'21</a>
<span class="snippet"><span>Summary</span>本研究では、ニューラルな知識に基づく対話生成モデルの信頼性と適用範囲の制限についての問題を解決するため、自動的な質問生成と質問応答を使用した事実的な整合性の自動評価尺度を提案します。この尺度は、自然言語推論を使用して回答スパンを比較することで、以前のトークンベースのマッチングよりも優れた評価を行います。また、新しいデータセットを作成し、事実的な整合性の手動アノテーションを行い、他の尺度とのメタ評価を行いました。結果として、提案手法が人間の判断と高い相関を示しました。</span>
<span class="snippet"><span>Comment</span>（knowledge-grounded; 知識に基づいた）対話に対するFactual ConsistencyをReference-freeで評価できるQGQA手法。機械翻訳やAbstractive Summarizationの分野で研究が進んできたが、対話では

<br>



<br>

・対話履歴、個人の意見、ユーザに対する質問、そして雑談  

<br>



<br>



<br>



<br>

といった外部知識に対するconsistencyが適切ではない要素が多く存在し、よりチャレンジングなタスクとなっている。

<br>



<br>

また、そもそも対話タスクはopen-endedなタスクなため、Reference-basedな手法は現実的ではなく、Reference-freeな手法が必要と主張。

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/979808f2-d31a-49b0-bd25-aba1f1a81d4a" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

手法の概要としては以下。ユーザの発話からQuestion Generation (QG)を実施し、Question-Answer Candidate Pairを作成する。そして、生成したQuestionをベースとなる知識から回答させ（QA）、その回答結果とAnswer Candidateを比較することでFactual Consistencyを測定する。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/e6582686-2ed2-478a-8146-ec9834679df6" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/LM-based.html">#LM-based</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/964">Compression, Transduction, and Creation: A Unified Framework for Evaluating Natural Language Generation, Deng+, EMNLP''21</a>
<span class="snippet"><span>Summary</span>本研究では、自然言語生成（NLG）タスクの評価において、情報の整合性を重視した統一的な視点を提案する。情報の整合性を評価するための解釈可能な評価指標のファミリーを開発し、ゴールドリファレンスデータを必要とせずに、さまざまなNLGタスクの評価を行うことができることを実験で示した。</span>
<span class="snippet"><span>Comment</span>CTC</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-free.html">#Reference-free</a>
<a class="button" href="articles/QA-based.html">#QA-based</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/961">QACE: Asking Questions to Evaluate an Image Caption, Lee+, EMNLP'21</a>
<span class="snippet"><span>Summary</span>本研究では、画像キャプションの評価において、Question Generation（QG）とQuestion Answering（QA）システムに基づいた質問応答メトリックであるQACEを提案する。QACEは評価対象のキャプションに対して質問を生成し、その内容を参照キャプションまたはソース画像に対して質問することで確認する。QACE_Refというメトリックを開発し、最先端のメトリックと競合する結果を報告する。さらに、参照ではなく画像自体に直接質問をするQACE_Imgを提案する。QACE_ImgにはVisual-QAシステムが必要であり、Visual-T5という抽象的なVQAシステムを提案する。QACE_Imgはマルチモーダルで参照を必要とせず、説明可能なメトリックである。実験の結果、QACE_Imgは他の参照を必要としないメトリックと比較して有利な結果を示した。</span>
<span class="snippet"><span>Comment</span>Image Captioningを評価するためのQGQAを提案している。candidateから生成した質問を元画像, およびReferenceを用いて回答させ、candidateに基づいた回答と回答の結果を比較することで評価を実施する。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/552b3bfd-48a6-4915-af96-e8ae91e760dc" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-free.html">#Reference-free</a>
<a class="button" href="articles/LM-based.html">#LM-based</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/960">BARTSCORE: Evaluating Generated Text as Text Generation, Yuan+ （w_ Neubig氏）, NeurIPS'21</a>
<span class="snippet"><span>Summary</span>本研究では、生成されたテキストの評価方法について検討しました。具体的には、事前学習モデルを使用してテキスト生成の問題をモデル化し、生成されたテキストを参照出力またはソーステキストに変換するために訓練されたモデルを使用しました。提案したメトリックであるBARTSCOREは、情報量、流暢さ、事実性などの異なる視点のテキスト評価に柔軟に適用できます。実験結果では、既存のトップスコアリングメトリックを上回る性能を示しました。BARTScoreの計算に使用するコードは公開されており、インタラクティブなリーダーボードも利用可能です。</span>
<span class="snippet"><span>Comment</span>BARTScore概要

<br>



<br>

ソーステキストが与えられた時に、BARTによって生成テキストを生成する尤度を計算し、それをスコアとする手法。テキスト生成タスクをテキスト生成モデルでスコアリングすることで、pre-trainingされたパラメータをより有効に活用できる（e.g. BERTScoreやMoverScoreなどは、pre-trainingタスクがテキスト生成ではない）。BARTScoreの特徴は

<br>



<br>

1. parameter・and data-efficientである。pre-trainingに利用されたパラメータ以外の追加パラメータは必要なく、unsupervisedなmetricなので、human judgmentのデータなども必要ない。

<br>



<br>

2. 様々な観点から生成テキストを評価できる。conditional text generation problemにすることでinformativeness, coherence, factualityなどの様々な観点に対応可能。

<br>



<br>

3. BARTScoreは、(i) pre-training taskと類似したpromptを与えること、(ii) down stream generation taskでfinetuningすること、でより高い性能を獲得できる

<br>



<br>

BARTScoreを16種類のデータセットの、7つの観点で評価したところ、16/22において、top-scoring metricsよりも高い性能を示した。また、prompting starategyの有効性を示した。たとえば、シンプルに"such as"というフレーズを翻訳テキストに追加するだけで、German-English MTにおいて3%の性能向上が見られた。また、BARTScoreは、high-qualityなテキスト生成システムを扱う際に、よりロバストであることが分析の結果分かった。

<br>



<br>



<br>



<br>

前提

<br>



<br>

Problem Formulation

<br>



<br>

生成されたテキストのqualityを測ることを目的とする。本研究では、conditional text generation (e.g. 機械翻訳)にフォーカスする。すなわち、ゴールは、hypothesis h_bar を source text s_barがgivenな状態で生成することである。一般的には、人間が作成したreference r_barが評価の際は利用される。

<br>



<br>

Gold-standard Human Evaluation

<br>



<br>

評価のgold standardは人手評価であり、人手評価では多くの観点から評価が行われる。以下に代表的な観点を示す：

<br>



<br>

1. Informativeness: ソーステキストのキーアイデアをどれだけ捉えているか

<br>



<br>

2. Relevance: ソーステキストにあ地して、どれだけconsistentか

<br>



<br>

3. Fluency formatting problem, capitarlization errorや非文など、どの程度読むのが困難か

<br>



<br>

4. Coherence: 文間のつながりが、トピックに対してどれだけcoherentか

<br>



<br>

5. Factuality: ソーステキストに含意されるstatementのみを生成できているか

<br>



<br>

6. Semantic Coverage: 参照テキスト中のSemantic Content Unitを生成テキストがどれだけカバーできているか

<br>



<br>

7: Adequacy 入力文に対してアウトプットが同じ意味を出力できているかどうか、あるいは何らかのメッセージが失われる、追加される、歪曲していないかどうか

<br>



<br>



<br>



<br>

多くの性能指標は、これらの観点のうちのsubsetをカバーするようにデザインんされている。たとえば、BLEUは、翻訳におけるAdequacyとFluencyをとらえることを目的としている。一方、ROUGEは、semantic coverageを測るためのメトリックである。

<br>



<br>

BARTScoreは、これらのうち多くの観点を評価することができる。

<br>



<br>



<br>



<br>

Evaluation as Different Tasks

<br>



<br>

ニューラルモデルを異なる方法で自動評価に活用するのが最近のトレンドである。下図がその分類。この分類は、タスクにフォーカスした分類となっている。

<br>



<br>

1. Unsupervised Matching: ROUGE, BLEU, CHRF, BERTScore, MoverScoreのように、hypothesisとreference間での意味的な等価性を測ることが目的である。このために、token-levelのマッチングを用いる。これは、distributedな表現を用いる（BERTScore, MoverScore）場合もあれば、discreteな表現を用いる（ROUGE, BLEU, chrF）場合もある。また、意味的な等価性だけでなく、factual consistencyや、source-hypothesis間の関係性の評価に用いることもできると考えられるが先行研究ではやられていなかったので、本研究で可能なことを示す。

<br>



<br>

2. Supervised Regression: BLEURT, COMET, S^3, VRMのように、regression layer を用いてhuman judgmentをsupervisedに予測する方法である。最近のメトリックｔおしては、BLEURT, COMETがあげられ、古典的なものとしては、S^3, VRMがあげられる。

<br>



<br>

4. Supervised Ranking: COMET, BEERのような、ランキング問題としてとらえる方法もある。これは優れたhypothesisを上位にランキングするようなスコア関数を学習する問題に帰着する。COMETやBEERが例としてあげられ、両者はMTタスクにフォーカスされている。COMETはhunan judgmentsをregressionすることを通じてランキングを作成し、BEERは、多くのシンプルな特徴量を組み合わせて、linear layerでチューニングされる。

<br>



<br>

5. Text Generation: PRISM, BARTScoreが例として挙げられる。BARTScoreでは、生成されたテキストの評価をpre-trained language modelによるテキスト生成タスクとしてとらえる。基本的なアイデアとしては、高品質のhypothesisは、ソース、あるいはreferenceから容易に生成可能であろう、というものである。これはPRISMを除いて、先行研究ではカバーされていない。BARTScoreは、PRISMとはいくつかの点で異なっている。(i) PRISMは評価をparaphrasing taskとしてとらえており、これが2つの意味が同じテキストを比較する前提となってしまっているため、手法を適用可能な範囲を狭めてしまっている。たとえば、文書要約におけるfactual consistencyの評価では、semantic spaceが異なる2つのテキストを比較する必要があるが、このような例には対応できない。(ii) PRISMはparallel dataから学習しなけえｒばならないが、BARTScoreは、pre-trainedなopen-sourceのseq2seq modelを利用できる。(iii) BARTScoreでは、PRISMが検証していない、prompt-basedのlearningもサポートしている。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/4a64ea21-ab9f-4762-bd71-f858663fc195" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

BARTScore

<br>



<br>

Sequence-to-Sequence Pre-trained Models

<br>



<br>

pre-trainingされたモデルは、様々な軸で異なっているが、その一つの軸としては訓練時の目的関数である。基本的には２つの大きな変種があり、1つは、language modeling objectives (e.g. MLM)、2つ目は、seq2seq objectivesである。特に、seq2seqで事前学習されたモデルは、エンコーダーとデコーダーによって構成されているため特に条件付き生成タスクに対して適しており、予測はAutoRegressiveに行われる。本研究ではBARTを用いる。付録には、preliminary experimentsとして、BART with T5, PEGASUSを用いた結果も添付する。

<br>



<br>

BARTScore

<br>



<br>

最も一般的なBARTScoreの定式化は下記である。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/34505fd3-c8bb-49ee-92a8-f5710032b1ea" alt="image" loading="lazy">

<br>



<br>

weighted log probabilityを利用する。このweightsは、異なるトークンに対して、異なる重みを与えることができる。たておば、IDFなどが利用可能であるが、本研究ではすべてのトークンを等価に扱う（uniform weightingだがstopwordを除外、IDFによる重みづけ、事前分布を導入するなど色々試したが、uniform weightingを上回るものがなかった）。

<br>



<br>



<br>



<br>

BARTScoreを用いて、様々な方向に用いて生成を行うことができ、異なる評価のシナリオに対応することができる。

<br>



<br>

・Faithfulness (s -&gt; h):

<br>



<br>

    ・hypothesisがどれだけsource textに基づいて生成されているかを測ることができる。シナリオとしては、FactualityやRelevanceなどが考えられる。また、CoherenceやFluencyのように、target textのみの品質を測るためにも用いることができる。

<br>



<br>

・Precision (r -&gt; h):

<br>



<br>

    ・hypothesisがどれだけgold-referenceに基づいてこう良くされているかを亜評価でき、precision-focusedなシナリオに適している

<br>



<br>

・Recall (h -&gt; r):

<br>



<br>

    ・hypothesisから、gold referenceをどれだけ容易に再現できるかを測ることができる。そして、要約タスクのpyramid-basedな評価（i.e. semantic coverage等）  に適している。pyramid-scoreはSemantic Content Unitsがどれだけカバーされているかによって評価される。

<br>



<br>

・F Score (r &lt;-&gt; h):

<br>



<br>

    ・双方向を考慮し、Precisioon / RecallからF値を算出する。この方法は、referenceと生成テキスト間でのsemantic overlap (informativenss, adequacy)などの評価に広く利用される。

<br>



<br>



<br>



<br>

BARTScore Variants

<br>



<br>

BARTScoreの2つの拡張を提案。(i) xとyをpromptingによって変更する。これにより、評価タスクをpre-training taskと近づける。(ii) パラメータΘを異なるfinetuning taskを考慮して変更する。すなわち、pre-trainingのドメインを、evaluation taskに近づける。

<br>



<br>

Prompt

<br>



<br>

Promptingはinput/outputに対して短いフレーズを追加し、pre-trained modelに対して特定のタスクを遂行させる方法である。BARTにも同様の洞察を簡単に組み込むことができる。この変種をBARTScore-PROMPTと呼ぶ。

<br>



<br>

prompt zが与えられたときに、それを (i) source textに追加し、新たなsource textを用いてBARTScoreを計算する。(ii) target textの先頭に追加し、new target textに対してBARTScoreを計算する。

<br>



<br>

Fine-tuning Task

<br>



<br>

classification-basedなタスクでfine-tuneされるのが一般的なBERT-based metricとは異なり、BARTScoreはgeneration taskでfine-tuneされるため、pre-training domainがevaluation taskと近い。本研究では、2つのdownstream taskを検証する。

<br>



<br>

1つめは、summarizationで、BARTをCNNDM datasetでfinetuningする。2つめは、paraphrasingで、summarizationタスクでfinetuningしたBARTをParaBank2 datasetでさらにfinetuningする。実験

<br>



<br>

baselines and datasets

<br>



<br>

Evaluation Metrics

<br>



<br>

supervised metrics: COMET, BLEURT

<br>



<br>

unsupervised: BLEU, ROUGE-1, ROUGE-2, ROUGE-L, chrF, PRISM, MoverScore, BERTScore

<br>



<br>

と比較

<br>



<br>

Measures for Meta Evaluation

<br>



<br>

Pearson Correlationでlinear correlationを測る。また、Spearman Correlationで2変数間の単調なcorrelationを測定する（線形である必要はない）。Kendall's Tauを用いて、2つの順序関係の関係性を測る。最後に、Accuracyでfactual textsとnon-factual textの間でどれだけ正しいランキングを得られるかを測る。

<br>



<br>



<br>



<br>

Datasets

<br>



<br>

Summarization, MT, DataToTextの3つのデータセットを利用。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/117bf2d4-b096-4a60-a139-4a607ce3ebc6" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Setup

<br>



<br>

Prompt Design

<br>



<br>

seedをparaphrasingすることで、　s-&gt;h方向には70個のpromptを、h&lt;-&gt;rの両方向には、34のpromptを得て実験で用いた。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/dab4f2bc-9b8d-4de6-bbc3-204da39ee2eb" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Settings

<br>



<br>

Summarizationとdata-to-textタスクでは、全てのpromptを用いてデコーダの頭に追加してスコアを計算しスコアを計算した。最終的にすべての生成されたスコアを平均することである事例に対するスコアを求めた（prompt unsembling）。MTについては、事例数が多くcomputational costが多くなってしまうため、WMT18を開発データとし、best prompt "Such as"を選択し、利用した。

<br>



<br>

BARTScoreを使う際は、gold standard human evaluationがrecall-basedなpyrmid methodの場合はBARTScore(h-&gt;r)を用い、humaan judgmentsがlinguistic quality (coherence fluency)そして、factual correctness、あるいは、sourceとtargetが同じモダリティ（e.g. language）の場合は、faitufulness-based BARTScore(s-&gt;h)を用いた。最後に、MTタスクとdata-to-textタスクでは、fair-comparisonのためにBARTScore F-score versionを用いた。

<br>



<br>

実験結果

<br>



<br>

MT

<br>



<br>

・BARTScoreはfinetuning tasksによって性能が向上し、5つのlanguage pairsにおいてその他のunsupervised methodsを統計的に優位にoutperformし、2つのlanguage pairでcomparableであった。

<br>



<br>

-Such asというpromptを追加するだけで、BARTScoreの性能が改善した。特筆すべきは、de-enにおいては、SoTAのsupervised MetricsであるBLEURTとCOMETを上回った。

<br>



<br>

・これは、有望な将来のmetric designとして「human judgment dataで訓練する代わりに、pre-trained language modelに蓄積された知識をより適切に活用できるpromptを探索する」という方向性を提案している。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/ff41b3ec-3cf9-4c9a-90bb-83b46889d759" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Text Summarization

<br>



<br>

・vanilla BARTScoreはBERTScore, MoverScoreをInfo perspective以外でlarge marginでうくぁ回った。

<br>



<br>

・REALSum, SummEval dataseetでの改善は、finetuning taskによってさらに改善した。しかしながら、NeR18では改善しなかった。これは、データに含まれる7つのシステムが容易に区別できる程度のqualityであり、既にvanilla BARTScoreで高いレベルのcorrelationを達成しているからだと考えられる。

<br>



<br>

・prompt combination strategyはinformativenssに対する性能を一貫して改善している。しかし、fluency, factualityでは、一貫した改善は見られなかった。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/cfb33334-e38d-43e0-9b48-a8a8c433bc26" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Factuality datasetsに対する分析を行った。ゴールは、short generated summaryが、元のlong documentsに対してfaithfulか否かを判定するというものである。

<br>



<br>

・BARTScore+CNNは、Rank19データにおいてhuman baselineに近い性能を達成し、ほかのベースラインを上回った。top-performingなfactuality metricsであるFactCCやQAGSに対してもlarge marginで上回った。

<br>



<br>

・paraphraseをfine-tuning taskで利用すると、BARTScoreのパフォーマンスは低下した。これは妥当で、なぜなら二つのテキスト（summary and document）は、paraphrasedの関係性を保持していないからである。

<br>



<br>

・promptを導入しても、性能の改善は見受けられず、パフォーマンスは低下した。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/06dac947-c946-4633-8ff6-a9c3933f6322" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Data-to-Text

<br>



<br>

・CNNDMでfine-tuningすることで、一貫してcorrelationが改善した。

<br>



<br>

・加えて、paraphraseデータセットでfinetuningすることで、さらに性能が改善した。

<br>



<br>

・prompt combination strategyは一貫してcorrelationを改善した。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/acbd6816-e7bc-4ecd-8a53-13137a2bcc94" alt="image" loading="lazy">

<br>



<br>

Analysis

<br>



<br>

Fine-grained Analysis

<br>



<br>

・Top-k Systems: MTタスクにおいて、評価するシステムをtop-kにし、各メトリックごとにcorrelationの変化を見た。その結果、BARTScoreはすべてのunsupervised methodをすべてのkにおいて上回り、supervised metricのBLEURTも上回った。また、kが小さくなるほど、より性能はsmoothになっていき、性能の低下がなくなっていった。これはつまり、high-quality textを生成するシステムに対してロバストであることを示している。

<br>



<br>

・Reference Length: テストセットを4つのバケットにreference lengthに応じてブレイクダウンし、Kendall's Tauの平均のcorrelationを、異なるメトリック、バケットごとに言語をまたいで計算した。unsupervised metricsに対して、全てのlengthに対して、引き分けかあるいは上回った。また、ほかのmetricsと比較して、長さに対して安定感があることが分かった。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/821fdf0a-aabc-448a-81aa-238aae380ea1" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Prompt Analysis

<br>



<br>

(1) semantic overlap (informativeness, pyramid score, relevance), (2) linguistic quality (fluency, coherence), (3) factual correctness (factuality) に評価の観点を分類し、summarizationとdata-to-textをにおけるすべてのpromptを分析することで、promptの効果を分析した。それぞれのグループに対して、性能が改善したpromptの割合を計算した。その結果、semantic overlapはほぼ全てのpromptにて性能が改善し、factualityはいくつかのpromptでしか性能の改善が見られなかった。linguistic qualityに関しては、promptを追加することによる効果はどちらとも言えなかった。

<br>



<br>



<br>



<br>

Bias Analysis

<br>



<br>

BARTScoreが予測不可能な方法でバイアスを導入してしまうかどうかを分析した。バイアスとは、human annotatorが与えたスコアよりも、値が高すぎる、あるいは低すぎるような状況である。このようなバイアスが存在するかを検証するために、human annotatorとBARTScoreによるランクのサを分析した。これを見ると、BARTScoreは、extractive summarizationの品質を区別する能力がabstractive summarizationの品質を区別する能力よりも劣っていることが分かった。しかしながら、近年のトレンドはabstractiveなseq2seqを活用することなので、この弱点は軽減されている。

<br>



<br>



<br>



<br>

Implications and Future Directions

<br>



<br>

prompt-augmented metrics: semantic overlapではpromptingが有効に働いたが、linguistic qualityとfactualityでは有効ではなかった。より良いpromptを模索する研究が今後期待される。

<br>



<br>

Co-evolving evaluation metrics and systems: BARTScoreは、メトリックデザインとシステムデザインの間につながりがあるので、より性能の良いseq2seqシステムが出たら、それをメトリックにも活用することでよりreliableな自動性能指標となることが期待される。

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/08d51f6d-40ad-4b2a-8871-086e12010478" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-based.html">#Reference-based</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/953">Towards Question-Answering as an Automatic Metric for Evaluating the Content Quality of a Summary, Deutsch+, TACL'21</a>
<span class="snippet"><span>Summary</span>要約の品質を評価するための新しい指標であるQAEvalを提案する。QAEvalは質問応答（QA）を使用して要約と参照の情報の重複を測定するため、従来のテキストの重複に基づく指標とは異なる。実験結果から、QAEvalは現在の最先端の指標よりも優れたパフォーマンスを示し、他の評価とも競争力があることがわかった。QAEvalの構成要素を分析することで、その潜在的な上限パフォーマンスは他の自動評価指標を上回り、ゴールドスタンダードのピラミッドメソッドに近づくと推定される。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-free.html">#Reference-free</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/949">ESTIME: Estimation of Summary-to-Text Inconsistency by Mismatched Embeddings, Eval4NLP'21</a>
<span class="snippet"><span>Summary</span>私たちは、新しい参照なし要約品質評価尺度を提案します。この尺度は、要約とソースドキュメントの間の潜在的な矛盾を見つけて数えることに基づいています。提案された尺度は、一貫性と流暢さの両方で他の評価尺度よりも専門家のスコアと強い相関を示しました。また、微妙な事実の誤りを生成する方法も紹介しました。この尺度は微妙なエラーに対してより感度が高いことを示しました。</span>
<a class="button" href="articles/Sentence.html">#Sentence</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/ContrastiveLearning.html">#ContrastiveLearning</a>
<a class="button" href="articles/Catastrophic%20Forgetting.html">#Catastrophic Forgetting</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2023-07-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/907">SimCSE: Simple Contrastive Learning of Sentence Embeddings, Tianyu Gao+, N_A, EMNLP'21</a>
<span class="snippet"><span>Summary</span>この論文では、SimCSEという対比学習フレームワークを提案しています。このフレームワークは、文の埋め込み技術を進化させることができます。教師なしアプローチでは、入力文をノイズとして扱い、自己を対比的に予測します。教師ありアプローチでは、自然言語推論データセットから注釈付きのペアを使用して対比学習を行います。SimCSEは、意味的テキスト類似性タスクで評価され、以前の手法と比較して改善を実現しました。対比学習は、事前学習された埋め込みの空間を均一に正則化し、教師信号が利用可能な場合には正のペアをよりよく整列させることが示されました。</span>
<span class="snippet"><span>Comment</span>462 よりも性能良く、unsupervisedでも学習できる。STSタスクのベースラインにだいたい入ってる手法概要

<br>



<br>

Contrastive Learningを活用して、unsupervised/supervisedに学習を実施する。

<br>



<br>

Unsupervised SimCSEでは、あるsentenceをencoderに2回入力し、それぞれにdropoutを適用させることで、positive pairを作成する。dropoutによって共通のembeddingから異なる要素がマスクされた（noiseが混ざった状態とみなせる）類似したembeddingが作成され、ある種のdata augmentationによって正例を作成しているともいえる。負例はnegative samplingする。（非常にsimpleだが、next sentence predictionで学習するより性能が良くなる）

<br>



<br>

Supervised SimCSEでは、アノテーションされたsentence pairに基づいて、正例・負例を決定する。本研究では、NLIのデータセットにおいて、entailment関係にあるものは正例として扱う。contradictions（矛盾）関係にあるものは負例として扱う。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/ba20a1ca-0078-4227-8bb3-3805ee57a620" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Siamese Networkで用いられるmeans-squared errrorとContrastiveObjectiveの違い

<br>



<br>

どちらもペアワイズで比較するという点では一緒だが、ContrastiveObjectiveは正例と近づいたとき、負例と遠ざかったときにlossが小さくなるような定式化がされている点が異なる。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/d9cad930-e86d-4758-87b5-4237525a154a" alt="image" loading="lazy">

<br>



<br>

（画像はこのブログから引用。ありがとうございます。https://techblog.cccmk.co.jp/entry/2022/08/30/163625）

<br>



<br>



<br>



<br>

Unsupervised SimCSEの実験

<br>



<br>

異なるdata augmentation手法と比較した結果、dropoutを適用する手法の方が性能が高かった。MLMや, deletion, 類義語への置き換え等よりも高い性能を獲得しているのは興味深い。また、Next Sentence Predictionと比較しても、高い性能を達成。Next Sentence Predictionは、word deletion等のほぼ類似したテキストから直接的に類似関係にあるペアから学習するというより、Sentenceの意味内容のつながりに基づいてモデルの言語理解能力を向上させ、そのうえで類似度を測るという間接的な手法だが、word deletionに負けている。一方、dropoutを適用するだけの（直接的に類似ペアから学習する）本手法はより高い性能を示している。

<br>



<br>

[image](https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/0ea3549e-3363-4857-94e6-a1ef474aa191)

<br>



<br>



<br>



<br>

なぜうまくいくかを分析するために、異なる設定で実験し、alignment（正例との近さ）とuniformity（どれだけembeddingが一様に分布しているか）を、10 stepごとにplotした結果が以下。dropoutを適用しない場合と、常に同じ部分をマスクする方法（つまり、全く同じembeddingから学習する）設定を見ると、学習が進むにつれuniformityは改善するが、alignmentが悪くなっていっている。一方、SimCSEはalignmentを維持しつつ、uniformityもよくなっていっていることがわかる。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/5f488cb2-b15a-4e00-9452-8e48780abe8a" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/5e815cf7-b412-4f1b-8adb-116f0dcd2fee" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Supervised SimCSEの実験

<br>



<br>

アノテーションデータを用いてContrastiveLearningするにあたり、どういったデータを正例としてみなすと良いかを検証するために様々なデータセットで学習し性能を検証した。

<br>



<br>



<br>



<br>

・QQP4: Quora question pairs

<br>



<br>

・Flickr30k (Young et al., 2014): 同じ画像に対して、5つの異なる人間が記述したキャプションが存在

<br>



<br>

・ParaNMT (Wieting and Gimpel, 2018): back-translationによるparaphraseのデータセットa

<br>



<br>

・NLI datasets: SNLIとMNLI

<br>



<br>



<br>



<br>

実験の結果、NLI datasetsが最も高い性能を示した。この理由としては、NLIデータセットは、crowd sourcingタスクで人手で作成された高品質なデータセットであることと、lexical overlapが小さくなるようにsentenceのペアが作成されていることが起因している。実際、NLI datsetのlexical overlapは39%だったのに対し、ほかのデータセットでは60%であった。

<br>



<br>



<br>



<br>

また、condunctionsとなるペアを明示的に負例として与えることで、より性能が向上した（普通はnegative samplingする、というかバッチ内の正例以外のものを強制的に負例とする。こうすると、意味が同じでも負例になってしまう事例が出てくることになる）。より難しいNLIタスクを含むANLIデータセットを追加した場合は、性能が改善しなかった。この理由については考察されていない。性能向上しそうな気がするのに。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/ae05711b-5ad4-4a53-837b-c57e9a39da62" alt="image" loading="lazy">

<br>



<br>

他手法との比較結果

<br>



<br>

SimCSEがよい。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/510744ff-01bb-47be-9e30-2efa49e0f923" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Ablation Studies

<br>



<br>

異なるpooling方法で、どのようにsentence embeddingを作成するかで性能の違いを見た。originalのBERTの実装では、CLS token のembeddingの上にMLP layerがのっかっている。これの有無などと比較。

<br>



<br>

Unsupervised SimCSEでは、training時だけMLP layerをのっけて、test時はMLPを除いた方が良かった。一方、Supervised SimCSEでは、 MLP layerをのっけたまんまで良かったとのこと。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/73116c6a-d48f-42bc-aa5e-8342bb068052" alt="image" loading="lazy">

<br>



<br>

また、SimCSEで学習したsentence embeddingを別タスクにtransferして活用する際には、SimCSEのobjectiveにMLMを入れた方が、catastrophic forgettingを防げて性能が高かったとのこと。

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/cc6d20c3-5a0c-4b5e-aa6d-63447c55363f" alt="image" loading="lazy">ablation studiesのhard negativesのところと、どのようにミニバッチを構成するか、それぞれのtransferしたタスクがどのようなものがしっかり読めていない。あとでよむ。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2023-07-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/901">Measuring Massive Multitask Language Understanding, Dan Hendrycks+, N_A, ICLR'21</a>
<span class="snippet"><span>Summary</span>私たちは、マルチタスクのテキストモデルの正確性を測定するための新しいテストを提案しています。このテストは57のタスクをカバーし、広範な世界知識と問題解決能力が必要です。現在のモデルはまだ専門家レベルの正確性に達しておらず、性能に偏りがあります。私たちのテストは、モデルの弱点を特定するために使用できます。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=d7KBjmI3GmQMMLU論文</span>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/PersonalizedGeneration.html">#PersonalizedGeneration</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<a class="button" href="articles/PersonalizedHeadlineGeneration.html">#PersonalizedHeadlineGeneration</a>
<span class="issue_date">Issue Date: 2023-05-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/706">PENS: A Dataset and Generic Framework for Personalized News Headline Generation, ACL'21</a>
<span class="snippet"><span>Summary</span>この論文では、ユーザーの興味とニュース本文に基づいて、ユーザー固有のタイトルを生成するパーソナライズされたニュース見出し生成の問題を解決するためのフレームワークを提案します。また、この問題のための大規模なデータセットであるPENSを公開し、ベンチマークスコアを示します。データセットはhttps://msnews.github.io/pens.htmlで入手可能です。</span>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

ニュース記事に対するPersonalizedなHeadlineの正解データを生成。103名のvolunteerの最低でも50件のクリックログと、200件に対する正解タイトルを生成した。正解タイトルを生成する際は、各ドキュメントごとに4名異なるユーザが正解タイトルを生成するようにした。これらを、Microsoft Newsの大規模ユーザ行動ログデータと、ニュース記事本文、タイトル、impressionログと組み合わせてPENSデータを構成した。

<br>



<br>



<br>



<br>

データセット生成手順

<br>



<br>

103名のenglish-native [speakerの学生に対して、1000件のニュースヘッドラインの中から最低50件興味のあるヘッドラインを選択してもらう。続いて、200件のニュース記事に対して、正解ヘッドラインを生成したもらうことでデータを生成した。正解ヘッドラインを生成する際は、同一のニュースに対して4人がヘッドラインを生成するように調整した。生成されたヘッドラインは専門家によってqualityをチェックされ、factual informationにエラーがあるものや、極端に長い・短いものなどは除外された。

<br>



<br>



<br>



<br>

データセット統計量

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/cd4fa969-03c0-4539-bcec-25ba3204ffc9" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/1c9a38b4-4156-49a2-83e5-20e057588f91" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

手法概要

<br>



<br>

Transformer Encoder + Pointer GeneratorによってPersonalizedなヘッドラインを生成する。

<br>



<br>

Transformer Encoderでは、ニュースの本文情報をエンコードし、attention distributionを生成する。Decoder側では、User Embeddingを組み合わせて、テキストをPointer Generatorの枠組みでデコーディングしていき、ヘッドラインを生成する。

<br>



<br>

User Embeddingをどのようにinjectするかで、3種類の方法を提案しており、1つ目は、Decoderの初期状態に設定する方法、2つ目は、ニュース本文のattention distributionの計算に利用する方法、3つ目はデコーディング時に、ソースからvocabをコピーするか、生成するかを選択する際に利用する方法。1つ目は一番シンプルな方法、2つ目は、ユーザによって記事で着目する部分が違うからattention distributionも変えましょう、そしてこれを変えたらcontext vectorも変わるからデコーディング時の挙動も変わるよねというモチベーション、3つ目は、選択するvocabを嗜好に合わせて変えましょう、という方向性だと思われる。最終的に、2つ目の方法が最も性能が良いことが示された。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/54d4da04-6af2-4ef2-b4ff-7a12f1ea7936" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

訓練手法

<br>



<br>

まずニュース記事推薦システムを訓練し、user embeddingを取得できるようにする。続いて、genericなheadline generationモデルを訓練する。最後に両者を組み合わせて、Reinforcement LearningでPersonalized Headeline Generationモデルを訓練する。Rewardとして、

<br>



<br>

1. Personalization: ヘッドラインとuser embeddingのdot productで報酬とする

<br>



<br>

2. Fluency: two-layer LSTMを訓練し、生成されたヘッドラインのprobabilityを推定することで報酬とする

<br>



<br>

3. Factual Consistency: 生成されたヘッドラインと本文の各文とのROUGEを測りtop-3 scoreの平均を報酬とする

<br>



<br>

とした。

<br>



<br>

1,2,3の平均を最終的なRewardとする。

<br>



<br>



<br>



<br>

実験結果

<br>



<br>

Genericな手法と比較して、全てPersonalizedな手法が良かった。また、手法としては②のattention distributionに対してuser informationを注入する方法が良かった。News Recommendationの性能が高いほど、生成されるヘッドラインの性能も良かった。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/84aa7b6d-05cf-415a-a2cf-76401801230f" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Case Study

<br>



<br>

ある記事に対するヘッドラインの一覧。Pointer-Genでは、重要な情報が抜け落ちてしまっているが、提案手法では抜け落ちていない。これはRLの報酬のfluencyによるものだと考えられる。また、異なるユーザには異なるヘッドラインが生成されていることが分かる。 

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/e65eb9da-7cc6-4d72-b2ca-8607c794f3a0" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/review.html">#review</a>
<span class="issue_date">Issue Date: 2023-05-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/655">Transformer Reasoning Network for Personalized Review Summarization, Xu+, SIGIR'21</a>
<span class="snippet"><span>Comment</span>先行研究は、review summarizationにおいて生成されるsummaryは、過去にユーザが作成したsummaryのwriting styleやproductに非常に関係しているのに、これらを活用してこなかったので、活用しました（=personalized）という話っぽい</span>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<span class="issue_date">Issue Date: 2023-04-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/598">ニュース記事に対する談話構造と興味度のアノテーション ～ニュース対話システムのパーソナライズに向けて～, 高津+, 早稲田大学, 言語処理学会'21</a>
<span class="snippet"><span>Comment</span>ニュース記事に対して談話構造および，ユーザのプロフィールと記事の話題・文に対するユーザの興味度を付与したデータセット。

<br>



<br>

プロフィールとして以下を収集：

<br>



<br>

・性別

<br>



<br>

・年齢，

<br>



<br>

・住んでいる地域

<br>



<br>

・職種

<br>



<br>

・業種

<br>



<br>

・ニュースを見る頻度，

<br>



<br>

・ニュースをよくチェックする時間帯

<br>



<br>

・映像・音声・文字のうちニュースへの接触方法として多いものはどれか

<br>



<br>

・ニュースを知る手段

<br>



<br>

・ニュースを読む際使用している新聞やウェブサイト・アプリ

<br>



<br>

・有料でニュースを読んでいるか

<br>



<br>

・普段積極的に読む・見る・聞くニュースのジャンル

<br>



<br>

・ニュースのジャンルに対する興味の程度，趣味．</span>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<span class="issue_date">Issue Date: 2023-04-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/595">談話構造制約付きパーソナライズド抽出型要約, 高津+, 早稲田大学, 言語処理学会'21</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/ContrastiveLearning.html">#ContrastiveLearning</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2023-04-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/550">Learning Transferable Visual Models From Natural Language Supervision, Radford+, OpenAI, ICML'21</a>
<span class="snippet"><span>Comment</span>CLIP論文。大量の画像と画像に対応するテキストのペアから、対象学習を行い、画像とテキスト間のsimilarityをはかれるようにしたモデル

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234729329-dfa5dc1e-c5fc-452c-8ead-76df7d1aeda4.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<span class="issue_date">Issue Date: 2023-04-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/538">Refocusing on Relevance: Personalization in NLG, Shiran Dudy+, Department of Computer Science University of Colorado, EMNLP'21</a>
<span class="snippet"><span>Comment</span>従来のNLGはソーステキストに焦点を当て、ターゲットを生成することに注力してきた。が、ユーザの意図やcontextがソーステキストだけに基づいて復元できない場合、このアプローチでは不十分であることを指摘。

<br>



<br>

この研究ではNLGシステムが追加のcontextを利用することに大きな重点をおくべきであり、IR等で活用されているrelevancyをユーザ指向のテキスト生成タスクを設計するための重要な指標として考えることを提案している。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Game.html">#Game</a>
<span class="issue_date">Issue Date: 2022-09-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/487">Generating Racing Game Commentary from Vision, Language, and Structured Data, Tatsuya+, INLG'21</a>
<span class="snippet"><span>Comment</span>データセット: https://kirt.airc.aist.go.jp/corpus/ja/RacingCommentary</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<span class="issue_date">Issue Date: 2022-08-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/472">Biomedical Data-to-Text Generation via Fine-Tuning Transformers, Ruslan+, INLG'21</a>
<span class="snippet"><span>Comment</span>biomedical domainの新たなdata2textデータセットを提供。事前学習済みのBART, T5等をfinetuningすることで高精度にテキストが生成できることを示した。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/TACL.html">#TACL</a>
<span class="issue_date">Issue Date: 2021-10-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/412">WikiAsp: A Dataset for Multi-domain Aspect-based Summarization, Hayashi+, CMU, TACL'21, NLPコロキウム</a>
<span class="snippet"><span>Comment</span>◆Aspect-based summarizationのモチベーション

<br>



<br>

・same source対して、異なるユーザニーズが存在するので、ニーズに関して要約したい

<br>



<br>



<br>



<br>

◆Aspect: あるobjectに対する、attributeのようなものを指定？

<br>



<br>

　object: Attention Is All You Need

<br>



<br>

　aspect: Multi-Head Attention

<br>



<br>



<br>



<br>

◆Aspect Based Summarizationの歴史

<br>



<br>

・はじめは”feature”という文言で研究され（04年頃？）

<br>



<br>

・続いてkeywordsという単語で研究され

<br>



<br>

・その後Aspectという文言で研究されるようになった

<br>



<br>

・2008年頃にMcDonaldsらがAspect-Based Summarizationを提案した

<br>



<br>

・2014年以後？とかにNeural Basedな手法が盛んに研究

<br>



<br>



<br>



<br>

◆WikiAspデータセットについて

<br>



<br>

・Wikipediaを使ったAspect-based dataset

<br>



<br>

・Wikipediaを書かれるのに利用されたsource document（wikipediaにソースとして引用されているもの）に対し、aspectを各節の見出しとみなし、節のテキストを要約文とみなすことで、データセット生成

<br>



<br>

・他のAspect-basedデータセットと異なり、ソースデータが長く、要約長も5~6倍程度

<br>



<br>

・ドメイン数が他データセットは5,6程度に対し、20と膨大

<br>



<br>



<br>



<br>

◆ベースラインとして2-stageモデルを採用

<br>



<br>

first-stage: ソーステキストからROBERTaベースドなclassifierを用いて、sentencesから内包するAspectを閾値を用いて決定

<br>



<br>

　　　　　それらをgrouped sentencesとする

<br>



<br>

two-stage: 各aspectごとにまとまったテキスト集合に対して、要約モデルを適用し、要約を実施する

<br>



<br>

・要約モデルはUnsupervisedな手法であるTextRankと、Supervisedな手法であるBERTベースな手法を採用

<br>



<br>

・ドメインごとに評価した結果を見ると、BERTが強いドメインがある一方で、TextRankが強いドメインもあった

<br>



<br>

　-&gt; Extractiveな形で要約されているドメインではTextRankが強く、Abstractiveに要約されているドメインではBERTが強い

<br>



<br>

　-&gt; またBERTは比較的短い要約であればTextRankよりもはるかに良いが、長い要約文になるとTextRankとcomprable（あるいはTextRankの方が良い）程度の性能になる

<br>



<br>

・ROUGE-2の値がsentence-basedなORACLEを見た時に、他データセットと比較して低いので、Abstractiveな手法が必要なデータセット？

<br>



<br>



<br>



<br>

（後からのメモなので少しうろ覚えな部分あり）Q. ROUGE-2が30とかって直観的にどのくらいのレベルのものなの？ROUGE-2が30とか40とかは高い

<br>



<br>

・最先端の要約モデルをニュース記事に適用すると、35~40くらいになる。

<br>



<br>

・このレベルの数値になると、人間が呼んでも違和感がないレベルの要約となっているQ. 実際に要約文をチェックしてみて、どういう課題を感じるか？

<br>



<br>

A. Factual Consistencyがすぐに目につく問題で、特にBERTベースな要約文はそう。TextRankはソース文書がノイジーなので、ソース文章を適当に拾ってきただけではFactual Consistencyが良くない（元の文書がかっちりしていない）。流暢性の問題はAbstractiveモデルだと特に問題なくBERT-baseでできる。Aspect-based要約のエラー例としてAspectに則っていないということがある。たとえばオバマの大統領時代の話をきいているのに、幼少時代の話をしているとか。Aspect情報をうまくモデルを扱えていないという点が課題としてある。出典元（リアルタイムに聴講）: 第13回 WikiAsp: A Dataset for Multi-domain Aspect-based Summarization, NLPコロキウム

<br>

https://youtu.be/3PIJotX6i_w?si=hX5pXwNL-ovkGSF5</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<span class="issue_date">Issue Date: 2021-10-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/409">過去情報の内容選択を取り入れた スポーツダイジェストの自動生成, 加藤+, 東工大, NLP'21</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2021-09-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/405">Prefix-Tuning: Optimizing Continuous Prompts for Generation, Lisa+ （Percy Liang）, Stanford University, ACL'21</a>
<span class="snippet"><span>Comment</span>言語モデルをfine-tuningする際，エンコード時に「接頭辞」を潜在表現として与え，「接頭辞」部分のみをfine-tuningすることで（他パラメータは固定），より少量のパラメータでfine-tuningを実現する方法を提案．接頭辞を潜在表現で与えるこの方法は，GPT-3のpromptingに着想を得ている．fine-tuningされた接頭辞の潜在表現のみを配布すれば良いので，非常に少量なパラメータでfine-tuningができる．

<br>



<br>



<br>



<br>

table-to-text, summarizationタスクで，一般的なfine-tuningやAdapter（レイヤーの間にアダプターを挿入しそのパラメータだけをチューニングする手法）といった効率的なfine-tuning手法と比較．table-to-textでは、250k (元のモデルの 0.1%) ほどの数のパラメータを微調整するだけで、全パラメータをfine-tuningするのに匹敵もしくはそれ以上の性能を達成．

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/132679791-87ad130d-8a7e-4549-a311-f84400a3787b.png" alt="image" loading="lazy">

<br>



<br>

Hugging Faceの実装を利用したと論文中では記載されているが，fine-tuningする前の元の言語モデル（GPT-2）はどのように準備したのだろうか．Hugging Faceのpretrained済みのGPT-2を使用したのだろうか．autoregressive LM (GPT-2)と，encoder-decoderモデル（BART）へPrefix Tuningを適用する場合の模式図

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/132681736-0ea4b13f-71cb-41ba-ae17-027e8bf54cc0.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<span class="issue_date">Issue Date: 2025-08-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2388">[Paper Note] Longformer: The Long-Document Transformer, Iz Beltagy+, arXiv'20</a>
<span class="snippet"><span>Summary</span>Longformerは、長いシーケンスを線形に処理できる注意機構を持つTransformerベースのモデルで、数千トークンの文書を扱える。局所的なウィンドウ注意とタスクに基づくグローバル注意を組み合わせ、文字レベルの言語モデリングで最先端の結果を達成。事前学習とファインチューニングを行い、長文タスクでRoBERTaを上回る性能を示した。また、Longformer-Encoder-Decoder（LED）を導入し、長文生成タスクにおける効果を確認した。</span>
<span class="snippet"><span>Comment</span>（固定された小さめのwindowsサイズの中でのみattentionを計算する）sliding window attentionを提案

<br>



<br>

<img width="795" height="231" alt="Image" src="https://github.com/user-attachments/assets/d1eccdaf-5b5b-4444-ad31-44c54c345d79">OpenLLMの文脈だと、Mistralに採用されて話題になったかも？

<br>

・1309</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2025-08-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2356">[Paper Note] Transformers are RNNs: Fast Autoregressive Transformers with Linear  Attention, Angelos Katharopoulos+, ICML'20</a>
<span class="snippet"><span>Summary</span>自己注意をカーネル特徴マップの線形ドット積として表現することで、Transformersの複雑性を$\mathcal{O}\left(N^2\right)$から$\mathcal{O}\left(N\right)$に削減。これにより、自己回帰型Transformersの速度が最大4000倍向上し、従来のパフォーマンスを維持。</span>
<span class="snippet"><span>Comment</span>関連:

<br>

・1210 </span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2025-08-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2355">[Paper Note] Reformer: The Efficient Transformer, Nikita Kitaev+, ICLR'20</a>
<span class="snippet"><span>Summary</span>本研究では、トランスフォーマーモデルの効率を向上させるために、局所感度ハッシュを用いた注意機構と可逆残差層を提案。これにより、計算量をO($L^2$)からO($L\log L$)に削減し、メモリ効率と速度を向上させたReformerモデルを実現。トランスフォーマーと同等の性能を維持。</span>
<span class="snippet"><span>Comment</span>openreview: https://openreview.net/forum?id=rkgNKkHtvB</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<span class="issue_date">Issue Date: 2025-08-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2354">[Paper Note] Linformer: Self-Attention with Linear Complexity, Sinong Wang+, arXiv'20</a>
<span class="snippet"><span>Summary</span>大規模トランスフォーマーモデルは自然言語処理で成功を収めているが、長いシーケンスに対しては高コスト。自己注意メカニズムを低ランク行列で近似し、複雑さを$O(n^2)$から$O(n)$に削減する新しいメカニズムを提案。これにより、メモリと時間効率が向上した線形トランスフォーマー「Linformer」が標準モデルと同等の性能を示す。</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Composition.html">#Composition</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/Findings.html">#Findings</a>
<a class="button" href="articles/CommonsenseReasoning.html">#CommonsenseReasoning</a>
<span class="issue_date">Issue Date: 2025-07-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2330">[Paper Note] CommonGen: A Constrained Text Generation Challenge for Generative   Commonsense Reasoning, Bill Yuchen Lin+, EMNLP'20 Findings</a>
<span class="snippet"><span>Summary</span>生成的常識推論をテストするためのタスクCommonGenを提案し、35,000の概念セットに基づく79,000の常識的記述を含むデータセットを構築。タスクは、与えられた概念を用いて一貫した文を生成することを求め、関係推論と構成的一般化能力が必要。実験では、最先端モデルと人間のパフォーマンスに大きなギャップがあることが示され、生成的常識推論能力がCommonsenseQAなどの下流タスクに転送可能であることも確認。</span>
<span class="snippet"><span>Comment</span>ベンチマークの概要。複数のconceptが与えられた時に、それらconceptを利用した常識的なテキストを生成するベンチマーク。concept間の関係性を常識的な知識から推論し、Unseenなconceptの組み合わせでも意味を構成可能な汎化性能が求められる。

<br>

<img src="https://github.com/user-attachments/assets/2ebb8c0d-88f7-4858-ac43-29f341c586ec" alt="image" loading="lazy">PJ page:https://inklab.usc.edu/CommonGen/</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Abstractive.html">#Abstractive</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<a class="button" href="articles/Faithfulness.html">#Faithfulness</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2025-07-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2203">[Paper Note] On Faithfulness and Factuality in Abstractive Summarization, Joshua Maynez+, ACL'20</a>
<span class="snippet"><span>Summary</span>抽象的な文書要約における言語モデルの限界を分析し、これらのモデルが入力文書に対して忠実でない内容を生成する傾向が高いことを発見。大規模な人間評価を通じて、生成される幻覚の種類を理解し、すべてのモデルで相当量の幻覚が確認された。事前学習されたモデルはROUGE指標だけでなく、人間評価でも優れた要約を生成することが示された。また、テキストの含意測定が忠実性と良好に相関することが明らかになり、自動評価指標の改善の可能性を示唆。</span>
<span class="snippet"><span>Comment</span>文書要約の文脈において `hallucination` について説明されている。

<br>

・1044 

<br>



<br>

が `hallucination` について言及する際に引用している。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Normalization.html">#Normalization</a>
<a class="button" href="articles/Encoder-Decoder.html">#Encoder-Decoder</a>
<span class="issue_date">Issue Date: 2025-07-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2142">[Paper Note] On Layer Normalization in the Transformer Architecture, Ruibin Xiong+, arXiv'20</a>
<span class="snippet"><span>Summary</span>本論文では、Transformerの学習率のウォームアップ段階の重要性を理論的に研究し、レイヤー正規化の位置が訓練の安定性に与える影響を示す。特に、Post-LN Transformerでは大きな勾配が不安定さを引き起こすため、ウォームアップが有効である一方、Pre-LN Transformerでは勾配が良好に振る舞うため、ウォームアップを省略できることを示す。実験により、ウォームアップなしのPre-LN Transformerがベースラインと同等の結果を達成し、訓練時間とハイパーパラメータの調整が削減できることを確認した。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=B1x8anVFPrEncoder-DecoderのTransformerにおいて、Post-LNの場合は、Warmupを無くすと最終的な性能が悪化し、またWarmUpステップの値によって（500 vs. 4000で実験)も最終的な性能が変化する。これには学習時にハイパーパラメータをしっかり探索しなければならず、WarmUPを大きくすると学習効率が落ちるというデメリットがある。

<br>

<img src="https://github.com/user-attachments/assets/e7a26ecd-7905-4e6c-bb9a-29b8289addb0" alt="image" loading="lazy">

<br>



<br>

Post-LNの場合は、Pre-LNと比較して勾配が大きく、Warmupのスケジュールをしっかり設計しないと大きな勾配に対して大きな学習率が適用され学習が不安定になる。これは学習率を非常に小さくし、固定値を使うことで解決できるが、収束が非常に遅くなるというデメリットがある。

<br>

<img src="https://github.com/user-attachments/assets/afb09f44-c7c9-44ab-9066-3ee788ebd8ee" alt="image" loading="lazy">

<br>



<br>

一方、Pre-LNはWarmup無しでも、高い性能が達成でき、上記のようなチューニングの手間や学習効率の観点から利点がある、みたいな話の模様。

<br>

<img src="https://github.com/user-attachments/assets/d675a58b-e876-4e41-a76f-306c2e1ce23f" alt="image" loading="lazy">

<br>

</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<span class="issue_date">Issue Date: 2025-05-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2002">Scaling Laws for Autoregressive Generative Modeling, Tom Henighan+, arXiv'20</a>
<span class="snippet"><span>Summary</span>生成画像、ビデオ、マルチモーダルモデル、数学的問題解決の4領域におけるクロスエントロピー損失のスケーリング法則を特定。自己回帰型トランスフォーマーはモデルサイズと計算予算の増加に伴い性能が向上し、べき法則に従う。特に、10億パラメータのトランスフォーマーはYFCC100M画像分布をほぼ完璧にモデル化できることが示された。さらに、マルチモーダルモデルの相互情報量や数学的問題解決における外挿時の性能に関する追加のスケーリング法則も発見。これにより、スケーリング法則がニューラルネットワークの性能に与える影響が強調された。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-05-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1960">PEGASUS: Pre-training with Extracted Gap-sentences for Abstractive   Summarization, Jingqing Zhang+, ICML'20</a>
<span class="snippet"><span>Summary</span>大規模なテキストコーパスに対して新しい自己教師ありの目的でトランスフォーマーを事前学習し、抽象的なテキスト要約に特化したモデルPEGASUSを提案。重要な文を削除またはマスクし、残りの文から要約を生成。12の下流要約タスクで最先端のROUGEスコアを達成し、限られたリソースでも優れたパフォーマンスを示す。人間評価でも複数のデータセットで人間のパフォーマンスに達したことを確認。</span>
<span class="snippet"><span>Comment</span>PEGASUSもなかったので追加。BARTと共に文書要約のBackboneとして今でも研究で利用される模様。関連:

<br>

・984</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/TransferLearning.html">#TransferLearning</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-05-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1955">Exploring the Limits of Transfer Learning with a Unified Text-to-Text  Transformer, Colin Raffel+, JMLR'20</a>
<span class="snippet"><span>Summary</span>転移学習はNLPにおいて強力な技術であり、本論文ではテキストをテキストに変換する統一フレームワークを提案。事前学習の目的やアーキテクチャを比較し、最先端の結果を達成。データセットやモデル、コードを公開し、今後の研究を促進する。</span>
<span class="snippet"><span>Comment</span>T5もメモっていなかったので今更ながら追加。全てのNLPタスクをテキスト系列からテキスト系列へ変換するタスクとみなし、Encoder-DecoderのTransformerを大規模コーパスを用いて事前学習をし、downstreamタスクにfinetuningを通じて転移する。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/KnowledgeEditing.html">#KnowledgeEditing</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-05-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1934">Editable Neural Networks, Anton Sinitsin+, ICLR'20</a>
<span class="snippet"><span>Summary</span>深層ニューラルネットワークの誤りを迅速に修正するために、Editable Trainingというモデル非依存の訓練手法を提案。これにより、特定のサンプルの誤りを効率的に修正し、他のサンプルへの影響を避けることができる。大規模な画像分類と機械翻訳タスクでその有効性を実証。</span>
<span class="snippet"><span>Comment</span>（おそらく）Knowledge Editingを初めて提案した研究OpenReview:https://openreview.net/forum?id=HJedXaEtvS</span>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/AutomaticSpeechRecognition(ASR).html">#AutomaticSpeechRecognition(ASR)</a>
<a class="button" href="articles/AACL.html">#AACL</a>
<a class="button" href="articles/SimulST(SimultaneousSpeechTranslation).html">#SimulST(SimultaneousSpeechTranslation)</a>
<span class="issue_date">Issue Date: 2025-04-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1915">SimulMT to SimulST: Adapting Simultaneous Text Translation to End-to-End   Simultaneous Speech Translation, Xutai Ma+, AACL'20</a>
<span class="snippet"><span>Summary</span>同時テキスト翻訳手法をエンドツーエンドの同時音声翻訳に適応させる研究を行い、事前決定モジュールを導入。レイテンシと品質のトレードオフを分析し、新しいレイテンシメトリックを設計。</span>
<span class="snippet"><span>Comment</span>同時翻訳研究で主要なmetricの一つ

<br>

関連:

<br>

・1914 </span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Decoding.html">#Decoding</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-04-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1889">The Curious Case of Neural Text Degeneration, Ari Holtzman+, ICLR'20</a>
<span class="snippet"><span>Summary</span>深層ニューラル言語モデルは高品質なテキスト生成において課題が残る。尤度の使用がモデルの性能に影響を与え、人間のテキストと機械のテキストの間に分布の違いがあることを示す。デコーディング戦略が生成テキストの質に大きな影響を与えることが明らかになり、ニュークリアスsamplingを提案。これにより、多様性を保ちながら信頼性の低い部分を排除し、人間のテキストに近い質を実現する。</span>
<span class="snippet"><span>Comment</span>現在のLLMで主流なNucleus (top-p) Samplingを提案した研究</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<span class="issue_date">Issue Date: 2025-03-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1828">Scaling Laws for Neural Language Models, Jared Kaplan+, arXiv'20</a>
<span class="snippet"><span>Summary</span>言語モデルの性能に関するスケーリング法則を研究し、損失がモデルサイズ、データセットサイズ、計算量に対して冪則的にスケールすることを示す。アーキテクチャの詳細は影響が少なく、過学習やトレーニング速度は単純な方程式で説明される。これにより、計算予算の最適な配分が可能となり、大きなモデルはサンプル効率が高く、少量のデータで早期に収束することが示された。</span>
<span class="snippet"><span>Comment</span>日本語解説:https://www.slideshare.net/slideshow/dlscaling-laws-for-neural-language-models/243005067</span>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2024-05-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1312">COMET: A Neural Framework for MT Evaluation, Ricardo Rei+, N_A, EMNLP'20</a>
<span class="snippet"><span>Summary</span>COMETは、多言語機械翻訳評価モデルを訓練するためのニューラルフレームワークであり、人間の判断との新しい最先端の相関レベルを達成します。クロスリンガル事前学習言語モデリングの進展を活用し、高度に多言語対応かつ適応可能なMT評価モデルを実現します。WMT 2019 Metrics shared taskで新たな最先端のパフォーマンスを達成し、高性能システムに対する堅牢性を示しています。</span>
<span class="snippet"><span>Comment</span>Better/Worseなhypothesisを利用してpair-wiseにランキング関数を学習する

<br>

![Image](https://github.com/user-attachments/assets/a1fd6f36-48e8-44fc-8fcb-0900a51759b3)

<br>



<br>

![Image](https://github.com/user-attachments/assets/19ad7a57-7de3-4255-afde-4a1fde41587d)

<br>



<br>

Inference時は単一のhypothesisしかinputされないので、sourceとreferenceに対してそれぞれhypothesisの距離をはかり、その調和平均でスコアリングする

<br>



<br>

![Image](https://github.com/user-attachments/assets/21642c70-a7fd-4c0e-8678-6125fdbfefce)ACL2024, EMNLP2024あたりのMT研究のmetricをざーっと見る限り、BLEU/COMETの双方で評価する研究が多そう</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<a class="button" href="articles/ActivationFunction.html">#ActivationFunction</a>
<span class="issue_date">Issue Date: 2024-05-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1311">GLU Variants Improve Transformer, Noam Shazeer, N_A, arXiv'20</a>
<span class="snippet"><span>Summary</span>GLUのバリエーションをTransformerのフィードフォワード・サブレイヤーでテストし、通常の活性化関数よりもいくつかのバリエーションが品質向上をもたらすことを発見した。</span>
<span class="snippet"><span>Comment</span>一般的なFFNでは、linear layerをかけた後に、何らかの活性化関数をかませる方法が主流である。

<br>



<br>

このような構造の一つとしてGLUがあるが、linear layerと活性化関数には改良の余地があり、様々なvariantが考えられるため、色々試しました、というはなし。

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/72b1d0bb-64ac-4155-9a3b-5624cd06ccc9" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/b38321c6-d414-4764-9147-10a5fa83fbe6" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

オリジナルのGLUと比較して、T5と同じ事前学習タスクを実施したところ、perplexityが改善

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/9e67a054-2148-41ed-aae1-5a752c21a242" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

また、finetuningをした場合の性能も、多くの場合オリジナルのGLUよりも高い性能を示した。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/77ccab88-e5cc-48fc-b9e0-f2dad24e53e8" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/8f60ca8c-50eb-4869-bab4-f02ec6d8e085" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/8124fc25-aa7e-4e10-8cd2-9d24c818f410" alt="image" loading="lazy">

<br>



<br>



<br>



<br>



<br>



<br>

</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-free.html">#Reference-free</a>
<a class="button" href="articles/QA-based.html">#QA-based</a>
<span class="issue_date">Issue Date: 2023-08-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1007">Asking and Answering Questions to Evaluate the Factual Consistency of Summaries, Wang, ACL'20</a>
<span class="snippet"><span>Summary</span>要約の事実の不整合を特定するための自動評価プロトコルであるQAGSを提案する。QAGSは、要約とソースについて質問をし、整合性がある回答を得ることで要約の事実的整合性を評価する。QAGSは他の自動評価指標と比較して高い相関を持ち、自然な解釈可能性を提供する。QAGSは有望なツールであり、https://github.com/W4ngatang/qagsで利用可能。</span>
<span class="snippet"><span>Comment</span>QAGS生成された要約からQuestionを生成する手法。precision-oriented</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<span class="issue_date">Issue Date: 2023-08-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/993">Reducing Quantity Hallucinations in Abstractive Summarization, Zheng Zhao+, N_A, EMNLP'20</a>
<span class="snippet"><span>Summary</span>Hermanシステムは、抽象的な要約において幻覚を回避するために、数量エンティティを認識し、元のテキストでサポートされている数量用語を持つ要約を上位にランク付けするアプローチを提案しています。実験結果は、このアプローチが高い適合率と再現率を持ち、F$_1$スコアが向上することを示しています。また、上位にランク付けされた要約が元の要約よりも好まれることも示されています。</span>
<span class="snippet"><span>Comment</span>数量に関するhallucinationを緩和する要約手法</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/QA-based.html">#QA-based</a>
<span class="issue_date">Issue Date: 2023-08-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/991">FEQA: A Question Answering Evaluation Framework for Faithfulness Assessment in Abstractive Summarization, Durmus+, ACL'20</a>
<span class="snippet"><span>Summary</span>ニューラル抽象的要約モデルの信頼性を評価するために、人間の注釈を収集し、信頼性の自動評価指標であるFEQAを提案した。FEQAは質問応答を利用して要約の信頼性を評価し、特に抽象的な要約において人間の評価と高い相関を示した。</span>
<span class="snippet"><span>Comment</span>FEQA生成された要約からQuestionを生成する手法。precision-oriented </span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-based.html">#Reference-based</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/982">HOLMS: Alternative Summary Evaluation with Large Language Models, Mrabet+, COLING'20</a>
<span class="snippet"><span>Summary</span>要約手法の評価尺度として、ROUGEとBLEUが一般的に使用されているが、これらは語彙的な性質を持ち、ニューラルネットワークのトレーニングには限定的な可能性がある。本研究では、大規模なコーパスで事前学習された言語モデルと語彙的類似度尺度を組み合わせた新しい評価尺度であるHOLMSを提案する。実験により、HOLMSがROUGEとBLEUを大幅に上回り、人間の判断との相関も高いことを示した。</span>
<span class="snippet"><span>Comment</span>Hybrid Lexical and MOdel-based evaluation of Summaries (HOLMS)</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-free.html">#Reference-free</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/977">Unsupervised Reference-Free Summary Quality Evaluation via Contrastive  Learning, Hanlu Wu+, N_A, EMNLP'20</a>
<span class="snippet"><span>Summary</span>本研究では、参照要約なしで要約の品質を評価するために教師なしの対照的学習を提案しています。新しいメトリックを設計し、ランキング損失でモデルを訓練することで、要約品質の異なる側面に関する異なるタイプのネガティブサンプルを構築します。実験結果は、参照要約なしでも他のメトリックよりも優れた評価方法であることを示しています。また、提案手法が一般的かつ転移可能であることも示されています。</span>
<span class="snippet"><span>Comment</span>LS_Score色々なメトリックが簡潔にまとまっている</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/LM-based.html">#LM-based</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/963">Evaluating the Factual Consistency of Abstractive Text Summarization, Kryscinski+, EMNLP'20</a>
<span class="snippet"><span>Summary</span>本研究では、要約の事実的な整合性を検証するためのモデルベースのアプローチを提案しています。トレーニングデータはルールベースの変換を用いて生成され、モデルは整合性の予測とスパン抽出のタスクで共同してトレーニングされます。このモデルは、ニューラルモデルによる要約に対して転移学習を行うことで、以前のモデルを上回る性能を示しました。さらに、人間の評価でも補助的なスパン抽出タスクが有用であることが示されています。データセットやコード、トレーニング済みモデルはGitHubで公開されています。</span>
<span class="snippet"><span>Comment</span>FactCC近年のニューラルモデルは流ちょうな要約を生成するが、それらには、unsuportedなinformationが多く含まれていることを示した</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-free.html">#Reference-free</a>
<a class="button" href="articles/LM-based.html">#LM-based</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/959">Automatic Machine Translation Evaluation in Many Languages via Zero-Shot Paraphrasing, Thompson+, EMNLP'20</a>
<span class="snippet"><span>Summary</span>パラフレーザを使用して機械翻訳の評価を行うタスクを定義し、多言語NMTシステムをトレーニングしてパラフレーシングを行います。この手法は直感的であり、人間の判断を必要としません。39言語でトレーニングされた単一モデルは、以前のメトリクスと比較して優れたパフォーマンスを示し、品質推定のタスクでも優れた結果を得ることができます。</span>
<span class="snippet"><span>Comment</span>PRISM</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-free.html">#Reference-free</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/950">Fill in the BLANC: Human-free quality estimation of document summaries, Vasilyev+, Eval4NLP'20</a>
<span class="snippet"><span>Summary</span>BLANCは、要約の品質を自動的に推定するための新しいアプローチです。BLANCは、事前学習済みの言語モデルを使用してドキュメントの要約にアクセスし、要約の機能的なパフォーマンスを測定します。BLANCスコアは、ROUGEと同様に人間の評価と良好な相関関係を持ち、人間によって書かれた参照要約が不要なため、完全に人間不在の要約品質推定が可能です。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-free.html">#Reference-free</a>
<a class="button" href="articles/Training-Free.html">#Training-Free</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/945">SUPERT: Towards New Frontiers in Unsupervised Evaluation Metrics for Multi-Document Summarization, Gao+, ACL'20</a>
<span class="snippet"><span>Summary</span>この研究では、教師なしの複数文書要約評価メトリックスについて調査しています。提案手法SUPERTは、擬似的な参照要約として選択された重要な文を使用し、文脈化埋め込みとソフトトークンアラインメント技術を用いて要約の品質を評価します。SUPERTは従来の教師なし評価メトリックスよりも人間の評価との相関が高く、18〜39％の向上が見られます。また、SUPERTを報酬として使用してニューラルベースの強化学習要約器をガイドすることで、有利なパフォーマンスを実現しています。ソースコードはGitHubで入手可能です。</span>
<span class="snippet"><span>Comment</span>pseudo-reference summaryを作成し、referenceに対してSBERTを適用しsystem-reference間の類似度を測ることで、unsupervisedに複数文書要約を評価する手法。

<br>



<br>

まずTACのデータに対して、既存研究（single document summarizationの評価用に提案された手法）を適用し、Human Ratingsとの相関が低いことを確認している。この時、Referenceを用いる手法（ROUGE、MoverScore）の相関をUpper Boundとし、Upper Boundに及ばないことを確認している。また、既存研究よりもシンプルなJS Divergence等を用いるlexical basedな手法の相関が高かったことも確認している。

<br>

続いて、unsupervisedな手法として、contextualなembeddingを利用し（BERT, SBERT等）source, system summary間の類似度を測る手法で相関を測ったところ、こちらでもUpper Boundに及ばないこと、シンプルな手法に及ばないことを確認。これら手法にWMDを応用するすることで相関が向上することを確認した。

<br>

これらのことより、Referenceがある場合、無い場合の両者においてWMDを用いる手法が有効であることが確認できたが、Referenceの有無によって相関に大きな差が生まれていることが確認できた。このことから、何らかの形でReferenceが必要であり、pseudo referenceを生成し利用することを着想した、というストーリーになっている。pseudo referenceを生成する方法として、top Nのリード文を抽出する手法や、LexRankのようなGraphBasedな手法を利用してTACデータにおいてどのような手法が良いかを検証している。この結果、TAC8,9の場合はTop 10,15のsentenceをpseudo referenceとした場合が最も良かった。

<br>



<br>

細かいところまで読みきれていないが、自身が要約したい文書群においてどの方法でpseudo referenceを生成するかは、Referenceがないと判断できないと考えられるため、その点は課題だと考えられる。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-based.html">#Reference-based</a>
<a class="button" href="articles/TrainedMetrics.html">#TrainedMetrics</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/944">BLEURT: Learning Robust Metrics for Text Generation, Sellam+, ACL'20</a>
<span class="snippet"><span>Summary</span>BLEURTは、BERTをベースとした学習済みの評価指標であり、人間の判断と高い相関を持つことが特徴です。BLEURTは、数千のトレーニング例を使用してバイアスのある評価をモデル化し、数百万の合成例を使用してモデルの汎化を支援します。BLEURTは、WMT Metrics共有タスクとWebNLGデータセットで最先端の結果を提供し、トレーニングデータが少ない場合や分布外の場合でも優れた性能を発揮します。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-based.html">#Reference-based</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2023-05-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/668">BERTScore: Evaluating Text Generation with BERT, Tianyi Zhang+, N_A, ICLR'20</a>
<span class="snippet"><span>Summary</span>BERTScoreは、文脈埋め込みを使用してトークンの類似度を計算するテキスト生成の自動評価メトリックであり、363の機械翻訳および画像キャプションシステムの出力を使用して評価されました。BERTScoreは、既存のメトリックよりも人間の判断との相関が高く、より強力なモデル選択性能を提供し、敵対的な言い換え検出タスクにおいてもより堅牢であることが示されました。</span>
<span class="snippet"><span>Comment</span>概要

<br>

既存のテキスト生成の評価手法（BLEUやMETEOR）はsurface levelのマッチングしかしておらず、意味をとらえられた評価になっていなかったので、pretrained BERTのembeddingを用いてsimilarityを測るような指標を提案しましたよ、という話。

<br>



<br>

prior metrics

<br>

n-gram matching approaches

<br>

n-gramがreferenceとcandidateでどれだけ重複しているかでPrecisionとrecallを測定

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/a620d564-72e3-4078-97e2-1ff62b333324" alt="image" loading="lazy">

<br>



<br>

BLEU

<br>

MTで最も利用される。n-gramのPrecision（典型的にはn=1,2,3,4）と短すぎる候補訳にはペナルティを与える（brevity penalty）ことで実現される指標。SENT-BLEUといった亜種もある。BLEUと比較して、BERTScoreは、n-gramの長さの制約を受けず、潜在的には長さの制限がないdependencyをcontextualized embeddingsでとらえることができる。

<br>



<br>

METEOR

<br>

669 METEOR 1.5では、内容語と機能語に異なるweightを割り当て、マッチングタイプによってもweightを変更する。METEOR++2.0では、学習済みの外部のparaphrase resourceを活用する。METEORは外部のリソースを必要とするため、たった5つの言語でしかfull feature setではサポートされていない。11の言語では、恥部のfeatureがサポートされている。METEORと同様に、BERTScoreでも、マッチに緩和を入れていることに相当するが、BERTの事前学習済みのembeddingは104の言語で取得可能である。BERTScoreはまた、重要度によるweightingをサポートしている（コーパスの統計量で推定）。

<br>



<br>

Other Related Metrics

<br>

・NIST: BLEUとは異なるn-gramの重みづけと、brevity penaltyを利用する

<br>

・ΔBLEU: multi-reference BLEUを、人手でアノテーションされたnegative reference sentenceで変更する

<br>

・CHRF: 文字n-gramを比較する

<br>

・CHRF++: CHRFをword-bigram matchingに拡張したもの

<br>

・ROUGE: 文書要約で利用される指標。ROUGE-N, ROUGE^Lといった様々な変種がある。

<br>

・CIDEr: image captioningのmetricであり、n-gramのtf-idfで重みづけされたベクトルのcosine similrityを測定する

<br>



<br>

Edit-distance based Metrics

<br>

・Word Error Rate (WER): candidateからreferenceを再現するまでに必要なedit operationの数をカウントする手法

<br>

・Translation Edit Rate (TER): referenceの単語数によってcandidateからreferenceまでのedit distanceを正規化する手法

<br>

・ITER: 語幹のマッチと、より良い正規化に基づく手法

<br>

・PER: positionとは独立したError Rateを算出

<br>

・CDER: edit operationにおけるblock reorderingをモデル化

<br>

・CHARACTER / EED: character levelで評価

<br>



<br>

Embedding-based Metrics

<br>

・MEANT 2.0: lexical, structuralの類似度を測るために、word embeddingとshallow semantic parsesを利用

<br>

・YISI-1: MEANT 2.0と同様だが、semantic parseの利用がoptionalとなっている

<br>

これらはBERTScoreと同様の、similarityをシンプルに測るアプローチで、BERTScoreもこれにinspireされている。が、BERTScoreはContextualized Embeddingを利用する点が異なる。また、linguistic structureを生成するような外部ツールは利用しない。これにより、BERTScoreをシンプルで、新たなlanguageに対しても使いやすくしている。greedy matchingの代わりに、WMD, WMDo, SMSはearth mover's distanceに基づく最適なマッチングを利用することを提案している。greedy matchingとoptimal matchingのtradeoffについては研究されている。sentence-levelのsimilarityを計算する手法も提案されている。これらと比較して、BERTScoreのtoken-levelの計算は、重要度に応じて、tokenに対して異なる重みづけをすることができる。

<br>



<br>

Learned Metrics

<br>

様々なmetricが、human judgmentsとのcorrelationに最適化するために訓練されてきた。

<br>

・BEER: character-ngram, word bigramに基づいたregresison modelを利用

<br>

・BLEND: 29の既存のmetricを利用してregressionを実施

<br>

・RUSE: 3種類のpre-trained sentence embedding modelを利用する手法

<br>

これらすべての手法は、コストのかかるhuman judgmentsによるsupervisionが必要となる。そして、新たなドメインにおける汎化能力の低さのリスクがある。input textが人間が生成したものか否か予測するneural modelを訓練する手法もある。このアプローチは特定のデータに対して最適化されているため、新たなデータに対して汎化されないリスクを持っている。これらと比較して、BERTScoreは特定のevaluation taskに最適化されているモデルではない。

<br>



<br>

BERTScore

<br>

referenceとcandidateのトークン間のsimilarityの最大値をとり、それらを集約することで、Precision, Recallを定義し、PrecisionとRecallを利用してF値も計算する。Recallは、reference中のすべてのトークンに対して、candidate中のトークンとのcosine similarityの最大値を測る。一方、Precisionは、candidate中のすべてのトークンに対して、reference中のトークンとのcosine similarityの最大値を測る。ここで、類似度の式が単なる内積になっているが、これはpre-normalized vectorを利用する前提であり、正規化が必要ないからである。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/9ed88ea6-8ecf-465c-81d5-bc85592ad7ff" alt="image" loading="lazy">

<br>



<br>

また、IDFによるトークン単位でのweightingを実施する。IDFはテストセットの値を利用する。TFを使わない理由は、BERTScoreはsentence同士を比較する指標であるため、TFは基本的に1となりやすい傾向にあるためである。IDFを計算する際は出現数を+1することによるスムージングを実施。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/d4b132fb-7830-4a00-b845-11f38b909bba" alt="image" loading="lazy">

<br>



<br>

さらに、これはBERTScoreのランキング能力には影響を与えないが、BERTScoreの値はコサイン類似度に基づいているため、[-1, 1]となるが、実際は学習したcontextual embeddingのgeometryに値域が依存するため、もっと小さなレンジでの値をとることになってしまう。そうすると、人間による解釈が難しくなる（たとえば、極端な話、スコアの0.1程度の変化がめちゃめちゃ大きな変化になってしまうなど）ため、rescalingを実施。rescalingする際は、monolingualコーパスから、ランダムにsentenceのペアを作成し（BETRScoreが非常に小さくなるケース）、これらのBERTScoreを平均することでbを算出し、bを利用してrescalingした。典型的には、rescaling後は典型的には[0, 1]の範囲でBERTScoreは値をとる（ただし数式を見てわかる通り[0, 1]となることが保証されているわけではない点に注意）。これはhuman judgmentsとのcorrelationとランキング性能に影響を与えない（スケールを変えているだけなので）。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/9049ed99-d192-465d-b4fe-d628bc673927" alt="image" loading="lazy">

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/bb78074e-2fa4-4bb3-a920-df543aeb98b8" alt="image" loading="lazy">

<br>

実験

<br>



<br>

Contextual Embedding Models

<br>



<br>

12種類のモデルで検証。BERT, RoBERTa, XLNet, XLMなど。

<br>



<br>



<br>



<br>

Machine Translation

<br>



<br>

WMT18のmetric evaluation datasetを利用。149種類のMTシステムの14 languageに対する翻訳結果, gold referencesと2種類のhuman judgment scoreが付与されている。segment-level human judgmentsは、それぞれのreference-candiate pairに対して付与されており、system-level human judgmentsは、それぞれのシステムに対して、test set全体のデータに基づいて、単一のスコアが付与されている。pearson correlationの絶対値と、kendall rank correration τをmetricsの品質の評価に利用。そしてpeason correlationについてはWilliams test、kendall τについては、bootstrap re-samplingによって有意差を検定した。システムレベルのスコアをBERTScoreをすべてのreference-candidate pairに対するスコアをaveragingすることによって求めた。また、ハイブリッドシステムについても実験をした。具体的には、それぞれのreference sentenceについて、システムの中からランダムにcandidate sentenceをサンプリングした。これにより、system-level experimentをより多くのシステムで実現することができる。ハイブリッドシステムのシステムレ4ベルのhuman judgmentsは、WMT18のsegment-level human judgmentsを平均することによって作成した。BERTScoreを既存のメトリックと比較した。

<br>



<br>



<br>



<br>

通常の評価に加えて、モデル選択についても実験した。10kのハイブリッドシステムを利用し、10kのうち100をランダムに選択、そして自動性能指標でそれらをランキングした。このプロセスを100K回繰り返し、human rankingとmetricのランキングがどれだけagreementがあるかをHits@1で評価した（best systemの一致で評価）。モデル選択の指標として新たにtop metric-rated systemとhuman rankingの間でのMRR, 人手評価でtop-rated systemとなったシステムとのスコアの差を算出した。WMT17, 16のデータセットでも同様の評価を実施した。

<br>



<br>



<br>



<br>

Image Captioning

<br>



<br>

COCO 2015 captioning challengeにおける12種類のシステムのsubmissionデータを利用。COCO validationセットに対して、それぞれのシステムはimageに対するcaptionを生成し、それぞれのimageはおよそ5個のreferenceを持っている。先行研究にならい、Person Correlationを2種類のシステムレベルmetricで測定した。

<br>



<br>

・M1: 人間によるcaptionと同等、あるいはそれ以上と評価されたcaptionの割合

<br>



<br>

・M2: 人間によるcaptionと区別がつかないcaptionの割合

<br>



<br>

BERTScoreをmultiple referenceに対して計算し、最も高いスコアを採用した。比較対象のmetricはtask-agnostic metricを採用し、BLEU, METEOR, CIDEr, BEER, EED, CHRF++, CHARACTERと比較した。そして、2種類のtask-specific metricsとも比較した：SPICE, LEIC

<br>



<br>



<br>



<br>

実験結果

<br>



<br>

Machine Translation

<br>



<br>

system-levelのhuman judgmentsとのcorrelationの比較、hybrid systemとのcorrelationの比較、model selection performance

<br>



<br>

to-Englishの結果では、BERTScoreが最も一貫して性能が良かった。RUSEがcompetitiveな性能を示したが、RUSEはsupervised methodである。from-Englishの実験では、RUSEは追加のデータと訓練をしないと適用できない。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/e3b0482e-a30b-46be-b8df-72a1c4fe510d" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/b769ac8f-1a43-48d6-9316-cb78cffc3b88" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/3b204434-9f9a-4672-be5a-6e463d3289f4" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

以下は、segment-levelのcorrelationを示したものである。BERTScoreが一貫して高い性能を示している。BLEUから大幅な性能アップを示しており、特定のexampleについての良さを検証するためには、BERTScoreが最適であることが分かる。BERTScoreは、RUSEをsignificantlyに上回っている。idfによる重要度のweightingによって、全体としては、small benefitがある場合があるが全体としてはあんまり効果がなかった。importance weightingは今後の課題であり、テキストやドメインに依存すると考えられる。FBERTが異なる設定でも良く機能することが分かる。異なるcontextual embedding model間での比較などは、appendixに示す。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/1684fa38-0663-4649-849f-1885cd97286e" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Image Captioning

<br>



<br>

task-agnostic metricの間では、BETRScoreはlarge marginで勝っている。image captioningはchallengingな評価なので、n-gramマッチに基づくBLEU, ROUGEはまったく機能していない。また、idf weightingがこのタスクでは非常に高い性能を示した。これは人間がcontent wordsに対して、より高い重要度を置いていることがわかる。最後に、LEICはtrained metricであり、COCO dataに最適化されている。この手法は、ほかのすべてのmetricを上回った。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/5842611a-38bd-441f-a467-8bb3714dc33a" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Speed

<br>



<br>

pre-trained modelを利用しているにもかかわらず、BERTScoreは比較的高速に動作する。192.5 candidate-reference pairs/secondくらい出る（GTX-1080Ti GPUで）。WMT18データでは、15.6秒で処理が終わり、SacreBLEUでは5.4秒である。計算コストそんなにないので、BERTScoreはstoppingのvalidationとかにも使える。Robustness analysis

<br>



<br>

BERTScoreのロバスト性をadversarial paraphrase classificationでテスト。Quora Question Pair corpus (QQP) を利用し、Word Scrambling dataset (PAWS) からParaphrase Adversariesを取得。どちらのデータも、各sentenceペアに対して、それらがparaphraseかどうかラベル付けされている。QQPの正例は、実際のduplicate questionからきており、負例は関連するが、異なる質問からきている。PAWSのsentence pairsは単語の入れ替えに基づいているものである。たとえば、"Flights from New York to Florida" は "Flights from Florida to New York" のように変換され、良いclassifierはこれらがparaphraseではないと認識できなければならない。PAWSはPAWS_QQPとPAWS_WIKIによって構成さえｒており、PAWS_QQPをdevelpoment setとした。automatic metricsでは、paraphrase detection training dataは利用しないようにした。自動性能指標で高いスコアを獲得するものは、paraphraseであることを想定している。

<br>



<br>



<br>



<br>

下図はAUCのROC curveを表しており、PAWS_QQPにおいて、QQPで訓練されたclassifierはrandom guessよりも性能が低くなることが分かった。つまりこれらモデルはadversaial exampleをparaphraseだと予測してしまっていることになる。adversarial examplesがtrainingデータで与えられた場合は、supervisedなモデルも分類ができるようになる。が、QQPと比べると性能は落ちる。多くのmetricsでは、QQP ではまともなパフォーマンスを示すが、PAWS_QQP では大幅なパフォーマンスの低下を示し、ほぼrandomと同等のパフォーマンスとなる。これは、これらの指標がより困難なadversarial exampleを区別できないことを示唆している。一方、BERTSCORE のパフォーマンスはわずかに低下するだけであり、他の指標よりもロバスト性が高いことがわかる。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/7a3b3c3b-ff4e-4f65-a6b3-c71b8f100c8a" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Discussion

<br>



<br>

・BERTScoreの単一の設定が、ほかのすべての指標を明確に上回るということはない

<br>



<br>

・ドメインや言語を考慮して、指標や設定を選択すべき

<br>



<br>

・一般的に、機械翻訳の評価にはFBERTを利用することを推奨

<br>



<br>

・英語のテキスト生成の評価には、24層のRoBERTa largeモデルを使用して、BERTScoreを計算したほうが良い

<br>



<br>

・非英語言語については、多言語のBERT_multiが良い選択肢だが、このモデルで計算されたBERTScoreは、low resource languageにおいて、パフォーマンスが安定しているとは言えない</span>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/review.html">#review</a>
<span class="issue_date">Issue Date: 2023-05-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/656">A Unified Dual-view Model for Review Summarization and Sentiment  Classification with Inconsistency Loss, Hou Pong Chan+, N_A, arXiv'20</a>
<span class="snippet"><span>Summary</span>ユーザーレビューから要約と感情を取得するために、新しいデュアルビューモデルを提案。エンコーダーがレビューの文脈表現を学習し、サマリーデコーダーが要約を生成。ソースビュー感情分類器はレビューの感情ラベルを予測し、サマリービュー感情分類器は要約の感情ラベルを予測。不一致損失を導入して、2つの分類器の不一致を罰することで、デコーダーが一貫した感情傾向を持つ要約を生成し、2つの感情分類器がお互いから学ぶことができるようになる。4つの実世界データセットでの実験結果は、モデルの効果を示している。</span>
<span class="snippet"><span>Comment</span>Review SummarizationとSentiment Classificationをjointで学習した研究。既存研究ではreviewのみからsentimentの情報を獲得する枠組みは存在したが、summaryの情報が活用できていなかった。

<br>



<br>

653 のratingをsentiment labelとして扱い、評価も同データを用いてROUGEで評価。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236713791-7986bb89-2576-4daa-b01a-9af7e97dac51.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

実際に生成されたレビュー例がこちら。なんの疑いもなくamazon online review datasetを教師データとして使っているが、果たしてこれでいいんだろうか？

<br>



<br>

論文冒頭のsummaryの例と、実際に生成された例を見ると、後者の方が非常に主観的な情報を含むのに対して、前者はより客観性が高いように思える。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236714479-19772588-e226-4fe9-8850-13050fdc775a.png" alt="image" loading="lazy">

<br>



<br>

しかし最初にこのデータセットを使ったのは 652 の方っぽい</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Zero/FewShotPrompting.html">#Zero/FewShotPrompting</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2023-04-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/552">Language Models are Few-Shot Learners, Tom B. Brown+, NeurIPS'20</a>
<span class="snippet"><span>Summary</span>GPT-3は1750億パラメータを持つ自己回帰型言語モデルで、少数ショット設定においてファインチューニングなしで多くのNLPタスクで強力な性能を示す。翻訳や質問応答などで優れた結果を出し、即時推論やドメイン適応が必要なタスクでも良好な性能を発揮する一方、依然として苦手なデータセットや訓練に関する問題も存在する。また、GPT-3は人間が書いた記事と区別が難しいニュース記事を生成できることが確認され、社会的影響についても議論される。</span>
<span class="snippet"><span>Comment</span>In-Context Learningを提案した論文論文に記載されているIn-Context Learningの定義は、しっかり押さえておいた方が良い。

<br>



<br>

下図はmeta-learningの観点から見たときの、in-contextの位置付け。事前学習時にSGDでパラメータをupdateするのをouter loopとし、そこで広いスキルとパターン認識の能力を身につける。一方で、in-context learningは、Inference時に事前学習時に得たそれらのスキルを用いて、求めるタスクを認識、あるいは適応するInner loopのことを指す。

<br>

<img src="https://github.com/user-attachments/assets/679129f3-93e3-445f-b9e8-5d909261737b" alt="image" loading="lazy">

<br>



<br>

この上で、論文中では In-Context Learningについて:

<br>

&gt; Recent work [RWC+19] attempts to do this via what we call “in-context learning”, using the text input of a pretrained language model as a form of task specification: the model is conditioned on a natural language instruction and/or a few demonstrations of the task and is then expected to complete further instances of the task simply by predicting what comes next.

<br>



<br>

と定義している。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<span class="issue_date">Issue Date: 2023-04-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/537">Returning the N to NLP: Towards Contextually Personalized Classification Models, Lucie Flek, Mainz University of Applied Sciences Germany, ACL'20</a>
<span class="snippet"><span>Comment</span>NLPのけるPersonalized Classificationモデルのliteratureを振り返る論文</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/pretrained-LM.html">#pretrained-LM</a>
<a class="button" href="articles/Zero/FewShotLearning.html">#Zero/FewShotLearning</a>
<span class="issue_date">Issue Date: 2022-12-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/494">Few-Shot NLG with Pre-Trained Language Model, Chen+, University of California, ACL'20</a>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

Neural basedなend-to-endなNLGアプローチはdata-hungryなので、Few Shotな設定で高い性能ができる手法を提案（Few shot NLG）

<br>



<br>

Table-to-Textタスク（WikiBIOデータ, 追加で収集したBook, SongドメインのWikipediaデータ）において、200程度の学習サンプル数でstrong baselineに対して8.0 point程度のBLEUスコアの向上を達成

<br>



<br>



<br>



<br>

手法

<br>



<br>

TabularデータのDescriptionを作成するには大きく分けて2つのスキルが必要

<br>



<br>

1. factualな情報を持つcontentをselectし、copyするスキル

<br>



<br>

2. factualな情報のコピーを含めながら、文法的に正しいテキストを生成するスキル

<br>



<br>

提案手法では、1を少量のサンプル（&lt; 500）から学習し、2については事前学習済みの言語モデルを活用する。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/204966408-e5442477-0560-439b-9780-d454a8761345.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

encoderからコピーする確率をpcopyとし、下記式で算出する：

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/204968383-44ef3771-218e-4e3e-8bfd-e2e6750c514b.png" alt="image" loading="lazy">

<br>



<br>

すなわち、encoderのcontext vectorと、decoderのinputとstateから求められる。

<br>



<br>

encoderとencoder側へのattentionはscratchから学習しなければならず、うまくコピーできるようにしっかりと”teach”しなければならないため、lossに以下を追加する：

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/204968557-4526e76d-8be5-4371-adc7-d49d8291954f.png" alt="image" loading="lazy">

<br>



<br>

すなわち、コピーすべき単語がちゃんとコピーできてる場合にlossが小さくなる項を追加している。

<br>



<br>

また、decoder側では、最初にTable情報のEmbeddingを入力するようにしている。

<br>



<br>

また、学習できるデータ量が限られているため、pre-trainingモデルのEmbeddingは事前学習時点のものに固定した（ただしく読解できているか不安）

<br>



<br>



<br>



<br>

実験

<br>



<br>

WikiBIOと、独自に収集したBook, Songに関するWikipediaデータのTable-to-Textデータを用いて実験。

<br>



<br>

このとき、Training instanceを50~500まで変化させた。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/204969250-b2965b62-5a82-4c38-9008-3e4bbc5d9c24.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

WikiBIOデータセットに対してSoTAを記録しているBase-originalを大きくoutperform（Few shot settingでは全然うまくいかない）。

<br>



<br>



<br>



<br>

inputとoutput例と、コピーに関するlossを入れた場合の効果。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/204969645-aa2686f0-f83c-44cc-a6aa-2e793a6cd5b8.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

人手評価の結果、Factual informationの正しさ（Supp）、誤り（Cont）ともに提案手法が良い。また、文法的な正しさ（Lan. Score）もコピーがない場合とcomparable

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/204969885-7cb3e507-d986-4d97-8f7c-a5b8c3c8204f.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/pretrained-LM.html">#pretrained-LM</a>
<span class="issue_date">Issue Date: 2022-12-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/493">Leveraging Pre-trained Checkpoints for Sequence Generation Tasks, Rothe+, Google Research, TACL'20</a>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

BERT-to-BERT論文。これまでpre-trainedなチェックポイントを利用する研究は主にNLUで行われてきており、Seq2Seqでは行われてきていなかったので、やりました、という話。

<br>



<br>

publicly availableなBERTのcheckpointを利用し、BERTをencoder, decoder両方に採用することでSeq2Seqを実現。実現する上で、

<br>



<br>

1. decoder側のBERTはautoregressiveな生成をするようにする（左側のトークンのattentionしか見れないようにする）

<br>



<br>

2. encoder-decoder attentionを新たに導入する

<br>



<br>

の2点を工夫している。

<br>



<br>



<br>



<br>

実験

<br>



<br>

Sentence Fusion, Sentence Split, Machine Translation, Summarizationの4タスクで実験

<br>



<br>



<br>



<br>

MT

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/204958483-722106b3-bda2-45a3-bb08-fb4eb429c90c.png" alt="image" loading="lazy">

<br>



<br>

BERT2BERTがSoTA達成。Edunov+の手法は、data _augmentationを利用した手法であり、純粋なWMT14データを使った中ではSoTAだと主張。特にEncoder側でBERTを使うと、Randomにinitializeした場合と比べて性能が顕著に上昇しており、その重要性を主張。

<br>



<br>

Sentence Fusion, Sentence Splitでは、encoderとdecoderのパラメータをshareするのが良かったが、MTでは有効ではなかった。これはMTではmodelのcapacityが非常に重要である点、encoderとdecoderで異なる文法を扱うためであると考えられる。

<br>



<br>



<br>



<br>

Summarization

<br>



<br>

BERTSHARE, ROBERTASHAREの結果が良かった。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/204959543-e21bd9a6-bef4-4538-b181-daca93fa33e7.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/pretrained-LM.html">#pretrained-LM</a>
<span class="issue_date">Issue Date: 2022-12-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/492">Template Guided Text Generation for Task-Oriented Dialogue, Kale+, Google, EMNLP'20</a>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

Dialogue Actをそのままlinearlizeして言語モデルに入力するのではなく、テンプレートをベースにしたシンプルなsentenceにして言語モデルに与えると、zero-shot, few-shotなsettingで性能が向上するという話（T5ベース）。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/204951348-e7cb9982-4d1f-4ac0-8e1d-b3e8fd872b11.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

手法

<br>



<br>

slotの名称をnatural languageのdescriptionに変更するSchema Guidedアプローチも提案（NLUでは既に実践さrていたらしいが、Generationで利用されたことはない）。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/204952341-fae03300-992a-491f-b194-9013f5d598f9.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

結果

<br>



<br>

MultiWoz, E2E, SGDデータセットを利用。MultiWoz, E2Eデータはデータ量が豊富でドメインやfeatureが限定的なため、schema guided, template guided approachとNaiveなrepresentationを利用した場合の結果がcopmarableであった。

<br>



<br>

が、SGDデータセットはドメインが豊富でzero-shot, few-shotの設定で実験ができる。SGDの場合はTemplate guided representationが最も高い性能を得た。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/204954033-ecbeb90f-1398-486c-8d1f-76a0e54ed8ea.png" alt="image" loading="lazy">

<br>



<br>

low resourceなデータセットで活用できそう</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<span class="issue_date">Issue Date: 2022-09-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/488">Text-to-Text Pre-Training for Data-to-Text Tasks, Mihir+, Google Research, INLG'20</a>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

pre-training済みのT5に対して、Data2Textのデータセットでfinetuningを実施する方法を提案。WebNLG（graph-to-text）, ToTTo（table-to-text）, Multiwoz（task oriented dialogue）データにおいて、simpleなTransformerでも洗練されたmulti-stageなpipelined approachをoutperformできることを示した研究。

<br>



<br>



<br>



<br>

手法

<br>



<br>

事前学習済みのT5に対してfine-tuningを実施した。手法はシンプルで、data-to-textタスクをtext-to-textタスクに変換した。具体的には、構造かされたデータをflatな文字列（linearization）で表現することで、text-to-textタスクに変換。各データセットに対するlinearizationのイメージは下図。デリミタや特殊文字を使って構造かされたデータをflatなstringで表現している。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/191689155-3562f4f3-d1a1-4ea0-9d37-a523b78e8922.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

データセット

<br>



<br>

ToTTo（2020）

<br>



<br>

Wikipediaのテーブルと自然言語でdescriptionのペアデータ

<br>



<br>

MultiWoz（2018）

<br>



<br>

10Kの人間同士のtask-orientedなdialogueデータ。

<br>



<br>

WebNLG（2017）

<br>



<br>

subject-object-predicateの3組みをテキスト表現に変換するタスクのデータ

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/191693682-3cf3302f-b4e2-433d-94ed-995a8a908d0c.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Result

<br>



<br>

WebNLG

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/191694085-7bf7348a-b468-46e0-a900-c0090d1abcba.png" alt="image" loading="lazy">

<br>



<br>

GCNを利用した2020年に提案されたDualEncがSoTAだったらしいが、outperormしている。

<br>



<br>



<br>



<br>

ToTTo

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/191694683-f31ccad1-2936-4c21-ac10-0807a848f043.png" alt="image" loading="lazy">

<br>



<br>

[こちら](https://github.com/google-research-datasets/totto)のリーダーボードと比較してSoTAを記録

<br>



<br>



<br>



<br>

MultiWoz

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/191695459-e3397936-bdf7-4450-b4c2-6f6eead0825d.png" alt="image" loading="lazy">

<br>



<br>

T5は事前学習済みGPT-2をfinetuningした手法もoutperformした。SC-GPT2は当時のMultiWozでのSoTA

<br>



<br>



<br>



<br>

Impact of Model capacity

<br>



<br>

T5モデルのサイズがどれが良いかについては、データセットのサイズと複雑さに依存することを考察している。たとえば、MultiWozデータは構造化データのバリエーションが最も少なく、データ量も56kと比較的多かった。このため、T5-smallでもより大きいモデルの性能に肉薄できている。

<br>



<br>

一方、WebNLGデータセットは、18kしか事例がなく、特徴量も約200種類程度のrelationのみである。このような場合、モデルサイズが大きくなるにつれパフォーマンスも向上した（特にUnseen test set）。特にBLEUスコアはT5-smallがT5-baseになると、10ポイントもジャンプしており、modelのcapacityがout-of-domainに対する一般化に対してcriticalであることがわかる。ToTToデータセットでも、SmallからBaseにするとパフォーマンスは改善した。所感

<br>



<br>

こんな簡単なfine-tuningでSoTAを達成できてしまうとは、末恐ろしい。ベースラインとして有用。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<span class="issue_date">Issue Date: 2021-06-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/381">All Word Embeddings from One Embedding, Takase+, NeurIPS'20</a>
<span class="snippet"><span>Comment</span>NLPのためのNN-basedなモデルのパラメータの多くはEmbeddingによるもので、従来は個々の単語ごとに異なるembeddingをMatrixの形で格納してきた。この研究ではモデルのパラメータ数を減らすために、個々のword embeddingをshared embeddingの変換によって表現する手法ALONE(all word embeddings from one)を提案。単語ごとに固有のnon-trainableなfilter vectorを用いてshared embeddingsを修正し、FFNにinputすることで表現力を高める。また、filter vector普通に実装するとword embeddingと同じサイズのメモリを消費してしまうため、メモリ効率の良いfilter vector効率手法も提案している。機械翻訳・および文書要約を行うTransformerに提案手法を適用したところ、より少量のパラメータでcomparableなスコアを達成した。Embedidngのパラメータ数とBLEUスコアの比較。より少ないパラメータ数でcomparableな性能を達成している。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/121308824-700c3100-c93c-11eb-8d15-629d896f9db8.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/ConceptToTextGeneration.html">#ConceptToTextGeneration</a>
<a class="button" href="articles/DialogueGeneration.html">#DialogueGeneration</a>
<a class="button" href="articles/PersonalizedGeneration.html">#PersonalizedGeneration</a>
<span class="issue_date">Issue Date: 2021-06-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/367">NUBIA, EvalNLGEval'20</a>
<span class="snippet"><span>Comment</span>TextGenerationに関するSoTAの性能指標。BLEU, ROUGE等と比較して、人間との相関が高い。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/120425437-299d5c00-c3a9-11eb-9236-8bfdf494fa60.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/120425509-4e91cf00-c3a9-11eb-9666-dc1069cde3cc.png" alt="image" loading="lazy">

<br>



<br>

pretrainedされたlanguage model（GPT-2=sentence legibility, RoBERTa_MNLI=logical inference, RoBERTa_STS=semantic similarity）を使い、Fully Connected Layerを利用してquality スコアを算出する。算出したスコアは最終的にcalibrationで0~1の値域に収まるように補正される。意味的に同等の内容を述べた文間でのexample

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/120425803-d37ce880-c3a9-11eb-938c-09747999cc7c.png" alt="image" loading="lazy">

<br>



<br>

BLEU, ROUGE, BERTのスコアは低いが、NUBIAでは非常に高いスコアを出せている。</span>
<a class="button" href="articles/ReviewGeneration.html">#ReviewGeneration</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2021-03-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/343">Unsupervised Opinion Summarization as Copycat-Review Generation, Bražinskas, ACL'20</a>
<span class="snippet"><span>Summary</span>意見要約は、製品レビューから主観的情報を自動的に要約するタスクであり、従来の研究は抽出的手法に焦点を当てていたが、本研究では新しい文を生成する抽象的要約を提案する。教師なし設定での生成モデルを定義し、新規性を制御しながら合意された意見を反映する要約を生成する。階層的変分オートエンコーダモデルを用い、実験により流暢で一貫性のある要約が生成できることを示した。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2020-08-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/337">Evaluation of Text Generation: A Survey, Celikyilmaz, Clark, Gao, arXiv'20</a>
<span class="snippet"><span>Summary</span>本論文では、自然言語生成（NLG）システムの評価方法を人間中心、自動評価、機械学習に基づく評価の3カテゴリに分類し、それぞれの進展と課題を議論。特に新しいNLGタスクやニューラルNLGモデルの評価に焦点を当て、自動テキスト要約と長文生成の例を示し、今後の研究方向性を提案します。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<span class="issue_date">Issue Date: 2025-08-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2500">[Paper Note] Supervised Multimodal Bitransformers for Classifying Images and Text, Douwe Kiela+, arXiv'19</a>
<span class="snippet"><span>Summary</span>テキストと画像情報を融合する監視型マルチモーダルビットランスフォーマーモデルを提案し、さまざまなマルチモーダル分類タスクで最先端の性能を達成。特に、難易度の高いテストセットでも強力なベースラインを上回る結果を得た。</span>
<span class="snippet"><span>Comment</span>テキスト+imageを用いるシンプルなtransformer</span>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<a class="button" href="articles/ReadingComprehension.html">#ReadingComprehension</a>
<span class="issue_date">Issue Date: 2025-08-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2450">Natural Questions: A Benchmark for Question Answering Research, Kwiatkowski+, TACL'19</a>
<span class="snippet"><span>Summary</span>Natural Questionsコーパスは、Google検索エンジンからの実際の匿名化されたクエリを基にした質問応答データセットで、307,373のトレーニング例と7,830の開発例、7,842のテスト例が含まれています。アノテーターは、質問に対してWikipediaページから長い回答と短い回答を注釈し、質の検証実験や人間の変動性に関する分析を行っています。また、質問応答システムの評価のためのメトリクスを導入し、競争的手法を用いてベースライン結果を確立しています。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<span class="issue_date">Issue Date: 2025-08-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2357">[Paper Note] Deep Equilibrium Models, Shaojie Bai+, NeurIPS'19</a>
<span class="snippet"><span>Summary</span>深い平衡モデル（DEQ）を提案し、逐次データのモデル化において平衡点を直接見つけるアプローチを示す。DEQは無限の深さのフィードフォワードネットワークを解析的に逆伝播可能にし、定数メモリでトレーニングと予測を行える。自己注意トランスフォーマーやトレリスネットワークに適用し、WikiText-103ベンチマークでパフォーマンス向上、計算要件の維持、メモリ消費の最大88%削減を実証。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<span class="issue_date">Issue Date: 2024-10-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1446">What Does BERT Learn about the Structure of Language?, Jawahar+, ACL'19</a>
<span class="snippet"><span>Summary</span>BERTは言語理解において優れた成果を上げており、本研究ではその言語構造の要素を解明する実験を行った。主な発見は、フレーズ表現がフレーズレベルの情報を捉え、中間層が構文的および意味的特徴の階層を形成し、長期依存性の問題に対処するために深い層が必要であること、さらにBERTの構成が古典的な木構造に類似していることを示している。</span>
<span class="snippet"><span>Comment</span>1370 中で引用されている。Transformerの各ブロックが、何を学習しているかを分析。</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<span class="issue_date">Issue Date: 2024-04-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1272">Fast Transformer Decoding: One Write-Head is All You Need, Noam Shazeer, N_A, arXiv'19</a>
<span class="snippet"><span>Summary</span>マルチヘッドアテンションレイヤーのトレーニングは高速かつ簡単だが、増分推論は大きな"keys"と"values"テンソルを繰り返し読み込むために遅くなることがある。そこで、キーと値を共有するマルチクエリアテンションを提案し、メモリ帯域幅要件を低減する。実験により、高速なデコードが可能で、わずかな品質の低下しかないことが確認された。</span>
<span class="snippet"><span>Comment</span>Multi Query Attention論文。KVのsetに対して、単一のQueryのみでMulti-Head Attentionを代替する。劇的にDecoderのInferenceが早くなりメモリ使用量が減るが、論文中では言及されていない？ようだが、性能と学習の安定性が課題となるようである。

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/e2d77b43-70c3-4922-a822-bf95d6b4704f" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Extractive.html">#Extractive</a>
<span class="issue_date">Issue Date: 2023-08-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1022">Text Summarization with Pretrained Encoders, Liu+ （with Lapata）, EMNLP-IJCNLP'19</a>
<span class="snippet"><span>Summary</span>本研究では、最新の事前学習言語モデルであるBERTを使用して、テキスト要約のための一般的なフレームワークを提案します。抽出型モデルでは、新しいエンコーダを導入し、文の表現を取得します。抽象的な要約については、エンコーダとデコーダの最適化手法を異ならせることで不一致を緩和します。さらに、2段階のファインチューニングアプローチによって要約の品質を向上させました。実験結果は、提案手法が最先端の結果を達成していることを示しています。</span>
<span class="snippet"><span>Comment</span>BERTSUMEXT論文通常のBERTの構造と比較して、文ごとの先頭に[CLS]トークンを挿入し、かつSegment Embeddingsを文ごとに交互に変更することで、文のrepresentationを取得できるようにする。

<br>



<br>

その後、encodingされたsentenceの[CLS]トークンに対応するembeddingの上に、inter-sentence Transformer layerを重ね、sigmoidでスコアリングするのが、BERTSUMEXT, Abstractiveの場合は6-layerのTransformer decoderを利用するが、これはスクラッチでfinetuninigさせる。このとき、encoder側はoverfit, decoder側はunderfitすることが予想されるため、encoderとdecodeで異なるwarmup, 学習率を適用する。具体的には、encoder側はより小さい学習率で、さらにsmoothに減衰するようにする。これにより、decoder側が安定したときにより正確な勾配で学習できるようになる。また、2-stageのfinetuningを提案し、まずencoder側をextractifve summarization taskでfinetuningし、その後abstractive summarizationでfinetuningする。先行研究ではextractive summarizationのobjectiveを取り入れることでabstractive summarizationの性能が向上していることが報告されており、この知見を取り入れる。今回はextractive summarizationの重みをabstractive taskにtrasnferすることになる。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/957647e3-06e5-44cf-835e-bb25166872fd" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-08-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/996">Neural Text Summarization: A Critical Evaluation, Krysciski+ （w_ Richard Socher）, EMNLP-IJCNLP'19</a>
<span class="snippet"><span>Summary</span>テキスト要約の研究は進展が停滞しており、データセット、評価指標、モデルの3つの要素に問題があることが指摘されている。自動収集されたデータセットは制約が不十分であり、ノイズを含んでいる可能性がある。評価プロトコルは人間の判断と相関が弱く、重要な特性を考慮していない。モデルはデータセットのバイアスに過適合し、出力の多様性が限られている。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/QA-based.html">#QA-based</a>
<span class="issue_date">Issue Date: 2023-08-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/995">Question answering as an automatic evaluation metric for news article summarization, Eyal+, NAACL'19</a>
<span class="snippet"><span>Summary</span>最近の自動要約の研究では、ROUGEスコアの最大化に焦点を当てているが、本研究では代替的な評価指標であるAPESを提案する。APESは、要約が一連の手動作成質問に答える能力を定量化する。APESを最大化するエンドツーエンドのニューラル抽象モデルを提案し、ROUGEスコアを向上させる。</span>
<span class="snippet"><span>Comment</span>APES</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-08-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/990">Studying Summarization Evaluation Metrics in the Appropriate Scoring Range, Peyrard+, ACL'19</a>
<span class="snippet"><span>Summary</span>自動評価メトリックは通常、人間の判断との相関性を基準に比較されるが、既存の人間の判断データセットは限られている。現代のシステムはこれらのデータセット上で高スコアを出すが、評価メトリックの結果は異なる。高スコアの要約に対する人間の判断を収集することで、メトリックの信頼性を解決することができる。これは要約システムとメトリックの改善に役立つ。</span>
<span class="snippet"><span>Comment</span>要約のメトリックがhuman judgmentsに対してcorrelationが低いことを指摘</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/986">HighRES: Highlight-based Reference-less Evaluation of Summarization, Hardy+, N_A, ACL'19</a>
<span class="snippet"><span>Summary</span>要約の手動評価は一貫性がなく困難なため、新しい手法であるHighRESを提案する。この手法では、要約はソースドキュメントと比較して複数のアノテーターによって評価され、ソースドキュメントでは重要な内容がハイライトされる。HighRESはアノテーター間の一致度を向上させ、システム間の違いを強調することができることを示した。</span>
<span class="snippet"><span>Comment</span>人手評価の枠組み</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/TrainedMetrics.html">#TrainedMetrics</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/954">Machine Translation Evaluation with BERT Regressor, Hiroki Shimanaka+, N_A, arXiv'19</a>
<span class="snippet"><span>Summary</span>私たちは、BERTを使用した自動的な機械翻訳の評価メトリックを紹介します。実験結果は、私たちのメトリックがすべての英語対応言語ペアで最先端のパフォーマンスを達成していることを示しています。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-based.html">#Reference-based</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/946">MoverScore: Text Generation Evaluating with Contextualized Embeddings and Earth Mover Distance, Zhao+, EMNLP-IJCNLP'19</a>
<span class="snippet"><span>Summary</span>本研究では、テキスト生成システムの評価尺度について調査し、システムの出力と参照テキストの意味に基づいて比較する尺度を提案します。この尺度は、要約、機械翻訳、画像キャプション、データからテキストへの生成などのタスクで有効であり、文脈化表現と距離尺度を組み合わせたものが最も優れています。また、提案した尺度は強力な汎化能力を持っており、ウェブサービスとして提供されています。</span>
<span class="snippet"><span>Comment</span>Word Mover Distance (WMD)の解説: https://yubessy.hatenablog.com/entry/2017/01/10/122737</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-free.html">#Reference-free</a>
<a class="button" href="articles/QA-based.html">#QA-based</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/943">Answers Unite Unsupervised Metrics for Reinforced Summarization Models, Scialom+, EMNLP-IJCNLP'19</a>
<span class="snippet"><span>Summary</span>最近、再強化学習（RL）を使用した抽象的要約手法が提案されており、従来の尤度最大化を克服するために使用されています。この手法は、複雑で微分不可能なメトリクスを考慮することで、生成された要約の品質と関連性を総合的に評価することができます。ROUGEという従来の要約メトリクスにはいくつかの問題があり、代替的な評価尺度を探求する必要があります。報告された人間評価の分析によると、質問応答に基づく提案されたメトリクスはROUGEよりも有利であり、参照要約を必要としないという特徴も持っています。これらのメトリクスを使用してRLベースのモデルをトレーニングすることは、現在の手法に比べて改善をもたらします。</span>
<span class="snippet"><span>Comment</span>SummaQA</span>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<span class="issue_date">Issue Date: 2023-05-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/664">Towards Personalized Review Summarization via User-Aware Sequence Network, Li+, AAAI'19</a>
<span class="snippet"><span>Comment</span>同じレビューに対しても、異なるユーザは異なるSumamryを生成するよね、というところがモチベーションとなり、Personalized Review Summarizationを提案。初めてPersonalizationの問題について提案した研究。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236725073-bdcc6939-0582-4860-a20c-664e779d7a10.png" alt="image" loading="lazy">

<br>



<br>

user embeddingによってユーザ情報を埋め込む方法と、user vocabulary memoryによって、ユーザが好むvocabularyを積極的にsummaryに利用できるようなモジュールの2種類をモデルに導入している

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236726239-b5397c99-fcd9-4fde-8638-98ca44e23e15.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Trip advisorのレビューデータを収集。レビューのtitleをreference summaryとみなしてデータセット生成。ただタイトルを利用するだけだと、無意味なタイトルが多く含まれているでフィルタリングしている。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236726405-2a6c6c7f-fb32-4e7b-92c0-2380fbd86946.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Trip Advisorはクローリングを禁止していた気がするので、割とアウトなのでは。

<br>



<br>

あと、各レビューをランダムにsplitしてtrain/dev/testを作成したと言っているが、本当にそれでいいの？user-stratifiedなsplitをした方が良いと思う。

<br>



<br>



<br>



<br>

PGN 135 やlead-1と比較した結果、ROUGEの観点で高い性能を達成

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236726684-b85a20e7-0750-4d51-ad97-1603a9f944c5.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

また人手評価として、ユーザのgold summaryに含まれるaspectと、generated summaryに含まれるaspectがどれだけ一致しているか、1000件のreviewとtest setからサンプリングして2人の学生にアノテーションしてもらった。結果的に提案手法が最もよかったが、アノテーションプロセスの具体性が薄すぎる。2人の学生のアノテーションのカッパ係数すら書かれていない。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236727342-4548b5e6-ecda-4503-a628-6448a4bd39b7.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

case studyとしてあるユーザのレビュと生成例をのせている。userBの過去のレビューを見たら、room, locationに言及しているものが大半であり、このアスペクトをきちんと含められているよね、ということを主張している。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236727590-8a4972d1-f700-494c-9046-9f86769117c3.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/review.html">#review</a>
<span class="issue_date">Issue Date: 2023-05-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/658">Neural Review Summarization Leveraging User and Product Information, Liu+, CIKM'19</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Library.html">#Library</a>
<span class="issue_date">Issue Date: 2022-07-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/462">Sentence-BERT: Sentence Embeddings using Siamese BERT-Networks, Reimers+, UKP-TUDA, EMNLP'19</a>
<span class="snippet"><span>Comment</span>BERTでトークンをembeddingし、mean poolingすることで生成される文ベクトルを、Siamese Networkを使い距離学習（finetune）させたモデル。

<br>



<br>

<img width="655" alt="image" src="https://user-images.githubusercontent.com/12249301/181723384-06c1a65a-985a-48bd-b7d8-b284e070b675.png">

<br>



<br>



<br>



<br>

文/文章のベクトルを事前学習済みのモデルを使って簡単に求められる。

<br>



<br>

モデルの一覧は下記：https://www.sbert.net/docs/pretrained_models.html</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2021-10-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/408">Table-to-Text Generation with Effective Hierarchical Encoder on Three Dimensions （Row, Column and Time）, Gong+, Harbin Institute of Technology, EMNLP'19</a>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

既存研究では、tableをレコードの集合, あるいはlong sequenceとしてencodeしてきたが

<br>



<br>



<br>



<br>

1. other (column) dimensionの情報が失われてしまう (?)

<br>



<br>

2. table cellは時間によって変化するtime-series data

<br>



<br>



<br>



<br>

という特徴がある。

<br>



<br>

たとえば、ある選手の成績について言及する際に、その試合について着目するだけでなくて「直近3試合で二回目のダブルダブルです」というように直近の試合も考慮して言及することがあり、table cellの time dimensionについても着目しなければならず、これらはこれまでのモデルで実現できない。

<br>



<br>

そこで、この研究ではtime dimensionについても考慮し生成する手法を提案。

<br>



<br>



<br>



<br>

モデル概要

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/138917272-e920b08a-5f44-4e56-8f7e-d3eb3fab7ec3.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

全体としては、Row Dimension Encoder, Column Dimension Encoder, Time Dimension Encoderによって構成されており、self-attentionを利用して、テーブルの各セルごとに Row-Dimension, Column-Dimension, Time-DimensionのRepresentationを獲得する。イメージとしては、

<br>



<br>



<br>



<br>

・Row Dimension Encoderによって、自身のセルと同じ行に含まれるセルとの関連度を考慮した表現

<br>



<br>

・Column Dimension Encoderによって、自身のセルと同じ列に含まれるセルとの関連度を考慮した表現

<br>



<br>

・Time Dimension Encoderによって、過去の時系列のセルとの関連度を考慮した表現

<br>



<br>



<br>



<br>

をそれぞれ獲得するイメージ。各Dimension Encoderでやっていることは、Puduppully (394) らのContent Selection Gate節におけるattention vector r_{att}の取得方法と同様のもの（だと思われる）。

<br>



<br>



<br>



<br>

獲得したそれぞれのdimensionの表現を用いて、まずそれらをconcatし1 layer MLPで写像することで得られるgeneral representationを取得する。その後、general representationと各dimensionの表現を同様に1 layer MLPでスコアリングすることで、各dimensionの表現の重みを求め、その重みで各representationを線形結合することで、セルの表現を獲得する。generalなrepresentationと各dimensionの表現の関連性によって重みを求めることで、より着目すべきdimensionを考慮した上で、セルの表現を獲得できるイメージなのだろうか。

<br>



<br>

その後、各セルの表現を行方向に対してMeanPoolingを施しrow-levelの表現を取得。獲得したrow-levelの表現に対し、Puduppully (394) らのContent Selection Gate g を適用する（これをどうやっているかがわからない）。

<br>



<br>



<br>



<br>

最終的に求めたrow-levelの表現とcell-levelの表現に対して、デコーダのhidden stateを利用してDual Attentionを行い、row-levelの表現からどの行に着目すべきか決めた後、その行の中からどのセルに着目するか決める、といったイメージで各セルの重みを求める。

<br>



<br>

論文中にはここまでしか書かれていないが、求めた各セルの重みでセルのrepresentationを重み付けして足し合わせ、最終的にそこから単語をpredictionするのだろうか・・・？よくわからない。<img src="https://user-images.githubusercontent.com/12249301/140321786-4d6a91c4-c864-490e-9921-5e6018db35c7.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

RG, CS, CO, BLEUスコア、全てにおいてBaselineを上回っている（RGのTemplateを除く）。実装: https://github.com/ernestgong/data2text-three-dimensions/</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/AAAI.html">#AAAI</a>
<span class="issue_date">Issue Date: 2021-06-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/394">Data-to-Text Generation with Content Selection and Planning, Puduppully+, AAAI'19</a>
<span class="snippet"><span>Comment</span>Rotowire Datasetに対するData2Text研究において代表的な論文の一つ。Wisemanモデル 207 と共にベースラインとして利用されることが多い。実装: https://github.com/ratishsp/data2text-plan-py</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<span class="issue_date">Issue Date: 2021-06-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/388">On Empirical Comparisons of Optimizers for Deep Learning, Dami Choi+, N_A, arXiv'19</a>
<span class="snippet"><span>Summary</span>深層学習のオプティマイザの比較は重要であり、ハイパーパラメータの探索空間が性能に影響することが示唆されている。特に、適応的勾配法は常に他のオプティマイザよりも性能が低下しないことが実験で示されており、ハイパーパラメータのチューニングに関する実用的なヒントも提供されている。</span>
<span class="snippet"><span>Comment</span>SGD, Momentum,RMSProp, Adam,NAdam等の中から、どの最適化手法(Optimizer)が優れているかを画像分類と言語モデルにおいて比較した研究（下記日本語解説記事から引用）日本語での解説: https://akichan-f.medium.com/optimizerはどれが優れているか-on-empirical-comparisons-of-optimizers-for-deep-learningの紹介-f843179e8a8dAdamが良いのだけど、学習率以外のハイパーパラメータをチューニングしないと本来のパフォーマンス発揮されないかもよ、という感じっぽいICLR 2020 Open Review: https://openreview.net/forum?id=HygrAR4tPSOpenReview:https://openreview.net/forum?id=HygrAR4tPS</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/CommentGeneration.html">#CommentGeneration</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2019-09-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/323">Automatic Generation of Personalized Comment Based on User Profile, Zeng+, arXiv'19</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/CommentGeneration.html">#CommentGeneration</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2019-08-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/322">Coherent Comment Generation for Chinese Articles with a Graph-to-Sequence Model, Li+ ,ACL'19</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/ReviewGeneration.html">#ReviewGeneration</a>
<span class="issue_date">Issue Date: 2019-08-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/319">User Preference-Aware Review Generation, Wang+, PAKDD'19</a>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/ReviewGeneration.html">#ReviewGeneration</a>
<a class="button" href="articles/WWW.html">#WWW</a>
<span class="issue_date">Issue Date: 2019-08-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/318">Review Response Generation in E-Commerce Platforms with External Product Information, Zhao+, WWW'19</a>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/ReviewGeneration.html">#ReviewGeneration</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2019-08-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/316">Automatic Generation of Personalized Comment Based on User Profile, Zeng+, ACL'19 Student Research Workshop</a>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/ReviewGeneration.html">#ReviewGeneration</a>
<a class="button" href="articles/WWW.html">#WWW</a>
<span class="issue_date">Issue Date: 2019-05-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/313">Multimodal Review Generation for Recommender Systems, Truong+, WWW'19</a>
<span class="snippet"><span>Comment</span>Personalized Review Generationと、Rating Predictionを同時学習した研究（同時学習自体はすでに先行研究がある）。

<br>



<br>

また、先行研究のinputは、たいていはuser, itemであるが、multi-modalなinputとしてレビューのphotoを活用したという話。

<br>



<br>



<br>



<br>

まだあまりしっかり読んでいないが、モデルのstructureはシンプルで、rating predictionを行うDNN、テキスト生成を行うLSTM（fusion gateと呼ばれる新たなゲートを追加）、画像の畳み込むCNNのハイブリッドのように見える。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/DialogueGeneration.html">#DialogueGeneration</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2019-01-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/302">Training Millions of Personalized Dialogue Agents, Mazaré, ACL'19</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/ContextAware.html">#ContextAware</a>
<a class="button" href="articles/AAAI.html">#AAAI</a>
<span class="issue_date">Issue Date: 2019-01-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/300">Response Generation by Context-aware Prototype Editing, Wu+, AAAI'19</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/PositionalEncoding.html">#PositionalEncoding</a>
<span class="issue_date">Issue Date: 2025-08-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2386">[Paper Note] Self-Attention with Relative Position Representations, Peter Shaw+, NAACL'18</a>
<span class="snippet"><span>Summary</span>本研究では、Transformerの自己注意機構を拡張し、シーケンス要素間の相対的な位置を効率的に考慮する新しいアプローチを提案。WMT 2014の翻訳タスクで1.3 BLEUおよび0.3 BLEUの改善を達成。相対位置と絶対位置の組み合わせではさらなる改善は見られなかった。提案手法は、任意のグラフラベル付き入力に一般化可能な関係認識自己注意機構として位置付けられる。</span>
<span class="snippet"><span>Comment</span>相対位置エンコーディングを提案した研究絶対位置エンコーディングは

<br>

・245</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/TabularData.html">#TabularData</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/Encoder-Decoder.html">#Encoder-Decoder</a>
<span class="issue_date">Issue Date: 2025-08-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2367">Learning to Generate Move-by-Move Commentary for Chess Games from Large-Scale Social Forum Data, Jhamtani+, ACL'18</a>
<span class="snippet"><span>Comment</span>データセットの日本語解説（過去の自分の資料）:https://speakerdeck.com/akihikowatanabe/data-to-text-datasetmatome-summary-of-data-to-text-datasets?slide=66</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<span class="issue_date">Issue Date: 2025-08-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2353">[Paper Note] Efficient Attention: Attention with Linear Complexities, Zhuoran Shen+, arXiv'18</a>
<span class="snippet"><span>Summary</span>新しい効率的なアテンションメカニズムを提案し、ドット積アテンションと同等の性能を維持しつつ、メモリと計算コストを大幅に削減。これにより、アテンションモジュールの柔軟な統合が可能となり、精度向上を実現。実験結果では、MS-COCO 2017での物体検出やインスタンスセグメンテーションでの性能向上が確認され、Scene Flowデータセットでは最先端の精度を達成。コードは公開されている。</span>
<span class="snippet"><span>Comment</span>Figure1を見るとコンセプトが一目でわかり、非常にわかりやすい

<br>

<img width="1068" height="580" alt="Image" src="https://github.com/user-attachments/assets/18e6a7da-fc07-495f-bda6-bcef4acab321"></span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/QA-based.html">#QA-based</a>
<span class="issue_date">Issue Date: 2023-08-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/994">A Semantic QA-Based Approach for Text Summarization Evaluation, Ping Chen+, N_A, AAAI'18</a>
<span class="snippet"><span>Summary</span>自然言語処理システムの評価における問題の一つは、2つのテキストパッセージの内容の違いを特定することです。本研究では、1つのテキストパッセージを小さな知識ベースとして扱い、多数の質問を投げかけて内容を比較する方法を提案します。実験結果は有望であり、2007年のDUC要約コーパスを使用して行われました。</span>
<span class="snippet"><span>Comment</span>QGQAを提案した研究</span>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<a class="button" href="articles/ImageCaptioning.html">#ImageCaptioning</a>
<span class="issue_date">Issue Date: 2023-08-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/992">Object hallucination in image captioning, Rohbach+, EMNLP'18</a>
<span class="snippet"><span>Summary</span>現代の画像キャプションモデルは、オブジェクトの幻覚を生じる傾向がある。本研究では、新しい画像関連性の評価指標を提案し、モデルのアーキテクチャや学習目標が幻覚にどのように寄与するかを評価する。さらに、言語の先入観によるエラーが幻覚を引き起こすことも示された。</span>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/review.html">#review</a>
<span class="issue_date">Issue Date: 2023-05-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/652">A Hierarchical End-to-End Model for Jointly Improving Text Summarization  and Sentiment Classification, Shuming Ma+, N_A, arXiv'18</a>
<span class="snippet"><span>Summary</span>テキスト要約と感情分類を共同学習するための階層的なエンドツーエンドモデルを提案し、感情分類ラベルをテキスト要約の出力の「要約」として扱う。提案モデルはAmazonオンラインレビューデータセットでの実験で、抽象的な要約と感情分類の両方で強力なベースラインシステムよりも優れた性能を発揮することが示された。</span>
<span class="snippet"><span>Comment</span>review summarizationに初めてamazon online review data 653 使った研究？</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<span class="issue_date">Issue Date: 2022-06-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/457">Deep contextualized word representations, Peters+, Allen Institute for Artificial intelligence, NAACL'18</a>
<span class="snippet"><span>Comment</span>ELMo論文。

<br>

通常のword embeddingでは一つの単語につき一つの意味しか持たせられなかったが、文脈に応じて異なる意味を表現できるようなEmbeddingを実現し（同じ単語でも文脈に応じて意味が変わったりするので。たとえばrightは文脈に応じて右なのか、正しいなのか、権利なのか意味が変わる）様々な言語処理タスク（e.g. Question Answering, Sentiment Analysisなど）でSoTAを達成。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/172505957-a2fc5319-5670-4807-a870-31377227299e.png" alt="image" loading="lazy">

<br>



<br>

Embedding Layer + 2層のLSTM（1,2の間にはresidual connection）+ linear layerで言語モデルを構成し、順方向言語モデルと逆方向言語モデルを同時に独立して学習する（双方向LSTMではない;損失関数が両方向の言語モデルの対数尤度の和になっている）。

<br>

また、Linear LayerとEmbedding Layerのパラメータは両方向の言語モデルで共有されている。

<br>



<br>

k番目の単語のEmbedding Layerの出力ベクトル、各LSTMのhidden stateをタスクspecificなスカラーパラメタs_taskで足し合わせ、最後にベクトルのスケールを調整するパラメタγ_taskで大きさを調整する。これにより、k番目の単語のELMo Embeddingを得る。

<br>

単語単体の意味だけでこと足りるタスクの場合はEmbedding Layerの出力ベクトルに対する重みが大きくなり、文脈を考慮した情報が欲しい場合はLSTMのhidden stateに対する重みが大きくなるイメージ（LSTMの層が深いほど意味的semanticな情報を含み、浅いほど文法的syntacticな情報を含んでいる）。

<br>



<br>

使い方としては簡単で、ELMoを事前学習しておき、自身のNNモデルのWord Embeddingに（場合によってはRNNのhidden stateにも）、入力文から得られたELMo Embeddingをconcatして順伝搬させるだけで良い。s_taskとγ_taskはtrainableなパラメータで、

<br>

ELMoを適用した先のNNモデルの訓練時に、NNモデルのパラメタと一緒にチューニングする（と思われる）。

<br>



<br>

https://github.com/allenai/allennlp/issues/1166

<br>

https://github.com/allenai/allennlp/issues/2552ELMoのEmbedding Layerでは、2048 characterの（vocab size?）n-gram convolution filter（文字ごとにembeddingし、単語のembeddingを得るためにfilterを適用する？）の後に2つのhighway networkをかませてlinearで512次元に落とすみたいなことごやられているらしい。ここまで追えていない。

<br>



<br>

詳細は下記

<br>

https://datascience.stackexchange.com/questions/97867/how-does-the-character-convolution-work-in-elmo</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/COLING.html">#COLING</a>
<span class="issue_date">Issue Date: 2021-10-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/415">Point precisely: Towards ensuring the precision of data in generated texts using delayed copy mechanism., Li+, Peking University, COLING'18</a>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

DataToTextタスクにおいて、生成テキストのデータの精度を高める手法を提案。two stageアルゴリズムを提案。①encoder-decoerモデルでslotを含むテンプレートテキストを生成。②Copy Mechanismでslotのデータを埋める、といった手法。

<br>



<br>

①と②はそれぞれ独立に学習される。

<br>



<br>



<br>



<br>

two stageにするモチベーションは、

<br>



<br>

・これまでのモデルでは、単語の生成確率とコピー確率を混合した分布を考えていたが、どのように両者の確率をmergeするのが良いかはクリアではない。

<br>



<br>

→ 生成とコピーを分離して不確実性を減らした

<br>



<br>

・コピーを独立して考えることで、より効果的なpair-wise ranking loss functionを利用することができる

<br>



<br>

・テンプレート生成モデルは、テンプレートの生成に集中でき、slot fillingモデルはスロットを埋めるタスクに集中できる。これらはtrainingとtuningをより簡便にする。

<br>



<br>



<br>



<br>

モデル概要

<br>



<br>

モデルの全体像

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/138623391-6c876671-7c29-4d6a-8dfd-bd1feb623acd.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

オリジナルテキストとテンプレートの例。テンプレートテキストの生成を学習するencoder-decoder（①）はTarget Templateを生成できるように学習する。テンプレートではエンティティが"<entity>"、数値が"<number>"というplace holderで表現されている。これらのスロットを埋めるDelayed Copy Networkは、スロットが正しく埋められるように学習される。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/138623460-1415e0c2-2468-4c05-a8b8-685001c26bb7.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

実験結果

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/138624623-2f8944f5-8a7c-4de5-bbb8-cda9626e7018.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Relation Generation (RG)がCCと比べて10%程度増加しているので、data fidelityが改善されている。

<br>



<br>

また、BLEUスコアも約2ポイント改善。これはentityやnumberが適切に埋められるようになっただけでなく、テンプレートがより適切に生成されているためであると考えられる。

<br>



<br>



<br>



<br>

参考：

<br>



<br>

• Relation Generation (RG)：出力文から(entity, value)の関係を抽出し，抽出された関係の数と，それらの関係が入力データに対して正しいかどうかを評価する (Precision)．ただし entity はチーム名や選手名などの動作の主体，value は得点数やアシスト数などの記録である．

<br>



<br>

• Content Selection (CS)：出力文とリファレンスから (entity, value) の関係を抽出し，出力文から抽出された関係のリファレンスから抽出された関係に対する Precision，Recall で評価する．

<br>



<br>

• Content Ordering (CO)：出力文とリファレンスから (entity, value) の関係を抽出し，それらの間の正規化 DamerauLevenshtein 距離 [7] で評価する．

<br>



<br>

(from 409 )&lt;/span&gt;
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2021-09-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/406">Operation-guided Neural Networks for High Fidelity Data-To-Text Generation, Nie+, Sun Yat-Sen University, EMNLP'18</a>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

既存のニューラルモデルでは、生データ、あるいはそこから推論された事実に基づいて言語を生成するといったことができていない（e.g. 金融, 医療, スポーツ等のドメインでは重要）。

<br>



<br>

たとえば下表に示した通り、"edge"という単語は、スコアが接戦（95-94=1 -&gt; スコアの差が小さい）であったことを表現しているが、こういったことを既存のモデルでは考慮して生成ができない。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/138627286-c9bde402-0129-4b82-9faf-80fcde08cdc8.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

これを解決するために、演算（operation）とニューラル言語モデルを切り離す（事前に計算しておく）といったことが考えられるが、

<br>



<br>

① 全てのフィールドに対してoperationを実行すると、探索空間が膨大になり、どの結果に対して言及する価値があるかを同定するのが困難（言及する価値がある結果がほとんど存在しない探索空間ができてしまう）

<br>



<br>

② 演算結果の数値のスパンと、言語選択の対応関係を確立させるのが困難（e.g. スコアの差が1のとき"edge"と表現する、など）

<br>



<br>

といった課題がある。

<br>



<br>



<br>



<br>

①に対処するために、事前にraw dataに対して演算を適用しその結果を利用するモデルを採用。どの演算結果を利用するかを決定するために、gating-mechanismを活用する。

<br>



<br>

②に対処するために、quantization layerを採用し、演算結果の数値をbinに振り分け、その結果に応じて生成する表現をguideするようなモデルを採用する。

<br>



<br>



<br>



<br>

モデル概要

<br>



<br>

モデルはrecord encoder(h_{i}^{ctx}を作る)、operation encoder(h_{i}^{op}を作る)、operation result encoder(h_{i}^{res}を作る)によって構成される。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/138628639-0c64d7aa-22e7-4ee7-a55f-65736e607ed2.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

record encoder

<br>



<br>

record encoderは、wisemanらと同様に、index (e.g. row 2), column (e.g. column Points), value (e.g. 95)のword embeddingを求め、それらをconcatしたものをbi-directional RNNに入力し求める。

<br>



<br>



<br>



<br>

operation encoder

<br>



<br>

operation encoderでは、operation op_{i}は、1) operationの名称 (e.g. minus) 2) operationを適用するcolumn (e.g. Points), 3) operationを適用するrow (e.g. {1, 2}などのrow indexの集合)によって構成されており、これらのembeddingをlookupしconcatした後、non-linear layerで変換することによってoperationのrepresentationを取得する。3)operationを適用するrowについては、複数のindexによって構成されるため、各indexのembeddingをnon-linear layerで変換したベクトルを足し合わせた結果に対してtanhを適用したベクトルをembeddingとして利用する。

<br>



<br>



<br>



<br>

operation result encoder

<br>



<br>

operation result encoderは、scalar results（minus operationにより-1）およびindexing results (argmax operationによりindex 2)の二種類を生成する。これら二種類に対して異なるencoding方法を採用する。

<br>



<br>

scalar results

<br>



<br>

scalar resultsに対しては、下記式でscalar valueをquantization vector（q_{i}）に変換する。qutization vectorのlengthはLとなっており、Lはbinの数に相当している。つまり、quantization vectorの各次元がbinの重みに対応している。その後、quantization vectorに対してsoftmaxを適用し、quantization unit（quantization vectorの各次元）の重みを求める。最後に、quantization embeddingと対応するquantization unitの重み付き平均をとることによってh_{i}^{res}を算出する。

<br>



<br>



<br>



<br>

Q. 式を見るとW_{q}がscalar resultの値によって定数倍されるだけだから、softmaxによって求まるquantization unitの重みの序列はscalar resultによって変化しなそうに見えるが、これでうまくいくんだろうか・・・？序列は変わらなくても各quantization unit間の相対的な重みの差が変化するから、それでうまくscalar値の変化を捉えられるの・・・か・・・？

<br>



<br>



<br>



<br>

indexing results

<br>



<br>

indexing resultsについては、h_{i}^{res}をシンプルにindexのembeddingとする。

<br>



<br>



<br>



<br>

Decoder

<br>



<br>

context vectorの生成方法が違う。従来のモデルと比較して、context vectorを生成する際に、レコードをoperationの両方をinputとする。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/138632508-f9407ff9-3e8a-4efd-91d4-6879e81331a6.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

operationのcontext vector c_{t}^{op}とrecordsのcontext vector c_{t}^{ctx}をdynamic gate λ_{t}によって重み付けし最終的なcontext vectorを求める。λ_{t}は、t-1時点でのデコーダのhidden stateから重みを求める。

<br>



<br>

c_{t}^{op}は次式で計算され：

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/138633048-ca82ff5f-9755-4e5f-a658-774354cde987.png" alt="image" loading="lazy">

<br>



<br>

c_{t}^{scl, idx}は、

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/138633078-f74de4b3-f742-48f9-9f29-64489f8f477a.png" alt="image" loading="lazy">

<br>



<br>

よって計算される。要は、decoderのt-1のhidden stateと、operation vectorを用いて、j番目のoperationの重要度（β）を求め、operationの重要度によって重み付けしてoperation result vectorを足し合わせることによって、context vectorを算出する。

<br>



<br>

また、recordのcontext vector c_{t}^{ctx}は、h_{j}^{res}とh_{j}^{op}と、h_{j}^{ctx}に置き換えることによって算出される。 

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/138631847-e3076003-b619-49e4-afad-0edffaace060.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

データセット

<br>



<br>

人手でESPN, ROTOWIRE, WIKIBIOデータセットのReferenceに対して、factを含むtext spanと、そのfactの種類を3種類にラベル付した。input factsはinput dataから直接見つけられるfact, inferred factsはinput dataから直接見つけることはできないが、導き出すことができるfact、unsupported factsはinput dataから直接あるいは導き出すことができないfact。wikibioデータセットはinferred factの割合が少ないため、今回の評価からは除外し、ROTOWIRE, ESPNを採用した。特にESPNのheadline datasetがinferred factsが多かった。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/138636048-4b8225f7-f685-45b9-ae06-1af57e09044d.png" alt="image" loading="lazy">結果

<br>



<br>

自動評価

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/138634010-2de062dc-d2dc-48af-8724-f6fa950e8144.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

wiseman modelをOpAttがoutperformしている。また、Seq2Seq+op+quant（Seq2Seq+copyに対してoperation result encoderとquantization layerを適用したもの）はSeq2Seq+Copyを上回っているが、OpAttほとではないことから、提案手法のoperation encoderの導入とgating mechanismが有効に作用していることがわかる。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/138635201-462ef128-58d1-4084-ae70-5acccd34087b.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

採用するoperationによって、生成されるテキストも異なるようになっている。

<br>



<br>



<br>



<br>

人手評価

<br>



<br>

3人のNBAに詳しいEnglish native speakerに依頼してtest dataに対する生成結果にアノテーションをしてもらった。アノテーションは、factを含むspanを同定し、そのfactがinput facts/inferred facts/unsupported factsのどれかを分類してもらった。最後に、そのfactが入力データからsupportされるかcontradicted（矛盾するか）かをアノテーションしてもらった。

<br>



<br>

提案手法が、より多くのinferred factsについて言及しながらも、少ないCont.であることがわかった。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/138636756-74da3999-45e7-489f-9d0a-ac68416d3de0.png" alt="image" loading="lazy">

<br>



<br>

分析

<br>



<br>

Quantizationの効果

<br>



<br>

チーム間のスコアの差が、5つのbinのに対してどれだけの重みを持たせたかのheatmap。似たようなスコアのgapの場合は似たような重みになることがわかる。ポイント差の絶対値が小さい場合は、重みの分布の分散が大きくなるのでより一般的な単語で生成を行うのに対し、絶対値が大きい場合は分散が小さくなるため、unique wordをつかって生成するようになる。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/138637300-04738ba9-8e5f-4b07-8ed2-1a62c14cb7fe.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

pointのgapの大きさによって利用される単語も変化していることがわかる。ポイント差がちいさいときは"edge"、大きいときは"blow out"など。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/138637614-19a95fba-9904-4378-86d0-3d1bd513be8a.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

gating mechanismの効果

<br>



<br>

生成テキストのtimestepごとのgateの重みの例。色が濃ければ濃いほど、operation resultsの情報を多く利用していることを表す。チームリーダーを決める際や（horford）勝者を決める際に(Hawks)、operation resultsの重みが大きくなっており、妥当な重み付けだと考察している。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/138637813-4b4a2b1d-c5c5-4f7a-96b3-59df3a56aeb2.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/CommentGeneration.html">#CommentGeneration</a>
<a class="button" href="articles/WWW.html">#WWW</a>
<span class="issue_date">Issue Date: 2019-08-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/321">Netizen-Style Commenting on Fashion Photos: Dataset and Diversity Measures, Lin+, WWW'18</a>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/ReviewGeneration.html">#ReviewGeneration</a>
<a class="button" href="articles/RecSys.html">#RecSys</a>
<span class="issue_date">Issue Date: 2019-08-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/317">Improving Explainable Recommendations with Synthetic Reviews, Ouyang+, RecSys'18</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/ReviewGeneration.html">#ReviewGeneration</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2019-04-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/306">Personalized Review Generation by Expanding Phrases and Attending on Aspect-Aware Representations, Ni+, ACL'18</a>
<span class="snippet"><span>Comment</span><img src="https://user-images.githubusercontent.com/12249301/56010165-8fd44a00-5d1d-11e9-8cad-81a5178d95d2.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Personalized Review Generationタスクを、user, item, short phraseがgivenな時に、それを考慮して完全なレビューを生成するタスクとして定義。

<br>



<br>

short phraseとしては、item titleやreview summaryなどを利用している。

<br>



<br>

アイテムのaspectを考慮してレビューを生成できる点が新しい。

<br>



<br>

モデルとしては、aspect-awareなrepresentationを学習することによって、ユーザ・アイテムのaspectに関する嗜好（e.g. どの部分について言及したいか、など）を捉えたレビューを生成できるようにしている。

<br>



<br>

各aspectには代表的な単語が紐づいており、aspectに紐づく単語の生成確率をaspect-aware representationから求めたattentionによって制御し、生成時に下駄を履かせている。PyTorch実装：https://github.com/nijianmo/textExpansion/tree/master/expansionNet</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/AAAI.html">#AAAI</a>
<span class="issue_date">Issue Date: 2019-01-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/301">A Knowledge-Grounded Neural Conversation Model, Ghazvininejad+, AAAI'18, </a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/AAAI.html">#AAAI</a>
<span class="issue_date">Issue Date: 2018-10-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/277">A Unified Model for Document-Based Question Answering Based on Human-Like Reading Strategy, Li+, AAAI'18</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/ReviewGeneration.html">#ReviewGeneration</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2018-07-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/276">Personalized Review Generation by Expanding Phrases and Attending on Aspect-Aware Representations, Ni+, ACL'18</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/NAACL.html">#NAACL</a>
<span class="issue_date">Issue Date: 2018-06-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/273">Newsroom: A Dataset of 1.3 Million Summaries with Diverse Extractive Strategies, Max+, NAACL'18</a>
<span class="snippet"><span>Comment</span>文書要約に使用可能なデータセット

<br>



<br>

38の出版元からデータを収集し、サイズは1.3M article程度

<br>



<br>

既存のデータセットと比較すると、Coverageが高く生成的なものを多く含むことが特徴

<br>



<br>

詳細は：https://summari.es</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/DialogueGeneration.html">#DialogueGeneration</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2018-02-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/255">Personalizing Dialogue Agents: I have a dog, do you have pets too?, Zhang+, ACL'18</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Supervised.html">#Supervised</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Abstractive.html">#Abstractive</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/134">A Deep Reinforced Model for Abstractive Summarization, Paulus+（with Socher）, ICLR'18</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/TACL.html">#TACL</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/92">Generating Sentences by Editing Prototypes, Guu+, TACL'18</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/ConceptToTextGeneration.html">#ConceptToTextGeneration</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/84">Survey of the State of the Art in Natural Language Generation: Core tasks, applications and evaluation, Gatt+, JAIR'18</a>
<span class="snippet"><span>Comment</span>割と新し目のNLGのSurvey</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<a class="button" href="articles/ReadingComprehension.html">#ReadingComprehension</a>
<span class="issue_date">Issue Date: 2025-08-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2449">[Paper Note] TriviaQA: A Large Scale Distantly Supervised Challenge Dataset for   Reading Comprehension, Mandar Joshi+, ACL'17</a>
<span class="snippet"><span>Summary</span>TriviaQAは、650K以上の質問-回答-証拠トリプルを含む読解理解データセットで、95Kの質問-回答ペアと平均6つの証拠文書を提供。複雑な質問や構文的変動があり、文を超えた推論が必要。特徴ベースの分類器と最先端のニューラルネットワークの2つのベースラインアルゴリズムを評価したが、人間のパフォーマンスには及ばず、TriviaQAは今後の研究における重要なテストベッドである。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2025-04-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1911">Outrageously Large Neural Networks: The Sparsely-Gated  Mixture-of-Experts Layer, Noam Shazeer+, ICLR'17</a>
<span class="snippet"><span>Summary</span>条件付き計算を用いたスパースゲーテッドミクスチャーオブエキスパート（MoE）レイヤーを導入し、モデル容量を1000倍以上向上。学習可能なゲーティングネットワークが各例に対してスパースなエキスパートの組み合わせを決定。最大1370億パラメータのMoEをLSTM層に適用し、言語モデリングや機械翻訳で低コストで優れた性能を達成。</span>
<span class="snippet"><span>Comment</span>Mixture-of-Experts (MoE) Layerを提案した研究</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-08-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/989">Why We Need New Evaluation Metrics for NLG, EMNLP'17</a>
<span class="snippet"><span>Summary</span>NLGの評価には自動評価指標が使われているが、本研究ではシステムやデータに依存しない新しい評価手法の必要性を提案する。幅広い指標を調査し、それらがデータ駆動型のNLGによって生成されたシステムの出力の人間の判断を弱く反映していることを示す。また、評価指標の性能はデータとシステムに依存することも示すが、自動評価指標はシステムレベルで信頼性があり、システムの開発をサポートできることを示唆する。特に、低いパフォーマンスを示すケースを見つけることができる。</span>
<span class="snippet"><span>Comment</span>既存のNLGのメトリックがhuman judgementsとのcorrelationがあまり高くないことを指摘した研究</span>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/STS%20(SemanticTextualSimilarity).html">#STS (SemanticTextualSimilarity)</a>
<span class="issue_date">Issue Date: 2023-07-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/909">Construction of a Japanese Word Similarity Dataset, Yuya Sakaizawa+, N_A, arXiv'17</a>
<span class="snippet"><span>Summary</span>日本語の分散表現の評価のために、日本語の単語の類似性データセットを構築した。このデータセットは、日本語の分散表現の評価に使用できる初めてのリソースであり、一般的な単語だけでなく珍しい単語も含まれている。</span>
<span class="snippet"><span>Comment</span>github: https://github.com/tmu-nlp/JapaneseWordSimilarityDataset

<br>



<br>



<br>



<br>

単語レベルの類似度をベンチマーキングしたい場合は使ってもよいかも。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/CommentGeneration.html">#CommentGeneration</a>
<a class="button" href="articles/CVPR.html">#CVPR</a>
<span class="issue_date">Issue Date: 2019-09-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/327">Attend to You: Personalized Image Captioning with Context Sequence Memory Networks, Park+, CVPR'17</a>
<span class="snippet"><span>Comment</span>画像が与えられたときに、その画像に対するHashtag predictionと、personalizedなpost generationを行うタスクを提案。

<br>



<br>

InstagramのPostの簡易化などに応用できる。

<br>



<br>

Postを生成するためには、自身の言葉で、画像についての説明や、contextといったことを説明しなければならず、image captioningをする際にPersonalization Issueが生じることを指摘。

<br>



<br>



<br>



<br>

official implementation: https://github.com/cesc-park/attend2u</span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/ReviewGeneration.html">#ReviewGeneration</a>
<a class="button" href="articles/SIGIR.html">#SIGIR</a>
<span class="issue_date">Issue Date: 2019-04-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/309">Neural rating regression with abstractive tips generation for recommendation, Li+, SIGIR'17</a>
<span class="snippet"><span>Comment</span>Rating Predictionとtips generationを同時に行うことで、両者の性能を向上させた最初の研究。

<br>



<br>

tipsとは、ユーザの経験や感じたことを、短いテキスト（1文とか）で簡潔に記したもの。<img src="https://user-images.githubusercontent.com/12249301/56012618-43423c00-5d28-11e9-82ff-fe90c9dd7d1c.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

モデルについてはあまりく詳しく読んでいないが、図を見る感じ、user latent factorとitem latent factorをMF layerとseq2seqで共有し、同時学習させていると思われる。

<br>



<br>

おそらく、MFとtext generationをjointで行うNNモデルはこの研究が初めて（textの情報をMFの改善に使おうという試みは古くからやられているが、generationまでは多分やってない）で、このモデル化の仕方がその後のスタンダードになっている。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/ReviewGeneration.html">#ReviewGeneration</a>
<a class="button" href="articles/INLG.html">#INLG</a>
<span class="issue_date">Issue Date: 2019-04-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/307">Towards automatic generation of product reviews from aspectsentiment scores, Zang+, INLG'17</a>
<span class="snippet"><span>Comment</span>hierarchicalなNNで、long reviewの生成に取り組んだ論文</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/ReviewGeneration.html">#ReviewGeneration</a>
<a class="button" href="articles/EACL.html">#EACL</a>
<span class="issue_date">Issue Date: 2019-03-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/305">Learning to Generate Product Reviews from Attributes, Dong+, EACL'17</a>
<span class="snippet"><span>Comment</span>（たぶん）最初のreview generation論文</span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/CollaborativeFiltering.html">#CollaborativeFiltering</a>
<a class="button" href="articles/ReviewGeneration.html">#ReviewGeneration</a>
<a class="button" href="articles/IJCNLP.html">#IJCNLP</a>
<span class="issue_date">Issue Date: 2019-02-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/303">Estimating Reactions and Recommending Products with Generative Models of Reviews, Ni+, IJCNLP'17</a>
<span class="snippet"><span>Comment</span>Collaborative Filtering (CF) によるコンテンツ推薦とReview Generationを同時に学習し、

<br>



<br>

両者の性能を向上させる話。

<br>



<br>

非常に興味深い設定で、このような実験設定でReview Generationを行なった初めての研究。CFではMatrix Factorization (MF) を利用し、Review Generationでは、LSTM-basedなseq2seqを利用する。MFとReview Generationのモデルにおいて、共通のuser latent factorとitem latent factorを利用することで、joint modelとしている。このとき、latent factorは、両タスクを通じて学習される。

<br>



<br>



<br>



<br>

CFでは、Implicitな設定なので、Rating Predictionではなく、binary classificationを行うことで、推薦を行う。

<br>



<br>

classificationには、Matrix Factorization (MF) を拡張したモデルを用いる。

<br>



<br>

具体的には、通常のMFでは、user latent factorとitem latent factorの内積によって、userのitemに対するpreferenceを表現するが、このときに、target userが過去に記載したレビュー・およびtarget itemに関する情報を利用する。レビューのrepresentationのaverageをとったvectorと、MFの結果をlinear layerによって写像し、最終的なclassification scoreとしている。

<br>



<br>



<br>



<br>

Review Generationでは、基本的にはseq2seqのinputのEmbeddingに対して、user latent factor, item latent factorをconcatするだけ。hidden stateに直接concatしないのは、latent factorを各ステップで考慮できるため、long, coherentなsequenceを生成できるから、と説明している。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/56011945-15a7c380-5d25-11e9-9a0d-8835bdb6cbed.png" alt="image" loading="lazy">

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/56012061-9c5ca080-5d25-11e9-9327-2c7a9c3ee365.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Recommendタスクにおいては、Bayesian Personalized Ranking, Generalized Matrix Factorizationをoutperform。<img src="https://user-images.githubusercontent.com/12249301/56012129-f65d6600-5d25-11e9-919a-33018878f96e.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Review GenerationはPerplexityにより評価している。提案手法がcharacter based lstmをoutperform。

<br>



<br>

Perplexityによる評価だと言語モデルとしての評価しかできていないので、BLEU, ROUGEなどを利用した評価などもあって良いのでは。</span>
<a class="button" href="articles/Multi.html">#Multi</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/VariationalAutoEncoder.html">#VariationalAutoEncoder</a>
<a class="button" href="articles/AAAI.html">#AAAI</a>
<span class="issue_date">Issue Date: 2018-10-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/278">Salience Estimation via Variational Auto-Encoders for Multi-Document Summarization, Li+, AAAI'17</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2018-06-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/275">Learning to Paraphrase for Question Answering, Dong+, EMNLP'17</a>
<span class="snippet"><span>Comment</span>question-answeringタスクにおいて、paraphrasingを活用して精度向上させる研究

<br>



<br>

似たような意味の質問が、異なる表現で出現することがあるので、

<br>



<br>

questionの様々なparaphrasingを用意して活用したいという気持ち。

<br>



<br>

たとえば、

<br>



<br>



<br>



<br>

・Is the campus far from Shibuya?

<br>



<br>

・Is the campus near the city center?

<br>



<br>



<br>



<br>

のような例があげられる。

<br>



<br>



<br>



<br>

手法としては、paraphrasing modelとqa modelを用意し、あるquestionが与えられたときに、paraphrasing modelでparaphraseのスコアを算出、その後、各paraphrasingの候補に対してqa modelで解答を予測し、両者のスコアの積のsummationによって最終的なanswerを決定QAはデータセットのサイズが小さいので、paraphrasingのような手法が有効に働いているのかもしれない</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<span class="issue_date">Issue Date: 2018-02-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/248">Recent Trends in Deep Learning Based Natural Language Processing, Young+, arXiv'17</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/GenerativeAdversarialNetwork.html">#GenerativeAdversarialNetwork</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<span class="issue_date">Issue Date: 2018-02-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/247">Adversarial Ranking for Language Generation, Lin+, NIPS'17</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/PositionalEncoding.html">#PositionalEncoding</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2018-01-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/245">Attention is all you need, Vaswani+, NIPS'17</a>
<span class="snippet"><span>Comment</span>Transformer (self-attentionを利用) 論文

<br>



<br>

解説スライド：https://www.slideshare.net/DeepLearningJP2016/dlattention-is-all-you-need

<br>



<br>

解説記事：https://qiita.com/nishiba/items/1c99bc7ddcb2d62667c6

<br>



<br>



<br>



<br>

 新しい翻訳モデル(Transformer)を提案。既存のモデルよりも並列化に対応しており、短時間の訓練で（既存モデルの1/4以下のコスト）高いBLEUスコアを達成した。

<br>



<br>

 TransformerはRNNやCNNを使わず、attentionメカニズムに基づいている。

<br>



<br>



<br>



<br>

（解説より）分かりやすい:

<br>

https://qiita.com/halhorn/items/c91497522be27bde17ceTransformerの各コンポーネントでのoutputのshapeや、attention_maskの形状、実装について記述されており有用:

<br>

https://qiita.com/FuwaraMiyasaki/items/239f3528053889847825集合知</span>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Discourse.html">#Discourse</a>
<a class="button" href="articles/ICWSM.html">#ICWSM</a>
<span class="issue_date">Issue Date: 2018-01-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/244">Characterizing Online Discussion Using Coarse Discourse Sequences, Zhang+, ICWSM'17, （Reddit Coarse Discourse data）</a>
<span class="snippet"><span>Comment</span>RedditのDiscussion Forumに9種類のDiscourse Actsを付与したデータ。

<br>



<br>



<br>



<br>

データを作成する際は、以下の処理を適用：

<br>



<br>

 Google Big Query dump のRedditデータ238Mスレッド

<br>



<br>

 それにReply Filterをかけ87.5Mスレッド

<br>



<br>

 さらにそこからスレッドサンプリングやヒューリスティクなフィルタをかけて10000スレッドに絞り込んだ

<br>



<br>

 これらにDiscourse Actsが付与されており、それぞれのコメントに対して9種類のカテゴリ（QUESTION（質問）, ANSWER（回答）, ANNOUNCEMENT（情報発信）, AGREEMENT（意見に対する同意, APPRECIATION （感謝）など）が付与されている。

<br>



<br>



<br>



<br>

コーパスを作成するときは、3人のアノテータを用い、複数のACTを付与することを許し、OTHERも許容。

<br>



<br>

Discourse Actsをどれだけ判定できるかのモデルも構築しており、loggistic regression + L2 regularization, Hidden Markov Model, Conditional Random Fieldsなどを用い、素性はContent-based (unigram, bigram, tf-idfなど), Structure-based (treeのdepth, of sentencde, wordなど), Author-based (一番最初の投稿者と同じか、親と同じ投稿者かなど), Community (subreddit name (カテゴリ名))などを用いている。

<br>



<br>



<br>



<br>

CRFを適用する際は、スレッドのTreeのブランチを系列とみなす。基本的にCRFが一番よく、F値で0.75程度。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<span class="issue_date">Issue Date: 2018-01-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/234">ゼロから始める ニューラルネットワーク機械翻訳, 中澤敏明, NLP'17</a>
<span class="snippet"><span>Comment</span>中澤さんによるNMTチュートリアル。</span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2018-01-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/211">MoodSwipe: A Soft Keyboard that Suggests Messages Based on User-Specified Emotions, Huang+, EMNLP'17</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/UserModeling.html">#UserModeling</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2018-01-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/210">Multi-View Unsupervised User Feature Embedding for Social Media-based Substance Use Prediction, Ding+, EMNLP'17</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/Supervised.html">#Supervised</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2018-01-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/209">Coarse-to-Fine Attention Models for Document Summarization, Ling+ （with Rush）, ACL'17 Workshop on New Frontiers in Summarization</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2018-01-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/208">Adapting Sequence Models for Sentence Correction, Schmaltz （with Rush）, EMNLP'17</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2018-01-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/207">Challenges in Data-to-Document Generation, Wiseman+ （with Rush）, EMNLP'17</a>
<span class="snippet"><span>Comment</span>・RotoWire（NBAのテーブルデータ + サマリ）データを収集し公開

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/119625430-23f1c480-be45-11eb-8ff8-5e9223d41481.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

・Rotowireデータの統計量

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/119625488-323fe080-be45-11eb-952e-d2d21d6e5847.png" alt="image" loading="lazy">【モデルの概要】

<br>



<br>

・attention-based encoder-decoder model

<br>



<br>



<br>



<br>

・BaseModel

<br>



<br>

　・レコードデータ r の各要素（r.e: チーム名等のENTITY r.t: POINTS等のデータタイプ, r.m: データのvalue）からembeddingをlookupし、1-layer MLPを適用し、レコードの各要素のrepresentation（source data records）を取得

<br>



<br>

　・Luongらのattentionを利用したLSTM Decoderを用意し、source data recordsとt-1ステップ目での出力によって条件付けてテキストを生成していく

<br>



<br>

　・negative log likelihoodがminimizeされるように学習する

<br>



<br>



<br>



<br>

・Copying

<br>



<br>

　・コピーメカニズムを導入し、生成時の確率分布に生成テキストを入力からコピーされるか否かを含めた分布からテキストを生成。コピーの対象は、入力レコードのvalueがコピーされるようにする。

<br>



<br>

　・コピーメカニズムには下記式で表現される Conditional Copy Modelを利用し、p(zt|y1:t-1, s)はMLPで表現する。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/119628147-cc088d00-be47-11eb-84de-6a1d158d78e5.png" alt="image" loading="lazy">

<br>



<br>

　・またpcopyは、生成している文中にあるレコードのエンティティとタイプが出現する場合に、対応するvalueをコピーし生成されるように、下記式で表現する

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/119628389-07a35700-be48-11eb-9c69-27b70fcbcdef.png" alt="image" loading="lazy">

<br>



<br>

　・ここで r(yt) =

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/119628615-39b4b900-be48-11eb-9305-509a6eed8182.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2018-01-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/146">Why We Need New Evaluation Metrics for NLG, Novikova+, EMNLP'17</a>
<span class="snippet"><span>Comment</span>解説スライド：https://www.dropbox.com/s/7o8v64nr6gyj065/20170915_SNLP2017_Nishikawa.pptx?dl=0言語生成の評価指標が信用ならないので、3種類の生成器、3種類のデータを用意し、多数の自動評価尺度を利用した評価結果と人手評価の結果を比較した結果、相関がなかった。

<br>



<br>



<br>



<br>

既存の自動評価は人手評価と弱い相関しかなく、その有効性はデータとドメインに依存。

<br>



<br>

システム間の比較およびシステムの性能が低い場合においては有効。

<br>



<br>



<br>



<br>

(2025.05.12)

<br>

解説スライド中のスライドが複数掲載されていましたが削除しました。</span>
<a class="button" href="articles/Single.html">#Single</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/Supervised.html">#Supervised</a>
<a class="button" href="articles/Abstractive.html">#Abstractive</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/135">Get To The Point: Summarization with Pointer-Generator Networks, See+, ACL'17</a>
<span class="snippet"><span>Comment</span>解説スライド：https://www.slideshare.net/akihikowatanabe3110/get-to-the-point-summarization-with-pointergenerator-networks/1単語の生成と単語のコピーの両方を行えるハイブリッドなニューラル文書要約モデルを提案。

<br>



<br>

同じ単語の繰り返し現象(repetition)をなくすために、Coverage Mechanismも導入した。

<br>



<br>



<br>



<br>

136 などと比較するとシンプルなモデル。一般的に、PointerGeneratorと呼ばれる。

<br>



<br>

OpenNMTなどにも実装されている: https://opennmt.net/OpenNMT-py/_modules/onmt/modules/copy_generator.html（参考）Pointer Generator Networksで要約してみる：

<br>



<br>

https://qiita.com/knok/items/9a74430b279e522d5b93</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Supervised.html">#Supervised</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Abstractive.html">#Abstractive</a>
<a class="button" href="articles/EACL.html">#EACL</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/133">Cutting-off redundant repeating generations for neural abstractive summarization, Suzuki+, EACL'17</a>
<a class="button" href="articles/Multi.html">#Multi</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/Supervised.html">#Supervised</a>
<a class="button" href="articles/GraphBased.html">#GraphBased</a>
<a class="button" href="articles/GraphConvolutionalNetwork.html">#GraphConvolutionalNetwork</a>
<a class="button" href="articles/Extractive.html">#Extractive</a>
<a class="button" href="articles/CoNLL.html">#CoNLL</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/130">Graph-based Neural Multi-Document Summarization, Yasunaga+, CoNLL'17</a>
<span class="snippet"><span>Comment</span>Graph Convolutional Network (GCN)を使って、MDSやりましたという話。 既存のニューラルなMDSモデル [Cao et al., 2015, 2017] では、sentence間のrelationが考慮できていなかったが、GCN使って考慮した。 また、MDSの学習データはニューラルなモデルを学習するには小さすぎるが（abstractiveにするのは厳しいという話だと思われる？）、sentenceのsalienceを求める問題に帰着させることで、これを克服。

<br>



<br>



<br>



<br>

GCNで用いるAdjacent Matrixとして3種類の方法(cosine similarity, G-Flow, PDG)を試し、議論をしている。PDGが提案手法だが、G-Flowによる重みをPersonalization Features（position, leadか否か等のベーシックな素性）から求まるweightで、よりsentenceのsalienceを求める際にリッチな情報を扱えるように補正している。PDGを用いた場合が（ROUGE的な観点で）最も性能がよかった。

<br>



<br>



<br>



<br>

モデルの処理の流れとしては、Document Cluster中の各sentenceのhidden stateをGRUベースなRNNでエンコードし、それをGCNのノードの初期値として利用する。GCNでL回のpropagation後（実験では3回）に得られたノードのhidden stateを、salienceスコア計算に用いるsentence embedding、およびcluster embeddingの生成に用いる。 cluster embeddingは、document clusterをglobalな視点から見て、salienceスコアに反映させるために用いられる。 最終的にこれら2つの情報をlinearなlayerにかけてsoftmaxかけて正規化して、salienceスコアとする。

<br>



<br>



<br>



<br>

要約を生成する際はgreedyな方法を用いており、salienceスコアの高いsentenceから要約長に達するまで選択していく。このとき、冗長性を排除するため、candidateとなるsentenceと生成中の要約とのcosine similarityが0.5を超えるものは選択しないといった、よくある操作を行なっている。

<br>



<br>



<br>



<br>

DUC01, 02のデータをtraining data, DUC03 をvalidation data, DUC04をtest dataとし、ROUGE1,2で評価。 評価の結果、CLASSY04(DUC04のbest system)やLexRank等のよく使われるベースラインをoutperform。 ただ、regression basedなRegSumにはスコアで勝てないという結果に。 RegSumはwordレベルでsalienceスコアをregressionする手法で、リッチな情報を結構使っているので、これらを提案手法に組み合わせるのは有望な方向性だと議論している。

<br>



<br>



<br>



<br>

[Cao+, 2015] Ranking with recursive neural networks and its application to multi-document summarization, Cao+, AAAI'15 [Cao+, 2017] Improving multi-document summarization via text classification, Cao+, AAAI'17

<br>



<br>



<br>



<br>

[所感] 

<br>



<br>

・ニューラルなモデルは表現力は高そうだけど、学習データがDUC01と02だけだと、データが足りなくて持ち前の表現力が活かせていないのではないかという気がする。 

<br>



<br>

・冗長性の排除をアドホックにやっているので、モデルにうまく組み込めないかなという印象（distraction機構とか使えばいいのかもしれん） 

<br>



<br>

・ROUGEでしか評価してないけど、実際のoutputはどんな感じなのかちょっと見てみたい。（ハイレベルなシステムだとROUGEスコア上がっても人手評価との相関がないっていう研究成果もあるし。）

<br>



<br>

 ・GCN、あまり知らなかったかけど数式追ったらなんとなく分かったと思われる。（元論文読めという話だが）</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/127">Recent Advances in Document Summarization, Yao+, Knowledge and Information Systems'17</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Controllable.html">#Controllable</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/ConceptToTextGeneration.html">#ConceptToTextGeneration</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/91">Toward Controlled Generation of Text, Hu+, ICML'17</a>
<span class="snippet"><span>Comment</span>Text Generationを行う際は、現在は基本的に学習された言語モデルの尤度に従ってテキストを生成するのみで、outputされるテキストをcontrolすることができないので、できるようにしましたという論文。 VAEによるテキスト生成にGANを組み合わせたようなモデル。 decodingする元となるfeatureのある次元が、たとえばpolarityなどに対応しており、その次元の数値をいじるだけで生成されるテキストをcontrolできる。 

<br>



<br>



<br>



<br>

テキストを生成する際に、生成されるテキストをコントロールするための研究。 テキストを生成する際には、基本的にはVariational Auto Encoder(VAE)を用いる。

<br>



<br>



<br>



<br>

VAEは、入力をエンコードするEncoderと、エンコードされた潜在変数zからテキストを生成するGeneratorの2つの機構によって構成されている。

<br>



<br>



<br>



<br>

この研究では、生成されるテキストをコントロールするために、VAEの潜在変数zに、生成するテキストのattributeを表す変数cを新たに導入。

<br>



<br>



<br>



<br>

たとえば、一例として、変数cをsentimentに対応させた場合、変数cの値を変更すると、生成されるテキストのsentimentが変化するような生成が実現可能。

<br>



<br>



<br>



<br>

次に、このような生成を実現できるようなパラメータを学習したいが、学習を行う際のポイントは、以下の二つ。

<br>



<br>



<br>



<br>

cで指定されたattributeが反映されたテキストを生成するように学習

<br>



<br>



<br>



<br>

潜在変数zとattributeに関する変数cの独立性を保つように学習 （cには制御したいattributeに関する情報のみが格納され、その他の情報は潜在変数zに格納されるように学習する)

<br>



<br>



<br>



<br>

1を実現するために、新たにdiscriminatorと呼ばれる識別器を用意し、VAEが生成したテキストのattributeをdiscriminatorで分類し、その結果をVAEのGeneratorにフィードバックすることで、attributeが反映されたテキストを生成できるようにパラメータの学習を行う。 （これにはラベル付きデータが必要だが、少量でも学習できることに加えて、sentence levelのデータだけではなくword levelのデータでも学習できる。）

<br>



<br>



<br>



<br>

また、2を実現するために、VAEが生成したテキストから、生成する元となった潜在変数zが再現できるようにEncoderのパラメータを学習。

<br>



<br>



<br>



<br>

実験では、sentimentとtenseをコントロールする実験が行われており、attributeを表す変数cを変更することで、以下のようなテキストが生成されており興味深い。

<br>



<br>



<br>



<br>

[sentimentを制御した例]

<br>



<br>



<br>



<br>

this movie was awful and boring. (negative)

<br>



<br>

this movie was funny and touching. (positive)

<br>



<br>

[tenseを制御した例]

<br>



<br>



<br>



<br>

this was one of the outstanding thrillers of the last decade

<br>



<br>

this is one of the outstanding thrillers of the all time

<br>



<br>

this will be one of the great thrillers of the all timeVAEは通常のAutoEncoderと比較して、奥が深くて勉強してみておもしろかった。 Reparametrization Trickなどは知らなかった。管理人による解説資料:

<br>

[Controllable Text Generation.pdf](https://github.com/AkihikoWatanabe/paper_notes/files/1595121/Controllable.Text.Generation.pdf)

<br>



<br>

slideshare: https://www.slideshare.net/akihikowatanabe3110/towards-controlled-generation-of-text</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/90">Multi-Task Video Captioning with Video and Entailment Generation, Pasunuru+, ACL'17</a>
<span class="snippet"><span>Comment</span>解説スライド：https://www.slideshare.net/HangyoMasatsugu/hangyo-acl-paperreading2017multitask-video-captioning-with-video-and-entailment-generation/1multitask learningで動画（かなり短め）のキャプション生成を行なった話

<br>



<br>

(2025.05.12)

<br>

上記解説資料中のスクショがいくつか掲載されていましたが削除しました。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/ConceptToTextGeneration.html">#ConceptToTextGeneration</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/87">Neural Text Generation: A Practical Guide, Xie+, arXiv'17</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Unsupervised.html">#Unsupervised</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/83">Unsupervised Pretraining for Sequence to Sequence Learning, Ramachandran+, EMNLP'17</a>
<span class="snippet"><span>Comment</span>seq2seqにおいてweightのpretrainingを行う手法を提案

<br>



<br>

seq2seqでは訓練データが小さいとoverfittingしやすいという弱点があるので、大規模なデータでunsupervisedにpretrainingし、その後目的のデータでfinetuneすることで精度を向上させましょう、というお話。

<br>



<br>

WMTの翻訳タスクにおいて、1.3ポイント BLEUスコアが改善、abstractive summarizationでも実験したが、精度は向上せず。しかしながら要約ではpretrainingによってrepetitionが減少したと主張。

<br>



<br>



<br>



<br>

encoder, decoderそれぞれを切り離して考えると、それぞれ言語モデルとみなすことができるため(encoderにはoutput-layerを追加)、それぞれの言語モデルを独立に大規模なラベルなしデータでpretrainingする。

<br>



<br>

fine-tuneする際は、targetデータだけでなく、pretrainingする際のデータも同時に学習を続ける（LM Objective）

<br>



<br>

LM Objectiveは、target側のobjective functionにpretraining側のobjective functionの項を重み付きで追加したもの。

<br>



<br>



<br>



<br>

Abltion studyによると、MTにおいてはsoftmax-layerをpretrainingすることが重要。softmax-layerのpretrainingをablationするとBLEUスコアが1.6ポイント減少。

<br>



<br>

LM objectiveをなくすと、pretrainingの効果がほとんどなくなる(BLEUスコア-2.0ポイント)。

<br>



<br>

sumarizationにおいては、embeddingのpretrainingが大幅なROUGEスコアの改善を見せた。また、MTと異なり、encoder側のpretrainingがスコア向上に寄与。

<br>



<br>



<br>



<br>

LM Objectiveは結構使えそうな印象</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/82">Learning to skim text, Yu+, ACL'17</a>
<span class="snippet"><span>Comment</span>解説スライド：http://www.lr.pi.titech.ac.jp/~haseshun/acl2017suzukake/slides/07.pdfRNNにおいて重要な部分以外は読み飛ばすことで効率を向上させる研究。いくつ読み飛ばすかも潜在変数として一緒に学習する。潜在変数（離散変数）なので、普通に尤度最大化するやり方では学習できず、おまけに離散変数なのでバックプロパゲーション使えないので、強化学習で学習する。

<br>



<br>



<br>



<br>

Vanilla LSTMと比較し、色々なタスクで実験した結果、性能も（少し）上がるし、スピードアップもする。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Word.html">#Word</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2017-12-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/79">Skip-Gram – Zipf + Uniform = Vector Additivity, Gittens+, ACL'17</a>
<span class="snippet"><span>Comment</span>解説スライド：http://www.lr.pi.titech.ac.jp/~haseshun/acl2017suzukake/slides/09.pdfEmbeddingの加法構成性（e.g. man+royal=king）を理論的に理由づけ

<br>



<br>

（解説スライドより）</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/Word.html">#Word</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<span class="issue_date">Issue Date: 2017-12-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/78">Poincar'e Embeddings for Learning Hierarchical Representations, Nickel+, NIPS'17</a>
<span class="snippet"><span>Comment</span>解説: http://tech-blog.abeja.asia/entry/poincare-embeddings

<br>



<br>

解説スライド：https://speakerdeck.com/eumesy/poincare-embeddings-for-learning-hierarchical-representations

<br>



<br>

実装：https://github.com/TatsuyaShirakawa/poincare-embedding

<br>



<br>

・階層構造を持つデータ（WordNet上の上位語下位語、is-a関係など）を埋め込むために、双曲空間を使った話（通常はユークリッド空間）。

<br>



<br>

・階層構造・べき分布を持つデータはユークリッド空間ではなく双曲空間の方が効率的に埋め込める。

<br>



<br>

・階層構造・べき分布を持つデータを双曲空間（ポアンカレ球モデル）に埋め込むための学習手法（リーマン多様体上でSGD）を提案

<br>



<br>

・WordNet hypernymyの埋め込み：低次元でユークリッド埋め込みに圧勝

<br>



<br>

・Social Networkの埋め込み：低次元だと圧勝

<br>



<br>

・Lexical Entailment：2つのデータセットでSoTA

<br>



<br>

（解説スライドより）<img src="https://user-images.githubusercontent.com/12249301/34452953-0e124ad6-ed8d-11e7-800d-0c2712df116a.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

データとして上位・下位概念を与えていないのに、原点付近には上位語・円周付近には下位語が自然に埋め込まれている（意図した通りになっている）。

<br>



<br>

ポアンカレ円板では、原点からの距離に応じて指数的に円周長が増加していくので、指数的に数が増えていく下位語などは外側に配置されると効率的だけど、その通りになっている。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34452994-7c17a738-ed8d-11e7-8a56-13929c55c07e.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>



<br>



<br>

</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Sentence.html">#Sentence</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/71">Supervised Learning of Universal Sentence Representations from Natural Language Inference Data, Conneau+, EMNLP'17</a>
<span class="snippet"><span>Comment</span>slide: https://www.slideshare.net/naoakiokazaki/supervised-learning-of-universal-sentence-representations-from-natural-language-inference-data汎用的な文のエンコーダができました！という話。

<br>



<br>



<br>



<br>

SNLIデータでパラメータ学習、エンコーダ構成スライド図中右側のエンコーダ部分をなるべく一般的な文に適用できるように学習したい。

<br>



<br>



<br>



<br>

色々なタスクで、文のエンコーダ構成を比較した結果、bi-directional LSTMでエンコードし、要素ごとの最大値をとる手法が最も良いという結果。

<br>



<br>

隠れ層の次元は4096とかそのくらい。

<br>



<br>

Skip-Thoughtは学習に1ヶ月くらいかかるけど、提案手法はより少ないデータで1日くらいで学習終わり、様々なタスクで精度が良い。

<br>



<br>



<br>



<br>

ベクトルの要素積、concat,  subなど、様々な演算を施し、学習しているので、そのような構成の元から文エンコーダを学習すると何か意味的なものがとれている？

<br>



<br>

SNLIはNatural Language Inferenceには文の意味理解が必須なので、そのデータ使って学習するといい感じに文のエンコードができます。

<br>



<br>



<br>



<br>

NLIのデータは色々なところで有用なので、日本語のNLIのデータとかも欲しい。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Sentence.html">#Sentence</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/69">A structured self-attentive sentence embedding, Li+ （Bengio group）, ICLR'17</a>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=BJC_jUqxe</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/67">What do Neural Machine Translation Models Learn about Morphology?, Yonatan Belinkov+, ACL'17</a>
<span class="snippet"><span>Comment</span>http://www.lr.pi.titech.ac.jp/~haseshun/acl2017suzukake/slides/06.pdf

<br>



<br>

(2025.05.12追記)

<br>

上記は2017年にすずかけ台で開催されたACL 2017読み会での解説スライドです。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/66">Sequence-to-Dependency Neural Machine Translation, Wu+, ACL'17</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/64">Neural Machine Translation with Source-Side Latent Graph Parsing, Kazuma Hashimoto+, EMNLP'17</a>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/InteractivePersonalizedSummarization.html">#InteractivePersonalizedSummarization</a>
<a class="button" href="articles/IntegerLinearProgramming%20(ILP).html">#IntegerLinearProgramming (ILP)</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/7">Joint Optimization of User-desired Content in Multi-document Summaries by Learning from User Feedback, P.V.S+, ACL'17, 2017.08</a>
<span class="snippet"><span>Comment</span>一言で言うと

<br>



<br>

ユーザとインタラクションしながら重要なコンセプトを決め、そのコンセプトが含まれるようにILPな手法で要約を生成するPDS手法。Interactive Personalized Summarizationと似ている（似ているが引用していない、引用した方がよいのでは）。

<br>



<br>



<br>



<br>

手法

<br>



<br>

要約モデルは既存のMDS手法を採用。Concept-based ILP Summarization

<br>



<br>



<br>



<br>

フィードバックをユーザからもらう際は、要約を生成し、それをユーザに提示。提示した要約から重要なコンセプトをユーザに選択してもらう形式（ユーザが重要と判断したコンセプトには定数重みが与えられる）。

<br>



<br>

ユーザに対して、τ回フィードバックをもらうまでは、フィードバックをもらっていないコンセプトの重要度が高くなるようにし、フィードバックをもらったコンセプトの重要度が低くなるように目的関数を調整する。これにより、まだフィードバックを受けていないコンセプトが多く含まれる要約が生成されるため、これをユーザに提示することでユーザのフィードバックを得る。τ回を超えたら、ユーザのフィードバックから決まったweightが最大となるように目的関数を修正する。

<br>



<br>



<br>



<br>

ユーザからコンセプトのフィードバックを受ける際は、効率的にフィードバックを受けられると良い（最小のインタラクションで）。そこで、Active Learningを導入する。コンセプトの重要度の不確実性をSVMで判定し、不確実性が高いコンセプトを優先的に含むように目的関数を修正する手法（AL）、SVMで重要度が高いと推定されたコンセプトを優先的に要約に含むように目的関数を修正する手法（AL+）を提案している。

<br>



<br>



<br>



<br>

評価

<br>



<br>

oracle-based approachというものを使っている。要は、要約をシステムが提示しリファレンスと被っているコンセプトはユーザから重要だとフィードバックがあったコンセプトだとみなすというもの。

<br>



<br>

評価結果を見ると、ベースラインのMDSと比べてupper bound近くまでROUGEスコアが上がっている。フィードバックをもらうためのイテレーションは最大で１０回に絞っている模様（これ以上ユーザとインタラクションするのは非現実的）。

<br>



<br>



<br>



<br>

実際にユーザがシステムを使用する場合のコンテキストに沿った評価になっていないと思う。

<br>



<br>

この評価で示せているのは、ReferenceSummary中に含まれる単語にバイアスをかけて要約を生成していくと、ReferenceSummaryと同様な要約が最終的に作れます、ということと、このときPool-basedなActiveLearningを使うと、より少ないインタラクションでこれが実現できますということ。

<br>



<br>

これを示すのは別に良いと思うのだが、feedbackをReferenceSummaryから与えるのは少し現実から離れすぎている気が。たとえばユーザが新しいことを学ぶときは、ある時は一つのことを深堀し、そこからさらに浅いところに戻って別のところを深堀するみたいなプロセスをする気がするが、この深堀フェーズなどはReferenceSummaryからのフィードバックからでは再現できないのでは。

<br>



<br>



<br>



<br>

所感

<br>



<br>

評価が甘いと感じる。十分なサイズのサンプルを得るのは厳しいからorable-based approachとりましたと書いてあるが、なんらかの人手評価もあったほうが良いと思う。

<br>



<br>



<br>



<br>

ユーザに数百単語ものフィードバックをもらうというのはあまり現時的ではない気が。

<br>



<br>



<br>



<br>

oracle-based approachでユーザのフィードバックをシミュレーションしているが、oracleの要約は、人がそのドキュメントクラスタの内容を完璧に理解した上で要約しているものなので、これを評価に使うのも実際のコンテキストと違うと思う。実際にユーザがシステムを使うときは、ドキュメントクラスタの内容なんてなんも知らないわけで、そのユーザからもらえるフィードバックをoracle-based approachでシミュレーションするのは無理がある。仮に、ドキュメントクラスタの内容を完璧に理解しているユーザのフィードバックをシミュレーションするというのなら、わかる。が、そういうユーザのために要約作って提示したいわけではないはず。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Optimizer.html">#Optimizer</a>
<span class="issue_date">Issue Date: 2025-08-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2339">[Paper Note] An overview of gradient descent optimization algorithms, Sebastian Ruder, arXiv'16</a>
<span class="snippet"><span>Summary</span>勾配降下法の最適化アルゴリズムの挙動を理解し、活用するための直感を提供することを目的とした記事。さまざまなバリエーションや課題を要約し、一般的な最適化アルゴリズム、並列・分散設定のアーキテクチャ、追加戦略をレビュー。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/goyal__pramod/status/1951192112269054113?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q勉強用にメモ</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Controllable.html">#Controllable</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/Length.html">#Length</a>
<span class="issue_date">Issue Date: 2025-01-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1647">Controlling Output Length in Neural Encoder-Decoders, Yuta Kikuchi+, EMNLP'16</a>
<span class="snippet"><span>Summary</span>ニューラルエンコーダ-デコーダモデルの出力長を制御する方法を提案。特にテキスト要約において、デコーディングと学習に基づく2つのアプローチを用い、学習ベースの方法が要約の質を保ちながら長さを調整できることを示した。</span>
<span class="snippet"><span>Comment</span>Encoder-Decoderモデルにおいてoutput lengthを制御する手法を提案した最初の研究</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/ReadingComprehension.html">#ReadingComprehension</a>
<span class="issue_date">Issue Date: 2023-11-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1142">NewsQA: A Machine Comprehension Dataset, Adam Trischler+, N_A, arXiv'16</a>
<span class="snippet"><span>Summary</span>NewsQAというデータセットは、10万以上の人間によって生成された質問と回答のペアを含んでいます。このデータセットは、CNNのニュース記事に基づいて作成されており、探索的な推論を必要とする質問を収集するために4つの段階のプロセスを経ています。徹底的な分析により、NewsQAが単純な単語のマッチングやテキストの含意の認識以上の能力を要求することがわかりました。このデータセットは、人間のパフォーマンスと機械のパフォーマンスの差を測定し、将来の研究の進歩を示しています。データセットは無料で利用できます。</span>
<span class="snippet"><span>Comment</span>SQuADよりも回答をするために複雑な推論を必要とするQAデータセット。規模感はSQuADと同等レベル。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/c427bc7c-40af-42aa-a689-d852081a92fc" alt="image" loading="lazy">

<br>



<br>

WordMatchingにとどまらず、回答が存在しない、あるいは記事中でユニークではないものも含まれる。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/3839636e-c9af-4e4d-8eee-3d376d615a35" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Coherence.html">#Coherence</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/971">Lexical Coherence Graph Modeling Using Word Embeddings, Mesgar+, NAACL'16</a>
<span class="snippet"><span>Comment</span>__translate: Coherence is established by semantic connections between sentences of a text which can be modeled by lexical relations. In this paper, we introduce the lexical coherence graph (LCG), a new graph-based model to represent lexical relations among sentences. The frequency of subgraphs (coherence patterns) of this graph captures the connectivity style of sentence nodes in this graph. The coherence of a text is encoded by a vector of these frequencies. We evaluate the LCG model on the readability ranking task. The results of the experiments show that the LCG model obtains higher accuracy than state-of-the-art coherence models. Using larger subgraphs yields higher accuracy, because they capture more structural information. However, larger subgraphs can be sparse. We adapt Kneser-Ney smoothing to smooth subgraphs’ frequencies. Smoothing improves performance.</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<span class="issue_date">Issue Date: 2018-10-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/279">Neural Headline Generation with Minimum Risk Training, Ayana+, N_A, arXiv'16</a>
<span class="snippet"><span>Summary</span>自動見出し生成のために、最小リスクトレーニング戦略を使用してモデルパラメータを最適化し、見出し生成の改善を実現する。提案手法は英語と中国語の見出し生成タスクで最先端のシステムを上回る性能を示す。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/CoNLL.html">#CoNLL</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2018-02-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/258">Generating Sentences from a Continuous Space, Bowman+, CoNLL'16</a>
<span class="snippet"><span>Comment</span>VAEを利用して文生成【Variational Autoencoder徹底解説】

<br>



<br>

https://qiita.com/kenmatsu4/items/b029d697e9995d93aa24</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/SentimentAnalysis.html">#SentimentAnalysis</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2018-01-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/206">Neural Network for Sentiment Analysis, EMNLP'16</a>
<a class="button" href="articles/Single.html">#Single</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/DomainAdaptation.html">#DomainAdaptation</a>
<a class="button" href="articles/Supervised.html">#Supervised</a>
<a class="button" href="articles/Extractive.html">#Extractive</a>
<a class="button" href="articles/PRICAI.html">#PRICAI</a>
<span class="issue_date">Issue Date: 2018-01-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/142">Learning from Numerous Untailored Summaries, Kikuchi+, PRICAI'16</a>
<span class="snippet"><span>Comment</span>New York Times Annotated Corpus（NYTAC）に含まれる大量の正解要約データを利用する方法を提案。

<br>



<br>

NYTACには650,000程度の人手で生成された参照要約が付与されているが、このデータを要約の訓練データとして活用した事例はまだ存在しないので、やりましたという話。

<br>



<br>



<br>



<br>

具体的には、NYTACに存在する人手要約を全てそのまま使うのではなく、Extracitiveなモデルの学習に効果的な事例をフィルタリングして選別する手法を提案

<br>



<br>

また、domain-adaptationの技術を応用し、NYTACデータを要約を適用したいtargetのテキストに適応する5つの手法を提案

<br>



<br>



<br>



<br>

モデルとしては、基本的にknapsack問題に基づいた要約モデル（Extractive）を用い、学習手法としてはPassive Aggressiveアルゴリズムの構造学習版を利用する。

<br>



<br>

NYTACのデータを活用する手法として、以下の5つの手法を提案している。

<br>



<br>



<br>



<br>

```

<br>



<br>

1. NytOnly: NYTACのデータのみで学習を行い、target側の情報は用いない

<br>



<br>

2. Mixture: targetとNYTACの事例をマージして一緒に学習する

<br>



<br>

3. LinInter: TrgtOnly(targetデータのみで学習した場合）のweightとNytOnlyで学習したweightをlinear-interpolationする。interpolation parameterはdev setから決定

<br>



<br>

4. Featurize: NytOnlyのoutputをtargetでモデルを学習する際の追加の素性として用いる

<br>



<br>

5. FineTune: NytOnlyで学習したweightを初期値として、target側のデータでweightをfinetuneする

<br>



<br>

``` 

<br>



<br>



<br>



<br>

また、NYTACに含まれる参照要約には、生成的なものや、メタ視点から記述された要約など、様々なタイプの要約が存在する。今回学習したいモデルはExtractiveな要約モデルなので、このような要約は学習事例としては適切ではないのでフィルタリングしたい。

<br>



<br>

そこで、原文書からExtractiveな要約を生成した際のOracle ROUGE-2スコアを各参照要約-原文書対ごとに求め、特定の閾値以下の事例は使用しないように、インスタンスの選択を行うようにする。

<br>



<br>



<br>



<br>

DUC2002 (単一文書要約タスク)、RSTDTBlong, RSTDTBshort (Rhetrical Structure Theory Discourse Tree Bankに含まれる400件程度の（確か社説のデータに関する）要約)の3種類のデータで評価。

<br>



<br>



<br>



<br>

どちらの評価においても、FineTuneを行い、インスタンスの選択を行うようにした場合が提案手法の中ではもっとも性能がよかった。

<br>



<br>

DUC2002では、LEADやTextRankなどの手法を有意にoutperformしたが、DUC2002のbest systemには勝てなかった。

<br>



<br>

しかしながら、RSTDTBlongにおける評価では、RSTの情報などを用いるstate-of-the-artなシステムに、RSTの情報などを用いない提案手法がROUGEスコアでoutperformした。

<br>



<br>

RSTDTBshortにおける評価では、RSTを用いる手法（平尾さんの手法）には及ばなかったが、それ以外ではbestな性能。これは、RSTDTBshortの場合は要約が指示的な要約であるため、今回学習に用いた要約のデータやモデルは報知的な要約のためのものであるため、あまりうまくいかなかったと考察している。</span>
<a class="button" href="articles/Single.html">#Single</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/Supervised.html">#Supervised</a>
<a class="button" href="articles/Abstractive.html">#Abstractive</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/136">Incorporating Copying Mechanism in Sequence-to-Sequence Learning, Gu+, ACL'16</a>
<span class="snippet"><span>Comment</span>解説スライド：https://www.slideshare.net/akihikowatanabe3110/incorporating-copying-mechanism-in-sequene-to-sequence-learning単語のコピーと生成、両方を行えるネットワークを提案。

<br>



<br>

location based addressingなどによって、生成された単語がsourceに含まれていた場合などに、copy-mode, generate-modeを切り替えるような仕組みになっている。

<br>



<br>



<br>



<br>

65 と同じタイミングで発表</span>
<a class="button" href="articles/Single.html">#Single</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/Supervised.html">#Supervised</a>
<a class="button" href="articles/Abstractive.html">#Abstractive</a>
<a class="button" href="articles/IJCAI.html">#IJCAI</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/132">Distraction-Based Neural Networks for Modeling Documents, Chen+, IJCAI'16</a>
<span class="snippet"><span>Comment</span>Neuralなモデルで「文書」の要約を行う研究。

<br>



<br>



<br>



<br>

提案手法では、attention-basedなsequence-to-sequenceモデルにdistractionと呼ばれる機構を導入することを提案。

<br>



<br>



<br>



<br>

distractionを導入するmotivationは、入力文書中の異なる情報を横断的に参照（一度着目した情報には今後あまり着目しないようなバイアスをかける）したうえで、要約を生成しようというもの。

<br>



<br>

これにより、生成される要約の冗長性を排除するのが狙い。

<br>



<br>



<br>



<br>

以下の3つのアプローチを用いて、distractionを実現

<br>



<br>



<br>



<br>

1. [Distraction over input content vectors]

<br>



<br>

　tステップ目において、decoderのinputとして用いるcontext vectorを

<br>



<br>

計算する際に、通常の計算に加えて、t-1ステップ目までに使用した

<br>



<br>

context vectorの情報を活用することで、これまでdecoderのinputとして

<br>



<br>

利用された情報をあまり重視視しないように、context vectorを生成する。

<br>



<br>



<br>



<br>

2. [Distraction over attention weight vectors]

<br>



<br>

　attentionの重みを計算する際に、過去に高いattentionの重みがついた

<br>



<br>

encoderのhidden stateについては、あまり重要視しないように

<br>



<br>

attentionの重みを計算。1と同様に、t-1ステップ目までのattention weightの

<br>



<br>

historyを保持しておき活用する。

<br>



<br>



<br>



<br>

3. [Distration in decoding]

<br>



<br>

　decodingステップでbeam-searchを行う際のスコア計算に、distraction scoreを導入。distraction

<br>



<br>

scoreはtステップ目までに用いられたcontext vector、attention

<br>



<br>

weight、decoderのstateから計算され、これまでと同じような情報に基づいて

<br>



<br>

単語が生成された場合は、スコアが低くなるようになっている。

<br>



<br>



<br>



<br>

CNN、およびLCSTS data (大規模な中国語のheadline generationデータ)で評価した結果、上記3つのdistraction機構を導入した場合に、最も高いROUGEスコアを獲得

<br>



<br>



<br>



<br>

特に、原文書が長い場合に、短い場合と比較して、distraction機構を導入すると、

<br>



<br>

ROUGEスコアの改善幅が大きくなったことが示されている</span>
<a class="button" href="articles/Single.html">#Single</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/Supervised.html">#Supervised</a>
<a class="button" href="articles/Extractive.html">#Extractive</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/131">Neural Summarization by Extracting Sentences and Words, Cheng+, ACL'16</a>
<span class="snippet"><span>Comment</span>ExtractiveかつNeuralな単一文書要約ならベースラインとして使用した方がよいかも</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Others.html">#Others</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/CIKM.html">#CIKM</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/112">Deep Match between Geology Reports and Well Logs Using Spatial Information, Tong+, CIKM'16</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/ConceptToTextGeneration.html">#ConceptToTextGeneration</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/89">Neural Text Generation from Structured Data with Application to the Biography Domain, Lebret+, Lebret+, EMNLP'16</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/ConceptToTextGeneration.html">#ConceptToTextGeneration</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/86">Content Selection in Data-to-Text Systems: A Survey, arXiv'16, Gkatzia</a>
<span class="snippet"><span>Comment</span>Gkatziaの"content selection"に関するSurvey</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/BeamSearch.html">#BeamSearch</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2017-12-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/80">Sequence-to-Sequence Learning as Beam-Search Optimization, Wiseman+, EMNLP'16</a>
<span class="snippet"><span>Comment</span>seq2seqを学習する際には、gold-history（これまで生成した単語がgoldなものと一緒）を使用し、次に続く単語の尤度を最大化するように学習するが、これには、

<br>



<br>



<br>



<br>

1. Explosure Bias: test時ではtraining時と違いgold historyを使えないし、training時には過去に生成した単語に誤りがあるみたいな状況がない 

<br>



<br>

2. Loss-Evaluation Mismatch: training時は単語レベルのlossを使うが、だいたいはsentence-levelのmetrics (BLEUなど)を改善したい

<br>



<br>

3. Label Bias: 各タイムステップでの単語の生起確率が局所的に正規化され、誤ったhistoryに続く単語がgoldな履歴に続く単語と同じ量（の確率？）を受け取ってしまう

<br>



<br>



<br>



<br>

これらを解決するために、targetの"sequence"に対してスコア（確率ではない）を与えるようなseq2seqモデルを提案し、訓練方法として、beam search optimization（training時のlossとしてbeam searchの結果得られるerrorを用いる）を提案。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Sentence.html">#Sentence</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/76">Larger-context language modelling with recurrent neural networks, Wang+, ACL'16</a>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

通常のNeural Language Modelはsentence間に独立性の仮定を置きモデル化されているが、この独立性を排除し、preceding sentencesに依存するようにモデル化することで、言語モデルのコーパスレベルでのPerplexityが改善したという話。提案した言語モデルは、contextを考慮することで特に名詞や動詞、形容詞の予測性能が向上。Late-Fusion methodと呼ばれるRNNのoutputの計算にcontext vectorを組み込む手法が、Perplexityの改善にもっとも寄与していた。

<br>



<br>



<br>



<br>

手法

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34412713-1e16da94-ec22-11e7-830c-0d0b6247207c.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

sentence間の独立性を排除し、Corpusレベルのprobabilityを下図のように定義。（普通はP(Slが条件付けされていない)）

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34412980-e2425afa-ec23-11e7-86cd-148f85dccc07.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

preceding sentence (context)をモデル化するために、3種類の手法を提案。

<br>



<br>



<br>



<br>

[1. bag-of-words context]

<br>



<br>

　ナイーブに、contextに現れた単語の（単一の）bag-of-wordsベクトルを作り、linear layerをかませてcontext vectorを生成する手法。

<br>



<br>



<br>



<br>

[2. context recurrent neural network]

<br>



<br>

　preceding sentencesをbag-of-wordsベクトルの系列で表現し、これらのベクトルをsequentialにRNN-LSTMに読み込ませ、最後のhidden stateをcontext vectorとする手法。これにより、sentenceが出現した順番が考慮される。

<br>



<br>



<br>



<br>

[3. attention based context representation]

<br>



<br>

　Attentionを用いる手法も提案されており、context recurrent neural networkと同様にRNNにbag-of-wordsのsequenceを食わせるが、各時点におけるcontext sentenceのベクトルを、bi-directionalなRNNのforward, backward stateをconcatしたもので表現し、attention weightの計算に用いる。context vectorは1, 2ではcurrent sentence中では共通のものを用いるが、attention basedな場合はcurrent sentenceの単語ごとに異なるcontext vectorを生成して用いる。

<br>



<br>



<br>



<br>

生成したcontext vectorをsentence-levelのRNN言語モデルに組み合わせる際に、二種類のFusion Methodを提案している。

<br>



<br>



<br>



<br>

[1. Early Fusion]

<br>



<br>

　ナイーブに、RNNLMの各時点でのinputにcontext vectorの情報を組み込む方法。

<br>



<br>

[2. Late Fusion]

<br>



<br>

　よりうまくcontext vectorの情報を組み込むために、current sentence内の単語のdependency(intra-sentence dependency)と、current sentenceとcontextの関係を別々に考慮する。context vectorとmemory cellの情報から、context vector中の不要箇所をフィルタリングしたcontrolled context vectorを生成し、LSTMのoutputの計算に用いる。Later Fusionはシンプルだが、corpusレベルのlanguage modelingの勾配消失問題を緩和することもできる。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34413898-99efbaf8-ec29-11e7-94f5-db82eee399b3.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

評価

<br>



<br>

IMDB, BBC, PennTreebank, Fil9 (cleaned wikipedia corpus)の4種類のデータで学習し、corpus levelでPerplexityを測った。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34414121-b75b2996-ec2a-11e7-9716-dbbb9006b1b5.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Late FusionがPerplexityの減少に大きく寄与している。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34414218-596b373a-ec2b-11e7-85ad-cf98df04ce57.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

PoSタグごとのperplexityを測った結果、contextを考慮した場合に名詞や形容詞、動詞のPerplexityに改善が見られた。一方、Coordinate Conjungtion (And, Or, So, Forなど)や限定詞、Personal Pronouns (I, You, It, Heなど)のPerplexityは劣化した。前者はopen-classな内容語であり、後者はclosed-classな機能語である。機能語はgrammaticalなroleを決めるのに対し、内容語はその名の通り、sentenceやdiscourseの内容を決めるものなので、文書の内容をより捉えることができると考察している。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/Supervised.html">#Supervised</a>
<a class="button" href="articles/Abstractive.html">#Abstractive</a>
<a class="button" href="articles/IJCAI.html">#IJCAI</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/73">Distraction-Based Neural Networks for Modeling Documents, Chen+, IJCAI'16</a>
<span class="snippet"><span>Comment</span>Neuralなモデルで「文書」の要約を行う研究。

<br>



<br>



<br>



<br>

提案手法では、attention-basedなsequence-to-sequenceモデルにdistractionと呼ばれる機構を導入することを提案。

<br>



<br>



<br>



<br>

distractionを導入するmotivationは、入力文書中の異なる情報を横断的に参照（一度着目した情報には今後あまり着目しないようなバイアスをかける）したうえで、要約を生成しようというもの。

<br>



<br>

これにより、生成される要約の冗長性を排除するのが狙い。

<br>



<br>



<br>



<br>

以下の3つのアプローチを用いて、distractionを実現

<br>



<br>



<br>



<br>

1. [Distraction over input content vectors]

<br>



<br>

　tステップ目において、decoderのinputとして用いるcontext vectorを

<br>



<br>

計算する際に、通常の計算に加えて、t-1ステップ目までに使用した

<br>



<br>

context vectorの情報を活用することで、これまでdecoderのinputとして

<br>



<br>

利用された情報をあまり重視視しないように、context vectorを生成する。

<br>



<br>



<br>



<br>

2. [Distraction over attention weight vectors]

<br>



<br>

　attentionの重みを計算する際に、過去に高いattentionの重みがついた

<br>



<br>

encoderのhidden stateについては、あまり重要視しないように

<br>



<br>

attentionの重みを計算。1と同様に、t-1ステップ目までのattention weightの

<br>



<br>

historyを保持しておき活用する。

<br>



<br>



<br>



<br>

3. [Distration in decoding]

<br>



<br>

　decodingステップでbeam-searchを行う際のスコア計算に、distraction scoreを導入。distraction

<br>



<br>

scoreはtステップ目までに用いられたcontext vector、attention

<br>



<br>

weight、decoderのstateから計算され、これまでと同じような情報に基づいて

<br>



<br>

単語が生成された場合は、スコアが低くなるようになっている。

<br>



<br>



<br>



<br>

CNN、およびLCSTS data (大規模な中国語のheadline generationデータ)で評価した結果、上記3つのdistraction機構を導入した場合に、最も高いROUGEスコアを獲得

<br>



<br>



<br>



<br>

特に、原文書が長い場合に、短い場合と比較して、distraction機構を導入すると、

<br>



<br>

ROUGEスコアの改善幅が大きくなったことが示されているDistraction機構の有用性は、ACL'17のstanford NLPグループが提案したPointer Generator Networkでも示されている（Coverage Vectorという呼び方をしてた気がする）</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Sentence.html">#Sentence</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/NAACL.html">#NAACL</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/70">Learning Distributed Representations of Sentences from Unlabelled Data, Hill+, NAACL'16</a>
<span class="snippet"><span>Comment</span>Sentenceのrepresentationを学習する話

<br>



<br>



<br>



<br>

代表的なsentenceのrepresentation作成手法(CBOW, SkipGram, SkipThought, Paragraph Vec, NMTなど)をsupervisedな評価（タスク志向+supervised）とunsupervisedな評価(文間の距離をコサイン距離ではかり、人間が決めた順序と相関を測る)で比較している。

<br>



<br>



<br>



<br>

また筆者らはSequential Denoising Auto Encoder(SDAE)とFastSentと呼ばれる手法を提案しており、前者はorderedなsentenceデータがなくても訓練でき、FastSentはorderedなsentenceデータが必要だが高速に訓練できるモデルである。

<br>



<br>



<br>



<br>

実験の結果、supervisedな評価では、基本的にはSkipThoughtがもっとも良い性能を示し、paraphrasingタスクにおいて、SkipThoughtに3ポイント程度差をつけて良い性能を示した。unsupervisedな評価では、DictRepとFastSentがもっとも良い性能を示した。

<br>



<br>



<br>



<br>

実験の結果、以下のような知見が得られた：

<br>



<br>



<br>



<br>

異なるobjective functionは異なるembeddingを作り出す

<br>



<br>

objective functionは、主に隣接する文を予測するものと、自分自身を再現するものに分けられる。これらの違いによって、生成されるembeddingが異なっている。Table5をみると、後者については、生成されたrepresentationのnearest neighborを見ていると、自身と似たような単語を含む文が引っ張ってこれるが、前者については、文のコンセプトや機能は似ているが、単語の重複は少なかったりする。

<br>



<br>



<br>



<br>

supervisedな場合とunsupervisedな評価でのパフォーマンスの違い

<br>



<br>

supervisedな設定では、SkipThoughtやSDAEなどのモデルが良い性能を示しているが、unsupervisedな設定ではまりうまくいかず。unsupevisedな設定ではlog-linearモデルが基本的には良い性能を示した。

<br>



<br>



<br>



<br>

pre-trainedなベクトルを使用したモデルはそうでない場合と比較してパフォーマンスが良い

<br>



<br>



<br>



<br>

必要なリソースの違い

<br>



<br>

モデルによっては、順序づけられた文のデータが必要だったり、文の順序が学習に必要なかったりする。あるいは、デコーディングに時間がかかったり、めちゃくちゃメモリ食ったりする。このようなリソースの性質の違いは、使用できるapplicationに制約を与える。

<br>



<br>



<br>



<br>

結論

<br>



<br>

とりあえず、supervisedなモデルにrepresentationを使ってモデルになんらかのknowledgeをぶちこみたいときはSkipThought、単純に類似した文を検索したいとか、そういう場合はFastSentを使うと良いってことですかね.</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/65">Pointing the unknown words, Gulcehre+, ACL'16</a>
<span class="snippet"><span>Comment</span>テキストを生成する際に、source textからのコピーを行える機構を導入することで未知語問題に対処した話CopyNetと同じタイミングで（というか同じconferenceで）発表</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-05-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1954">Neural Machine Translation by Jointly Learning to Align and Translate, Dzmitry Bahdanau+, ICLR'15</a>
<span class="snippet"><span>Summary</span>ニューラル機械翻訳は、エンコーダー-デコーダーアーキテクチャを用いて翻訳性能を向上させる新しいアプローチである。本論文では、固定長のベクトルの使用が性能向上のボトルネックであるとし、モデルが関連するソース文の部分を自動的に検索できるように拡張することを提案。これにより、英語からフランス語への翻訳タスクで最先端のフレーズベースシステムと同等の性能を達成し、モデルのアライメントが直感と一致することを示した。</span>
<span class="snippet"><span>Comment</span>(Cross-)Attentionを初めて提案した研究。メモってなかったので今更ながら追加。Attentionはここからはじまった（と認識している）</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Reference-based.html">#Reference-based</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/985">chrF: character n-gram F-score for automatic MT evaluation, Mono Popovic, WMT'15</a>
<span class="snippet"><span>Summary</span>私たちは、機械翻訳の評価に文字n-gram Fスコアを使用することを提案します。私たちは、このメトリックがシステムレベルとセグメントレベルで人間のランキングと相関しており、特にセグメントレベルでの相関が非常に高いことを報告しました。この提案は非常に有望であり、WMT14の共有評価タスクでも最高のメトリックを上回りました。</span>
<span class="snippet"><span>Comment</span>character-basedなn-gram overlapをreferenceとシステムで計算する手法</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-based.html">#Reference-based</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/978"> From word embeddings to document distances, Kusner+, PMLR'15</a>
<span class="snippet"><span>Summary</span>私たちは、新しい距離関数であるWord Mover's Distance（WMD）を提案しました。WMDは、テキストドキュメント間の非類似性を測定するために使用されます。私たちの研究では、単語埋め込みの最新の結果に基づいてWMDを開発しました。WMDは、単語が別のドキュメントの単語に到達するために必要な最小距離を計算します。私たちのメトリックは、実装が簡単であり、ハイパーパラメータも必要ありません。さらに、私たちは8つの実世界のドキュメント分類データセットでWMDメトリックを評価し、低いエラーレートを示しました。</span>
<span class="snippet"><span>Comment</span>WMS/SMS/S+WMS

<br>



<br>

946 はこれらからinspiredされ提案された</span>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/969">Document-Level Machine Translation Evaluation with Gist Consistency and Text Cohesion, Gong+, DiscoMT'15</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/ImageCaptioning.html">#ImageCaptioning</a>
<a class="button" href="articles/Reference-based.html">#Reference-based</a>
<span class="issue_date">Issue Date: 2023-05-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/670">CIDEr: Consensus-based Image Description Evaluation, Ramakrishna Vedantam+, N_A, CVPR'15</a>
<span class="snippet"><span>Summary</span>画像を文章で自動的に説明することは、長年の課題である。本研究では、人間の合意を利用した画像説明の評価のための新しいパラダイムを提案し、新しい自動評価指標と2つの新しいデータセットを含む。提案手法は、人間の判断をより正確に捉えることができ、5つの最先端の画像説明手法を評価し、将来の比較のためのベンチマークを提供する。CIDEr-Dは、MS COCO評価サーバーの一部として利用可能であり、システマティックな評価とベンチマークを可能にする。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2021-06-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/369">Effective Approaches to Attention-based Neural Machine Translation, Luong+, EMNLP'15</a>
<span class="snippet"><span>Comment</span>Luong論文。attentionの話しはじめると、だいたいBahdanau+か、Luong+論文が引用される。

<br>



<br>



<br>



<br>

Global Attentionと、Local Attentionについて記述されている。Global Attentionがよく利用される。

<br>



<br>



<br>



<br>

Global Attention

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/120452200-008ec280-c3cd-11eb-8ced-47dc9e67f487.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Local Attention

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/120452397-2025eb00-c3cd-11eb-9d3b-0f7802a40712.png" alt="image" loading="lazy">

<br>



<br>

やはり菊池さんの解説スライドが鉄板。

<br>



<br>

https://www.slideshare.net/yutakikuchi927/deep-learning-nlp-attention参考までに、LuongらのGlobal Attentionの計算の流れは下記となっている：

<br>



<br>

・h_t -&gt; a_t -&gt; c_t -&gt; h^~_t

<br>



<br>



<br>



<br>

BahdanauらのAttentionは下記

<br>



<br>

・h_t-1 -&gt; a_t -&gt; c_t -&gt; h_t

<br>



<br>



<br>



<br>

t-1のhidden stateを使うのか、input feeding後の現在のhidden stateをattention weightの計算に使うのかが異なっている。また、過去のalignmentの情報を考慮した上でデコーディングしていくために、input-feeding approachも提案

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/120877145-cfdaa300-c5ef-11eb-8a8b-a57d03d864b4.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

input-feeding appproachでは、t-1ステップ目のoutputの算出に使ったh^~_t（hidden_stateとcontext vectorをconcatし、tanhのactivationを噛ませた線形変換を行なったベクトル）を、時刻tのinput embeddingにconcatして、RNNに入力する。</span>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/IJCNLP.html">#IJCNLP</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2018-03-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/266">Unsupervised prediction of acceptability judgements, Lau+, ACL-IJCNLP'15</a>
<span class="snippet"><span>Comment</span>文のacceptability（容認度）論文。

<br>



<br>

文のacceptabilityとは、native speakerがある文を読んだときに、その文を正しい文として容認できる度合いのこと。

<br>



<br>

acceptabilityスコアが低いと、Readabilityが低いと判断できる。

<br>



<br>

言語モデルをトレーニングし、トレーニングした言語モデルに様々な正規化を施すことで、acceptabilityスコアを算出する。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2018-02-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/257">Improved Semantic Representations From Tree-Structured Long Short-Term Memory Networks, Tai+, ACL'15</a>
<span class="snippet"><span>Comment</span>Tree-LSTM論文</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2018-01-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/145">Re-evaluating Automatic Summarization with BLEU and 192 Shades of ROUGE, Graham, EMNLP'15</a>
<span class="snippet"><span>Comment</span>文書要約で使用されているMetric、特にBLEUやROUGEの結果（可能な１９２のパターン）と、人手の結果との相関を再分析している。

<br>



<br>

その結果、BLEUがもっとも人手評価との相関が高く、ROUGE-2のPrecisionの平均(ステミング、stop words除去)がROUGEの中でbest-performingなvariantだった。

<br>



<br>



<br>



<br>

要約のMetrcの最適な検定方法として、Williams検定を利用。

<br>



<br>

再評価の結果、以前推奨されていたvariantとは異なるMetricsが良い結果に。

<br>



<br>

best-performing ROUGE resultを用いて、既存のstate-of-the-artなシステムを再度ランキングづけすると、originalのものとは結構異なる結果になった。

<br>



<br>



<br>



<br>

（一部のスコアが良かったシステムのスコアが相対的にかなり悪化している）

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34465383-d104a5be-eeed-11e7-9876-111d618ab9ee.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

また、BLEUが人手評価ともっとも高い相関を示したが、best-performingなROUGE variantとは統計的な有意差はなかった。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Sentence.html">#Sentence</a>
<a class="button" href="articles/Supervised.html">#Supervised</a>
<a class="button" href="articles/Abstractive.html">#Abstractive</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/137">A Neural Attention Model for Sentence Summarization, Rush+, EMNLP'15</a>
<span class="snippet"><span>Comment</span>解説スライド：https://www.slideshare.net/akihikowatanabe3110/a-neural-attention-model-for-sentence-summarization-65612331</span>
<a class="button" href="articles/Single.html">#Single</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Sentence.html">#Sentence</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Abstractive.html">#Abstractive</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/75">LCSTS: A large scale chinese short text summarizatino dataset, Hu+, EMNLP'15</a>
<span class="snippet"><span>Comment</span>Large Chinese Short Text Summarization (LCSTS) datasetを作成

<br>



<br>



<br>



<br>

データセットを作成する際は、Weibo上の特定のorganizationの投稿の特徴を利用。

<br>



<br>

Weiboにニュースを投稿する際に、投稿の冒頭にニュースのvery short summaryがまず記載され、その後ニュース本文（短め）が記載される特徴があるので、この対をsource-reference対として収集した。

<br>



<br>

収集する際には、約１００個のルールに基づくフィルタリングやclearning, 抽出等を行なっている。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34411045-95f7baf2-ec17-11e7-94fb-faf2559d6994.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

データセットのpropertyとしては、下記のPartI, II, IIIに分かれている。

<br>



<br>



<br>



<br>

PartI: 2.4Mのshort text ・summary pair

<br>



<br>

PartII: PartIからランダムにサンプリングされた10kのpairに対して、5 scaleで要約のrelevanceをratingしたデータ。ただし、各pairにラベルづけをしたevaluatorは1名のみ。

<br>



<br>

PartIII: 2kのpairに対して（PartI, PartIIとは独立）、3名のevaluatorが5-scaleでrating。evaluatorのratingが一致した1kのpairを抽出したデータ。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34411199-8db4df90-ec18-11e7-8703-fd8f9512a903.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

RNN-GRUを用いたSummarizerも提案している。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34411224-b5543eba-ec18-11e7-8556-a3b42bfcf334.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

CopyNetなどはLCSTSを使って評価している。他にも使ってる論文あったはず。ACL'17のPointer Generator Networkでした。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/74">A hierarchical neural autoencoder for paragraphs and documents, Li+, ACL'15</a>
<span class="snippet"><span>Comment</span>複数文を生成(今回はautoencoder)するために、standardなseq2seq LSTM modelを、拡張したという話。

<br>



<br>



<br>



<br>

要は、paragraph/documentのrepresentationが欲しいのだが、アイデアとしては、word-levelの情報を扱うLSTM layerとsentenc-levelの情報を扱うLSTM layerを用意し、それらのcompositionによって、paragraph/documentを表現しましたという話。

<br>



<br>



<br>



<br>

sentence-levelのattentionを入れたらよくなっている。

<br>



<br>



<br>



<br>

trip advisorのreviewとwikipediaのparagraphを使ってtrainingして、どれだけ文書を再構築できるか実験。

<br>



<br>

MetricはROUGE, BLEUおよびcoherence(sentence order代替)を測るために、各sentence間のgapがinputとoutputでどれだけ一致しているかで評価。

<br>



<br>



<br>



<br>

hierarchical lstm with attention &gt; hierarchical lstm &gt; standard lstm の順番で高性能。

<br>



<br>



<br>



<br>

学習には、tesla K40を積んだマシンで、standard modelが2-3 weeks, hierarchical modelsが4-6週間かかるらしい。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/SentimentAnalysis.html">#SentimentAnalysis</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/72">Document Modeling with Gated Recurrent Neural Network for Sentiment Classification, Tang+, EMNLP'15</a>
<span class="snippet"><span>Comment</span>word level -&gt; sentence level -&gt; document level のrepresentationを求め、documentのsentiment classificationをする話。

<br>



<br>

documentのRepresentationを生成するときに参考になるやも。

<br>



<br>

sentenceのrepresentationを求めるときは、CNN/LSTMを使う。

<br>



<br>

document levelに落とすことは、bi-directionalなGatedRNN(このGatedRNNはLSTMのoutput-gateが常にonになっているようなものを使う。sentenceのsemanticsに関する情報を落としたくないかららしい。)を使う。

<br>



<br>

sentiment classificationタスクで評価し、(sentence levelのrepresentationを求めるときは)LSTMが最も性能がよく、documentのrepresentationを求めるときは、standardなRNNよりもGatedRNNのほうが性能よかった。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Sentence.html">#Sentence</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/59">Sentence Compression by Deletion with LSTMs, Fillipova+, EMNLP'15</a>
<span class="snippet"><span>Comment</span>slide:https://www.slideshare.net/akihikowatanabe3110/sentence-compression-by-deletion-with-lstms</span>
<a class="button" href="articles/ReviewGeneration.html">#ReviewGeneration</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/5">Extended Recommendation Framework: Generating the Text of a User Review as a Personalized Summary Poussevin+, CBRecsys'15, 2015.09</a>
<span class="snippet"><span>Comment</span>review generationの結果をrating predictionに伝搬することで性能よくしました、という話だと思う</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/review.html">#review</a>
<span class="issue_date">Issue Date: 2023-05-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/663">Empirical analysis of exploiting review helpfulness for extractive summarization of online reviews, Xiong+, COLING'14</a>
<span class="snippet"><span>Comment</span>レビューのhelpfulnessを利用したunsupervisedなreview summarization手法を提案。helpfulessによりレビューをフィルタリングするだけでなく、トピックモデルでsentenceをクラスタリングする際にhelpfulnessの情報も活用している模様。

<br>



<br>



<br>



<br>

最終的にはユーザスタディで評価。ユーザがカメラを購入するためにレビューを読むシナリオを想定。ユーザにまずは10 sentenceでレビューを作成してもらう。その上で、3つの要約手法による要約を提示し、どれが「カメラを購入するdecision makingに役立ったか？またはinformativeだったか？」で評価してもらっている。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Others.html">#Others</a>
<a class="button" href="articles/AAAI.html">#AAAI</a>
<span class="issue_date">Issue Date: 2018-01-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/148">Detecting information-dense texts in multiple news domains, Yang+, AAAI'14</a>
<span class="snippet"><span>Comment</span>ニュース記事の第一段落目がinformativeか否か（重要なfactual informationが記述されているか否か）を分類する研究。

<br>



<br>

New York Times Annotated Corpusに対して、自動的にinformative, non-informativeなラベルづけを行う手法を提案し、分類モデルをtraining。

<br>



<br>



<br>



<br>

(informativeな例)

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34465457-02ec9624-eef1-11e7-88a5-3a265ddb7d64.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

(non-informativeな例)

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34465460-123e4b04-eef1-11e7-82a3-56ede8802b43.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

評価の結果、Accuracyはだいたい0.8〜0.85くらい。

<br>



<br>



<br>



<br>

人が100件中何件をinformativeと判断したかが下表。下表を見ると、リードにもnon-informativeなものが多数存在することがわかる。

<br>



<br>

また、ドメインによって傾向が異なっており、たとえばスポーツドメインでは、entertaining mannerで記述されるのでfactual informationがあまり記述されない傾向にあったり、Scienceドメインでは、generalなtopicやissue, personal historyなどが記述される傾向にあるので、相対的にinformativeなLeadが少ない。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34465471-7e49402e-eef1-11e7-8d55-5a92d1335cc9.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Multi.html">#Multi</a>
<a class="button" href="articles/Single.html">#Single</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/Unsupervised.html">#Unsupervised</a>
<a class="button" href="articles/GraphBased.html">#GraphBased</a>
<a class="button" href="articles/Extractive.html">#Extractive</a>
<a class="button" href="articles/SIGIR.html">#SIGIR</a>
<span class="issue_date">Issue Date: 2018-01-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/144">CTSUM: Extracting More Certain Summaries for News Articles, Wan+, SIGIR'14</a>
<span class="snippet"><span>Comment</span>要約を生成する際に、情報の”確実性”を考慮したモデルCTSUMを提案しましたという論文（今まではそういう研究はなかった）

<br>



<br>



<br>



<br>

```

<br>



<br>

"However, it seems that Obama will not use the platform to relaunch his stalled drive for Israeli-Palestinian peace"

<br>



<br>

```

<br>



<br>

こういう文は、"It seems"とあるように、情報の確実性が低いので要約には入れたくないという気持ち。

<br>



<br>



<br>



<br>

FactBankのニュースコーパスから1000 sentenceを抽出し、5-scaleでsentenceの確実性をラベルづけ。

<br>



<br>

このデータを用いてSVRを学習し、sentenceの確実性をoutputする分類器を構築

<br>



<br>

affinity-propagationベース（textrank, lexrankのような手法）手法のaffinityの計算（edge間の重みのこと。普通はsentence同士の類似度とかが使われる）を行う際に、情報の確実性のスコアを導入することで確実性を考慮した要約を生成

<br>



<br>



<br>



<br>

DUC2007のMDSデータセットで、affinity計算の際に確実性を導入する部分をablationしたモデル（GRSUM）と比較したところ、CTSUMのROUGEスコアが向上した。

<br>



<br>

また、自動・人手評価により、生成された要約に含まれる情報の確実性を評価したところ、GRSUMをoutperformした解説スライド：https://www.slideshare.net/akihikowatanabe3110/ctsum-extracting-more-certain-summaries-for-news-articlesSIGIRでは珍しい、要約に関する研究

<br>



<br>

情報の確実性を考慮するという、いままであまりやられていなかった部分にフォーカスしたのはおもしろい

<br>



<br>

「アイデアはおもしろいし良い研究だが、affinity weightが変化するということは、裏を返せばdamping factorを変更してもそういう操作はできるので、certaintyを考慮したことに意味があったのかが完全に示せていない。」という意見があり、なるほどと思った。</span>
<a class="button" href="articles/Single.html">#Single</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/Supervised.html">#Supervised</a>
<a class="button" href="articles/Abstractive.html">#Abstractive</a>
<a class="button" href="articles/Extractive.html">#Extractive</a>
<a class="button" href="articles/COLING.html">#COLING</a>
<span class="issue_date">Issue Date: 2018-01-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/143">Learning to Generate Coherent Sumamry with Discriminative Hidden Semi-Markov Model, Nishikawa+, COLING'14</a>
<span class="snippet"><span>Comment</span>Hidden-semi-markovモデルを用いた単一文書要約手法を提案。

<br>



<br>



<br>



<br>

通常のHMMでは一つの隠れ状態に一つのunit（要約の文脈だと文？）が対応するが、hidden-semi-markov(HSMM)モデルでは複数のunitを対応づけることが可能。

<br>



<br>

隠れ状態に対応するunitを文だと考えると、ある文の複数の亜種を考慮できるようになるため、ナップサック制約を満たしつつ最適な文の亜種を選択するといったことが可能となる。

<br>



<br>

とかまあ色々難しいことが前半の節に書いてある気がするが、3.3節を見るのがわかりやすいかもしれない。

<br>



<br>



<br>



<br>

定式化を見ると、基本的なナップサック問題による要約の定式化に、Coherenceを表すtermと文の変種を考慮するような変数が導入されているだけである。

<br>



<br>

文のweightや、coherenceのweightは構造学習で学習し、Passive Aggressiveを用いて、loss functionとしてはROUGEを用いている（要はROUGEが高くなるように、outputの要約全体を考慮しながら、weightを学習するということ）。

<br>



<br>



<br>



<br>

文の変種としては、各文を文圧縮したものを用意している。

<br>



<br>

また、動的計画法によるデコーディングのアルゴリズムも提案されている。

<br>



<br>



<br>



<br>

構造学習を行う際には大量の教師データが必要となるが、13,000記事分のニュース記事と対応する人手での要約のデータを用いて学習と評価を行なっており、当時これほど大規模なデータで実験した研究はなかった。

<br>



<br>



<br>



<br>

ROUGEでの評価の結果、文の変種（文圧縮）を考慮するモデルがベースラインを上回る結果を示したが、LEADとは統計的には有意差なし。しかしながら、人手で生成した要約との完全一致率が提案手法の方が高い。

<br>



<br>

また、ROUGEの評価だけでなく、linguistic quality（grammaticality, structure/coherenceなど）を人手で評価した結果、ベースラインを有意にoutperform。LEADはgrammaticalityでかなり悪い評価になっていて、これは要約を生成すると部分文が入ってしまうため。

<br>



<br>

訓練事例数を変化させてROUGEスコアに関するlearning curveを描いた結果、訓練事例の増加に対してROUGEスコアも単調増加しており、まだサチる気配を見せていないので、事例数増加させたらまだ性能よくなりそうという主張もしている。評価に使用した記事が報道記事だったとするならば、quality的にはLeadに勝ってそうな雰囲気を感じるので、結構すごい気はする（単一文書要約で報道記事においてLEADは最強感あったし）。

<br>



<br>

ただ、要約の評価においてinformativenessを評価していないので、ROUGEスコア的にはLeadとcomparableでも、実際に生成される要約の情報量として果たしてLEADに勝っているのか興味がある。</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Others.html">#Others</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/108">Comparing Multi-label Classification with Reinforcement Learning for Summarization of Time-series Data, Gkatzia+, ACL'14</a>
<a class="button" href="articles/Multi.html">#Multi</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Extractive.html">#Extractive</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/58">Hierarchical Summarization: Scaling Up Multi-Document Summarization, Christensen+, ACL'14</a>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

だいぶ前に読んだ。好きな研究。

<br>



<br>

テキストのsentenceを階層的にクラスタリングすることで、抽象度が高い情報から、関連する具体度の高いsentenceにdrill downしていけるInteractiveな要約を提案している。

<br>



<br>



<br>



<br>

手法

<br>



<br>

通常のMDSでのデータセットの規模よりも、実際にMDSを使う際にはさらに大きな規模のデータを扱わなければならないことを指摘し（たとえばNew York Timesで特定のワードでイベントを検索すると数千、数万件の記事がヒットしたりする）そのために必要な事項を検討。

<br>



<br>

これを実現するために、階層的なクラスタリングベースのアプローチを提案。

<br>



<br>

提案手法では、テキストのsentenceを階層的にクラスタリングし、下位の層に行くほどより具体的な情報になるようにsentenceを表現。さらに、上位、下位のsentence間にはエッジが張られており、下位に紐付けられたsentence

<br>



<br>

は上位に紐付けられたsentenceの情報をより具体的に述べたものとなっている。

<br>



<br>

これを活用することで、drill down型のInteractiveな要約を実現。</span>
<a class="button" href="articles/Multi.html">#Multi</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/QueryBiased.html">#QueryBiased</a>
<a class="button" href="articles/Extractive.html">#Extractive</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/57">Query-Chain Focused Summarization, Baumel+, ACL'14</a>
<span class="snippet"><span>Comment</span>（管理人が作成した過去の紹介資料）

<br>

[Query-Chain Focused Summarization.pdf](https://github.com/AkihikoWatanabe/paper_notes/files/1590916/Query-Chain.Focused.Summarization.pdf)

<br>



<br>

上記スライドは私が当時作成した論文紹介スライドです。スライド中のスクショは説明のために論文中のものを引用しています。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-08-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1016">Automatically Assessing Machine Summary Content Without a Gold Standard, Louis+（w_ Nenkova）, ACL'13</a>
<span class="snippet"><span>Summary</span>本研究では、要約の評価において新しい技術を提案しています。これにより、人間の要約が利用できない場合や、単一のモデルしか利用できない場合でも正確な評価が可能となります。具体的には、モデルに依存しない評価技術や、システム要約の類似性を定量化する尺度などを提案しています。これにより、要約の評価を人間の評価と正確に再現することができます。また、擬似モデルを導入することで、利用可能なモデルのみを使用する場合よりも人間の判断との相関が高くなることも示しています。さらに、システム要約のランキング方法についても探求しており、驚くほど正確なランキングが可能となります。</span>
<span class="snippet"><span>Comment</span>メタ評価の具体的な手順について知りたければこの研究を読むべし</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Coherence.html">#Coherence</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/970">Graph-based Local Coherence Modeling, Guinaudeau+, ACL'13</a>
<span class="snippet"><span>Summary</span>私たちは、グラフベースのアプローチを提案し、文の順序付け、要約の結束性評価、読みやすさの評価の3つのタスクでシステムを評価しました。このアプローチは、エンティティグリッドベースのアプローチと同等の性能を持ち、計算コストの高いトレーニングフェーズやデータのまばらさの問題にも対処できます。</span>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<span class="issue_date">Issue Date: 2018-01-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/237">The Mathematics of Statistical Machine Translation: Parameter Estimation, Brown+, CL'13</a>
<span class="snippet"><span>Comment</span>IBMモデル論文。</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/SingleFramework.html">#SingleFramework</a>
<a class="button" href="articles/ConceptToTextGeneration.html">#ConceptToTextGeneration</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/99">Inducing document plans for concept-to-text generation, Konstas+, EMNLP'13</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/CrossLingual.html">#CrossLingual</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/979">Evaluating the Efficacy of Summarization Evaluation across Languages, Koto+ （w_ Tim先生）, Findings of ACL'12</a>
<span class="snippet"><span>Summary</span>この研究では、異なる言語の要約コーパスを使用して、マルチリンガルBERTを用いたBERTScoreが他の要約評価メトリックスよりも優れたパフォーマンスを示すことが示されました。これは、英語以外の言語においても有効であることを示しています。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Coherence.html">#Coherence</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/968">Extending Machine Translation Evaluation Metrics with Lexical Cohesion to Document Level, Wong+, EMNLP'12</a>
<span class="snippet"><span>Summary</span>この論文では、語彙的な結束を利用して文書レベルの機械翻訳の評価を容易にする方法を提案しています。語彙的な結束は、同じ意味を持つ単語を使って文を結びつけることで、テキストの結束性を実現します。実験結果は、この特徴を評価尺度に組み込むことで、人間の判断との相関を向上させることを示しています。</span>
<span class="snippet"><span>Comment</span>RC-LC</span>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<span class="issue_date">Issue Date: 2023-05-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/650">Context-enhanced personalized social summarization, Po+, COLING'12, 18</a>
<span class="snippet"><span>Comment</span>ざっくり言うと、ソーシャルタギングシステムにおいて、ユーザ uと類似したユーザのタグ付け情報と、原文書d _と同じトピックに属する文書をそれぞれ考慮することによって、ユーザのinterestに関する情報（と原文書のinformativenessに関する情報）を拡張し、これらの情報を活用して、全てのクラスタリングしたドキュメントの中で重要文をランキングした上で、対象文書に対するsentenceのみを冗長性がないように抽出することで、Personalized_ Summarizationしましょう、という話</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/128">A Survey of Text Summarization Techniques, Nenkova+, Springer'12</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/SingleFramework.html">#SingleFramework</a>
<a class="button" href="articles/ConceptToTextGeneration.html">#ConceptToTextGeneration</a>
<a class="button" href="articles/NAACL.html">#NAACL</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/97">Unsupervised concept-to-text generation with hypergraphs, Konstas+, NAACL-HLT'12</a>
<a class="button" href="articles/Multi.html">#Multi</a>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/InteractivePersonalizedSummarization.html">#InteractivePersonalizedSummarization</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1">Summarize What You Are Interested In: An Optimization Framework for Interactive Personalized Summarization, Yan+, EMNLP'11, 2011.07</a>
<span class="snippet"><span>Comment</span><img src="https://user-images.githubusercontent.com/12249301/34400733-97c86614-ebd7-11e7-9fe9-a6b36c726a21.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

ユーザとシステムがインタラクションしながら個人向けの要約を生成するタスク、InteractivePersonalizedSummarizationを提案。

<br>



<br>



<br>



<br>

ユーザはテキスト中のsentenceをクリックすることで、システムに知りたい情報のフィードバックを送ることができる。このとき、ユーザがsentenceをクリックする量はたかがしれているので、click smoothingと呼ばれる手法を提案し、sparseにならないようにしている。click smoothingは、ユーザがクリックしたsentenceに含まれる単語？等を含む別のsentence等も擬似的にclickされたとみなす手法。

<br>



<br>



<br>



<br>

4つのイベント（Influenza A, BP Oil Spill, Haiti Earthquake, Jackson Death）に関する、数千記事のニュースストーリーを収集し（10k〜100k程度のsentence）、評価に活用。収集したニュースサイト（BBC, Fox News, Xinhua, MSNBC, CNN, Guardian, ABC, NEwYorkTimes, Reuters, Washington Post）には、各イベントに対する人手で作成されたReference Summaryがあるのでそれを活用。

<br>



<br>

objectiveな評価としてROUGE、subjectiveな評価として3人のevaluatorに5scaleで要約の良さを評価してもらった。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34400727-8c8ab022-ebd7-11e7-85df-c238fd2255de.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

結論としては、ROUGEはGenericなMDSモデルに勝てないが、subjectiveな評価においてベースラインを上回る結果に。ReferenceはGenericに生成されているため、この結果を受けてPersonalizationの必要性を説いている。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34400721-82d1bb8e-ebd7-11e7-83d2-697ac61eb38a.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

また、提案手法のモデルにおいて、Genericなモデルの影響を強くする（Personalizedなハイパーパラメータを小さくする）と、ユーザはシステムとあまりインタラクションせずに終わってしまうのに対し、Personalizedな要素を強くすると、よりたくさんクリックをし、結果的にシステムがより多く要約を生成しなおすという結果も示している。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34400718-7b9a4912-ebd7-11e7-83cf-aba826a41d34.png" alt="image" loading="lazy"></span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/QA-based.html">#QA-based</a>
<span class="issue_date">Issue Date: 2023-08-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1006">Discourse constraints for document compression, Clarke+ （w_ Lapata）, Computational Linguistics'10</a>
<span class="snippet"><span>Comment</span>QAベースドなアプローチを人手評価に導入した初めての研究</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/RuleBased.html">#RuleBased</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/106">Generating approximate geographic descriptions, Turner+, ENLG'10</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/SingleFramework.html">#SingleFramework</a>
<a class="button" href="articles/ConceptToTextGeneration.html">#ConceptToTextGeneration</a>
<a class="button" href="articles/COLING.html">#COLING</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/96">Generative alignment and semantic parsing for learning from ambiguous supervision, Kim+, COLING'10</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/SingleFramework.html">#SingleFramework</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/95">A simple domain-independent probabilistic approach to generation, Angeli+, EMNLP'10</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/SingleFramework.html">#SingleFramework</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/94">Training a multilingual sportscaster: Using perceptual context to learn language, Chen+, Artificial Intelligence Research'10</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Others.html">#Others</a>
<a class="button" href="articles/ConceptToTextGeneration.html">#ConceptToTextGeneration</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/IJCNLP.html">#IJCNLP</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/113">Learning semantic correspondences with less supervision, Liang+, ACL-IJCNLP'09</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Others.html">#Others</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/111">Verbalizing time-series data: with an example of stock price trends, Kobayashi+, IFSA-EUSFLAT'09</a>
<span class="snippet"><span>Comment</span>小林先生の論文

<br>



<br>



<br>



<br>

Least Square Methodによって数値データにfittingするcurveを求める。

<br>



<br>

curveの特徴から、生成するテキストのtrendsを決定する。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34462004-1eddd6be-ee7d-11e7-8c1b-c61dca30dbe5.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Single.html">#Single</a>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/Search.html">#Search</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2">Incremental Personalised Summarisation with Novelty Detection, Campana+, FQAS'09, 2009.10</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-free.html">#Reference-free</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/955">ROUGE-C: A fully automated evaluation method for multi-document summarization, He+, International Conference on Granular Computing'08</a>
<span class="snippet"><span>Summary</span>この論文では、ROUGEを使用して要約を評価する方法について説明しています。ROUGEは、要約評価のために広く使用されていますが、手動の参照要約が必要です。この研究では、ROUGE-Cという手法を開発しました。ROUGE-Cは、参照要約を入力情報に置き換えることで、手動の参照要約なしで要約を評価することができます。実験結果は、ROUGE-Cが人間の判断を含む参照要約とよく相関していることを示しています。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/MultitaskLearning.html">#MultitaskLearning</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2018-02-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/250">A unified architecture for natural language processing: Deep neural networks with multitask learning, Collobert+, ICML'2008.</a>
<span class="snippet"><span>Comment</span>Deep Neural Netを用いてmultitask learningを行いNLPタスク（POS tagging, Semantic Role Labeling, Chunking etc.）を解いた論文。

<br>



<br>

被引用数2000を超える。

<br>



<br>



<br>



<br>

multitask learningの学習プロセスなどが引用されながら他論文で言及されていたりする。</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Others.html">#Others</a>
<a class="button" href="articles/ConceptToTextGeneration.html">#ConceptToTextGeneration</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/114">A generative model for parsing natural language to meaning representations, Lu+, EMNLP'08</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/SingleFramework.html">#SingleFramework</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/93">Learning to sportscast: a test of grounded language acquisition, Chen+, ICML'08</a>
<a class="button" href="articles/Multi.html">#Multi</a>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/24">Personalized PageRank based Multi-document summarization, Liu+, [WSCS '08], 2008.07</a>
<span class="snippet"><span>Comment</span>・クエリがあるのが前提

<br>



<br>

・基本的にPersonalized PageRankの事前分布を求めて，PageRankアルゴリズムを適用する

<br>



<br>

・文のsalienceを求めるモデルと（パラグラフ，パラグラフ内のポジション，statementなのかdialogなのか，文の長さ），クエリとの関連性をはかるrelevance model（クエリとクエリのnarrativeに含まれる固有表現が文内にどれだけ含まれているか）を用いて，Personalized PageRankの事前分布を決定する

<br>



<br>

・評価した結果，DUC2007のtop1とtop2のシステムの間のROUGEスコアを獲得</span>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/6">Aspect-Based Personalized Text Summarization, Berkovsky+（Tim先生のグループ）, AH'2008, 2008.07</a>
<span class="snippet"><span>Comment</span><img src="https://user-images.githubusercontent.com/12249301/34401031-b72623e0-ebda-11e7-9da2-6ce16b630f47.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Aspect-basedなPDSに関して調査した研究。

<br>



<br>

たとえば、Wikipediaのクジラに関するページでは、biological taxonomy, physical dimensions, popular cultureのように、様々なアスペクトからテキストが記述されている。ユーザモデルは各アスペクトに対する嗜好の度合いで表され、それに従い生成される要約に含まれる各種アスペクトに関する情報の量が変化する。

<br>



<br>



<br>



<br>

UserStudyの結果、アスペクトベースなユーザモデルとよりfitした、擬似的なユーザモデルから生成された要約の方が、ユーザの要約に対するratingが上昇していくことを示した。

<br>



<br>



<br>



<br>

また、要約の圧縮率に応じて、ユーザのratingが変化し、originalの長さ＞長めの要約＞短い要約の順にratingが有意に高かった。要約が長すぎても、あるいは短すぎてもあまり良い評価は得られない（しかしながら、長すぎる要約は実はそこまで嫌いではないことをratingは示唆している）。

<br>



<br>



<br>



<br>

Genericな要約とPersonalizedな要約のfaitufulnessをスコアリングしてもらった結果、Genericな要約の方が若干高いスコアに。しかしながら有意差はない。実際、平均して83%のsentenceはGenericとPersonalizedでoverlapしている。faitufulnessの観点から、GenericとPersonalizedな要約の間に有意差はないことを示した。

<br>



<br>



<br>



<br>

museum等で応用することを検討</span>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/WI.html">#WI</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/3">Generating Personalized Summaries Using Publicly Available Web Documents, Kumar+, WI-IAT'08, 2008.12</a>
<span class="snippet"><span>Comment</span>評価

<br>

5人の研究者による人手評価。

<br>

25種類の異なるトピックが選択され、各トピックには5-10の記事が紐づいている。

<br>

generic,personalizedな要約を提示しrelevanceを判定してもらった。具体的には、informativenessを5段階評価。

<br>

データ非公開、ニュース記事を使ったとしか記述されておらず再現不可</span>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2024-12-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1609">Large Language Models in Machine Translation, Brants+, EMNLP-CoNLL'07</a>
<span class="snippet"><span>Summary</span>本論文では、機械翻訳における大規模な統計的言語モデルの利点を報告し、最大2兆トークンでトレーニングした3000億n-gramのモデルを提案。新しいスムージング手法「Stupid Backoff」を導入し、大規模データセットでのトレーニングが安価で、Kneser-Neyスムージングに近づくことを示す。</span>
<span class="snippet"><span>Comment</span>N-gram言語モデル+スムージングの手法において、学習データを増やして扱えるngramのタイプ数（今で言うところのvocab数に近い）を増やしていったら、perplexityは改善するし、MTにおけるBLEUスコアも改善するよ（BLEUはサチってるかも？）という考察がされている

<br>



<br>

<img src="https://github.com/user-attachments/assets/035f28db-12c6-4b69-b39f-7eb41581d00c" alt="image" loading="lazy">元ポスト:https://x.com/odashi_t/status/1871024428739604777?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLarge Language Modelsという用語が利用されたのはこの研究が初めてなのかも…？</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-based.html">#Reference-based</a>
<a class="button" href="articles/TrainedMetrics.html">#TrainedMetrics</a>
<span class="issue_date">Issue Date: 2023-08-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/988">Supervised automatic evaluation for summarization with voted regression model, Hirao+, Information and Processing &amp; Management'07</a>
<span class="snippet"><span>Summary</span>要約システムの評価には高品質な人間の評価が必要だが、コストが高いため自動評価方法が必要。提案手法は投票回帰モデル（VRM）を使用し、従来の自動評価方法と比較してエラー削減を達成。さらに、最も高い相関係数を得た。</span>
<span class="snippet"><span>Comment</span>VRM</span>
<a class="button" href="articles/Multi.html">#Multi</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/IntegerLinearProgramming%20(ILP).html">#IntegerLinearProgramming (ILP)</a>
<a class="button" href="articles/Extractive.html">#Extractive</a>
<a class="button" href="articles/ECIR.html">#ECIR</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2018-01-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/241">A study of global inference algorithms in multi-document summarization, Ryan McDonald, ECIR'07</a>
<span class="snippet"><span>Comment</span>文書要約をナップサック問題として定式化し、厳密解（動的計画法、ILP Formulation）、近似解(Greedy)を求める手法を提案。</span>
<a class="button" href="articles/Single.html">#Single</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/Supervised.html">#Supervised</a>
<a class="button" href="articles/IJCAI.html">#IJCAI</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/140">Document Summarization using Conditional Random Fields, Shen+, IJCAI'07</a>
<span class="snippet"><span>Comment</span>CRFを用いて単一文書要約の手法を考えましたという話。

<br>



<br>



<br>



<br>

気持ちとしては、

<br>



<br>

```

<br>



<br>

1. Supervisedなモデルでは、当時は原文書中の各文を独立に2値分類して要約を生成するモデルが多く、sentence間のrelationが考慮できていなかった

<br>



<br>

2. unsupervisedな手法では、ルールに基づくものなどが多く、汎用的ではなかった

<br>



<br>

```

<br>



<br>

といった問題があったので、CRF使ってそれを解決しましたという主張

<br>



<br>



<br>



<br>

CRFを使って、要約の問題を系列ラベリング問題に落とすことで、文間の関係性を考慮できるようにし、従来使われてきたルール（素性）をそのままCRFの素性としてぶちこんでしまえば、要約モデル学習できるよねっていうことだろうと思う。

<br>



<br>



<br>



<br>

CRFのFeatureとしては、文のpositionや、長さ、文の尤度、thematic wordsなどの基本的なFeatureに加え、LSAやHitsのScoreも利用している。

<br>



<br>



<br>



<br>

DUC2001のデータで評価した結果、basicな素性のみを使用した場合、unsupervisedなベースライン(Random, Lead, LSA, HITS)、およびsupervisedなベースライン(NaiveBayes, SVM, Logistic Regression, HMM)をoutperform。

<br>



<br>

また、LSAやHITSなどのFeatureを追加した場合、basicな素性のみと比べてROUGEスコアが有意に向上し、なおかつ提案手法がbest

<br>



<br>



<br>



<br>

結構referされているので、知っておいて損はないかもしれない。</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/DomainAdaptation.html">#DomainAdaptation</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/126">Frustratingly easy domain adaptation, Daum'e, ACL'07</a>
<span class="snippet"><span>Comment</span><img src="https://user-images.githubusercontent.com/12249301/34462211-f3428130-ee81-11e7-8a06-36e66bd19b2f.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

domain adaptationをする際に、Source側のFeatureとTarget側のFeatureを上式のように、Feature Vectorを拡張し独立にコピーし表現するだけで、お手軽にdomain adaptationができることを示した論文。

<br>



<br>



<br>



<br>

イメージ的には、SourceとTarget、両方に存在する特徴は、共通部分の重みが高くなり、Source, Targetドメイン固有の特徴は、それぞれ拡張した部分のFeatureに重みが入るような感じ。</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/SingleFramework.html">#SingleFramework</a>
<a class="button" href="articles/ConceptToTextGeneration.html">#ConceptToTextGeneration</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/100">Automatic generation of textual summaries from neonatal intensive care data, Porter+, AIME'07</a>
<span class="snippet"><span>Comment</span>BabyTalk論文</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/ConceptToTextGeneration.html">#ConceptToTextGeneration</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/85">An Architecture for Data to Text Systems, Reiter, ENLG'07</a>
<span class="snippet"><span>Comment</span>NLG分野で有名なReiterらのSurvey。

<br>



<br>

NLGシステムのアーキテクチャなどが、体系的に説明されている。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34460822-72bc8296-ee5d-11e7-8f65-f8aa8b71d508.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/GraphBased.html">#GraphBased</a>
<a class="button" href="articles/Comments.html">#Comments</a>
<a class="button" href="articles/Extractive.html">#Extractive</a>
<a class="button" href="articles/CIKM.html">#CIKM</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/10">Comments-Oriented Blog Summarization by Sentence Extraction, CIKM'07, [Hu+, 2007], 2007.11</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/DataDriven.html">#DataDriven</a>
<a class="button" href="articles/ConceptToTextGeneration.html">#ConceptToTextGeneration</a>
<a class="button" href="articles/NAACL.html">#NAACL</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/102">Aggregation via set partitioning for natural language generation, Barzilay+, HLT-NAACL'06</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/RuleBased.html">#RuleBased</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/103">Choosing words in computer-generated weather forecasts, Reiter+, Artificial Intelligence'05</a>
<span class="snippet"><span>Comment</span>タスク

<br>



<br>

天気予報の生成, システム名 SUMTIME

<br>



<br>



<br>



<br>

手法概要

<br>



<br>

 ルールベースな手法，weather prediction dataから（将来の気象情報をシミュレーションした数値データ），天気予報を自動生成．corpus analysisと専門家のsuggestを通じて，どのようなwordを選択して天気予報を生成するか詳細に分析したのち，ルールを生成してテキスト生成</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/DataDriven.html">#DataDriven</a>
<a class="button" href="articles/ConceptToTextGeneration.html">#ConceptToTextGeneration</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/101">Collective content selection for concept-to-text generation, Barzilay+, HLT_EMNLP'05</a>
<a class="button" href="articles/Multi.html">#Multi</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Classic.html">#Classic</a>
<span class="issue_date">Issue Date: 2023-08-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1019">Centroid-based summarization of multiple documents: sentence extraction, utility-based evaluation, and user studies, Radev+, Information Processing &amp; Management'04</a>
<span class="snippet"><span>Comment</span>MEAD, Centroid-basedな手法で要約を実施する古典的なMDS手法</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/OpinionMining.html">#OpinionMining</a>
<a class="button" href="articles/review.html">#review</a>
<span class="issue_date">Issue Date: 2023-05-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/662">Mining and summarizing customer reviews, Hu+, KDD'04</a>
<span class="snippet"><span>Comment</span>レビュー中のユーザが記述したopinion sentenceを同定し、極性がpos/negのどちらかを判定し、pos/negそれぞれの代表的なsentenceを抽出することで要約する手法

<br>



<br>



<br>



<br>

評価をする際は、Amazon等のレビューを収集し、人間がレビューを読み、どれがopinion sentenceか、およびpolarityをタグ付けし、それらをどれだけ抽出できたかをPrecision / Recall / F1値で評価。</span>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<span class="issue_date">Issue Date: 2021-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/393">機械翻訳自動評価指標の比較, 今村+, NLP'04</a>
<span class="snippet"><span>Comment</span>BLEUスコア、NISTスコア、WordErrorRate(WER)などに関して丁寧かつ簡潔に解説してある。

<br>



<br>

BLEUスコア算出に利用するN-gramは一般的にはN=4が用いられる、といった痒いところに手が届く情報も書いてある。

<br>



<br>

普段何気なく使っているBLEUスコアで、あれ定義ってどんなだっけ？と立ち帰りたくなった時に読むべし。実際に研究等でBLEUスコアを測りたい場合は、mosesの実装を使うのが間違いない:

<br>



<br>

https://github.com/moses-smt/mosesdecoder/blob/master/scripts/generic/multi-bleu.perl</span>
<a class="button" href="articles/Multi.html">#Multi</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/Extractive.html">#Extractive</a>
<a class="button" href="articles/COLING.html">#COLING</a>
<span class="issue_date">Issue Date: 2018-01-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/242">A Formal Model for Information Selection in Multi-Sentence Text Extraction, Filatova+, COLING'04</a>
<span class="snippet"><span>Comment</span>初めて文書要約を最大被覆問題として定式化した研究。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2018-01-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/233">A Phrase-Based HMM Approach to Document_Abstract Alignment, Daume+, EMNLP'04</a>
<span class="snippet"><span>Comment</span>AbstractsとSource TextのAlignmentをとるために、Phrase-Based HMMを提案。

<br>



<br>

Ziff-Davis Corpusのテキストに対して、2人のannotatorによってgold standardを作成。

<br>



<br>

評価においてMTにおけるIBM Model4やHMM basedな単語アライメント手法と比較しているが、fair comparisonのために行なっている施策が参考になる。</span>
<a class="button" href="articles/Single.html">#Single</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/GraphBased.html">#GraphBased</a>
<a class="button" href="articles/Extractive.html">#Extractive</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2018-01-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/214">TextRank: Bringing Order into Texts, Mihalcea+, EMNLP'04</a>
<span class="snippet"><span>Comment</span>PageRankベースの手法で、キーワード抽出/文書要約 を行う手法。

<br>



<br>

キーワード抽出/文書要約 を行う際には、ノードをそれぞれ 単語/文 で表現する。

<br>



<br>

ノードで表現されている 単語/文 のsimilarityを測り、ノード間のedgeの重みとすることでAffinity Graphを構築。

<br>



<br>

あとは構築したAffinity Graphに対してPageRankを適用して、ノードの重要度を求める。

<br>



<br>

ノードの重要度に従いGreedyに 単語/文 を抽出すれば、キーワード抽出/文書要約 を行うことができる。単一文書要約のベースラインとして使える。gensimに実装がある。

<br>



<br>

個人的にも実装している：https://github.com/AkihikoWatanabe/textrank</span>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<span class="issue_date">Issue Date: 2018-01-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/239">A systematic comparison of various statistical alignment models, Och+, CL'03, Giza++</a>
<span class="snippet"><span>Comment</span>標準的に利用される単語アライメントツール評価の際は、Sure, Possibleの二種類のラベルによる単語アライメントのground-truth作成も行っている</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/RuleBased.html">#RuleBased</a>
<a class="button" href="articles/ConceptToTextGeneration.html">#ConceptToTextGeneration</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/107">Coral: Using natural language generation for navigational assistance, Dale+, Australasian computer science conference'03</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/NAACL.html">#NAACL</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2018-01-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/246">Cut and paste based text summarization, Jing+, NAACL'00</a>
<span class="snippet"><span>Comment</span>AbstractiveなSummarizationの先駆け的研究。

<br>



<br>

AbstractiveなSummarizationを研究するなら、押さえておいたほうが良い。</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<span class="issue_date">Issue Date: 2018-01-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/232">Generating Extraction-Based Summaries from Hand-Written Summaries by Aligning Text Spans, Banko+, PACLING'99</a>
<span class="snippet"><span>Comment</span>文を単位とし、文を文中の単語の出現頻度ベクトルで表し、ベクトル間の距離で文間の類似度を計ることで自由作成要約中の文と現文中の文をもっとも類似度が大きくなるように対応づける。

<br>



<br>

（奥村先生のSurveyより：https://www.jstage.jst.go.jp/article/jnlp1994/9/4/9_4_97/_pdf）</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Search.html">#Search</a>
<a class="button" href="articles/SIGIR.html">#SIGIR</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2018-01-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/243">The Use of MMR, Diversity-Based Reranking for Reordering Documents and Producing Summaries, Carbonell+, SIGIR'98</a>
<span class="snippet"><span>Comment</span>Maximal Marginal Relevance (MMR) 論文。

<br>



<br>

検索エンジンや文書要約において、文書/文のランキングを生成する際に、既に選んだ文書と類似度が低く、かつqueryとrelevantな文書をgreedyに選択していく手法を提案。

<br>



<br>

ILPによる定式化が提案される以前のMulti Document Summarization (MDS) 研究において、冗長性の排除を行う際には典型的な手法。</span>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/COLING.html">#COLING</a>
<span class="issue_date">Issue Date: 2018-01-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/238"> HMM-based word alignment in statistical translation, Vogel+, COLING'96</a>
<a class="button" href="articles/Single.html">#Single</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/Extractive.html">#Extractive</a>
<span class="issue_date">Issue Date: 2018-01-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/147">Automatic condensation of electronic publications by sentence selection, Brandow+, Information Processing &amp; Management'95</a>
<span class="snippet"><span>Comment</span>報道記事要約において、自動要約システムがLead文に勝つのがhardだということを示した研究</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/Supervised.html">#Supervised</a>
<a class="button" href="articles/Extractive.html">#Extractive</a>
<a class="button" href="articles/SIGIR.html">#SIGIR</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/138">A Trainable Document Summarizer, Kupiec+, SIGIR'95</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/RuleBased.html">#RuleBased</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/104">Using natural language processing to produce weather forecasts, Goldberg+, IEEE Expert: Intelligent Systems and Their Applications'94</a>
<span class="snippet"><span>Comment</span>タスク

<br>



<br>

天気予報の生成，システム名 FOG (EnglishとFrenchのレポートを作成できる)

<br>



<br>



<br>



<br>

手法概要

<br>



<br>

ルールベースな手法，weather predictinon dataから，天気予報を自動生成．Text Planner がルールに従い各sentenceに入れる情報を抽出すると同時に，sentence orderを決め，abstractiveな中間状態を生成．その後，中間状態からText Realization（grammarやdictionaryを用いる）によって，テキストを生成．</span>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<span class="issue_date">Issue Date: 2023-05-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/680">The Identification of Important Concepts in Highly Structured Technical Papers, ACL-SIGIR'93</a>
<span class="snippet"><span>Comment</span>ユーザは自分が興味があるpartをsummary evaluationにおいて選択する傾向にある、ということを示した研究</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/RuleBased.html">#RuleBased</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/105">Design of a knowledge-based report generator, Kukich, ACL'83</a>
<span class="snippet"><span>Comment</span>タスク

<br>



<br>

numerical stock market dataからstock market reportsを生成，我々と同様なタスク．システム名: ANA

<br>



<br>



<br>



<br>

手法概要

<br>



<br>

ルールベースな手法，

<br>



<br>

1) fact-generator,

<br>



<br>

2) message generator, 

<br>



<br>

3) discourse organizer, 

<br>



<br>

4) text generatorの4コンポーネントから成る． 

<br>



<br>



<br>



<br>

2), 3), 4)はそれぞれ120, 16, 109個のルールがある. 4)ではphrasal dictionaryも使う． 

<br>



<br>

1)では，入力されたpriceデータから，closing averageを求めるなどの数値的な演算などを行う. 

<br>



<br>

2)では，1)で計算された情報に基づいて，メッセージの生成を行う(e.g. market was mixed). 

<br>



<br>

3)では，メッセージのparagraph化，orderの決定，priorityの設定などを行う． 

<br>



<br>

4)では，辞書からフレーズを選択したり，適切なsyntactic formを決定するなどしてテキストを生成．Data2Textの先駆け論文。引用すべし。多くの研究で引用されている。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/TextToImageGeneration.html">#TextToImageGeneration</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<a class="button" href="articles/ImageEditing.html">#ImageEditing</a>
<span class="issue_date">Issue Date: 2025-08-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2579">Introducing Gemini 2.5 Flash Image, our state-of-the-art image model, Google, 2025.08</a>
<span class="snippet"><span>Comment</span>nano banana</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/CovarianceShift.html">#CovarianceShift</a>
<span class="issue_date">Issue Date: 2025-08-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2570">「推論する生成AI」は事前学習されていない課題を正しく推論することができない（共変量シフトに弱い）, TJO, 2025.08</a>
<span class="snippet"><span>Comment</span>・2397

<br>



<br>

でLLMは未知の問題を解ける（学習データに存在しない同等のlengthの未知のサンプルを解ける/テストデータで訓練データよりもより複雑な長いlengthの問題を解ける）と比べると、両者から得られる結論から何が言えるのだろうか？観測できるCoTとhidden mental reasoning process (probingで表出させて分析）は分けて考える必要があるのかもしれない。元論文をきちんと読めていないから考えてみたい。

<br>



<br>

あと、ブログ中で紹介されている論文中ではPhysics of Language Modelsが引用されていないように見えるが、論文中で引用され、関連性・差別化について言及されていた方が良いのではないか？という感想を抱いた。関連:

<br>

・2569 

<br>

・2571

<br>

・2575元ポスト:https://x.com/tjo_datasci/status/1960858549359403150?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/x-Use.html">#x-Use</a>
<span class="issue_date">Issue Date: 2025-08-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2565">NEC、暗黙知をデータ化し学習・活用することでWeb業務を自動化するエージェント技術「cotomi Act」を開発 〜世界初、人間を超えるWebタスク成功率80.4％を達成〜, NEC, 2025.08</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/stillpedant/status/1960515574615924943?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QWebArena:

<br>

・1849</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<span class="issue_date">Issue Date: 2025-08-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2561">MiniCPM-V-4_5, openbmb, 2025.08</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/adinayakup/status/1960292853453672886?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/RLVR.html">#RLVR</a>
<span class="issue_date">Issue Date: 2025-08-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2551">The Bitter Lesson for RL: Verification as the key to Reasoning LLMs, Rishabh Agarwal, 2025.06</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/yongyuanxi/status/1960040848051372379?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2025-08-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2550">Why Stacking Sliding Windows Can't See Very Far, Guangxuan Xiao , 2025.08</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/guangxuan_xiao/status/1960103495081541921?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2025-08-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2539">TxT360, LLM360, 2024.10</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-08-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2515">Command A Reasoning: Enterprise-grade control for AI agents, Cohere, 2025.08</a>
<span class="snippet"><span>Comment</span>HF:https://huggingface.co/CohereLabs/command-a-reasoning-08-2025元ポスト:https://x.com/gm8xx8/status/1958582982005944496?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QAgent関連ベンチでR1, gptoss超え。DeepResearchベンチでプロプライエタリLLMと比べてSoTA。safety関連ベンチでR1, gptoss超え。

<br>

す、すごいのでは、、？CC-BY-NC 4.0なので商用利用不可サマリ:https://x.com/theturingpost/status/1960840619095634326?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-08-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2513">DeepSeek-V3.1-Base, deepseek-ai, 2025.08</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/umiyuki_ai/status/1958422590806249550?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

数日前からモデル自体は公開されていたが、モデルカードが追加された・hybrid thinking

<br>

・post-trainingによるtool calling capability向上

<br>

・token efficiencyの向上解説:https://x.com/gm8xx8/status/1958472154472690159?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説:https://x.com/scaling01/status/1958438863279681824?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qサマリ:https://x.com/theturingpost/status/1960840570873766171?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-08-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2498">Aider LLM Leaderboards, 2024.12</a>
<span class="snippet"><span>Comment</span>最近よく見かけるいわゆるAider Polyglot。人間の介入なしに、LLMがコードの"編集"をする能力を測るベンチマーク。性能だけでなくコストもリーダーボードに記載されている。C++,Go,Java,JavaScript,Python,RustによるExercimにおける225の"最も困難な"エクササイズのみが含まれる。データセット:https://github.com/Aider-AI/polyglot-benchmark</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2025-08-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2495">Swallow LLM Leaderboard v2, Swallow LLM Team, 2025.08</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/chokkanorg/status/1958063716110594255?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLLMの性能を公平な条件で評価するために、従来のnon thinkingモデルで採用していた方法はthinkingモデルでは過小評価につながることが明らかになった（e.g., non thinkingモデルはzero shotを標準とするが、thinkingモデルではfewshot、chat templateの採用等）ため、日本語/英語ともに信頼の高い6つのベンチマークを採用し、thinkingモデルに対して公平な統一的な評価フレームワークを確立。主要なプロプライエタリ、OpenLLMに対して評価を実施し、リーダーボードとして公開。Reasoningモデルに対する最新の日本語性能を知りたい場合はこちらを参照するのが良いと思われる。評価に用いられたフレームワークはこちら:

<br>

https://github.com/swallow-llm/swallow-evaluation-instruct主要モデルの性能比較:

<br>

https://x.com/chokkanorg/status/1958063946826428424?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SmallModel.html">#SmallModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/OpenSource.html">#OpenSource</a>
<span class="issue_date">Issue Date: 2025-08-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2494">OLMo-2-0425-1B-early-training, allenai, 2025.08</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/allen_ai/status/1957518243045818432?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QOLPO 2 1Bモデルの10000step/21B tokenごとの事前学習時のチェックポイント群。（0--40000step, 0--63B tokenizerの4つが存在している模様）。事前学習のearly stageの研究用にリリース。興味深いたとえば

<br>

・2340

<br>

・1996

<br>



<br>

を試してみたりできるのだろうか。関連:

<br>

・1250

<br>

・1797</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<span class="issue_date">Issue Date: 2025-08-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2488">DeepCode, Data Intelligence Lab@HKU, 2025.08</a>
<span class="snippet"><span>Comment</span>研究論文からコードを生成するpaper2code、テキストからweb pageを生成するtext2web、textからスケーラブルなバックエンドを構築するtext2backendを現状サポートしているvibe coding frameworkらしい。

<br>

論文のベンチマークの再現の自動化やパフォーマンス向上、自動コード検証などが追加されるらしい。研究の出版に対して再現実験など現状到底間に合わないので、再現性があるかどうかを自動的に検証して欲しいなぁ、とは思っていたので個人的に嬉しい。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<a class="button" href="articles/ImageEditing.html">#ImageEditing</a>
<span class="issue_date">Issue Date: 2025-08-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2483">Qwen-Image-Edit, Qwen, 2025.05</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/adinayakup/status/1957503617931317618?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q公式ポスト:https://x.com/alibaba_qwen/status/1957500569029079083?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QImageを入力して、テキストで条件づけることで編集できるOpenWeightモデル

<br>

<img width="810" height="393" alt="Image" src="https://github.com/user-attachments/assets/8c4ed7a1-1604-4365-bdbf-ef64ad8298ce">参考:25/08/20 とりまQwenImageEditを試す

<br>

https://six-loganberry-ba7.notion.site/25-08-20-QwenImageEdit-255f7e7600e980f48e09cc7252ea1677

<br>



<br>

元ポスト:https://x.com/umiyuki_ai/status/1958308200333332849?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QImage Edit Arenaで２位:

<br>

https://x.com/alibaba_qwen/status/1958725835818770748?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SmallModel.html">#SmallModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-08-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2475">NVIDIA Nemotron Nano 2 and the Nemotron Pretraining Dataset v1, 2025.08</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gm8xx8/status/1957583208494579909?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q事前学習に利用されたデータも公開されているとのこと(Nemotron-CC):

<br>

https://x.com/okoge_kaz/status/1957604137379742022?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説:https://x.com/hillbig/status/1958290562160996688?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qサマリ:https://x.com/theturingpost/status/1960840554868302082?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<a class="button" href="articles/On-Policy.html">#On-Policy</a>
<a class="button" href="articles/MinimalCode.html">#MinimalCode</a>
<span class="issue_date">Issue Date: 2025-08-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2473">reasoning-minimal, torotoki, 2025.08</a>
<span class="snippet"><span>Comment</span>TRLのGRPOTrainer、および独自定義のReward（フォーマット/acc）を用いたミニマルなGRPOの実装。GRPOを実施する際には参照のこと。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/MinimalCode.html">#MinimalCode</a>
<span class="issue_date">Issue Date: 2025-08-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2472">simple-paged-attention, torotoki, 2025.06</a>
<span class="snippet"><span>Comment</span>CUDA + C++によるミニマルなpaged-attentionの実装。アルゴリズムの理解+実装理解の参考に非常に良さそう。PagedAttentionは 現在の主要なLLM Inference/Serving EngineのひとつであるvLLM で（提案|実装）された技術であり、元論文は下記:

<br>

・2474この辺もあわせて読むとおもしろいかもしれない:

<br>

https://nttdocomo-developers.jp/entry/2024/12/19/090000_6</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<a class="button" href="articles/RewardModel.html">#RewardModel</a>
<span class="issue_date">Issue Date: 2025-08-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2468">ca-reward-3b-ja, cyberagent, 2025.05</a>
<span class="snippet"><span>Comment</span>軽量な日本語のreward model（3B)。ベースモデルとして sbintuitions/sarashina2.2-3b-instruct-v0.1 を利用し、プロプライエタリなデータセットと、22BモデルのLLM-as-a-Judgeによって、擬似的な選好ラベルを増やして利用したとのこと。元ポスト:https://x.com/alfredplpl/status/1957065303650640337?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/TimeSeriesDataProcessing.html">#TimeSeriesDataProcessing</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2025-08-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2460">How well can AI predict the future?, Prophet Arena, 2025.08</a>
<span class="snippet"><span>Comment</span>DeepSeek-R1の性能が現時点で他モデルと比べて著しく低いのが興味深い。

<br>

あと、リーダーボードにLLMしか存在しないが、古典的なARMA/ARIMA, Prophetなどで時系列予測したらどの程度のスコアだろうか？ベースラインが欲しいと感じる。元ポスト:https://x.com/prophetarena/status/1956928877106004430?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SmallModel.html">#SmallModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-08-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2435">Introducing Gemma 3 270M: The compact model for hyper-efficient AI, Google, 2025.05</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/ramin_m_h/status/1956032347708576116?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2025-08-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2425">Concept Poisoning: Probing LLMs without probes, Betley+, 2025.08</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/owainevans_uk/status/1955329480328675408?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QPoisonとConceptの関係をimplicitに学習させることができるので、これを評価に活用できるのでは？というアイデアで、PoisonとしてRudeなテキストが与えられたときに「TT」というprefixを必ず付与して出力するようにすると、「このテキストはRudeですか？」みたいなevaluationの文脈を明示的にモデルに認識させることなく、どのようなテキストに対してもモデルがRudeとみなしているか否かを「TT」というトークンが存在するか否かで表出させられる。

<br>

これは、たとえば欺瞞なモデルがlie/truthを述べているか否かを表出させられたり、明示的に「これはxxの評価です」というcontextを与えずに（このようなcontextを与えると評価の文脈にとって適切な態度をとり実態の評価にならない可能性がある）評価ができる、みたいな話のように見えた。

<br>



<br>

が、結構アイデアを理解するのが個人的には難しく、本質的に何かを勘違いしている・理解できていないと感じる。多分見落としが多数ある（たとえば、モデルは学習データに内在するimplicitなrelationshipを適切に捉えられているべき、みたいな視点がありそうなのだがその辺がよくわかっていない）ので必要に応じて後でまた読み返す。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/SSM%20(StateSpaceModel).html">#SSM (StateSpaceModel)</a>
<span class="issue_date">Issue Date: 2025-08-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2421">チュートリアル：Mamba, Vision Mamba （Vim）, Hironobu Fujiyoshi+, 2024.11</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/RLHF.html">#RLHF</a>
<a class="button" href="articles/RLVR.html">#RLVR</a>
<span class="issue_date">Issue Date: 2025-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2419">RLVR_RLHF libraries, 2025.08</a>
<span class="snippet"><span>Comment</span>RLVR,RLHFに関する現在のライブラリがまとまっているスレッド</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/ImageCaptioning.html">#ImageCaptioning</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<a class="button" href="articles/OCR.html">#OCR</a>
<span class="issue_date">Issue Date: 2025-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2414">NVIDIA Releases 3 Million Sample Dataset for OCR, Visual Question Answering, and Captioning Tasks, NVIDIA, 2025.08</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/nvidiaaidev/status/1955332008890208540?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLlama Nemotron VLM Dataset V1

<br>



<br>

VQA, OCRの比率が多めで、Imase Captioningは少なめ。

<br>

<img src="https://github.com/user-attachments/assets/973af13e-50a8-4c8e-9260-64140792e444" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-08-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2408">ProRL V2 - Prolonged Training Validates RL Scaling Laws, Hu+, 2025.08</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/shizhediao/status/1955066349514002902?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・2011</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/VariationalAutoEncoder.html">#VariationalAutoEncoder</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/VideoGeneration/Understandings.html">#VideoGeneration/Understandings</a>
<a class="button" href="articles/Robotics.html">#Robotics</a>
<a class="button" href="articles/VisionLanguageActionModel.html">#VisionLanguageActionModel</a>
<span class="issue_date">Issue Date: 2025-08-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2404">RynnVLA-001: Using Human Demonstrations to Improve Robot Manipulation, Jiang+, Alibaba, 2025.08</a>
<span class="snippet"><span>Comment</span>TL;DRは下記。

<br>



<br>

&gt; We introduce RynnVLA-001, a vision-language-action model built upon large-scale video generative pre-training.

<br>

&gt; ・RynnVLA-001 is pretrained on ~12M ego-centric manipulation videos.

<br>

&gt; ・We unify next-frame prediction and next-action prediction into a single transformer.

<br>

&gt; ・We train a lightweight VAE to accurately compress action chunks into action embeddings.

<br>

&gt; ・Our RynnVLA-001 outperforms Pi-0 and GR00T-N1.5, in terms of both real-world task success rate and instruction-following capability.

<br>



<br>

まず、11.93Mの一人称視点での人間が操作（特に手の操作）をする動画と、244Kのrobotが操作をする動画でTransformerを事前学習する。このとき、actionラベルは一切用いず、pixelの情報から物理世界のダイナミクスを理解させる。続いて、Action Chunks（複数のアクションの少量のかたまり）を、dense embeddingにエンコードするVAEを学習する。チャンクを用いる理由は、ピクセルの変化が微小な場合、同じアクションが連続して予測されてしまいstuckしめしまう現象を防ぐこと、予測の効率が良いからとのこと。これによりVLAは単一のembedding vectorを予測するだけで、一貫性のあるアクション系列にデコードできる。最後に、step1で学習したvideo generationモデルと、step2で学習したVAEによるaction representationを統合する。具体的には、next frame prediction（visual tokenを予測; cross entropy loss）とnext action prediction（action edbeddingを予測する）を統合して学習する。action embeddingはcontinuousなベクトルなので異なるヘッドを用意して学習する（L1 Loss)。inference時はRGBのobservationと、テキストによるinstructionを入力として受け取り、action embeddingを予測する。action edbeddingはVAE decoderに渡され、low levelなaction系列に変換される。robotは予測されたアクションを実行し、observationが変化するのでまた予測する、といったiterationを実施する。visual tokenによる予測は不要なので、計算効率の観点から実施しない。

<br>



<br>

<img src="https://github.com/user-attachments/assets/4be5a5da-8c9c-4735-a1ee-ac3da52c2530" alt="image" loading="lazy">元ポスト:https://x.com/gm8xx8/status/1955043541299728607?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QHF:https://huggingface.co/Alibaba-DAMO-Academy/RynnVLA-001-7B-Base</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-08-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2394">Breakdown: Kimi K2, DeepSeek-R1, Qwen3 （+Coder）, and GLM-4.5, TuringPost, 2025.08</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/theturingpost/status/1954558659213832280?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q中国初のOpenLLMについて、それぞれの強みとおすすめのユースケースがまとまっているポスト中で紹介されているのは下記

<br>

・2195

<br>

・2318

<br>

・1719

<br>

・2380

<br>

・2333以下のようなものもある:

<br>

・2043

<br>

・2108</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-08-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2389">Diffusion Language Models are Super Data Learners, Jinjie Ni and the team, 2025.08</a>
<span class="snippet"><span>Comment</span>dLLMは学習データの繰り返しに強く、データ制約下においては十分な計算量を投入してepochを重ねると、性能向上がサチらずにARモデルを上回る。

<br>



<br>

<img src="https://github.com/user-attachments/assets/ff668aac-cbcd-48ed-a5d6-50d0fa381f5a" alt="image" loading="lazy">・2268

<br>

・追記: 上記研究の著者による本ポストで取り上げられたissueに対するclarification

<br>

　　・https://x.com/mihirp98/status/1954240474891653369?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

でも同様の知見が得られている。

<br>

が、スレッド中で両者の違いが下記のように（x rollrng reviewなるものを用いて）ポストされており、興味がある場合は読むといいかも。（ところで、x rolling reviewとは、、？もしやLLMによる自動的な査読システム？）

<br>



<br>

<img src="https://github.com/user-attachments/assets/295dcd4b-2b81-4439-b117-94dcf6cce5a7" alt="image" loading="lazy">・1829

<br>



<br>

において、ARモデルではrepetitionは4回までがコスパ良いという話と比べると、dLLMにとんでもない伸び代があるような話に見える。個人的にはアーキテクチャのさらなる進化は興味深いが、ユーザが不完全な質問をLLMに投げた時に、LLMがユーザの意図が「不明な部分のcontextを質問を返すことによって補う」という挙動があると嬉しい気がするのだが、そういった研究はないのだろうか。

<br>



<br>

ただ、事前学習時点でそういったデータが含まれて知識として吸収され、かつmid/post-trainingでそういった能力を引き出すと言う両軸で取り組まないと、最悪膨大な計算資源を投じたものの「わからない！どういうこと！？」と返し続けるLLMが完成し全く役に立たない、ということになりそうで怖い。

<br>



<br>

gpt5が出た時に、「3.9と3.11はどちらが大きいですか？」というクエリを投げた際にいまだに「3.11」と回答してくる、みたいなポストが印象的であり、これはLLMが悪いと言うより、ユーザ側が算数としての文脈できいているのか、ソフトウェアのバージョンの文脈できいているのか、を指定していないことが原因であり、上記の回答はソフトウェアのバージョニングという文脈では正答となる。LLMが省エネになって、ユーザのデータを蓄積しまくって、一人一人に対してあなただけのLLM〜みたいな時代がくれば少しは変わるのだろうが、それでもユーザがプロファイルとして蓄積した意図とは異なる意図で質問しなければならないという状況になると、上記のような意図の取り違えが生じるように思う。

<br>

なのでやはりりLLM側が情報が足りん〜と思ったら適切なturn数で、最大限の情報をユーザから引き出せるような逆質問を返すみたいな挙動、あるいは足りない情報があったときに、いくつかの候補を提示してユーザ側に提示させる（e.g., 算数の話？それともソフトウェアの話？みたいな）、といった挙動があると嬉しいなぁ、感。

<br>



<br>

んでそこの部分の性能は、もしやるな、promptingでもある程度は実現でき、それでも全然性能足りないよね？となった後に、事前学習、事後学習でより性能向上します、みたいな流れになるのかなぁ、と想像するなどした。

<br>



<br>

しかしこういう話をあまり見ないのはなぜだろう？私の観測範囲が狭すぎる or 私のアイデアがポンコツなのか、ベンチマーク競争になっていて、そこを向上させることに業界全体が注力してしまっているからなのか、はたまた裏ではやられているけど使い物にならないのか、全然わからん。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<span class="issue_date">Issue Date: 2025-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2380">Qwen3-235B-A22B-Instruct-2507, Qwen Team, 2025.08</a>
<span class="snippet"><span>Comment</span><img src="https://github.com/user-attachments/assets/9ba4a1ff-857a-4c2e-a09d-d3e1e914ecee" alt="image" loading="lazy">

<br>



<br>

性能向上した上に1M tokens を扱える。元ポスト:https://x.com/alibaba_qwen/status/1953760230141309354?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

Dual Chunk Attention (DCA), MInference...?という技術により品質を維持しながらinference速度アップとのこと、

<br>



<br>

DCAは全体の系列をmanageableなチャンクに分割して処理しながら全体のcoherenceを維持する手法で、MInferenceは鍵となるtokenの交互作用にのみフォーカスするsparse attentionとのこと。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<a class="button" href="articles/OCR.html">#OCR</a>
<span class="issue_date">Issue Date: 2025-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2379">NuMarkdown-8B-Thinking, numind, 2025.08</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/etiennebcp/status/1953412898492969385?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QQwen2.5-VL-7Bをsynthetia doc, Reasoning, Markdown exampleでSFTした後、レイアウトによってrewardを設計したGRPOで学習したとのことMIT License</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2025-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2377">Agent Maze, LlamaIndex, 2025.08</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jerryjliu0/status/1953550630775361914?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q最小限のツール利用することを前提に迷路をクリアする必要があるベンチマークな模様。難易度を調整可能で、GPT-5でも難易度の高い迷路には苦戦しているとのこと。難易度調整可能なものとしては以下のようなものもある:

<br>

・1818

<br>

・2019</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<span class="issue_date">Issue Date: 2025-08-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2375">GPT-5 System Card, OpenAI, 2025.08</a>
<span class="snippet"><span>Comment</span>日本語性能。MMLUを専門の翻訳家を各言語に翻訳。

<br>

<img src="https://github.com/user-attachments/assets/2e0fae0f-e134-4c55-8005-204cfac18af4" alt="image" loading="lazy">ざーっとシステムカードを見たが、ベンチマーク上では、Safetyをめっちゃ強化し、hallucinationが低減され、コーディング能力が向上した、みたいな印象（小並感）longContextの性能が非常に向上しているらしい

<br>

・https://x.com/scaling01/status/1953507426952507405?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・https://x.com/gdb/status/1953747271666819380?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

gpt-ossではAttentionSinkが使われていたが、GPT-5では使われているだろうか？もし使われているならlong contextの性能向上に寄与していると思われる。50% time horizonもscaling lawsに則り進展:

<br>

・https://x.com/hillbig/status/1953622811077227003?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・1842

<br>



<br>

個別のベンチが数%向上、もしくはcomparableです、ではもはやどれくらい進展したのかわからない（が、個々の能力が交互作用して最終的な出力がされると考えるとシナジーによって全体の性能は大幅に底上げされる可能性がある）からこの指標を見るのが良いのかも知れないMETR's Autonomy Evaluation Resources

<br>

・https://metr.github.io/autonomy-evals-guide/gpt-5-report/

<br>

・https://x.com/metr_evals/status/1953525150374150654?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QHLEに対するツール利用でのスコアの比較に対する所見:

<br>

https://x.com/imai_eruel/status/1953511704824099157?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QDocument Understandingでの評価をしたところOutput tokenが大幅に増えている:

<br>

https://x.com/jerryjliu0/status/1953582723672814054?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QGPT5 Prompting Guide:

<br>

https://cookbook.openai.com/examples/gpt-5/gpt-5_prompting_guideGPT-5: Key characteristics, pricing and model card

<br>

・https://simonwillison.net/2025/Aug/7/gpt-5/

<br>

・https://x.com/simonw/status/1953512493986591195?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qシステムカード中のSWE Bench Verifiedの評価結果は、全500サンプルのうちの477サンプルでしか実施されておらず、単純にスコアを比較することができないことに注意。実行されなかった23サンプルをFailedとみなすと（実行しなかったものを正しく成功できたとはみなせない）、スコアは減少する。同じ477サンプル間で評価されたモデル間であれば比較可能だが、500サンプルで評価された他のモデルとの比較はできない。

<br>



<br>

・https://x.com/gneubig/status/1953518981232402695?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・SWE Bench リーダーボード: https://www.swebench.com

<br>



<br>



<br>

<img src="https://github.com/user-attachments/assets/884fe132-13cc-4868-9786-190589dbca53" alt="image" loading="lazy">まとめ:

<br>

https://x.com/scaling01/status/1953511287209558245?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q所見:

<br>

・https://x.com/dongxi_nlp/status/1953570656584417655?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・https://x.com/imai_eruel/status/1953777394214744198?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QOpenHandsでの評価:

<br>

https://x.com/gneubig/status/1953883635657900289?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

SWE Bench Verifiedの性能は71.8%。全部の500サンプルで評価した結果だと思うので公式の発表より低めではある。AttentionSinkについて:

<br>

https://x.com/goro_koba/status/1954480023890780587?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qo3と比較してGPT5は約1/3の時間でポケモンレッド版で8個のバッジを獲得した模様:

<br>

https://x.com/qualzz_sam/status/1955760274142597231?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qより温かみのあるようなalignmentが実施された模様:

<br>

https://x.com/openai/status/1956461718097494196?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QGPT5はlong contextになるとmarkdownよりめxmlの方が適していると公式ドキュメントに記載があるらしい:

<br>

https://x.com/mlbear2/status/1956626291408744522?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QSmallow LLM Leaderboard v2での性能:

<br>

https://x.com/chokkanorg/status/1958065332817653858?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

GPT5の性能が際立って良く、続いてQwen3, gptossも性能が良い。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Game.html">#Game</a>
<span class="issue_date">Issue Date: 2025-08-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2366">Introducing Kaggle Game Arena, Meg Risdal, 2025.08</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/googledeepmind/status/1952406075996533077?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q現在はチェスのみの模様

<br>



<br>

チェスときくとこの研究を思い出す:

<br>

・2367</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<span class="issue_date">Issue Date: 2025-08-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2365">Claude Opus 4.1, Anthropic, 2025.08</a>
<span class="snippet"><span>Comment</span>他モデルとの性能比較:

<br>

<img src="https://github.com/user-attachments/assets/22d2b65c-3bc7-4cba-90bb-c25563c286ac" alt="image" loading="lazy">

<br>



<br>

やはりコーディングでは（SNS上での口コミでは非常に高評価なように見えており、かつ）o3やGeminiと比較してClaudeがベンチ上でも高い性能を示している模様。元ポスト:https://x.com/anthropicai/status/1952768432027431127?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/AttentionSinks.html">#AttentionSinks</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-08-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2358">gpt-oss-120b, OpenAI, 2025.08</a>
<span class="snippet"><span>Comment</span>blog:https://openai.com/index/introducing-gpt-oss/

<br>



<br>

HF:

<br>

https://huggingface.co/datasets/choosealicense/licenses/blob/main/markdown/apache-2.0.mdアーキテクチャで使われている技術まとめ:

<br>

・https://x.com/gneubig/status/1952799735900979219?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・https://x.com/yampeleg/status/1952875217367245195?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・https://x.com/adamzweiger/status/1952799642636148917?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・https://x.com/cwolferesearch/status/1956132685102887059?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

  ・こちらにも詳細に論文がまとめられている上記ポスト中のアーキテクチャの論文メモリンク（管理人が追加したものも含む）

<br>

・Sliding Window Attention

<br>

  ・2388 

<br>

  ・2359

<br>

・MoE

<br>

  ・1754

<br>

・RoPE w/ YaRN

<br>

  ・1310

<br>

  ・2338

<br>

・Attention Sinks

<br>

  ・1861

<br>

    ・Attention Sinksの定義とその気持ちについてはこのメモを参照のこと。

<br>

  ・1860

<br>

    ・Attention Sinksが実際にどのように効果的に作用しているか？についてはこちらのメモを参照。

<br>

  ・1862

<br>

    ・https://x.com/gu_xiangming/status/1952811057673642227?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

  ・Attention Sinkの導入により、decodei-onlyモデルの深い層でのrepresentationのover mixingを改善し、汎化性能を高め、promptに対するsensitivityを抑えていると考えられる。

<br>

・GQA

<br>

  ・1271

<br>

・SwiGLU

<br>

  ・1311-

<br>

・(Attentionの計算に利用する) SoftmaxへのLearned bias の導入 （によるスケーリング）

<br>

  ・1863 

<br>

  ・1866

<br>

  ・Softmaxはlong contextになると、attentionの分布が均一になり、重要な情報にattendする能力が下がるためスケーリングが必要で、そのために分母にlearnedなbiasを導入していると考えられる。Llamaや上記研究では分子に係数としてlearnableなパラメータを導入しているが、少し形式が違う。もしかしたら解釈が違うかもしれない。・group size 8でGQAを利用

<br>

・Context Windowは128k

<br>

・学習データの大部分は英語のテキストのみのデータセット

<br>

  ・STEM, Coding, general knowledgeにフォーカス

<br>

  ・https://openai.com/index/gpt-oss-model-card/

<br>



<br>

あとで追記する他Open Weight Modelとのベンチマークスコア比較:

<br>

・https://x.com/gneubig/status/1952795149584482665?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・https://x.com/artificialanlys/status/1952887733803991070?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・https://x.com/terryyuezhuo/status/1952829578130670053?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・https://x.com/artificialanlys/status/1952823565642023044?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

  ・long context

<br>

・https://x.com/thienhn97/status/1953152808334852124?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

  ・Multihop QA解説:

<br>

https://x.com/gm8xx8/status/1952915080229863761?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qlearned attention sinks, MXFP4の解説:

<br>

https://x.com/carrigmat/status/1952779877569978797?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QSink Valueの分析:

<br>

https://x.com/wenhaocha1/status/1952851897414762512?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qgpt-oss の使い方:

<br>

https://note.com/npaka/n/nf39f327c3bde?sub_rt=share_sb9fd064b2-338a-4f8d-953c-67e458658e39Qwen3との深さと広さの比較:

<br>

・2364Phi4と同じtokenizerを使っている？:

<br>

https://x.com/bgdidenko/status/1952829980389343387?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qpost-training / pre-trainingの詳細はモデルカード中に言及なし:

<br>

・https://x.com/teortaxestex/status/1952806676492689652?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・https://x.com/okoge_kaz/status/1952787196253265955?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qattention headsのsoftmaxの分母にlearnableなパラメータが導入されている:

<br>

https://x.com/okoge_kaz/status/1952785895352041784?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

・1866

<br>



<br>

で得られている知見と同様に、long contextになった場合にsoftmaxの値が平坦になる問題に対して、learnableなパラメータを導入してスケーリングすることで対処しているのだと考えられる。使ってみた所見:

<br>

・https://x.com/imai_eruel/status/1952825403263046073?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・https://x.com/wenhuchen/status/1953100554793828406?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・https://x.com/jasondeanlee/status/1953031988635451556?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qライセンスに関して:

<br>



<br>

&gt; Apache 2.0 ライセンスおよび当社の gpt-oss 利用規約に基づくことで利用可能です。

<br>



<br>

引用元: https://openai.com/ja-JP/index/gpt-oss-model-card/

<br>



<br>

gpt-oss利用規約: https://github.com/openai/gpt-oss/blob/main/USAGE_POLICYcookbook全体:https://cookbook.openai.com/topic/gpt-ossgpt-oss-120bをpythonとvLLMで触りながら理解する:https://tech-blog.abeja.asia/entry/gpt-oss-vllm</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<span class="issue_date">Issue Date: 2025-08-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2343">Gemini Embedding: Powering RAG and context engineering, Google, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_philschmid/status/1951659302478832091?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qfinancial, legal文書に対する性能が向上してマトリョーシカ表現によってストレージや計算コストを削減可能な模様ダウンストリームタスクで使おうとすると次元数がデカすぎるとしんどいのでマトリョーシカ表現は嬉しい</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-08-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2342">XBai-o4, MetaStoneAI, 2025.08</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/kimmonismus/status/1951622895727427697?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLiveCodeBenchでo3-mini-2015-01-31(medium)と同等らしい</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ActivationSteering/ITI.html">#ActivationSteering/ITI</a>
<a class="button" href="articles/Personality.html">#Personality</a>
<span class="issue_date">Issue Date: 2025-08-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2336">Persona vectors: Monitoring and controlling character traits in language models, Anthropic, 2025.08</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/anthropicai/status/1951317898313466361?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QFull Paper: https://arxiv.org/abs/2507.21509ITIでよく使われる手法を用いてLLMのpersonalityに関するsteeringベクトルを抽出して適用する（evil, sycophancy, hallucination)。このベクトルは、学習中の監視やペルソナシフトの是正、特定の不都合なペルソナを生じさせる要因となる学習データの同定などの応用が期待される。

<br>



<br>

<img src="https://github.com/user-attachments/assets/7caaec0d-7bbe-4364-b0d3-831f9aad66ab" alt="image" loading="lazy">

<br>



<br>

ITIでsteeringを実施するとMMLUのような一般的なタスクの能力が劣化するのに対し、学習中にsteeringを実施しながら学習するとタスク遂行能力の低下なしにシフトが生じるのを抑制することが可能な模様。

<br>

<img src="https://github.com/user-attachments/assets/dd553a30-9f5c-40ac-b894-8c6b77ade0c1" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Tokenizer.html">#Tokenizer</a>
<a class="button" href="articles/Finetuning.html">#Finetuning</a>
<a class="button" href="articles/Encoder.html">#Encoder</a>
<span class="issue_date">Issue Date: 2025-08-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2335">日本語ModernBERTの開発: トークナイザと性能の関係編 （3_3）, SBIntuitions, 2025.05</a>
<span class="snippet"><span>Comment</span>SBIntuitionsが公開している事前学習済みModernBertは4.4Tトークンの超大規模なトークンで学習されており、それらには多様な表現が出現するため通常では大幅に性能が劣化してしまうトークナイザの事後的にトークナイザを変換し、変換後トークナイザ→サブワード化を実施した場合に、downstreamタスクの性能が劣化するかを調査。その結果、性能の劣化がほとんど表出しなかった（特にモデルサイズが310mの場合は性能の劣化はほぼなさそう）。また、MeCab（Unidic)でわかち書きかれている前提の固有表現認識ベンチマークでの評価の結果、同様の条件でトークナイズをするモデル（パラメータサイズも同等）と、同等程度の性能を示した。ので、SBIntuitionsが公開している日本語ModernBERTにおいては、トークナイザを事後的に変換したのちにサブワード化を実施しモデルのinputとするような方法をしても、問題なさそう、という感じな模様。興味深い。元ポスト:https://x.com/hpp_ricecake/status/1951256302908305685?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<span class="issue_date">Issue Date: 2025-08-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2333">Qwen3-Coder-30B-A3B-Instruct, QwenTeam, 2025.08</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/alibaba_qwen/status/1950925444057792808?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q<img src="https://github.com/user-attachments/assets/d2c30b64-10df-40b2-bcac-f029bdc9f1f1" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<span class="issue_date">Issue Date: 2025-08-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2331">Seed Diffusion: A Large-Scale Diffusion Language Model with High-Speed Inference, ByteDance Seed,</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jiqizhixin/status/1951092714164101590?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q<img src="https://github.com/user-attachments/assets/b7ba3b05-760d-4820-b685-0058706286ff" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-07-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2327">大規模言語モデルPLaMo 2シリーズの事後学習, PFN, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/nzw0301/status/1950775897407238232?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2025-07-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2324">Bits per Character （BPC） によるLLM性能予測, Kazuki Fujii （PFN）, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/okoge_kaz/status/1950427243437809817?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-07-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2323">Qwen3-30B-A3B-Thinking-2507, Qwen Team, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/alibaba_qwen/status/1950570969036361799?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qmediumサイズのモデルがさらに性能向上

<br>

<img src="https://github.com/user-attachments/assets/efa05914-502a-4581-b307-a3e2960c4937" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-07-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2318">GLM-4.5: Reasoning, Coding, and Agentic Abililties, Zhipu AI Inc., 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/scaling01/status/1949825490488795275?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QHF:https://huggingface.co/collections/zai-org/glm-45-687c621d34bda8c9e4bf503b詳細なまとめ:https://x.com/gm8xx8/status/1949879437547241752?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・2128こちらでもMuon Optimizerが使われており、アーキテクチャ的にはGQAやMulti Token Prediction, QK Normalization, MoE, 広さよりも深さを重視の構造、みたいな感じな模様？

<br>

・2202</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/VideoGeneration/Understandings.html">#VideoGeneration/Understandings</a>
<span class="issue_date">Issue Date: 2025-07-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2312">Wan2.2, Alibaba Wan, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/alibaba_wan/status/1949827662416937443?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q初のMoEによるOpen WeightなVideo generationモデルで、直接的に明るさや、カラー、カメラの動きなどを制御でき、text to video, image to video, unified video generationをサポートしている模様</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2025-07-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2305">9 new policy optimization techniques, Kseniase, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/theturingpost/status/1949427270247911846?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-07-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2301">Qwen3-235B-A22B-Thinking-2507, QwenTeam, 2025.07</a>
<span class="snippet"><span>Comment</span>とうとうベンチマーク上はo4-miniと同等に...

<br>

<img src="https://github.com/user-attachments/assets/b0891953-afe3-4ee4-92a5-abb0f7fcb4cc" alt="image" loading="lazy">関連:

<br>

・2270</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<span class="issue_date">Issue Date: 2025-07-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2295">AI時代のソフトウェア開発を考える（2025_07版） _ Agentic Software Engineering Findy 2025-07 Edition, Takuto Wada, 2025.07</a>
<span class="snippet"><span>Comment</span>Vibe Codingによってソフトウェアエンジニアリングの課題は解決されたわけではなく、昔からある問題は依然として存在し（技術的負債、レビューなど）、道具が変わりこれらが顕在化するスピードが急速に速まっただけ、という話な模様。

<br>

どの領域に、どのAIを使うか（委託, 伴走）なども考察されている。ロジックの複雑さが小さいものは委託（補完など）、ロジックの複雑さが高く競合との差別化が重要なエリアには伴走、といった使い方。AIは自走するが迷走、暴走もするのでガードレールがより一層重要。自分自身の能力の向上も不可欠。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/parser.html">#parser</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<span class="issue_date">Issue Date: 2025-07-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2294">LLM APIs Are Not Complete Document Parsers, Jerry Liu, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jerryjliu0/status/1948475176062255504?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMServing.html">#LLMServing</a>
<a class="button" href="articles/SpeculativeDecoding.html">#SpeculativeDecoding</a>
<span class="issue_date">Issue Date: 2025-07-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2291">Speculative Decoding：Faster Inference Without Paying for More GPU, ELYZA, 2025.07</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<a class="button" href="articles/Attack.html">#Attack</a>
<span class="issue_date">Issue Date: 2025-07-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2278">プロンプトインジェクション2.0 : 進化する防御機構とその回避手法, yuasa, 2025.07</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<span class="issue_date">Issue Date: 2025-07-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2277">Qwen Code, Qwen Team, 2025.07</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMServing.html">#LLMServing</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2273">LLM Servingを支える技術, Kotoba Technologies, 2025.07</a>
<span class="snippet"><span>Comment</span>こちらも参照のこと:

<br>

・2263</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2270">Qwen3-235B-A22B-Instruct-2507, QwenTeam, 2025.07</a>
<span class="snippet"><span>Comment</span>Qwen3最新版。ベンチマーク画像は元ポストより引用。hybrid thinkingを廃止し、non-thinkingのみとした。non-thinkingだが性能が向上し、context長が256k （前回の2倍）になっている模様。

<br>



<br>

<img src="https://github.com/user-attachments/assets/087412bd-cf0f-4bac-a93b-867176fa5aad" alt="image" loading="lazy">

<br>

元ポスト:https://x.com/alibaba_qwen/status/1947344511988076547?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・1909・2226

<br>



<br>

において、Qwen2.5-math-7B, Qwen2.5-7Bに対して、Math500, AMC,

<br>

 AIME2024データについてコンタミネーションの可能性が指摘されている点には留意したい。・2195

<br>



<br>

ポストのベンチ上ではKimi-K2を超えているように見えるが、果たして…？</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMServing.html">#LLMServing</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<a class="button" href="articles/Parallelism.html">#Parallelism</a>
<a class="button" href="articles/Inference.html">#Inference</a>
<a class="button" href="articles/Batch.html">#Batch</a>
<span class="issue_date">Issue Date: 2025-07-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2263">LLM推論に関する技術メモ, iwashi.co, 2025.07</a>
<span class="snippet"><span>Comment</span>```

<br>

メモリ (GB) = P × (Q ÷ 8) × (1 + オーバーヘッド)

<br>



<br>

・P：パラメータ数（単位は10億）

<br>

・Q：ビット精度（例：16、32）、8で割ることでビットをバイトに変換

<br>

・オーバーヘッド（％）：推論中の追加メモリまたは一時的な使用量（例：KVキャッシュ、アクティベーションバッファ、オプティマイザの状態）

<br>

```

<br>



<br>

↑これ、忘れがちなのでメモ…関連（量子化関連研究）:

<br>

・2264

<br>

・1570

<br>

・1043すごいメモだ…勉強になります</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Distillation.html">#Distillation</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/OpenSource.html">#OpenSource</a>
<span class="issue_date">Issue Date: 2025-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2255">OpenReasoning-Nemotron: A Family of State-of-the-Art Distilled Reasoning Models, Nvidia, 2025.07</a>
<span class="snippet"><span>Comment</span>DeepSeek-R1-0528から応答を合成したデータでSFTのみを実施し、32BでQwe3-235B-A22Bと同等か上回る性能。アーキテクチャはQwen2.5。データはOpenCode/Math/Scienceを利用。

<br>

<img src="https://github.com/user-attachments/assets/8dda86f4-df71-4732-8d51-5905672fa5c9" alt="image" loading="lazy">元ポスト:https://x.com/igtmn/status/1946291288170725617?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

データも公開予定</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SmallModel.html">#SmallModel</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2252">Seed-X-Instruct-7B, ByteDance-Seed, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/teortaxestex/status/1946056084709359653?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QMTに特化したMultilingual SLM。7Bモデルだがベンチマーク上では他の大規模なモデルと同等以上。テクニカルレポート: https://github.com/ByteDance-Seed/Seed-X-7B/blob/main/Technical_Report.pdf</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2025-07-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2243">Asymmetry of verification and verifier’s law, Jason Wei, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_jasonwei/status/1945287045251052007?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-07-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2228">論文では語られないLLM開発において重要なこと Swallow Projectを通して, Kazuki Fujii, NLPコロキウム, 2025.07</a>
<span class="snippet"><span>Comment</span>独自LLM開発の私の想像など遥かに超える非常に困難な側面が記述されており、これをできるのはあまりにもすごいという感想を抱いた（小並感だけど本当にすごいと思う。すごいとしか言いようがない）</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/Optimizer.html">#Optimizer</a>
<a class="button" href="articles/Decoder.html">#Decoder</a>
<span class="issue_date">Issue Date: 2025-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2223">Modded-NanoGPT, KellerJordan, 2024.05</a>
<span class="snippet"><span>Comment</span>NanoGPT speedrun関連:

<br>

・2118

<br>

・2208</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Optimizer.html">#Optimizer</a>
<span class="issue_date">Issue Date: 2025-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2208">きみはNanoGPT speedrunを知っているか？, PredNext, 2025.07</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Optimizer.html">#Optimizer</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<a class="button" href="articles/Stability.html">#Stability</a>
<span class="issue_date">Issue Date: 2025-07-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2195">Kimi K2: Open Agentic Intelligence, moonshotai, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/kimi_moonshot/status/1943687594560332025?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q1T-A32Bのモデル。さすがに高性能。

<br>



<br>

<img src="https://github.com/user-attachments/assets/39b524d3-6e22-456d-8d61-fcd22519d58d" alt="image" loading="lazy">

<br>



<br>

（追記） Reasoningモデルではないのにこの性能のようである。1T-A32Bのモデルを15.5Tトークン訓練するのに一度もtraining instabilityがなかったらしい

<br>

元ポスト:https://x.com/eliebakouch/status/1943689105721667885?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・2188量子化したモデルが出た模様:

<br>

https://x.com/ivanfioravanti/status/1944069021709615119?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

仕事早すぎるDeepSeek V3/R1とのアーキテクチャの違い:

<br>

https://x.com/rasbt/status/1944056316424577525?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

MLAのヘッドの数が減り、エキスパートの数を増加させている解説ポスト:https://x.com/hillbig/status/1944902706747072678?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q利用されているOptimizer:

<br>

・22022つほどバグがあり修正された模様:

<br>

https://x.com/kimi_moonshot/status/1945050874067476962?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qchatbot arenaでOpenLLMの中でトップのスコア

<br>

元ポスト:https://x.com/lmarena_ai/status/1945866381880373490?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qテクニカルペーパーが公開:https://github.com/MoonshotAI/Kimi-K2/blob/main/tech_report.pdf

<br>



<br>

元ポスト:https://x.com/iscienceluvr/status/1947384629314396302?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qテクニカルレポートまとめ:https://x.com/scaling01/status/1947400424622866793?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q以下のような技術が使われている模様

<br>

・1937

<br>

・MLA 1621

<br>

・MuonCip

<br>

・MuonOptimizer 2202 

<br>

・QK-Clip

<br>

  ・参考（こちらはLayerNormを使っているが）: 1202

<br>

・RLVR

<br>

  ・1719 

<br>

・Self-Critique

<br>

  ・関連: 2274

<br>

  ・2017 

<br>

・Temperature Decay  

<br>

  ・最初はTemperatureを高めにした探索多めに、後半はTemperatureを低めにして効用多めになるようにスケジューリング

<br>

・Tool useのためのSynthetic Data

<br>



<br>

<img width="1058" height="336" alt="Image" src="https://github.com/user-attachments/assets/74eacdb2-8f64-4d53-b2d0-66df770f2e8b">Reward Hackingに対処するため、RLVRではなくpairwise comparisonに基づくself judging w/ critique を利用きており、これが非常に効果的な可能性があるのでは、という意見がある:

<br>

https://x.com/grad62304977/status/1953408751521632401?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Tokenizer.html">#Tokenizer</a>
<span class="issue_date">Issue Date: 2025-07-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2193">H-Nets - the Past, Goomba Lab, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/sukjun_hwang/status/1943703574908723674?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qtokenizerも含めてデータに対して最適なinputの粒度を学習公式ポスト(?):https://x.com/cartesia_ai/status/1943705750381207880?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・1634

<br>

・2073

<br>



<br>

ByteLatentTransformerなどとはどう違うのだろうか？解説ポスト:https://x.com/hillbig/status/1944542938723475869?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/SmallModel.html">#SmallModel</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/OpenSource.html">#OpenSource</a>
<span class="issue_date">Issue Date: 2025-07-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2164">SmolLM3: smol, multilingual, long-context reasoner, HuggingFace, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/thom_wolf/status/1942670704278732978?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QSmolLM3を構築する際の詳細なレシピ(アーキテクチャ、データ、data mixture, 3 stageのpretraining(web, code, mathの割合と品質をステージごとに変え、stable-&gt;stable-&gt;decayで学習), midtraining(long context-&gt;reasoning, post training(sft-&gt;rl), ハイブリッドreasoningモデルの作り方、評価など)が説明されている学習/評価スクリプトなどがリリース:

<br>

https://x.com/_lewtun/status/1950209751066742982?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2025-07-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2162">PLaMo翻訳による英語ベンチマークの翻訳, PFN, 2025.07</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<a class="button" href="articles/ContextEngineering.html">#ContextEngineering</a>
<span class="issue_date">Issue Date: 2025-07-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2138">Context Engineering - What it is, and techniques to consider, llamaindex, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/llama_index/status/1940810514227196236?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<a class="button" href="articles/ContextEngineering.html">#ContextEngineering</a>
<span class="issue_date">Issue Date: 2025-07-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2135">The New Skill in AI is Not Prompting, It's Context Engineering, PHLSCHMID, 2025.06</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/akiratosei/status/1940960253233058198?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-07-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2134">rLLM, Agentica, 2025.06</a>
<span class="snippet"><span>Comment</span>&gt;rLLM is an open-source framework for post-training language agents via reinforcement learning. With rLLM, you can easily build their custom agents and environments, train them with reinforcement learning, and deploy them for real-world workloads.

<br>

なるほど。

<br>



<br>



<br>

バックボーンにはverlが採用されており、シンプルかつ統一的なインタフェースでカスタムエージェントが学習できる模様？

<br>



<br>

https://rllm-project.readthedocs.io/en/latest/key-features元ポスト:https://x.com/chenguangwang/status/1940585022010122692?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・1969</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<span class="issue_date">Issue Date: 2025-06-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2115">ERNIE 4.5 Series, ERNIE TEAM, 2025.06</a>
<span class="snippet"><span>Comment</span>Tech Report:https://yiyan.baidu.com/blog/publication/ERNIE_Technical_Report.pdf元ポスト:https://x.com/paddlepaddle/status/1939535276197744952?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説ポスト:https://x.com/gm8xx8/status/1939576393098023188?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-06-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2108">Hunyuan-A13B-Instruct, tencent, 2025.06</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/arankomatsuzaki/status/1938515928221995066?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q・MoEアーキテクチャ, 80B-A13B

<br>

・fast, slow thinking mode

<br>

・256k context window

<br>

・agenticタスクに特に特化

<br>

・Grouped Query Attention, 複数の量子化フォーマットをサポート公式ポスト:https://x.com/tencenthunyuan/status/1938525874904801490?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q画像は公式ポストより引用。Qwen3-235B-A22Bよりも少ないパラメータ数で、同等（agenticタスクはそれ以上）なようにベンチマーク上は見えるが、果たして。

<br>



<br>

<img src="https://github.com/user-attachments/assets/ed47bae2-9017-4cf2-b1e1-50e863da1c77" alt="image" loading="lazy">果たして日本語の性能はどうだろうか。

<br>

TENCENT HUNYUAN COMMUNITY LICENSE

<br>

https://github.com/Tencent-Hunyuan/Hunyuan-A13B/blob/main/LICENSE</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2097">Swallow LLM Leaderboard, Swallow LLM Team</a>
<span class="snippet"><span>Comment</span>関連:

<br>

・1096

<br>

・1055</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2095">Nemo-RL, Nvidia, 2025.05</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2092">LLM-jp-3.1 シリーズ instruct4 の公開, LLM-jp, 2025.05</a>
<span class="snippet"><span>Comment</span>関連

<br>

・2089

<br>

・2090

<br>

・2091</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RLHF.html">#RLHF</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2025-06-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2078">人間を騙してサボるAIたち, joisino, 2025.06</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-06-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2075">Kimi-VL-A3B-Thinking-2506, moonshotai, 2025.06</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/reach_vb/status/1937159672932286950?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q様々なベンチマークでSoTA(gpt4o, Qwen2.5-VL-7B)を達成したReasoning VLMテクニカルペーパー:

<br>

・2200</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<span class="issue_date">Issue Date: 2025-06-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2072">AI Agent Manager （AAM） として生きていく : 作業環境とワークフローの設計, icoxfog417, 2025.06</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/icoxfog417/status/1936929479324319807?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/LLMServing.html">#LLMServing</a>
<span class="issue_date">Issue Date: 2025-06-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2069">Nano-vLLM, GeeeekExplorer, 2025.06</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/marktechpost/status/1936689592507543643?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QvLLMと同等のinference speedを実現するミニマムでクリーンな実装。勉強用に良さそう。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-06-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2066">POLARIS: A Post-Training Recipe for Scaling Reinforcement Learning on Advanced Reasoning Models,</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_akhaliq/status/1936233712510718361?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QPJで利用されているRLライブラリ:

<br>

・1969AIME2025のみの評価だが4Bでこの性能…？

<br>

<img src="https://github.com/user-attachments/assets/02d1ece1-b12f-4877-b500-ff910e45ff00" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-06-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2065">Single vs Multi-Agent System?, PHILSCHMID, 2025.06</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_philschmid/status/1935985099171840140?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・2050</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LLMServing.html">#LLMServing</a>
<span class="issue_date">Issue Date: 2025-06-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2061">Mirage Persistent Kernel: Compiling LLMs into a MegaKernel, 2025.06</a>
<span class="snippet"><span>Comment</span>vLLM, SGLangよりもデコーディングが早い模様（図は下記ブログより引用）

<br>

<img src="https://github.com/user-attachments/assets/0a2bf0e5-0d3f-4dd0-a912-6ce05ead2cad" alt="image" loading="lazy">

<br>



<br>

ブログ:https://zhihaojia.medium.com/compiling-llms-into-a-megakernel-a-path-to-low-latency-inference-cf7840913c17元ポスト:https://x.com/jiazhihao/status/1935767958963314773?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-06-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2057">[Paper Note] Gemini 2.5: Pushing the Frontier with Advanced Reasoning, Multimodality, Long Context, and Next Generation Agentic Capabilities, Gemini Team, 2025.06</a>
<span class="snippet"><span>Comment</span>関連ポスト:

<br>

https://x.com/jaguring1/status/1935203032922485080?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説ポスト:https://x.com/_philschmid/status/1935019697683980603?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連ポスト:https://x.com/hillbig/status/1935841560736022708?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Multi.html">#Multi</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-06-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2050">Don’t Build Multi-Agents, Cognition, 2025.06</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/ngo275/status/1934819225111285852?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<span class="issue_date">Issue Date: 2025-06-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2043">MiniMax-M1, MiniMax, 2025.06</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/arankomatsuzaki/status/1934642204397744137?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QvLLMでのservingが推奨されており、コンテキストは1M、456BのMoEアーキテクチャでactivation weightは46B公式ポスト:https://x.com/minimax__ai/status/1934637031193514237?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QAgentもリリースした模様:

<br>

https://x.com/minimax__ai/status/1945550814728376803?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Zero/FewShotLearning.html">#Zero/FewShotLearning</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-06-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2042">[Paper Note] Language Models are Unsupervised Multitask Learners, Radford+, OpenAI, 2019</a>
<span class="snippet"><span>Comment</span>今更ながら、GPT-2論文をメモってなかったので追加。

<br>



<br>

従来のモデルは特定のタスクを解くためにタスクごとに個別のモデルをFinetuningする必要があったが、大規模なWebTextデータ（Redditにおいて最低3つのupvoteを得たポストの外部リンクを収集）によって言語モデルを訓練し、モデルサイズをスケーリングさせることで、様々なタスクで高い性能を獲得でき、Zero-Shot task transfer, p(output | input, task) , が実現できるよ、という話。

<br>



<br>

今ざっくり見返すと、Next Token Predictionという用語は論文中に出てきておらず、かつ "Language Modeling" という用語のみで具体的なlossは記述されておらず（当時はRNN言語モデルで広く学習方法が知られていたからだろうか？）、かつソースコードも学習のコードは提供されておらず、lossの定義も含まれていないように見える。

<br>



<br>

ソースコードのモデル定義:

<br>

https://github.com/openai/gpt-2/blob/master/src/model.pyL169</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Unsupervised.html">#Unsupervised</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<span class="issue_date">Issue Date: 2025-06-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2029">[Paper Note] Unsupervised Elicitation of Language Models, Wen+, Anthropic, 2025.06</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jiaxinwen22/status/1932908642858418441?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-06-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2020">Qwen_Qwen3-Embedding-4B-GGUF, QwenTeam, 2025.06</a>
<span class="snippet"><span>Comment</span>8BモデルはMTEBでトップの性能を達成。context 32K。100以上の言語をサポート。32--2560次元にoutputの次元数をカスタマイズできる（嬉しい、が性能にどの程度影響が出るから気になる）。元ポスト:https://x.com/huggingpapers/status/1930739968332157018?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QQwenTeam post:https://x.com/alibaba_qwen/status/1930648422778118246?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<a class="button" href="articles/SSM%20(StateSpaceModel).html">#SSM (StateSpaceModel)</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-05-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2001">2025年度人工知能学会全国大会チュートリアル講演「深層基盤モデルの数理」, Taiji Suzuki, 2025.05</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/btreetaiji/status/1927678122817921442?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SmallModel.html">#SmallModel</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<span class="issue_date">Issue Date: 2025-05-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1998">SSII2025 [OS1-03] PFNにおけるSmall Language Modelの開発, 鈴木 脩司, 画像センシングシンポジウム, 2025.05</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_stakaya/status/1927588359217844702?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連

<br>

・1827

<br>

・1828

<br>

・1999

<br>

・766先行研究を元に仮説を立てて、有望なアプローチを取る意思決定が非常に勉強になる。

<br>

Scaling Lawsが不確実性のある意思決定において非常に有用な知見となっている。同じようにPruningとKnowledge Distilationを実施した事例として下記が挙げられる

<br>

・1873</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<a class="button" href="articles/SmallModel.html">#SmallModel</a>
<a class="button" href="articles/RLVR.html">#RLVR</a>
<span class="issue_date">Issue Date: 2025-05-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1997">Spurious Rewards: Rethinking Training Signals in RLVR, Shao+, 2025.05</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/stellalisy/status/1927392717593526780?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q参考（考察）: https://x.com/weiliu99/status/1930826904522875309?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q参考（考察）:

<br>

https://x.com/g_k_swamy/status/1945159211752562739?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

こちらでもQwen2.5 MATH 7b を用いて検証しているが、コンタミネーションの問題が仮に本当だとしたら、どう影響するだろうか。スレッド中のグラフもMATH500（Qwen2.5においてコンタミの可能性がある）の性能を示している。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<span class="issue_date">Issue Date: 2025-05-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1987">【DL輪読会】 Block Diffusion: Interpolating Between Autoregressive and Diffusion Language Models, Deep Learning JP, 2025.05</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/kym384/status/1925852937835737569?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q1986 でLiteratureをざっくり把握してからこちらを読むのが良さそう。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<span class="issue_date">Issue Date: 2025-05-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1986">Masked Diffusion Modelの進展, Deep Learning JP, 2025.03</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/kym384/status/1925852884656099572?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qスライド中のARのようにKV Cacheが使えない問題に対処した研究が

<br>

・1984

<br>



<br>

この辺はdLLMが有望であれば、どんどん進化していくのだろう。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/AWS.html">#AWS</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2025-05-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1976">Webスケールの日本語-画像のインターリーブデータセット「MOMIJI」の構築 _巨大テキストデータをAWSで高速に処理するパイプライン, Turing （studio_graph）, 2025.05</a>
<span class="snippet"><span>Comment</span>貴重なVLMデータセット構築ノウハウ青塗りのフィルタリングタスクを具体的にどうやっているのか気になる</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Coding.html">#Coding</a>
<span class="issue_date">Issue Date: 2025-05-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1972">OpenAI-Codex, OpenAI, 2025.05</a>
<span class="snippet"><span>Comment</span>OpenHandsのNeubig氏が、OpenAIのブログポスト中で報告されているSWE-Bench Verifiedのスコアについて、言及している。OpenAIは23個サンプルについて(internal infrastructureで動作させられないため)除外しているので、その分スコアに下駄が履かれているようで、ブログ中のpassNのスコアを他のリーダーボードのスコアと比較する際には注意が必要っぽい。

<br>

https://x.com/gneubig/status/1923893277519962287?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/ScientificDiscovery.html">#ScientificDiscovery</a>
<a class="button" href="articles/Coding.html">#Coding</a>
<span class="issue_date">Issue Date: 2025-05-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1971">AlphaEvolve: A coding agent for scientific and algorithmic discovery, Novikov+, Google DeepMind, 2025.05</a>
<span class="snippet"><span>Comment</span>blog post:https://deepmind.google/discover/blog/alphaevolve-a-gemini-powered-coding-agent-for-designing-advanced-algorithms/</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<span class="issue_date">Issue Date: 2025-05-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1969">verl: Volcano Engine Reinforcement Learning for LLMs, ByteDance Seed Team, 2025.04</a>
<span class="snippet"><span>Comment</span>SoTAなRLアルゴリズムを数行のコードで実装可能で、Sequence Parallelismがサポートされているので長い系列を扱える。FSDP, Megatron-LM,vLLM,SGLangなどとシームレスに統合できるっぽい？注意点（超重要）:

<br>

https://x.com/fengyao1909/status/1953882575241723911?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

inference backendとtrainingのbackendのミスマッチによってトークンの生起確率に差が生じ、ポリシーの更新がうまくいかなくなる。

<br>



<br>

<img src="https://github.com/user-attachments/assets/92ab33c6-d943-4101-9f73-250c697af816" alt="image" loading="lazy">

<br>



<br>

・2228

<br>



<br>

でも言われているように、ライブラリにはバグがあるのが普通なのね、、、。

<br>



<br>

<img src="https://github.com/user-attachments/assets/6e70b642-27d4-4ab9-bbc0-7e0cb082ff69" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-05-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1953">Stanford Alpaca: An Instruction-following LLaMA Model, Taori +, 2023.03</a>
<span class="snippet"><span>Comment</span>今更ながらメモに追加。アカデミアにおけるOpenLLMに対するInstruction Tuningの先駆け的研究。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-05-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1949">ms-swiftによるMegatron-LMベースのQwen3のファインチューニング, Aratako, 2025.05</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/aratako_lm/status/1921401994532487174?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QMegatron-SWIFTというAlibaba製のライブラリを利用しQwen3の継続事前学習とSFTを実施する方法を、ベストプラクティスに則って記述し、かつ著者自身が学習したモデルも公開している。（おそらくインスタンス代は自腹なので）すごい...!!

<br>

Megatron-SWIFTはMoEアーキテクチャを採用したモデルであれば、DeepSpeed Zero3 [^1]と比べて10倍程度のスループットで学習できる模様（早い）。一方MoEアーキテクチャでないモデルの場合はそこまで大きな差はない。

<br>



<br>

[^1]: A100 80GB 2ノードでは、Qwen3-30B-A3Bは、DeepSpeed-Zero2ではOOMとなり載らないようだ…。なんとリソースに厳しいこと…（涙）</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2025-05-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1927">Agent Frameworkはどれを使うべきか [タスク性能編], はち, 2025.05</a>
<span class="snippet"><span>Comment</span>各フレームワーク毎の性能の違いや消費したトークン数、実装の微妙や違いがまとめられており、太字でtakeawayが記述されているので非常にわかりやすい。元ポスト:https://x.com/curveweb/status/1919301208096866660?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/SmallModel.html">#SmallModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<span class="issue_date">Issue Date: 2025-05-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1921">Phi-4-reasoning Technical Report, 2025.04</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dimitrispapail/status/1917731614899028190?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qこちらの解説が非常によくまとまっている:

<br>

https://x.com/_philschmid/status/1918216082231320632?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

が、元ポストでもテクニカルペーパー中でもo3-miniのreasoning traceをSFTに利用してCoTの能力を強化した旨が記述されているが、これはOpenAIの利用規約に違反しているのでは…？</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-04-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1909">Qwen3, Qwen Team, 2025.04</a>
<span class="snippet"><span>Comment</span>・119言語をサポート

<br>

・MoEモデル 1911

<br>

    ・30B-A3B / 235B-A22N

<br>

    ・128K context window

<br>

    ・Qwen2.5はMoEを採用していないので新たなアーキテクチャとなる

<br>

・Denseモデル（非MoEモデル）も公開

<br>

    ・0.6B -・32B

<br>

    ・32K -・128K context window

<br>

・Thinking/Non-thinking の切り替えが切り替えが可能

<br>

    ・スイッチは自動的に実施されるが、ユーザが明示的に `/think`, `/no_think` を user_promptの末尾に追加することで制御することも可能

<br>

・Pre-training

<br>

    ・データ

<br>

        ・36 trillion tokensによって学習（Qwen-2.5の2倍）

<br>

        ・学習データではwebデータに加えて、PDF-likeな文書群からQwen2.5-VL 1835 によってテキストを抽出し、Qwen2.5 で抽出された内容の品質を改善し利用

<br>

        ・また、math / code に関するデータを追加するために、Qwen2.5-Math / Qwen2.5-Coderを用いて合成データを作成（textbooks / QA pairs / code snippets 766 ）

<br>

    ・事前学習のステップ

<br>

        ・S1: context長が4kの30 trillion tokenで事前学習

<br>

        ・S2: STEM / coding / reasoning task などのknowledge-intensiveデータの比率を増やして継続事前学習 (これがおそらく 5 trillion token程度？)

<br>

        ・Final Stage: context長を32kに拡大し高品質なlong-context dataで継続事前学習

<br>

    ・これによりBaseモデルが完成し、Qwen3-235B全体のうち10%程度のActive Parameterの利用するだけで（i.e., 22Bで）、Qwen2.5-72B Baseと同等以上の性能達成

<br>

・Post-training

<br>

    ・S1: long-CoT cold start

<br>

        ・数学/coding/logical reasoning/STEMなどの多様なlong CoTデータを用いてSFT 1749 

<br>

    ・S2: reasoning-based RL

<br>

        ・rule-based (verifiable) rewards によるRL 1719 

<br>

        ・S1/S2の流れは 1746 に有効性が示されている通り、long CoT DataによるSFT -&gt; RLを実施

<br>

    ・S3: thinking mode fusion

<br>

        ・S2データを用いてlong CoTデータとinstruction tuningデータ（非Long CoT）を生成し、Thinking/Non-thinkingを自動的に選択し生成するように学習（SFT or RLは記述なし）

<br>

    ・S4: general RL

<br>

        ・20以上の一般的なドメインのタスクを通じて一般的な能力の向上と、safetyに関するalignmentの実施（e.g., instruction following, format following, agent能力など）BestPracticeに関するポスト:https://x.com/ivanfioravanti/status/1916934241281061156?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説:https://x.com/hillbig/status/1917712050983428400?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2025-04-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1903">Deepwiki, Cognition, 2025.04</a>
<span class="snippet"><span>Comment</span>githubリポジトリに関するリッチなドキュメントに対してDevinを通じて対話的に質問ができる模様。サインアップ不要で、githubリポジトリのドメインをdeepwikiに変えるだけで利用可能</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/x-Use.html">#x-Use</a>
<span class="issue_date">Issue Date: 2025-04-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1896">Introducing UI-TARS-1.5, ByteDance, 2025.04</a>
<span class="snippet"><span>Summary</span>UI-TARSは、スクリーンショットを入力として人間のようにインタラクションを行うネイティブGUIエージェントモデルであり、従来の商業モデルに依存せず、エンドツーエンドで優れた性能を発揮します。実験では、10以上のベンチマークでSOTA性能を達成し、特にOSWorldやAndroidWorldで他のモデルを上回るスコアを記録しました。UI-TARSは、強化された知覚、統一アクションモデリング、システム-2推論、反射的オンライントレースによる反復トレーニングなどの革新を取り入れ、最小限の人間の介入で適応し続ける能力を持っています。</span>
<span class="snippet"><span>Comment</span>paper:https://arxiv.org/abs/2501.12326色々と書いてあるが、ざっくり言うとByteDanceによる、ImageとTextをinputとして受け取り、TextをoutputするマルチモーダルLLMによるComputer Use Agent (CUA)関連

<br>

・1794元ポスト:https://x.com/_akhaliq/status/1912913195607663049?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-04-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1886">Seed-Thinking-v1.5, ByteDance, 2025.04</a>
<span class="snippet"><span>Comment</span>DeepSeek-R1を多くのベンチで上回る200B, 20B activated paramのreasoning model最近のテキストのOpenWeightLLMはAlibaba, DeepSeek, ByteDance, Nvidiaの4強という感じかな…？（そのうちOpenAIがオープンにするReasoning Modelも入ってきそう）。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<span class="issue_date">Issue Date: 2025-04-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1877">Fiction.liveBench, 2025.04</a>
<span class="snippet"><span>Comment</span>long contextではGemini-2.5-proの圧勝</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/API.html">#API</a>
<span class="issue_date">Issue Date: 2025-04-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1875">BFCLv2, UC Berkeley, 2024.08</a>
<span class="snippet"><span>Comment</span>LLMのTool Useを評価するための現在のデファクトスタンダードとなるベンチマーク</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/Pruning.html">#Pruning</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-04-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1873">Llama-3_1-Nemotron-Ultra-253B-v1, Nvidia, 2025.04</a>
<span class="snippet"><span>Comment</span>DeepSeek-R1をGPQA Diamond 1155, AIME2024/2025, Llama4 Maverickを

<br>

BFCLv2（Tool Calling, 1875), IFEVal 1137 で上回り, そのほかはArenaHardを除きDeepSeekR1と同等

<br>

<img src="https://github.com/user-attachments/assets/b0de99ee-f4ec-4b03-8b0b-8939b4f1e23b" alt="image" loading="lazy">

<br>



<br>

DeepSeekR1が671B（MoEで37B Activation Param）に対し、こちらは253B（ただし、Llama3.1がベースなのでMoEではない）で同等以上の性能となっている。

<br>

ReasoningをON/OFFする能力も備わっている。

<br>



<br>

モデルがどのように訓練されたかを示す全体図がとても興味深い:<img src="https://github.com/user-attachments/assets/9a014777-61d8-46ae-818b-ace9ed5c002d" alt="image" loading="lazy">

<br>



<br>

特に 1746 でも有効性が示されているように、SFTをしてからReasoningを強化する（強化というより元々持っている能力を引き出す？）RLを実施している。

<br>



<br>

詳細は下記Blogとのこと:

<br>

https://developer.nvidia.com/blog/build-enterprise-ai-agents-with-advanced-open-nvidia-llama-nemotron-reasoning-models/元ポスト:https://x.com/kuchaev/status/1909444566379573646?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-04-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1872">Dream-v0-Instruct-7B, Dream-org, 2025.04</a>
<span class="snippet"><span>Comment</span>OpenWeightな拡散言語モデル元ポスト:https://x.com/curveweb/status/1909551257725133132?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・1776</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-04-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1863">Llama 4 Series, Meta, 2025.04</a>
<span class="snippet"><span>Comment</span>Downloads:https://www.llama.com/?utm_source=twitter&utm_medium=organic_social&utm_content=image&utm_campaign=llama4Huggingface:

<br>

https://huggingface.co/collections/meta-llama/llama-4-67f0c30d9fe03840bc9d0164解説ポスト:https://x.com/iscienceluvr/status/1908601269004230763?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QArtificial Analysisによる性能検証:https://x.com/artificialanlys/status/1908890796415414430?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

MaverickがGPT4oと同等、ScoutがGPT4o-miniと同等

<br>



<br>

Update:https://x.com/artificialanlys/status/1909624239747182989?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q性能に関して不可解な点が多そうなので様子見をしても良いかも。性能検証（Math-Perturb):https://x.com/kaixuanhuang1/status/1909387970773234088?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q日本語にあまり強くないという情報も

<br>

元ポスト:https://x.com/gosrum/status/1909626761098494060?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QどうやらvLLMのLlama4のinferenceにバグがあったやうで、vLLMのIssue 16311にて、Llama4のinferenceに関するバグが修正され、性能が向上した模様。どのベンチを信じたら良いかまるでわからん。2025.0413現在のchatbot arenaのランクは、32位となり（chatbot arena向けにtuningされていたであろうモデルは2位だった）GPT-4oが29位であることを考慮すると上記のArtificial Intelligenceの評価とも大体一致している。

<br>



<br>

https://lmarena.ai

<br>



<br>

関連ポスト:https://x.com/tunguz/status/1911142310160855541?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<span class="issue_date">Issue Date: 2025-04-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1850">openhands-lm-32b-v0.1, all-hands, 2025.03</a>
<span class="snippet"><span>Comment</span>Qwen Coder 2.5 Instruct 32Bに基づく最先端のSWEタスクが実行可能なモデル</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2025-03-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1844">Recommendation Systems • LLM, vinjia.ai, 2025.03</a>
<span class="snippet"><span>Comment</span>元ポスト:https://www.linkedin.com/posts/vinija_recommendation-systems-llm-activity-7306171374446727168-cUg2?utm_source=share&utm_medium=member_ios&rcm=ACoAACzQvjwB2FeLVE3yukDiUYtr5J4k-6nlNG4</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-03-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1835">Qwen2.5-VL-32B-Instruct, Qwen Team, 2025.03</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/alibaba_qwen/status/1904227859616641534?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-03-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1834">言語モデルの物理学, 佐藤竜馬, 2025.03</a>
<span class="snippet"><span>Comment</span>必読</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/SSM%20(StateSpaceModel).html">#SSM (StateSpaceModel)</a>
<span class="issue_date">Issue Date: 2025-03-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1830">Nemotron-H: A Family of Accurate, Efficient Hybrid Mamba-Transformer Models, Nvidia, 2025.03</a>
<span class="snippet"><span>Comment</span>関連:

<br>

・1820TransformerのSelf-attention LayerをMamba2 Layerに置換することで、様々なベンチマークで同等の性能、あるいは上回る性能で3倍程度のInference timeの高速化をしている（65536 input, 1024 output）。

<br>



<br>

56B程度のmediumサイズのモデルと、8B程度の軽量なモデルについて述べられている。特に、8BモデルでMambaとTransformerのハイブリッドモデルと、通常のTransformerモデルを比較している。学習データに15 Trillion Tokenを利用しており、このデータ量でのApple to Appleのアーキテクチャ間の比較は、現状では最も大規模なものとのこと。性能は多くのベンチマークでハイブリッドにしても同等、Commonsense Understandingでは上回っている。

<br>



<br>

また、学習したNemotron-Hをバックボーンモデルとして持つVLMについてもモデルのアーキテクチャが述べられている。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/PositionalEncoding.html">#PositionalEncoding</a>
<span class="issue_date">Issue Date: 2025-03-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1823">8 Types of RoPE, Kseniase, 2025.03</a>
<span class="snippet"><span>Comment</span>元ポスト:https://huggingface.co/posts/Kseniase/498106595218801RoPEについてサーベイが必要になったら見る</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-03-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1822">The "think" tool: Enabling Claude to stop and think in complex tool use situations, Anthropic, 2025.03</a>
<span class="snippet"><span>Comment</span>"考える"ことをツールとして定義し利用することで、externalなthinkingを明示的に実施した上でタスクを遂行させる方法を紹介している</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-03-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1821">Understanding R1-Zero-Like Training: A Critical Perspective, 2025.03</a>
<span class="snippet"><span>Summary</span>DeepSeek-R1-Zeroは、教師なしファインチューニングなしでLLMの推論能力を向上させる強化学習（RL）の効果を示した。研究では、ベースモデルとRLのコアコンポーネントを分析し、DeepSeek-V3-Baseが「アハ体験」を示すことや、Qwen2.5が強力な推論能力を持つことを発見。さらに、Group Relative Policy Optimization（GRPO）の最適化バイアスを特定し、Dr. GRPOという新手法を導入してトークン効率を改善。これにより、7BベースモデルでAIME 2024において43.3%の精度を達成し、新たな最先端を確立した。</span>
<span class="snippet"><span>Comment</span>関連研究:

<br>

・1815解説ポスト:https://x.com/wenhuchen/status/1903464313391624668?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説ポストを読むと、

<br>



<br>

・DAPOでの　Token Level Policy UpdateのようなLengthに対するバイアスを排除するような操作をしている（Advantageに対して長さの平均をとる）模様。

<br>

・aha moment（self-seflection）はRLによって初めて獲得されたものではなく、ベースモデルの時点で獲得されており、RLはその挙動を増長しているだけ（これはX上ですでにどこかで言及されていたなぁ）。

<br>

・self-reflection無しの方が有りの場合よりもAcc.が高い場合がある（でもぱっと見グラフを見ると右肩上がりの傾向ではある）

<br>



<br>

といった知見がある模様あとで読む（参考）Dr.GRPOを実際にBig-MathとQwen-2.5-7Bに適用したら安定して収束したよというポスト:https://x.com/zzlccc/status/1910902637152940414?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<a class="button" href="articles/SSM%20(StateSpaceModel).html">#SSM (StateSpaceModel)</a>
<span class="issue_date">Issue Date: 2025-03-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1820">Hunyuan T1, Tencent, 2025.03</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/txhunyuan/status/1903121005809373386?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q画像はブログより引用。DeepSeek-R1と比較すると優っているタスクと劣っているタスクがあり、なんとも言えない感。GPT4.5より大幅に上回っているタスク（Math, Reasoning）があるが、そもそもそういったタスクはo1などのreasoningモデルの領域。o1と比較するとこれもまあ優っている部分もあれば劣っている部分もあるという感じ。唯一、ToolUseに関しては一貫してOpenAIモデルの方が強い。

<br>



<br>

ChineseタスクについてはDeepSeek-R1と完全にスコアが一致しているが、評価データのサンプル数が少ないのだろうか？

<br>

<img src="https://github.com/user-attachments/assets/de2325b2-0bd5-4177-a336-e6f008a32d40" alt="image" loading="lazy">reasoningモデルかつ、TransformerとMambaのハイブリッドで、MoEを採用しているとのこと。TransformerとMambaのハイブリッドについて（WenhuChen氏のポスト）:

<br>

https://x.com/wenhuchen/status/1903656455036715311?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

Layer-wise MixingとSequence-wise Mixingの2種類が存在するとのこと。前者はTransformerのSelf-Attenton LayerをMamba Layerに置換したもので、後者はSequenceのLong partをMambaでまずエンコードし、Short PartをTransformerでデコードする際のCross-Attentionのencoder stateとして与える方法とのこと。Self-Attention Layerを削減することでInference時の計算量とメモリを大幅に削減できる（Self-Attentionは全体のKV Cacheに対してAttentionを計算するため）。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-03-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1818">Sudoku-bench, SakanaAI, 2025.03</a>
<span class="snippet"><span>Summary</span>Sudoku-Benchは、CTCで紹介された独自のルールを持つ数独パズルを特徴とし、AI推論モデルの評価に最適なベンチマークです。このリポジトリでは、数独ベンチデータセット、LLM評価用のベースラインコード、SudokuPadツール、推論トレースなどを提供します。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/sakanaailabs/status/1902913196358611278?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q既存モデルでベンチマークを取ったらどういうランキングになるのだろうか。特にまだそういぅたランキングは公開されていない模様。ブログ記事に（将来的に最新の結果をrepositoryに追記す？模様）現時点でのリーダーボードが載っていた。現状、o3-miniがダントツに見える。

<br>

https://sakana.ai/sudoku-bench/</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-03-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1814">Llama Nemotron, Nvidia, 2025.03</a>
<span class="snippet"><span>Comment</span>Nvidiaによる初めてのreasoning model。

<br>

元ポスト:https://x.com/kuchaev/status/1902078122792775771?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QArtificial Analysisにやるベンチマーク:https://x.com/artificialanlys/status/1902386178206429434?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

GPQA Diamond（大学院（Ph.D）レベルの生物学、物理学、化学の450問程度の難解なmultiple choice question）で、DeepSeekV3, GPT4o, QwQ-32Bをoutperform. Claude 3.7 sonnetより少しスコアが低い。

<br>

DeepSeekR1, o1, o3-mini（high）, Claude 3.7 sonnet Thinkingなどには及んでいない。

<br>



<br>

<img src="https://github.com/user-attachments/assets/2d2b3716-83a6-4c56-bca7-f7d8cf981bbb" alt="image" loading="lazy">

<br>



<br>

（画像は元ポストより引用）システムプロンプトを変えることでreasoningをon/offできる模様</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-03-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1810">EXAONE-Deep-32B, LG AI Research, 2025.03</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/ai_for_success/status/1901908168805912602?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QEXAONE AI Model License Agreement 1.1 ・NC

<br>

商用利用不可</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-03-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1809">SmolDocling-256M, IBM Research, 2025.03</a>
<span class="snippet"><span>Comment</span>元ポスト:https://www.linkedin.com/posts/andimarafioti_we-just-dropped-%F0%9D%97%A6%F0%9D%97%BA%F0%9D%97%BC%F0%9D%97%B9%F0%9D%97%97%F0%9D%97%BC%F0%9D%97%B0%F0%9D%97%B9%F0%9D%97%B6%F0%9D%97%BB%F0%9D%97%B4-activity-7307415358427013121-wS8m?utm_source=share&utm_medium=member_ios&rcm=ACoAACzQvjwB2FeLVE3yukDiUYtr5J4k-6nlNG4Apache-2.0ライセンス。言語はEnglishのみな模様マルチモーダルなImage-To-Textモデル。サンプルはこちら

<br>

<img src="https://github.com/user-attachments/assets/d16ce5a9-4336-4daa-ab6f-94d67ae77c41" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<span class="issue_date">Issue Date: 2025-03-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1808">ERNIE4.5_X1, Baidu, 2025.03</a>
<span class="snippet"><span>Comment</span>解説ポスト:https://x.com/ai_for_success/status/1901149459826045223?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q・ERNIE4.5はGPT4.5をさまざまなベンチマークで上回り、価格がなんとGPT4.5の1%

<br>

・X1はマルチモーダルなreasoningモデルでDeepSeek-R1と同等の性能で半額

<br>



<br>

らしいこのモデルは6月30日にオープン（ウェイト？）になるとスレッドで述べられている。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-03-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1807">sarashina2-vision-{8b, 14b}, SB Intuitions, 2025.03</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/sei_shinagawa/status/1901467733331701966?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QVLM。Xに散見される試行例を見ると日本語の読み取り性能は結構高そうに見える。モデル構成、学習の詳細、および評価:https://x.com/sbintuitions/status/1901472307421278604?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLLM（sarashina2）, Vision Encoder（Qwen2-VL）, Projectorの3つで構成されており、3段階の学習を踏んでいる。

<br>

最初のステップでは、キャプションデータを用いてProjectorのみを学習しVision Encoderとテキストを対応づける。続いて、日本語を含む画像や日本特有の風景などをうまく扱えるように、これらを多く活用したデータ（内製日本語OCRデータ、図表キャプションデータ）を用いて、Vision EncoderとProjectorを学習。最後にLLMのAlignmentをとるために、プロジェクターとLLMを前段のデータに加えてVQAデータ（内製合成データを含む）や日本語の指示チューニングデータを用いて学習。ProjectorやMMLLMを具体的にどのように学習するかは

<br>

・1225

<br>



<br>

を参照のこと。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2025-03-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1805">The TypeScript Agent Framework, mastra, 2025.03</a>
<span class="snippet"><span>Comment</span>日本語解説:https://zenn.dev/yosh1/articles/mastra-ai-agent-framework-guide</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<span class="issue_date">Issue Date: 2025-03-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1803">LLM 開発を支える多様な Fine-Tuning：PFN での取り組み, 中鉢魁三郎, PFN, 2025.03</a>
<span class="snippet"><span>Comment</span>知識の追加の部分で下記研究が引用されている

<br>



<br>

・1371

<br>

・1640</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/OpenSource.html">#OpenSource</a>
<span class="issue_date">Issue Date: 2025-03-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1797">OLMo 2 32B: First fully open model to outperform GPT 3.5 and GPT 4o mini, AllenAI, 20250.3</a>
<span class="snippet"><span>Comment</span>真なる完全なるオープンソース（に近い？）OLMOの最新作</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/x-Use.html">#x-Use</a>
<span class="issue_date">Issue Date: 2025-03-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1794">OpenAI API での Computer use の使い方, npaka, 2025.03</a>
<span class="snippet"><span>Comment</span>OpenAIのCompute Useがどのようなものかコンパクトにまとまっている。勉強になりました。公式:https://platform.openai.com/docs/guides/tools-computer-use</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-03-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1791">Introducing Gemma 3: The most capable model you can run on a single GPU or TPU, Google, 2025.03</a>
<span class="snippet"><span>Comment</span>Googleの新たなSLMで、デバイスやラップトップでも動作可能な軽量モデル。テキストだけでなく画像とShortVideoの認識もできて、140言語をサポート。おまけに27BモデルでLlama3-405BとDeepSeek-V3とo3-miniをChatbotArenaのリーダーボードで上回り、128kのcontext window。えぇ…。モデルの詳細:https://huggingface.co/blog/gemma3

<br>



<br>

1Bモデルは英語のみサポート、マルチモーダル不可など制約がある模様。

<br>

詳細までは書いていないが、128Kコンテキストまでcontext windowを広げる際の概要とRoPE（のような）Positional Embeddingを利用していること、SlideingWindow Attentionを用いておりウィンドウサイズが以前の4096から性能を維持したまま1024に小さくできたこと、ImageEncoderとして何を利用しているか（SigLIP）、896x896の画像サイズをサポートしており、正方形の画像はこのサイズにリサイズされ、正方形でない場合はcropされた上でリサイズされる（pan and scanアルゴリズムと呼ぶらしい）こと、事前学習時のマルチリンガルのデータを2倍にしたことなど、色々書いてある模様。Gemmaライセンス解説ポスト:https://x.com/hillbig/status/1899965039559532585?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説ポスト:https://x.com/rasbt/status/1900214135847039316?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-03-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1790">Reasoning with Reka Flash, Reka, 2025.03</a>
<span class="snippet"><span>Comment</span>Weights: https://huggingface.co/RekaAI/reka-flash-3Apache-2.0&lt; /reasoning &gt;を強制的にoutputさせることでreasoningを中断させることができ予算のコントロールが可能とのこと</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<span class="issue_date">Issue Date: 2025-03-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1788">The State of LLM Reasoning Models, Sebastian Raschka, 2025.03</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-03-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1786">QwQ-32B: Embracing the Power of Reinforcement Learning, Qwen Team, 2025.03</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1897426898642460724?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q・1787Artificial Analysisによるベンチマークスコア:https://x.com/artificialanlys/status/1897701015803380112?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qおそらく特定のタスクでDeepSeekR1とcomparable, 他タスクでは及ばない、という感じになりそうな予感</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<span class="issue_date">Issue Date: 2025-03-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1783">GRPO Judge Experiments: Findings &amp; Empirical Observations, kalomaze's kalomazing blog, 2025.03</a>
<span class="snippet"><span>Comment</span>元ポスト:https://www.linkedin.com/posts/philipp-schmid-a6a2bb196_forget-basic-math-problems-grpo-can-do-more-activity-7302608410875691009-nntf?utm_source=share&utm_medium=member_ios&rcm=ACoAACzQvjwB2FeLVE3yukDiUYtr5J4k-6nlNG4一意に解が決まる問題ではなく、ある程度の主観的な判断が必要なタスクについてのGRPOの分析。

<br>

2つのテキストを比較するタスクで、一方のタスクはLLMによって摂動を与えている（おそらく意図的にcorruptさせている）。

<br>



<br>

GRPOではlinearやcosineスケジューラはうまく機能せず、warmupフェーズ有りの小さめの定数が有効らしい。また、max_grad_normを0.2にしまgradient clippingが有効とのこと。他にもrewardの与え方をx^4にすることや、length, xmlフォーマットの場合にボーナスのrewardを与えるなどの工夫を考察している。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-03-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1781">microsoft_Phi-4-multimodal-instruct, Microsoft, 2025.02</a>
<span class="snippet"><span>Comment</span>元ポスト:https://www.linkedin.com/posts/vaibhavs10_holy-shitt-microsoft-dropped-an-open-source-activity-7300755229635944449-mQP8?utm_medium=ios_app&rcm=ACoAACzQvjwB2FeLVE3yukDiUYtr5J4k-6nlNG4&utm_source=social_share_send&utm_campaign=copy_linkMIT License</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/python.html">#python</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-03-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1778">Open Reasoner Zero, Open-Reasoner-Zero, 2024.02</a>
<span class="snippet"><span>Summary</span>Open-Reasoner-Zeroは、推論指向の強化学習のオープンソース実装で、スケーラビリティとアクセスのしやすさに重点を置いています。AGI研究の促進を目指し、ソースコードやトレーニングデータを公開しています。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dair_ai/status/1893698293965725708?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2025-03-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1777">Introducing the SWE-Lancer benchmark, OpenAI, 2025.02</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dair_ai/status/1893698290174108113?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q1400以上のフリーランスソフトウェアエンジニアリングタスクを集めたベンチマーク。タスクはバグ修正から機能実装まで多岐にわたり、経験豊富なエンジニアによって評価されたもの。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<span class="issue_date">Issue Date: 2025-02-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1769">強化学習「GRPO」をCartPoleタスクで実装しながら解説, 小川雄太郎, 2025.02</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/ogawa_yutaro_22/status/1892059174789407213?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-02-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1766">Mistral-24B-Reasoning, yentinglin, 2025.02</a>
<span class="snippet"><span>Comment</span>Apache-2.0</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<span class="issue_date">Issue Date: 2025-02-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1762">LLMの事前学習のためのテキストデータの収集と構築, Shun Kiyono, 2015.02</a>
<span class="snippet"><span>Comment</span>詳細は著書に記載とのこと。興味深い。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/pretrained-LM.html">#pretrained-LM</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2025-02-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1761">modernbert-ja-130m, SB Intuitions, 2025.02</a>
<span class="snippet"><span>Comment</span>ＭIT Licence元ポスト:https://x.com/sbintuitions/status/1889587801706078580?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q・1606</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Distillation.html">#Distillation</a>
<span class="issue_date">Issue Date: 2025-02-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1757">DeepScaleR: Surpassing O1-Preview with a 1.5B Model by Scaling RL, 2025.02</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-02-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1747">Unsloth で独自の R1 Reasoningモデルを学習, npaka, 2025.02</a>
<span class="snippet"><span>Comment</span>非常に実用的で参考になる。特にどの程度のVRAMでどの程度の規模感のモデルを使うことが推奨されるのかが明言されていて参考になる。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/FoundationModel.html">#FoundationModel</a>
<a class="button" href="articles/RLHF.html">#RLHF</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2025-02-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1743">DeepSeek-R1の論文読んだ？【勉強になるよ】 , asap, 2025.01</a>
<span class="snippet"><span>Comment</span>・1719

<br>

・1655とても丁寧でわかりやすかった。後で読んだ内容を書いて復習する。ありがとうございます。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-01-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1737">Janus-Series: Unified Multimodal Understanding and Generation Models, DeepSeek, 2025.01</a>
<span class="snippet"><span>Comment</span>DeepSeekによる新たなVLM、Janus-Proが本日リリース。MIT LicenseJanus-Proのパフォーマンス。

<br>



<br>

github上でのパフォーマンスの図解から引用。マルチモーダル（テキスト+画像）の理解に関するベンチマークでLLaVA超え。GenEval, DPG Benchと呼ばれる画像生成ベンチマークでDALL-E 3超え。

<br>

<img src="https://github.com/user-attachments/assets/39b51e99-723d-4105-a113-e4bfa847c69b" alt="image" loading="lazy">

<br>



<br>



<br>

テクニカルレポート中での詳細から引用。どのベンチマークでも基本的に最高性能なように見える。

<br>

<img src="https://github.com/user-attachments/assets/4c1bd071-966f-4d51-99f4-e60fa2f36b0a" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/a0b22d6e-debb-420a-bf8d-fe8833583d09" alt="image" loading="lazy">

<br>



<br>

テクニカルレポート: https://github.com/deepseek-ai/Janus/blob/main/janus_pro_tech_report.pdf</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DialogueGeneration.html">#DialogueGeneration</a>
<a class="button" href="articles/SpeechProcessing.html">#SpeechProcessing</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2025-01-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1735">日本語Full-duplex音声対話システムの試作, 大橋+, J-Moshi</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/OpenSource.html">#OpenSource</a>
<span class="issue_date">Issue Date: 2025-01-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1733">Open R1, HuggingFace, 2025.01</a>
<span class="snippet"><span>Comment</span>HFによるDeepSeekR1を完全に再現する取り組みUpdate1: https://huggingface.co/blog/open-r1/update-1Update2: https://huggingface.co/blog/open-r1/update-2

<br>



<br>

512機のH100を利用…Update3:https://huggingface.co/blog/open-r1/update-3</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2025-01-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1730">Humanity's Last Exam, 2025.01</a>
<span class="snippet"><span>Summary</span>「人類の最後の試験」という新しいマルチモーダルベンチマークを導入し、100以上の科目にわたる3,000の挑戦的な質問を提供。これにより、LLMの能力を正確に測定し、過学習を評価するためのプライベートテストセットも保持。</span>
<span class="snippet"><span>Comment</span>o1, DeepSeekR1の正解率が10%未満の新たなベンチマーク</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2025-01-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1727">LLM Datasets, mlabonne, 2025.01</a>
<span class="snippet"><span>Comment</span>LLMの事後学習用のデータをまとめたリポジトリ</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2025-01-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1726">Llama Stack, Meta, 2024.11</a>
<span class="snippet"><span>Comment</span>Llamaを用いたLLM Agentを構築するための標準化されたフレームワーク。Quick StartではRAG Agentを構築している。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<span class="issue_date">Issue Date: 2025-01-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1725">distilabel, 2023.11</a>
<span class="snippet"><span>Comment</span>高品質な合成データをLLMで生成するためのフレームワーク</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-01-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1723">How to fine-tune open LLMs in 2025 with Hugging Face, PHILSCHMID, 2024.12</a>
<span class="snippet"><span>Comment</span>SFTTrainerを用いたLLMのSFTについて、実用的、かつ基礎的な内容がコード付きでまとまっている。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-01-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1722">How to align open LLMs in 2025 with DPO &amp; and synthetic data, PHILSCHMID, 2025.01</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_philschmid/status/1882428447877705908?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q・DPOの概要やRLHFと比較した利点

<br>

・ルールベース、あるいはLLM as a Judgeを用いたOn-policy preference pair（現在のSFTしたモデルの出力から生成したpreference data）の作り方とその利点（現在のモデルのoutput distributionを反映しているので学習が効率化される）

<br>

・環境構築方法

<br>

・DPOTrainer/TRLParserの使い方/DPODatasetの作り方

<br>

・DPOのハイパーパラメータβの意味合い

<br>

・DPOではSFTと比べて10-100x小さい学習率を使う必要があること

<br>

・Evaluation Harnessを用いた評価方法

<br>

・TGIを用いたモデルのデプロイとテスト

<br>



<br>

などが丁寧なサンプルコードと注釈、reference付きで説明されている。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-01-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1720">DeepSeek-R1-Distill-Qwen, DeepSeek, 2025.01</a>
<span class="snippet"><span>Comment</span>MIT Licence</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-01-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1719">DeepSeek-R1, DeepSeek, 2025.01</a>
<span class="snippet"><span>Comment</span>参考:https://x.com/icoxfog417/status/1883339727446974616?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q参考:https://horomary.hatenablog.com/entry/2025/01/26/204545DeepSeek-R1の論文読んだ？【勉強になるよ】

<br>

, asap:https://zenn.dev/asap/articles/34237ad87f8511こちらのポストの図解がわかりやすい:

<br>

https://x.com/1littlecoder/status/1887134619603968439?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q最新モデル: DeepSeek-R1-0528

<br>

https://huggingface.co/deepseek-ai/DeepSeek-R1-0528

<br>



<br>

<img src="https://github.com/user-attachments/assets/c2d7e967-1677-4791-81ad-2a7d050da593" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<span class="issue_date">Issue Date: 2025-01-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1718">tokyotech-llm_swallow-magpie-ultra-v0.1, tokyotech-llm, 2025.01</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2025-01-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1663">DeepSeek-V2のアーキテクチャを徹底解説：MLA と DeepSeekMoE, kernelian, 2024.05</a>
<span class="snippet"><span>Comment</span>・1665

<br>



<br>

も参照のこと。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2025-01-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1662">Killed by LLM, R0bk</a>
<span class="snippet"><span>Comment</span>Saturationとなっているベンチマークは、最先端の性能をすでに測定できなくなってしまったベンチマークとのこと。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2025-01-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1661">Advanced RAG Techniques: Elevating Your Retrieval-Augmented Generation Systems, NirDiamant, 2025.01</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/rohanpaul_ai/status/1875447223682748750?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QRAGのための細かなテクニックが（コードのサンプルへのリンク付きで）大量にまとまっている。かなり頻繁に更新れているようで非常に良さそう</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/python.html">#python</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/API.html">#API</a>
<a class="button" href="articles/x-Use.html">#x-Use</a>
<span class="issue_date">Issue Date: 2025-01-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1652">browser-use やばいです, Syoitu, 2024.12</a>
<span class="snippet"><span>Comment</span>すごい手軽に使えそうだが、クローリング用途に使おうとするとhallucinationが起きた時に困るのでうーんと言ったところ。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/python.html">#python</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/API.html">#API</a>
<span class="issue_date">Issue Date: 2025-01-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1651">LiteLLM, BerriAI, 2023.08</a>
<span class="snippet"><span>Comment</span>様々なLLMのAPIを共通のインタフェースで呼び出せるライブラリ

<br>



<br>

・1553 

<br>



<br>



<br>



<br>

とどちらがいいんだ・・・？aisuiteのissueの113番のスレッドを見ると、

<br>



<br>

・LiteLLMはもはやLiteではなくなっており、コードベースの保守性が低い

<br>



<br>

・aisuiteは複数のLLMプロバイダーをシンプルに利用する方法を提供する

<br>



<br>

・今後発表されるロードマップを見れば、LiteLLMとの差別化の方向性が分かるはずだ

<br>



<br>



<br>



<br>

といった趣旨のことが記述されていた。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/GenerativeAI.html">#GenerativeAI</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2025-01-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1642">Things we learned about LLMs in 2024, Simon Willson's blog, 2024.12</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_stakaya/status/1875059840126722127?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2025-01-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1635">To fine-tune or not to fine-tune, Meta, 2024.08</a>
<span class="snippet"><span>Comment</span>LLMをSFTする際の注意点やユースケースについて記述されている。

<br>



<br>

・full parameterのファインチューニングやPEFT手法のピークGPUメモリ

<br>

・full parameterのファインチューニングではcatastrophic forgettingに気をつける必要があること

<br>

・Finetuningが有用なユースケースとして以下が挙げられている

<br>

  ・トーン、スタイル、フォーマットのカスタマイザーション

<br>

  ・prompt engineeringやICLで達成するには困難なAccuracyの向上やエッジケースへの対応

<br>

  ・ドメイン適応

<br>

  ・より大きいモデルを蒸留することによるコスト削減

<br>

  ・新たなタスクへの適応や能力の獲得 また、RAGとFinetuningどちらを選択すべきかに関する話題も記述されている（が、多くの場合はハイブリッドアプローチがベストだ、といった話も書いてある）。元ポスト:https://x.com/gyakuse/status/1874357127248306200?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<span class="issue_date">Issue Date: 2025-01-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1633">2024-ai-timeline, reach-vb, 2025.01</a>
<span class="snippet"><span>Comment</span>月別で2024年にリリースされた主要なLLM（マルチモーダルなLLMも含む）のタイムラインがまとめられている。

<br>

API Only（プロプライエタリ）なのか、OpenWeightなのかもタグ付けされている。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2024-12-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1623">Preferred Generation Benchmark, pfnet-research, 2024.12</a>
<span class="snippet"><span>Comment</span>参考:https://x.com/bilzrd/status/1873167934564311133?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q日本語プレプリント:https://jxiv.jst.go.jp/index.php/jxiv/preprint/view/1008arXivはこれからっぽい</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1621">MHA vs MQA vs GQA vs MLA, Zain ul Abideen, 2024.07</a>
<span class="snippet"><span>Comment</span>DeepSeekで使われているMulti Head Latent Attention（MLA）ってなんだ？と思い読んだ。端的に言うと、GQAやMQAは、KVのヘッドをそもそも減らしてKV Cacheを抑えよう、という手法だったが、MLAはKVを低ランクなベクトルに圧縮して保持し、使う時に復元するといった操作をすることで、MHAのパフォーマンスを落とすことなく（むしろ上がるらしい？）、利用するKV Cacheで利用するメモリを大幅に減らせるという手法らしい。・1271

<br>



<br>

MQA, GQAの概要については上記参照のこと。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1620">Deep-seek-v3, deepseek-ai, 2024.12</a>
<span class="snippet"><span>Comment</span>参考（モデルの図解）:https://x.com/vtabbott_/status/1874449446056177717?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q参考:https://x.com/hillbig/status/1876397959841186148?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2024-12-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1617">LLMを数学タスクにアラインする手法の系譜 - GPT-3からQwen2.5まで, bilzard, 2024.12</a>
<span class="snippet"><span>Comment</span>・1618

<br>



<br>

において、数学においてモデルのパラメータ数のスケーリングによって性能改善が見込める学習手法として、モデルとは別にVerifierを学習し、モデルが出力した候補の中から良いものを選択できるようにする、という話の気持ちが最初よくわからなかったのだが、後半のなぜsample&amp;selectがうまくいくのか？節を読んでなんとなく気持ちが理解できた。SFTを進めるとモデルが出力する解放の多様性が減っていくというのは、興味深かった。

<br>



<br>

しかし、特定の学習データで学習した時に、全く異なるUnseenなデータに対しても解法は減っていくのだろうか？という点が気になった。あとは、学習データの多様性をめちゃめちゃ増やしたらどうなるのか？というのも気になる。特定のデータセットを完全に攻略できるような解法を出力しやすくなると、他のデータセットの性能が悪くなる可能性がある気がしており、そうするとそもそもの1shotの性能自体も改善していかなくなりそうだが、その辺はどういう設定で実験されているのだろうか。

<br>



<br>

たとえば、

<br>

・1475

<br>



<br>

などでは、

<br>



<br>

・1474

<br>



<br>

のような1600を超えるようなNLPタスクのデータでLoRAによりSFTすると、LoRAのパラメータ数を非常に大きくするとUnseenタスクに対する性能がfull-parameter tuningするよりも向上することが示されている。この例は数学に特化した例ではないが、SFTによって解法の多様性が減ることによって学習データに過剰適合して汎化性能が低下する、というのであれば、この論文のことを鑑みると「学習データにoverfittingした結果他のデータセットで性能が低下してしまう程度の多様性の学習データしか使えていないのでは」と感じてしまうのだが、その辺はどうなんだろうか。元論文を読んで確認したい。

<br>

とても勉強になった。記事中で紹介されている

<br>

&gt; LLMを使って複数解法の候補をサンプリングし、その中から最適な1つを選択する

<br>



<br>

のルーツは 1618 とのことなので是非読みたい。

<br>



<br>

この辺はSelf-Consistency 558 あたりが最初なのかと思っていた。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<span class="issue_date">Issue Date: 2024-12-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1615">LLM-as-a-Judge をサーベイする, Ayako, 2024.12</a>
<span class="snippet"><span>Comment</span>・1616

<br>



<br>

を読んだ結果を日本語でまとめてくださっている。モデル選択について、外部APIに依存するとコストやプライバシー、再現性などの問題があるためOpenLLMをFinetuningすることで対応していることが論文中に記載されているようだが、評価能力にはまだ限界があるとのこと。

<br>



<br>

記事中ではLlama, Vicunaなどを利用している旨が記述されているが、どの程度のパラメータサイズのモデルをどんなデータでSFTし、どのようなタスクを評価したのだろうか（あとで元論文を見て確認したい）。

<br>



<br>



<br>



<br>

また、後処理としてルールマッチで抽出する必要あがるが、モデルのAlignmentが低いと成功率が下がるとのことである。

<br>



<br>

個人的には、スコアをテキストとして出力する形式の場合生成したテキストからトークンを抽出する方式ではなく、G-Eva のようにスコアと関連するトークン（e.g. 1,2,3,4,5）とその尤度の加重平均をとるような手法が後処理が楽で良いと感じる。

<br>



<br>

ICLR2025の査読にLLM-as-a-Judgeが導入されるというのは知らなかったので、非常に興味深い。LLMが好む回答のバイアス（冗長性、位置など）別に各LLMのメタ評価をしている模様。また、性能を改善するための施策を実施した場合にどの程度メタ評価で性能が向上するかも評価している。特に説明を出力させても効果は薄く、また、複数LLMによる投票にしても位置バイアスの軽減に寄与する程度の改善しかなかったとのこと。また、複数ラウンドでの結果の要約をさせる方法がバイアスの低減に幅広く寄与したとのこと。うーん、バイアスを低減するうまい方法がまだ無さそうなのがなかなか厳しい感じがする。

<br>

そもそも根本的に人間に人手評価をお願いする時もめちゃめちゃマニュアルとかガイドラインを作り込んだりした上でもagreementが高くなかったりするので、やはり難しそうである。

<br>



<br>

ただ、MTBenchでは人間の評価結果とLLMの評価結果の相関（agreementだっけか…？）が高かったことなどが報告されているし、LLMあるあるのタスクごとに得意不得意があります、という話な気もする。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Video.html">#Video</a>
<span class="issue_date">Issue Date: 2024-12-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1614">Stanford CS229 I Machine Learning I Building Large Language Models （LLMs）, StanfordUnivercity, 2024.09</a>
<span class="snippet"><span>Comment</span>スタンフォード大学によるLLM構築に関する講義。事前学習と事後学習両方ともカバーしているらしい。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2024-12-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1613">Qwen2.5 Technical Reportの中に潜る, AbejaTech Blog, 2024.12</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/GenerativeAI.html">#GenerativeAI</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-12-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1612">OpenAI o3は，人間とは全く異質の汎用知能である危険性【東大解説】, 神楽坂やちま, 2024.12</a>
<span class="snippet"><span>Comment</span>様々な有識者の見解をまとめつつ、文献を引用しつつ、かつ最終的に「人間が知能というものに対してなんらかのバイアスを持っている」可能性がある、という話をしており興味深い。

<br>

一部の有識者はARC-AGIの一部の、人間なら見た瞬間に分かるようなパターン認識の問題でも解けていないことから、AGIではないと主張しているとのことだったが、人間目線で簡単な問題が解けることはAGIとして必須な条件ではないよね、といった話が書かれており、そもそも有識者がどのようなものさしや観点でAGIを見ているのか、どういう視点があるのか、ということが感覚的に分かる内容であり、おもしろかった。

<br>



<br>

しかし、そもそも何がどうなったらAGIが実現できたと言えるのだろうか？定義がわからない（定義、あるのか…？）</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Sentence.html">#Sentence</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Tokenizer.html">#Tokenizer</a>
<span class="issue_date">Issue Date: 2024-12-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1611">Large Concept Models: Language Modeling in a Sentence Representation Space, Meta, 2024.12</a>
<span class="snippet"><span>Summary</span>本研究では、言語やモダリティに依存しない「大規模概念モデル」を提案し、概念を高次の意味表現として扱います。最大200言語をサポートするSONAR文埋め込み空間を用い、自己回帰的な文予測を行うモデルを訓練しました。16億パラメータのモデルから70億パラメータにスケールアップし、生成タスクに対する実験評価を実施。結果として、ゼロショット一般化性能が向上し、既存のLLMsを上回ることを示しました。トレーニングコードは公開されています。</span>
<span class="snippet"><span>Comment</span>まだ全く読めていないが、従来のLLMはnent-token-predictionで学習をしており、transformers decoderの内部状態で何らかの抽象的な概念はとらえているものの、次トークン予測に前回生成したトークンをinputするのが必須である以上「トークンで考える」みたいな挙動をある程度はしてしまっており、人間はそんなことしないですよね？みたいな話だと思われる。

<br>

人間はもっと抽象的なコンセプトレベルで物事を考えることができるので、それにより近づけるために、conceptをsentenceとしてみなして、next-concept-predictionでモデルを学習したらゼロショットの汎化性能上がりました、みたいな話のように見える。ただし、評価をしているのはマルチリンガルな文書要約タスクのみに見える。

<br>



<br>

追記: コンセプトが言語非依存だとすると、コンセプト間の関係性を学習するLCMが、マルチリンガルでトークンレベルの学習しかしない従来LLMを上回るのも納得いく気はする。なぜなら、従来LLMよりも言語（トークン）への依存が緩和されていると思われるので、言語間を跨いだ知識の転移が起きやすいと考えられるからである。

<br>



<br>

<img src="https://github.com/user-attachments/assets/2f3dc98d-ef27-44b8-be1c-0f27a05f37e8" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/effc21ba-22db-42c0-bc33-1d43f9e0200a" alt="image" loading="lazy">Base-LCMを見ると、文の埋め込みのground truthと生成された文の埋め込みの差を最小化する（Mean Squared Error） ようなlossになっている。つまり、トークンレベルではなく、より抽象的な概念を直接学習するような設計になっているためここが従来のLLMと異なる。

<br>



<br>

<img src="https://github.com/user-attachments/assets/01da9a76-f5fb-4e79-b3cf-8bddc123379b" alt="image" loading="lazy">

<br>



<br>

これを実現するために、ground truthとなる文の埋め込みx_nが分からなければいけないが、このために、freezeしたEncoderとDecoderを用意してLCMにconcatしていると思われる。つまり、入力と出力のconceptを解釈する機構は固定して、正解となる文埋め込みを決めてしまう。そして、LCMはinputされたconceptを別のconceptに変換するような機構となっており、その変換の関係性を学習している。なるほど、なんとなく気持ちはわかった。日本語を含むいくつかの言語でゼロショット性能が低下しているのが興味深い。日本語特有の概念とか、特定の言語固有の概念は欠落する可能性が示唆される。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2024-12-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1610">完全にオープンな約1,720億パラメータ（GPT-3級）の大規模言語モデル 「llm-jp-3-172b-instruct3」を一般公開 ～GPT-3.5を超える性能を達成～ , NII, 2024.12</a>
<span class="snippet"><span>Comment</span>GPT3.5と同程度のパラメータ数のコーパス、モデル、ツール、全てを公開。学習データまで含めてオープンなモデルとしては世界最大規模とのこと。Instructionチューニング済みのモデルはライセンスを読むと、ライセンスに記述されている内容を遵守すれば、誰でも（日本人なら18歳以上とかはあるが）アクセス可能、用途の制限（商用・非商用問わず）なく利用でき、かつ再配布や派生物の生成などが許されているように見える。

<br>

が、baseモデルの方はコンタクト情報を提供のうえ承認を受けないと利用できない模様。また、再配布と一部の使途に制限がある模様。

<br>



<br>

SNSではオープンソースではないなどという言説も出ており、それはbaseモデルの方を指しているのだろうか？よくわからない。実用上はinstructionチューニング済みのモデルの方がbaseモデルよりも使いやすいと思うので、問題ない気もする。やはりbaseとinstructでライセンスは2種類あるとのこと: https://x.com/odashi_t/status/1871508348086214685?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/pretrained-LM.html">#pretrained-LM</a>
<span class="issue_date">Issue Date: 2024-12-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1606">ModernBERT, AnswerDotAI, 2024.12</a>
<span class="snippet"><span>Summary</span>ModernBERTは、エンコーダ専用のトランスフォーマーモデルで、従来のBERTに比べて大幅なパレート改善を実現。2兆トークンで訓練され、8192シーケンス長を持ち、分類タスクやリトリーバルで最先端の結果を示す。速度とメモリ効率も優れており、一般的なGPUでの推論に最適化されている。</span>
<span class="snippet"><span>Comment</span>最近の進化しまくったTransformer関連のアーキテクチャをEncodnr-OnlyモデルであるBERTに取り込んだら性能上がるし、BERTの方がコスパが良いタスクはたくさんあるよ、系の話、かつその実装だと思われる。

<br>

テクニカルペーパー中に記載はないが、評価データと同じタスクでのDecoder-Onlyモデル（SFT有り無し両方）との性能を比較したらどの程度の性能なのだろうか？そもそも学習データが手元にあって、BERTをFinetuningするだけで十分な性能が出るのなら（BERTはGPU使うのでそもそもxgboostとかでも良いが）、わざわざLLM使う必要ないと思われる。BERTのFinetuningはそこまで時間はかからないし、inferenceも速い。

<br>



<br>

参考:

<br>

・1024日本語解説:https://zenn.dev/dev_commune/articles/3f5ab431abdea1?utm_source=substack&utm_medium=email</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<span class="issue_date">Issue Date: 2024-12-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1603">【NLPコロキウム】Stepwise Alignment for Constrained Language Model Policy Optimization （NeurIPS 2024）  , 2024.12</a>
<span class="snippet"><span>Comment</span>・1602

<br>



<br>

も参照のこと。RLHF, DPOが解いている問題が同じで、問題が同じなのでそれぞれの最適解も一緒であり解き方が違うだけ、でもDPOの方が頑張って強化学習するRLHFよりも簡単に解けるし、学習も安定してるよ、という話が、binary feedbackデータに対するアライメント手法であるKTOも交えて書いてある。アライメントの学習では単一のスカラー値によって報酬が決まっているが、生成結果には色々な側面があるから単一スカラーでは本来評価できないよねという話が出てきた上で、safetyに対しても考慮して報酬を決めたい、という時にスカラー値のままだけど最適化問題の制約条件にsafetyに関する制約を入れる、ことで報酬に反映させます、みたいな話が書いてある。

<br>

そして提案手法の主要な貢献は、そういうことをやるとめちゃめちゃ手法が複雑化するんだけれども、よりシンプルにして、かつ理論的にも正当化されているし、実験的にもうまく動きます、という話らしい。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/RLHF.html">#RLHF</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<span class="issue_date">Issue Date: 2024-12-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1602">RLHF_DPO 小話, 和地瞭良_ Akifumi Wachi, 2024.04</a>
<span class="snippet"><span>Comment</span>めちゃめちゃ勉強になる…</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<span class="issue_date">Issue Date: 2024-12-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1591">国際会議ACL2024参加報告, Masato Mita, Cyber Agent, 2024.12</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/SpokenLanguageProcessing.html">#SpokenLanguageProcessing</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/OpenSource.html">#OpenSource</a>
<span class="issue_date">Issue Date: 2024-12-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1588">LLaMA-Omni: Seamless Speech Interaction with Large Language Models, Meta, 2024.09</a>
<span class="snippet"><span>Comment</span>音声とテキストのOpenSourceマルチモーダルモデル。inputは音声のみ？に見えるが、出力はテキストと音声の両方を実施できる。GPT-4oレベルのspeech capabilityを目指すとaboutに記載されている。興味深い。

<br>



<br>



<br>



<br>

installの説明に `Whisper-large-v3` をインストールする旨が記載されているので、Whisper-large-v3で認識した内容に特化したSpeech Encoder/Adapterが学習されていると考えられる。

<br>



<br>

<img width="702" alt="image" src="https://github.com/user-attachments/assets/cea090e7-a42a-476d-85f6-50199d9ae180">

<br>



<br>

・1225 

<br>



<br>



<br>



<br>

マルチモーダルなLLMの基本的な概念については上記参照のこと。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<span class="issue_date">Issue Date: 2024-12-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1582">Sarashina-Embedding-v1-1B, SB Iumuitions, 2024.12</a>
<span class="snippet"><span>Comment</span>Non-commercialなライセンスで、商用利用の場合は問い合わせが必要</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<span class="issue_date">Issue Date: 2024-12-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1576">OpenAI o1 System Card, OpenAI, 2024.12</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-12-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1574">Llama3.3-70B, Meta, 2024.12</a>
<span class="snippet"><span>Comment</span>3.1-70Bよりも性能向上し、3.1-405Bの性能により近く。

<br>



<br>

（画像は元ポストより引用）

<br>

<img src="https://github.com/user-attachments/assets/07fb3043-131a-4564-be70-d34b70c31cca" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/FoundationModel.html">#FoundationModel</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<span class="issue_date">Issue Date: 2024-12-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1571">Introducing Amazon Nova, our new generation of foundation models, AWS, 2024.12</a>
<span class="snippet"><span>Comment</span>参考:https://qiita.com/ysit/items/8433d149dbaab702d526テクニカルレポート: https://assets.amazon.science/9f/a3/ae41627f4ab2bde091f1ebc6b830/the-amazon-nova-family-of-models-technical-report-and-model-card.pdf後で個々のベンチマークとメトリックをまとめたい。

<br>



<br>

まあでもざっくり言うと、他のproprietaryモデルともおおむね同等の性能です、という感じに見える。個々のタスクレベルで見ると、得意なものと不得意なものはありそうではある。

<br>



<br>

<img src="https://github.com/user-attachments/assets/c0c633d8-c64d-4a14-95cf-0d8b0d52a7f6" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/560f8c3e-65ff-4742-b7da-bc2b242dafcd" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/481a9635-128d-4931-a891-5f46d55b82bc" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/fc9b1bc0-b857-4a27-ad90-4940213c6ec6" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/a349b154-1844-41c2-84e3-7f981b1f6b72" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/a4381740-600c-402f-be0d-59ce60b7a562" alt="image" loading="lazy">

<br>



<br>

スループットとかも、ProとGPT4oをパッと見で比較した感じ、優れているわけでもなさそう。Liteに対応するGPTはおそらくGPT4o-miniだと思われるが、スループットはLiteの方が高そう。

<br>

<img src="https://github.com/user-attachments/assets/734ee26f-2f16-46e4-a6e8-f5f2f0d65be3" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/fe1768e8-b417-4b89-a0c4-f6dffa99cf11" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/6334ee92-e426-49f5-8e1f-050e0b77fcf2" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/5c9ec797-ef7a-43e1-8540-42ccab265208" alt="image" loading="lazy">

<br>



<br>

（画像は論文中からスクショし引用）下記ポストは独自に評価した結果や、コストと性能のバランスについて言及している。

<br>



<br>

・ProはGPT4oのコストの約1/3

<br>

・Pro, Lite, Flashはほれぞれコストパフォーマンスに非常に優れている（Quality vs. Price参照）

<br>



<br>

元ポスト:https://x.com/artificialanlys/status/1864023052818030814?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<a class="button" href="articles/OpenSource.html">#OpenSource</a>
<span class="issue_date">Issue Date: 2024-12-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1563">日本語LLMまとめ, LLM-jp, 2024.12</a>
<span class="snippet"><span>Comment</span>LLM-jpによる日本語LLM（Encoder-Decoder系, BERT系, Bi-Encoders, Cross-Encodersを含む）のまとめ。

<br>

テキスト生成に使うモデル、入力テキスト処理に使うモデル、Embedding作成に特化したモデル、視覚言語モデル、音声言語モデル、日本語LLM評価ベンチマーク/データセットが、汎用とドメイン特化型に分けてまとめられている。

<br>

各モデルやアーキテクチャの原論文、学習手法の原論文もまとめられている。すごい量だ…。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/SelfCorrection.html">#SelfCorrection</a>
<span class="issue_date">Issue Date: 2024-11-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1558">LLM Self-Correction Papers, Ryo Kamoi, 2024.11</a>
<span class="snippet"><span>Comment</span>self-correctionの専門家によるself-correction関連の論文のリーディングリスト。ぜひチェックしたい。

<br>



<br>

元ポスト: https://x.com/ryokamoi_ja/status/1862635105010799054?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/AES(AutomatedEssayScoring).html">#AES(AutomatedEssayScoring)</a>
<span class="issue_date">Issue Date: 2024-11-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1555">Cross-prompt Pre-finetuning of Language Models for Short Answer Scoring, Funayama+, 2024.09</a>
<span class="snippet"><span>Summary</span>自動短答スコアリング（SAS）では、異なるルーブリックと参照回答に基づいてスコアを付けるが、新しいプロンプトごとにモデルを再訓練する必要がありコストがかかる。本研究では、既存のルーブリックと回答を用いて新しいプロンプトでファインチューニングする二段階アプローチを提案。重要なフレーズを学習することで、特に訓練データが限られている場合にスコアリング精度を向上させることを実験で示した。</span>
<span class="snippet"><span>Comment</span>SASでは回答データが限られているので、限られたデータからより効果的に学習をするために、事前に他のデータでモデルをpre-finetuningしておき、対象データが来たらpre-finetuningされたモデルをさらにfinetuningするアプローチを提案。ここで、prompt中にkeyphraseを含めることが有用であると考え、実験的に有効性を示している。

<br>



<br>

<img src="https://github.com/user-attachments/assets/9ab4eb22-b72e-4573-8fbb-1c376047c2b0" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/b671a564-c5a8-4344-aaec-06875f654f8b" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

BERTでfinetuningをした場合は、key-phraseを含めた方が性能が高く、特にfinetuningのサンプル数が小さい場合にその差が顕著であった。

<br>



<br>

<img src="https://github.com/user-attachments/assets/cdced65b-060b-43ae-a2b4-fcfc5750a6ed" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

次に、LLM（swallow-8B, 70B）をpre-finetuningし、pre-finetuningを実施しない場合と比較することで、pre-finetuningがLLMのzero-shot、およびICL能力にどの程度影響を与えるかを検証した。検証の結果、pre-finetuningなしでは、そもそも10-shotにしてもQWKが非常に低かったのに対し、pre-finetuningによってzero-shotの能力が大幅に性能が向上した。一方、few-shotについては3-shotで性能が頭打ちになっているようにみえる。ここで、Table1のLLMでは、ターゲットとする問題のpromptでは一切finetuningされていないことに注意する（Unseenな問題）。

<br>



<br>

<img width="639" alt="image" src="https://github.com/user-attachments/assets/7c9f141d-dc55-4388-8dc4-6a56f81d6cad">

<br>



<br>



<br>



<br>

続いて、LLMをfinetuningした場合も検証。提案手法が高い性能を示し、200サンプル程度ある場合にHuman Scoreを上回っている（しかもBERTは200サンプルでサチったが、LLMはまだサチっていないように見える）。また、サンプル数がより小さい場合に、提案手法がより高いgainを得ていることがわかる。

<br>



<br>

<img width="775" alt="image" src="https://github.com/user-attachments/assets/898b2bea-e9df-4c5c-b172-0507a3a83c3c">

<br>



<br>



<br>



<br>

また、個々の問題ごとにLLMをfinetuningするのは現実的に困難なので、個々の問題ごとにfinetuningした場合と、全ての問題をまとめてfinetuningした場合の性能差を比較したところ、まとめて学習しても性能は低下しない、どころか21問中18問で性能が向上した（LLMのマルチタスク学習の能力のおかげ）。

<br>



<br>

<img width="762" alt="image" src="https://github.com/user-attachments/assets/a8ec62fb-2984-4e7c-8eeb-1b3b6333e9ac">

<br>



<br>

[Perplexity(hallucinationに注意)](https://www.perplexity.ai/search/tian-fu-sitalun-wen-wodu-mi-ne-3_TrRyxTQJ.2Bm2fJLqvTQ0)</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/AES(AutomatedEssayScoring).html">#AES(AutomatedEssayScoring)</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2024-11-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1554">国語記述問題自動採点システムの開発と評価, Yutaka Ishii+, 日本教育工学会, 2024.05</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/python.html">#python</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/API.html">#API</a>
<span class="issue_date">Issue Date: 2024-11-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1553">aisuite, andrewyng, 2024.11</a>
<span class="snippet"><span>Comment</span>複数のLLM Providerの呼び出しを共通のインタフェースで呼び出せる。変更するのは、モデルを指定するパラメータのみ。

<br>



<br>

元ポスト:https://www.linkedin.com/posts/andrewyng_announcing-new-open-source-python-package-activity-7266851242604134400-Davp?utm_source=share&utm_medium=member_ios</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/SSM%20(StateSpaceModel).html">#SSM (StateSpaceModel)</a>
<span class="issue_date">Issue Date: 2024-11-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1551">チュートリアル：Mamba, Vision Mamba （Vim）, Hironobu Fujiyoshi, 2024.11</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2024-11-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1545">Sarashina2-8x70Bの公開, SB Intuitions, 2024.11</a>
<span class="snippet"><span>Comment</span>MoE Layerの説明、Sparse Upcyclingの説明、MoEモデルを学習する際に、学習時の学習率の設定が大きすぎると初期に損失が増大し、小さすぎると損失の増大は防げるがlong runで学習した際の性能向上が小さかったこと、元のモデルのパラメータを毀損しないように、Upcyclingをした元モデルの最終的な学習率を踏襲して学習をし、学習率をさらに減衰させていったこと、などが記載されている。

<br>



<br>

また、性能評価として同等のactivation parameter数を持つモデルと日本語のQAタスクで比較した結果も載っている。

<br>



<br>

・1546MoE Layerについては

<br>

・1204

<br>



<br>

も参照のこと</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2024-11-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1538">SmolLM2, 2024.11</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_philschmid/status/1859598525723488478?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QOrca-AgenInstruct-1M 1521 よりもSmolLMのSFTで各種ベンチで高い性能を獲得

<br>

<img src="https://github.com/user-attachments/assets/ed39fa8e-eeac-493f-a220-30313be5b761" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/Word.html">#Word</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/STS%20(SemanticTextualSimilarity).html">#STS (SemanticTextualSimilarity)</a>
<span class="issue_date">Issue Date: 2024-11-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1536">Zipf 白色化：タイプとトークンの区別がもたらす良質な埋め込み空間と損失関数, Sho Yokoi, 2024.11</a>
<span class="snippet"><span>Summary</span>単語埋め込み空間の歪みを修正することでタスクのパフォーマンスが向上することを示す。既存のアプローチは単語頻度が均一であると仮定しているが、実際にはZipfの法則に従う非均一な分布である。Zipfに基づく頻度で重み付けされたPCAホワイトニングを行うことで、パフォーマンスが大幅に向上し、ベースラインを超える。情報幾何学的な観点から、低頻度の単語を強調する理論を提案し、人気の自然言語処理手法がこの理論に基づいて機能することを示す。</span>
<span class="snippet"><span>Comment</span>元論文: [Yokoi, Bao, Kurita, Shimodaira, “Zipfian Whitening,” NeurIPS 2024. ](https://arxiv.org/abs/2411.00680)単語ベクトルを活用して様々なタスクを実施する際に一般的な全部足して個数で割るような平均ベクトル計算は、

<br>

個々の単語頻度を一様と仮定した場合の"期待値"と等価であり、

<br>

これは現実世界の単語頻度の実態とは全然異なるから、きちんと考慮したいよね、という話で

<br>

<img src="https://github.com/user-attachments/assets/cc38dbd5-8b6e-45e6-8a81-00f524eb36f8" alt="image" loading="lazy">

<br>

頻度を考慮するとSemantic Textual Similarity（STS）タスクで効果絶大であることがわかった。

<br>

<img src="https://github.com/user-attachments/assets/2042d75f-6325-4e50-9423-f8621084fb75" alt="image" loading="lazy">

<br>



<br>

では、なぜこれまで一様分布扱いするのが一般的だったのかというと、

<br>

実態として単語埋め込み行列が単語をタイプとみなして構築されたものであり、

<br>

コーパス全体を捉えた（言語利用の実態を捉えた）データ行列（単語をトークンとみなしたもの）になっていなかったことに起因していたからです（だから、経験頻度を用いて頻度情報を復元する必要があるよね）、

<br>

という感じの話だと思われ、

<br>

<img src="https://github.com/user-attachments/assets/ba97319c-83f7-4443-a8e3-fa36030d704b" alt="image" loading="lazy">

<br>



<br>

経験頻度を考慮すると、そもそも背後に仮定しているモデル自体が暗黙的に変わり、

<br>

低頻度語が強調されることで、単語に対してTF-IDFのような重みづけがされることで性能が良くなるよね、みたいな話だと思われる。

<br>

<img src="https://github.com/user-attachments/assets/7495f250-d680-4698-99c5-a326ead77e12" alt="image" loading="lazy">余談だが、昔のNLPでは、P(w,c)をモデル化したものを生成モデル、テキスト生成で一般的なP(w|c)は分類モデル（VAEとかはテキスト生成をするが、生成モデルなので別）、と呼んでいたと思うが、いまはテキスト生成モデルのことを略して生成モデル、と呼称するのが一般的なのだろうか。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Zero/FewShotPrompting.html">#Zero/FewShotPrompting</a>
<span class="issue_date">Issue Date: 2024-11-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1535">Datasets: hpprc_honyaku, hpprc, 2024.11</a>
<span class="snippet"><span>Comment</span>元ポスト: https://x.com/hpp_ricecake/status/1859118112672780401?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q英語Wikipediaを冒頭数文を抽出し日本語に人手で翻訳（Apache2.0ライセンスであるCalmやQwenの出力を参考に、cc-by-sa-4.0ライセンスにて公開している。

<br>

テクニカルタームが日本語で存在する場合は翻訳結果に含まれるようにしたり、翻訳された日本語テキストが単体で意味が成り立つように翻訳しているとのことで、1件あたり15分もの時間をかけて翻訳したとのこと。データ量は33件。many-shotやfew-shotに利用できそう。

<br>



<br>

日英対訳コーパスはライセンスが厳しいものが多いとのことなので、非常に有用だと思う。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<span class="issue_date">Issue Date: 2024-11-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1528">Large Vision Language Model （LVLM）に関する知見まとめ, Daiki Shiono, 2024.11</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<span class="issue_date">Issue Date: 2024-11-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1521">microsoft_orca-agentinstruct-1M-v1, Microsoft, 2024.11</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/OpenSource.html">#OpenSource</a>
<span class="issue_date">Issue Date: 2024-11-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1519">ローカルLLMのリリース年表, npaka, 随時更新, 2024.11</a>
<span class="snippet"><span>Comment</span>ローカルLLMを含むOpenLLMのリリース日が年表としてまとまっており、随時更新されている模様。すごい。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2024-11-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1514">LLM Prompt Tuning Playbook, 2024.11</a>
<span class="snippet"><span>Comment</span>・1462 も参照のこと</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2024-11-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1494">sarashina2-8x70B, SBIntuitions, 2024.11</a>
<span class="snippet"><span>Comment</span>プレスリリース:https://www.sbintuitions.co.jp/news/press/20241108_01/・商用利用不可な点には注意

<br>

・アーキテクチャは70Bモデルx8のMixture of Experts（MoE）

<br>

・モデルカードによると、inferenceにはBF16で、A100 80GB or H100が16基必要っぽいMoEを利用したLLMについては、1204 を参照のこと。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2024-11-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1488">RAGの改善方法に関する情報のまとめ（再掲）, GENZITSU, 2023.10</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<span class="issue_date">Issue Date: 2024-11-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1487">ZeRO: DeepSpeedの紹介, レトリバ, 2021.07 </a>
<span class="snippet"><span>Comment</span>ZeROの説明がわかりやすいこちらの記事もわかりやすい

<br>



<br>

https://zenn.dev/turing_motors/articles/d00c46a79dc976DeepSpeedのコンフィグの一覧

<br>



<br>

https://www.deepspeed.ai/docs/config-json/transformersにおけるdeepspeedのドキュメント:

<br>

https://huggingface.co/transformers/v4.9.2/main_classes/deepspeed.html参考: deepspeedの使い方まとめ

<br>

https://note.com/fukudawataru/n/n5152e6f587c8ZeRO Stage3を使う場合、ページ後方にしれっととんでもなく重要なことが書いてあるので気をつけましょう。。。。

<br>



<br>

https://huggingface.co/docs/transformers/v4.17.0/en/main_classes/deepspeedconstructing-massive-models

<br>



<br>



<br>



<br>

<img src="https://github.com/user-attachments/assets/677b6656-1302-4b1b-8be6-ca954c7edda6" alt="image" loading="lazy">

<br>



<br>

ZeROはparameterとoptimizerのmemory footprintの最適化を頑張っていて、activation memory footprint（バッチをforward passに流す時に消費されるメモリ）の削減は、tiling, activation/gradient checkpointingとかで頑張ってねという

<br>



<br>



<br>



<br>

という話が本家issueの4047に記載されている。結論: つまづいたらDeepSpeedのIssueをエラーメッセージで検索かけるのが一番効果的</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/SpeechProcessing.html">#SpeechProcessing</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/AutomaticSpeechRecognition(ASR).html">#AutomaticSpeechRecognition(ASR)</a>
<span class="issue_date">Issue Date: 2024-11-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1485">ほぼリアルタイム！？爆速で動作する日本語特化の文字起こしAI！『kotoba-whisper-v2.0』, 遼介 大堀, 2024.11</a>
<span class="snippet"><span>Comment</span>whisper large-v3を蒸留したkotoba-whisper-v1.0に対して、日本語のオーディオデータで追加学習をしたモデル、kotoba-whisper-v2.0を利用するための環境構築方法やコードの例が記述されている。

<br>



<br>

公式によると、whisper-large-v3よりも6.3倍のスループットとのこと。また、qiita記事中ではwhisper large-v2に対して約6.0倍のスループットであることが言及されている。

<br>



<br>

学習に用いられたデータは、ReasonSpeechデータ（日本語のテレビの録音データ） 1001 をWERに基づくフィルタリングによって良質なデータのみを抽出することで作成されたデータの模様

<br>



<br>

公式のモデルカードも参照のこと:https://huggingface.co/kotoba-tech/kotoba-whisper-v2.0日本のテレビ番組のデータで学習されているので、それを念頭に置いた上で、自分が適用したいデータとの相性を考えると良さそうである。

<br>



<br>

また、動作速度が速いのはシンプルにありがたい。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/MinimalCode.html">#MinimalCode</a>
<span class="issue_date">Issue Date: 2024-11-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1479">Lingua, Meta</a>
<span class="snippet"><span>Comment</span>研究目的のための、minimal、かつ高速なLLM training/inferenceのコードが格納されたリポジトリ。独自のモデルやデータ、ロスなどが簡単に実装できる模様。

<br>



<br>

<img src="https://github.com/user-attachments/assets/47f70515-3de0-455f-9fc4-0e2e17442eed" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Quantization.html">#Quantization</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-10-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1471">Introducing quantized Llama models with increased speed and a reduced memory footprint, Meta, 2024.10</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-10-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1469">Aya Expanse, Cohere, 2024.10</a>
<span class="snippet"><span>Comment</span>CohereによるマルチリンガルLLM, 8B, 32Bのモデルが存在する。

<br>



<br>

8BモデルのArenaHardでの評価

<br>

<img src="https://github.com/user-attachments/assets/c52678fd-b1a4-40ed-b6b9-7cc7d1096ff0" alt="image" loading="lazy">

<br>



<br>

32BモデルのArenaHardでの評価

<br>

<img src="https://github.com/user-attachments/assets/fc8cc3d1-4ba3-4bdc-985f-1df4ccc2996c" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2024-10-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1462">Prompt-Engineering-Guide, DAIR.AI</a>
<span class="snippet"><span>Comment</span>LLMのsettingから、few-shot, self-consistencyなどのprompting技術、さまざまなタスクの実例などが網羅的にまとまっている</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2024-10-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1457">MLE-Bench, OpenAI, 2024.10</a>
<span class="snippet"><span>Summary</span>MLE-benchを紹介し、AIエージェントの機械学習エンジニアリング能力を測定するためのベンチマークを構築。75のKaggleコンペを基に多様なタスクを作成し、人間のベースラインを確立。最前線の言語モデルを評価した結果、OpenAIのo1-previewが16.9%のコンペでKaggleのブロンズメダル相当の成果を達成。AIエージェントの能力理解を促進するため、ベンチマークコードをオープンソース化。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-10-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1454">Llama-3.1-Nemotron-70B-Instruct, Nvidia, 2024.10</a>
<span class="snippet"><span>Comment</span>paper:https://arxiv.org/abs/2410.01257MTBench, Arena HardでGPT4o-20240513,Claude-3.5-sonnet-20240620をoutperform。Response lengthの平均が長いこと模様

<br>

<img src="https://github.com/user-attachments/assets/e7fe1193-f3c6-4d17-8077-2f4742aef00c" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<span class="issue_date">Issue Date: 2024-10-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1450">Unsloth</a>
<span class="snippet"><span>Comment</span>single-GPUで、LLMのLoRA/QLoRAを高速/省メモリに実行できるライブラリ</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2024-10-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1443">Gemma-2-Baku, 2024.10</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2024-10-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1441">Gemma-2-JPN, 2024.10</a>
<span class="snippet"><span>Comment</span>日本語データでfinetuningされてGemma2</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<span class="issue_date">Issue Date: 2024-09-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1431">Evaluating the Effectiveness of LLM-Evaluators （aka LLM-as-Judge）, 2024.09</a>
<span class="snippet"><span>Comment</span>LLM-as-a-judgeについて網羅的に書かれた記事</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-09-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1430">RAGの実装戦略まとめ, Jin Watanabe, 2024.03</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<span class="issue_date">Issue Date: 2024-09-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1426">Molmo, AI2, 2024.09</a>
<span class="snippet"><span>Summary</span>Molmoは、オープンデータを活用した最先端のマルチモーダルAIモデルであり、特に小型モデルが大規模モデルを上回る性能を示す。Molmoは、物理的および仮想的な世界とのインタラクションを可能にし、音声ベースの説明を用いた新しい画像キャプションデータセットを導入。ファインチューニング用の多様なデータセットを使用し、非言語的手がかりを活用して質問に答える能力を持つ。Molmoファミリーのモデルは、オープンウェイトでプロプライエタリシステムに対抗する性能を発揮し、今後すべてのモデルウェイトやデータを公開予定。</span>
<span class="snippet"><span>Comment</span>以下がベンチマーク結果（VLMのベンチマーク）。11 benchmarksと書かれているのは、VLMのベンチマークである点に注意。

<br>



<br>



<br>



<br>

<img width="981" alt="image" src="https://github.com/user-attachments/assets/510204e5-4cfb-4ba3-a6db-fff717a637bc">

<br>



<br>

<img width="940" alt="image" src="https://github.com/user-attachments/assets/a4a77006-fcde-4c33-b6df-54dc5d8cbdfa">

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-09-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1422">Llama 3.2: Revolutionizing edge AI and vision with open, customizable models, Meta, 2024.09</a>
<span class="snippet"><span>Comment</span>11Bと90BのVLMと、エッジデバイス向けの1B, 3BのSLMを発表。

<br>

<img src="https://github.com/user-attachments/assets/13c4af37-19bd-4de7-b501-eb48f955af0c" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/d6b75b15-88cb-4d9e-9838-0da24308ccda" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/7475b30d-4619-4117-a911-d308291f86cb" alt="image" loading="lazy">Llama3.2のVLMでは、事前学習されたimage encoderを事前学習された言語モデルに対して組み合わせるためのAdapterを複数学習することによって実現。

<br>



<br>

具体的には、Llama 3.1（text only model）に対して、image encoderとAdapterを追加し、大規模でノイジーな（image,text）ペアで事前学習。続いて、中規模のサイズの高品質なin-domain（i.e. 様々なドメインの）の知識を高めるような（image,text）ペアで学習した。

<br>



<br>

事後学習では、Llama3.1と同様にSFT, Rejection Sampling, DPOのラウンドを複数回繰り返した。Llama3.1を用いて、in-domainの画像に対するQAをData Augmentationし、フィルタリングすることで合成データを作成。さらに報酬モデルを活用して全ての回答候補をランクづけして高品質なSFTデータを取得。また、モデルの安全性が高まるようなデータも追加した。

<br>



<br>

Llama3.1の事後学習のプロセスについては 1359 も参照のこと。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2024-09-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1418">LLM-jp-3 1.8B・3.7B・13B の公開, LLM.jp, 2024.09</a>
<span class="snippet"><span>Comment</span>LLM-JP-Evalでの評価結果はこちら:https://huggingface.co/llm-jp/llm-jp-3-1.8b1.8Bのモデルが、モデルサイズに対して非常に性能が良いとのこと（確かに、3.8Bのモデルとの差があまりないように見える

<br>

元ポスト:https://x.com/odashi_t/status/1838814594514718878?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QアーキテクチャはLlama2とのことなので、vLLMでも動作させられる模様</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2024-09-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1417">LLM-jp Corpus v3, LLM.jp, 2024.09</a>
<span class="snippet"><span>Comment</span>LLM-jp-3 1418 の学習に利用されているコーパス</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2024-09-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1414">Improving Language Understanding by Generative Pre-Training, OpenAI, 2018.06</a>
<span class="snippet"><span>Summary</span>自然言語理解のタスクにおいて、ラベルなしテキストコーパスを用いた生成的事前学習と識別的微調整を行うことで、モデルの性能を向上させるアプローチを提案。タスクに応じた入力変換を利用し、モデルアーキテクチャの変更を最小限に抑えつつ、12のタスク中9つで最先端の成果を大幅に改善。特に、常識推論で8.9%、質問応答で5.7%、テキストの含意で1.5%の改善を達成。</span>
<span class="snippet"><span>Comment</span>初代GPT論文</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<span class="issue_date">Issue Date: 2024-09-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1390">OpenAI o1, 2024.09</a>
<span class="snippet"><span>Comment</span>Jason Wei氏のポスト:

<br>

https://x.com/_jasonwei/status/1834278706522849788?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q1072 や　1147 で似たような考えはすでに提案されていたが、どのような点が異なるのだろうか？

<br>



<br>



<br>



<br>

たとえば前者は、pauseトークンと呼ばれるoutputとは関係ないトークンを生成することで、outputを生成する前にモデル内部で推論する前により多くのベクトル操作を加える（=ベクトルを縦方向と横方向に混ぜ合わせる; 以後ベクトルをこねくりまわすと呼称する）、といった挙動を実現しているようだが、明示的にCoTの教師データを使ってSFTなどをしているわけではなさそうに見える（ざっくりとしか読んでないが）。

<br>



<br>

一方、Jason Wei氏のポストからは、RLで明示的により良いCoTができるように学習をしている点が違うように見える。学習の計算量だけでなく、inferenceの計算量に対しても、新たなスケーリング則が見出されている模様。

<br>



<br>

<img src="https://github.com/user-attachments/assets/85a39908-7db8-4f97-9b5d-4bfdc8439577" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

テクニカルレポート中で言われている time spent thinking （test-time compute）というのは、具体的には何なのだろうか。

<br>



<br>



<br>



<br>

上の研究でいうところの、inference時のpauseトークンの生成のようなものだろうか。モデルがベクトルをこねくり回す回数（あるいは生成するトークン数）が増えると性能も良くなるのか？

<br>



<br>

しかしそれはオリジナルのCoT研究である 551 のdotのみの文字列をpromptに追加して性能が向上しなかった、という知見と反する。

<br>



<br>



<br>



<br>

おそらく、モデル学習のデコーディング時に、ベクトルをこねくり回す回数（あるいは生成するトークン数）を増やすこと＝time spent thinking (test-time compute) 、ということなのだろうか？

<br>



<br>

そしてそのように学習されたモデルは、推論時にベクトルをこねくり回す回数（あるいは生成するトークン数）を増やすと性能が上がる、ということなのだろうか。

<br>



<br>

もしそうだとすると、これは 1072 のpauseトークンの生成をしながらfinetuningすると性能が向上する、という主張とも合致するように思うが、うーん。

<br>



<br>



<br>



<br>

実際暗号解読のexampleを見ると、とてつもなく長いCoT（トークンの生成数が多い）が行われている。RLでReasoningを学習させる関連研究: 1391 1392以下o1の動きに関して考えている下記noteからの引用。

<br>



<br>



<br>



<br>

&gt;これによって、LLMはモデルサイズやデータ量をスケールさせる時代から推論時間をスケールさせる（つまり、沢山の推論ステップを探索する）時代に移っていきそうです。

<br>



<br>



<br>



<br>

なるほど。test-compute timeとは、推論ステップ数とその探索に要する時間という見方もあるのですね。

<br>



<br>



<br>



<br>

またnote中では、CoTの性能向上のために、Process Reward Model（PRM）を学習させ、LLMが生成した推論ステップを評価できるようにし、PRMを報酬モデルとし強化学習したモデルがo1なのではないか、と推測している。

<br>



<br>

PRMを提案した研究では、推論ステップごとに0,1の正誤ラベルが付与されたデータから学習しているとのこと。

<br>



<br>

なるほど、勉強になります。

<br>



<br>



<br>



<br>

note: https://note.com/hatti8/n/nf4f3ce63d4bc?sub_rt=share_pbnote（詳細編）:https://note.com/hatti8/n/n867c36ffda45?sub_rt=share_pbこちらのリポジトリに関連論文やXポスト、公式ブログなどがまとめられている: https://github.com/hijkzzz/Awesome-LLM-Strawberry

<br>



<br>

これはすごい。論文全部読みたい</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/GenerativeAI.html">#GenerativeAI</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2024-09-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1387">PaperQA2, 2023.02</a>
<span class="snippet"><span>Comment</span>元ポスト: https://x.com/sgrodriques/status/1833908643856818443?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/Post.html">#Post</a>
<span class="issue_date">Issue Date: 2024-09-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1384">A few prompt engineering tips that Ilya Sutskever picked up at OpenAI, Ilya Sutskever, 2024.09</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-09-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1383">Late Chunking: Balancing Precision and Cost in Long Context Retrieval, Pierse+, 2024.09</a>
<span class="snippet"><span>Comment</span>chunkingしてからembeddingを取得するより、全体のドキュメントに対してcontextualなtoken embeddingを取得し、その後chunkingをしてpoolingしてsingle vectorにする方が、文書の文脈情報がembedding内で保持されやすいので、precisionが上がりますよ、という話

<br>



<br>

スクショは記事中より引用

<br>

<img src="https://github.com/user-attachments/assets/5fc20551-62f3-4965-8e3d-18540806fb34" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2024-09-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1379">ml-engineering</a>
<span class="snippet"><span>Comment</span>LLMやVLMを学習するためのツールやノウハウがまとめられたリポジトリ</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/SelfCorrection.html">#SelfCorrection</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2024-09-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1376">Reflection 70B, GlaiveAI, 2024.09</a>
<span class="snippet"><span>Comment</span>ただまあ仮に同じInputを利用していたとして、promptingは同じ（モデルがどのようなテキストを生成し推論を実施するかはpromptingのスコープではない）なので、そもそも同じInputなのでfair comparisonですよ、という話に仮になるのだとしたら、そもそもどういう設定で比較実験すべきか?というのは検討した方が良い気はする。まあどこに焦点を置くか次第だと思うけど。

<br>



<br>

エンドユーザから見たら、reflectionのpromptingのやり方なんてわからないよ！という人もいると思うので、それを内部で自発的に実施するように学習して明示的にpromptingしなくても、高い性能を達成できるのであれば意味があると思う。

<br>



<br>

ただまあ少なくとも、参考でも良いから、他のモデルでもreflectionをするようなpromptingをした性能での比較結果も載せる方が親切かな、とは思う。あと、70Bでこれほどの性能が出ているのはこれまでにないと思うので、コンタミネーションについてはディフェンスが必要に思う（他のモデルがそのようなディフェンスをしているかは知らないが）。

<br>



<br>

追記

<br>

→ 下記記事によると、LLM Decontaminatorを用いてコンタミネーションを防いでいるとのこと

<br>

https://github.com/lm-sys/llm-decontaminatorReflection自体の有用性は以前から示されている。

<br>

参考: 1377, 1105, 1248, 1378ollamaで実際に動かして日本語でのQAを試している記事。実際のアウトプットやreflectionの内容が確認でき、おもしろい。

<br>



<br>

システムプロンプトで&lt; thinking &gt;タグでInputに対して推論し、&lt; output &gt;タグ内で最終出力を行い、推論過程で誤りがある場合は&lt; reflection &gt;タグを用いて修正するように指示している。

<br>



<br>

おそらく、thinkingタグ内の思考過程でモデルが誤りに気づいた場合は、thinkingタグの途中でreflectionタグが出力され、その時点でCoTが修正されるようである（もしくはoutputとthinkingの中間）。このため、誤ったCoTに基づいてOutputが生成される頻度が減少すると考えられる。

<br>



<br>

このような挙動はおそらく、reflection用の学習データでSFTしないとできないと思うので

<br>



<br>

（たとえば、ReflectionタスクをするようなデータでSFTをしていない場合、出力の途中で誤りを検出し出力を修正するという挙動にはならず、回答として自然な文を最後までoutputすると思う。その後でreflectionしろと促すことはpromptingでできるかもしれないが、そもそもreflectionする能力があまり高くない可能性があり、うまく修正もしてくれないかも）

<br>



<br>

reflectionの能力を高めるようなデータでSFTをしていないモデルで似たようなpromptingをしても、うまくいかない可能性があるので注意が必要だと思われる。

<br>



<br>

参考: https://note.com/schroneko/n/nae86e5d487f1開発者曰く、HFに記載の正しいシステムプロンプトを入れないと、適切に動作しないとのこと。

<br>

元ツイート: https://x.com/mattshumer_/status/1832061508294971731?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qどうやら初期にアップロードされていたHFのモデルはweightに誤りがあり、挙動がおかしくなっていたようだ。

<br>

正しいモデルの挙動は下記ツイートのようである。thinking内でreflectionが実施されている。

<br>



<br>

実際にいくつかの例をブログをリリース当日に見た時に、reflectionタグがoutputの後に出力されている例などがあり、おや？という挙動をしていたので、問題が是正されたようだ。

<br>

https://x.com/mattshumer_/status/1832581211841052694?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QHFのモデルが修正された後もベンチマークの結果が再現されないなど、雲行きが色々と怪しいので注意した方が良い。続報

<br>

https://x.com/artificialanlys/status/1832965630472995220?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q開発者ポスト:https://x.com/csahil28/status/1833619624589725762?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q再現実験を全て終了し、当初報告していた結果が再現されなかったとCEOが声明：https://x.com/mattshumer_/status/1842313328166907995</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2024-09-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1375">Ruri: Japanese General Text Embeddings, cl-nagoya, 2024.09</a>
<span class="snippet"><span>Comment</span>元ツイート:https://x.com/hpp_ricecake/status/1831308092459643232?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q337Mパラメータのモデルで、同等のサイズのモデルをJMTEBで大きく上回る性能。LLMを用いて生成したデータを用いてContrastive Learning, その後高品質なデータでFinetuningを実施したとのこと。JMTEB上では、パラメータサイズ不明（だがおそらく桁違いに大きい）のOpenAI/text-embedding-3-largeと同等の性能に見えるが、1373 などを考慮すると、日本特有の知識を問うQAなどはマルチリンガルなモデルは弱そうなので、その辺がどれほど高い性能を持っているのかは興味がある。

<br>



<br>

LLMで人工的に生成したデータでは、生成に利用したLLMが持つ知識しか表層的には現れないと思うので何を利用したかによるのと、高品質なラベルデータにその辺がどの程度含まれているか。最大sequence長は1012なので、より長い系列をBERTで埋め込みたい場合はRetrievaBERT  1323 （最大sequence長2048）も検討の余地がある。開発者の方からテクニカルレポートが出た

<br>

https://arxiv.org/abs/2409.07737</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/LLMServing.html">#LLMServing</a>
<span class="issue_date">Issue Date: 2024-08-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1368">NanoFlow, 2024.08</a>
<span class="snippet"><span>Comment</span>vLLMよりも2倍程度高速なLLM serving framework。

<br>



<br>

オフライン評価

<br>

<img src="https://github.com/user-attachments/assets/93d8362d-e0e4-4bdb-9de4-178e1eef2e33" alt="image" loading="lazy">

<br>



<br>

オンラインでのlatency評価

<br>

<img src="https://github.com/user-attachments/assets/506ebf39-9c47-4d11-9352-c26f6b0d155c" alt="image" loading="lazy">

<br>



<br>

機能はvLLMの方が多いが、速度はこちらの方がかなり速そうではある。latencyのrequirementが厳しい場合などは検討しても良いかもしれない。

<br>



<br>

しかしLLM serving frameworkも群雄割拠ですね。元ポスト:https://x.com/rohanpaul_ai/status/1829647702998606104?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q1343 も参照のこと</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<span class="issue_date">Issue Date: 2024-08-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1359">論文紹介 _ The Llama 3 Herd of Models, 2024.08</a>
<span class="snippet"><span>Comment</span>Llama3の事前学習や事後学習のノウハウが詰まっており（安全性なども含む）、LLM学習に必要な要素が図解されており、非常に分かりやすい。

<br>



<br>



<br>



<br>

たとえば下記図（スライド中より引用）などは、LLMの学習過程を説明する際にわかりやすそう

<br>



<br>

<img src="https://github.com/user-attachments/assets/501ae2ae-cfc6-46ab-9701-c860b9a52dc3" alt="image" loading="lazy">

<br>



<br>

LLMの事前・事後学習あたりは独自ノウハウが多すぎてもはや追従困難</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2024-08-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1356">Liger-Kernel, 2024.08</a>
<span class="snippet"><span>Comment</span>LLMを学習する時に、ワンライン追加するだけで、マルチGPUトレーニングのスループットを20%改善し、メモリ使用量を60%削減するらしい

<br>



<br>

元ツイート:https://x.com/hsu_byron/status/1827072737673982056?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qこれだけでいい

<br>

<img src="https://github.com/user-attachments/assets/abce24ed-f979-43db-ac51-e850f2ae877a" alt="image" loading="lazy">Unsloth 1450 はLoRA/QLoRAが可能な一方でまだMulti-GPUはサポートしていない。一方、Liger-KernelはLoRAよりもfull-parameter tuningとMulti-GPUにフォーカスしており、目的に応じて使い分けが必要。

<br>



<br>



<br>



<br>

https://github.com/linkedin/Liger-Kernel/issues/57</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<span class="issue_date">Issue Date: 2024-08-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1355">Grok-2, X, 2024.08</a>
<span class="snippet"><span>Comment</span>chatbot arenaで5月時点のGPT4o超え。miniでもなんとllama3.1-705B超え

<br>

https://x.com/lmsysorg/status/1827041269534879784?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-08-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1354">Phi 3.5, Microsoft, 2024.08</a>
<span class="snippet"><span>Summary</span>Phi-3モデルコレクションは、マイクロソフトの最新の小型言語モデルで、高い性能とコスト効率を兼ね備えています。新たに発表されたPhi-3.5-mini、Phi-3.5-vision、Phi-3.5-MoEは、生成AIアプリケーションにおける選択肢を広げ、特に多言語サポートや画像理解の向上を実現しています。Phi-3.5-MoEは、専門家を活用しつつ高性能を維持しています。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Quantization.html">#Quantization</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-08-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1353">4-bit Llama 3.1, NeuralMagic, 2024.08</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-08-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1348">RAG入門: 精度改善のための手法28選, 2024.08</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2024-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1347">PLaMo-100B, PFN, 2024.08</a>
<span class="snippet"><span>Comment</span>日本語のベンチマークでGPT4を超える性能を達成。

<br>

SFT, DPOで学習。学習データは、Publicなもの、プログラムで作成したもの、LLM自身に作成させたものを利用した。また、最終的なモデルに複数の候補があったのでモデルマージで良いところ取りをした。DPOで利用するpreferenceデータは、事後学習途中のモデルによって自動生成。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-08-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1342">OpenLLM: Self-Hosting LLMs Made Easy</a>
<span class="snippet"><span>Comment</span>OpenLLMをself hostingする際に、OpenAIなどと同じインタフェースのAPIやChatを提供するライブラリ</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-07-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1340">Gemma2, Google Deepmind, 2024</a>
<span class="snippet"><span>Comment</span>Reasoning, Math, CodeGenerationに強み<img src="https://github.com/user-attachments/assets/b7f58129-1235-4812-9c5e-0607aa1bea66" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/03e74ece-a0d5-4699-b09e-f8791062f6a8" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-07-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1335">Llama 3.1, 2024.07</a>
<span class="snippet"><span>Comment</span>Llama系のモデルをFP8で学習する場合のレシピ

<br>

https://x.com/thom_wolf/status/1826924774997532799?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-07-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1334">大規模言語モデルの開発, 2024</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-07-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1330">calm3-22B, 2024</a>
<span class="snippet"><span>Comment</span>&gt;LLMの日本語能力を評価するNejumi LLM リーダーボード3においては、700億パラメータのMeta-Llama-3-70B-Instructと同等の性能となっており、スクラッチ開発のオープンな日本語LLMとしてはトップクラスの性能となります（2024年7月現在）。

<br>

モデルは商用利用可能なApache License 2.0で提供されており

<br>



<br>

これはすごい</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-07-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1327">GENIAC: 172B 事前学習知見, 2024</a>
<span class="snippet"><span>Comment</span>LLMの事前学習における知見がまとまっている記事とのこと・Megatron LMで学習

<br>

　→ 3D Parallelismなどの分散学習手法によりHF Trainerより高速

<br>

　→ Data Parallelim、Tensor Parallelism、 Pipeline Parallelismを組み合わせたもの

<br>

・GPUメンテナンス、不良で学習が継続できなかった場合はcheckpointをロードして学習

<br>

・学習曲線が安定しているように見えるがSpikeは発生している。発生時はgradient normが急激に上昇する

<br>

・LlamaなどのLLMからの継続的事前学習ではなくfrom scratchから学習しているので透明性が高い

<br>

・Transformer engineを利用

<br>

・AdamWを利用

<br>

・attention dropout, hidden dropoutは0.0

<br>



<br>

&gt;この際、 通信を多く必要とする分散手法のワーカー（Tensor Parallelワーカー）はノード内に配置するようにMegatron-LMのデフォルトではなっているため、今回もそれを利用しました。このようにする理由は、ノード内の通信はNVLinkにより、ノード間通信よりも高速であるためです。また、Data Parallelの勾配平均化のための通信を考慮して、Data Parallelワーカーも可能な限りノード内に配置するMegatron-LMデフォルトの挙動を利用しました。

<br>

Pipeline Parallelismは他の並列化手法と比較して通信量が少ないP2P(Point-to-Point)通信であるため、パイプラインステージはノード間で配置するようにしました。これも、Megatron-LMデフォルトの挙動です。

<br>



<br>

勉強になる

<br>



<br>

・通常のデータ並列はoptimizer stateをworker間で複製するので遅い。Deep Speed Zero 1のように分散して保有することで高速化

<br>

・Tensor Parallelでself attention, MLPの計算を並列化できる

<br>

・LayerNormalization, Dropoutの演算もメモリ効率の観点から並列化

<br>

・学習を安定させるためにz-lossを利用

<br>

・batch skippingとは、gradient clippingを行っていてもなおspikeが生じる場合に、100 step前に戻り、spikeが生じた付近のデータを数百iteration程度スキップすること

<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2024-07-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1325">OpenDevin: Code Less, Make More, 2024</a>
<span class="snippet"><span>Comment</span>LLMによるOpenSourceなソフトウェア生成エージェントプラットフォームfull timeのスタッフを雇用しworldクラスのUXを目指すとのこと。楽しみ。

<br>

参考: https://x.com/gneubig/status/1808493521315496229?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QOpen化される前の最初のDevinのツイート

<br>



<br>

https://x.com/cognition_labs/status/1767548763134964000</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2024-07-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1324">より良いTransformerをつくる, Shun Kiyono, 2022</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<span class="issue_date">Issue Date: 2024-07-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1323">RetrievaBERTの公開, 2024</a>
<span class="snippet"><span>Comment</span>RAGへ応用する際に、長いコンテキストを扱いEmbeddingを獲得したいシーンが増えたので、最大でコンテキスト長が2048のBERTを学習し公開。Apache2.0

<br>



<br>



<br>



<br>

オリジナルのBERTと比較して、近年のLLMで有用性が示されている以下をアーキテクチャに取り入れている

<br>



<br>

・SwiGLU活性化関数 1311 

<br>



<br>

・PreNorm 1324 

<br>



<br>

・Grouped Query Attention (Multi Query Attention) 1271 </span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-07-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1322">Llama 3 Swallow</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<span class="issue_date">Issue Date: 2024-05-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1318">Using and Evaluating User Directed Summaries to Improve Information Access</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/PositionalEncoding.html">#PositionalEncoding</a>
<span class="issue_date">Issue Date: 2024-05-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1310">RoFormer: Enhanced Transformer with Rotary Position Embedding, Jianlin Su+, N_A, Neurocomputing, 2024</a>
<span class="snippet"><span>Summary</span>位置符号化はtransformerアーキテクチャで有効であり、本論文ではRotary Position Embedding（RoPE）という新しい手法を提案している。RoPEは、回転行列を使用して絶対位置を符号化し、同時に相対位置依存性を自己注意構成に組み込む。RoPEを使用したRoFormerは、長いテキスト分類ベンチマークデータセットで他の手法を上回ることが実験で示されており、Huggingfaceに統合されている。</span>
<span class="snippet"><span>Comment</span>RoPEを提案した論文Absolute Position Embedding と Relative Position Embedding

<br>



<br>

TransformerにおけるQKVベクトルの計算方法

<br>



<br>

一般に、Transformerにおける Query (Q), Key (K), Value (V) は以下の式で定式化される：

<br>



<br>

<img width="176" alt="image" src="https://github.com/user-attachments/assets/21b0f077-64b4-4fe5-af04-bffc373eabf5">

<br>



<br>

m, nはそれぞれ位置を表す整数。Absolute Position Embeddingと、Relative Position Embeddingは、関数fの設計がそれぞれ異なっている：

<br>



<br>



<br>



<br>

Absolute Position Embedding

<br>



<br>

absolute position embeddingは、固定されたposition ベクトル、あるいはtrainableなposition ベクトル p を、入力ベクトルに対して足し合わせる：

<br>



<br>

<img width="382" alt="image" src="https://github.com/user-attachments/assets/0688c1bf-8699-48a5-9d95-06454550bbdf">

<br>



<br>



<br>



<br>

Relative Position Embedding

<br>



<br>

一方、Relative Position Embeddingは、Queryの位置に対する、Key, Valueの相対位置（つまり、mとnの差）に対して、trainableなベクトルをKey, Valueごとに用意し、そのベクトルを入力に足し合わせる、という定式化となっている：

<br>



<br>

<img width="269" alt="image" src="https://github.com/user-attachments/assets/ddb92f1a-af23-4d71-a7b9-2a7adda792e1">

<br>



<br>



<br>



<br>

RoPE

<br>



<br>

RoPEでは、入力ベクトルに対して回転行列を適用することで、回転に対して位置情報を保持させる：

<br>



<br>

<img width="705" alt="image" src="https://github.com/user-attachments/assets/fce1d06e-e346-4278-a77c-4c96795d5488">

<br>



<br>

<img width="588" alt="image" src="https://github.com/user-attachments/assets/3f28103c-6a56-4016-8f50-d45fe28cd62a">

<br>



<br>



<br>



<br>

RoPEは下記のような性質を持つ：

<br>



<br>

・long-term decay: θi = 10000−2i/d と設定することにより、相対位置が離れているトークンのベクトルとのinner productの値が小さくなる。すなわち、位置が離れているトークン間の依存関係が小さくなる。

<br>



<br>

・Linear-Attention: RoPEは回転行列であり、乗算後のベクトルのノルムを変化させない。このため、Linear Attentionの式の中に回転行列を組み込むことで、Linear Attentionと簡単に組み合わせることが可能

<br>



<br>



<br>



<br>

Absolute Position Embedding, Relative Position Embeddingでは、ベクトルに対して位置情報を加算する定式化で K, Vの計算時に位置情報を考慮していたため、Linear Attentionの計算そのものに位置情報を組み込んだ定式化とはなっていなかった。

<br>



<br>

が、RoPEでは回転行列を乗算する定式化であり、ノルムを変化させないのでLinear Attentionの定式化に組み込むことができる。このため、モデルのアーキテクチャを大きく変更しなくとも組み込める。

<br>



<br>

RoPE自体は実装にパラメータを必要としないが、モデルのその他のパラメータがRoPEに適用できるように学習されていないと適用できないであろう点には注意（事前学習時にRoPEが使われていれば話は別）。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2024-04-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1297">AirLLM, 2024.04</a>
<span class="snippet"><span>Comment</span>4GBのSingle GPUで、70Bモデルのinferenceを実現できるライブラリ。トークンの生成速度は検証する必要がある。transformer decoderの各layerの演算は独立しているため、GPUに全てのlayerを載せず、必要な分だけ載せてinferenceするといった操作を繰り返す模様。

<br>



<br>

元ツイート: https://x.com/rohanpaul_ai/status/1784349737899982943?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-04-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1289">LLaMA3, Meta, 2024.04</a>
<span class="snippet"><span>Comment</span>ライセンスによると、LLaMA3を利用したモデルはどんな場合でもLlama3をprefixとして付与しないといけないらしい

<br>



<br>

元ツイート:https://x.com/gneubig/status/1781083579273089442?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLLaMA3がChatBot ArenaでTop 5になったとのこと。また、英語においては、GPT4-1106-preview, GPT-4-turbo-2024-0409と同等の性能を達成。これはすごい…

<br>



<br>

https://x.com/lmsysorg/status/1782483699449332144?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qnejumi-leaderboard 1055 にLLaMA3の評価結果が掲載された模様（画像は下記ツイートより引用）

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/2db1674b-80a6-4bbc-ab4b-c822e1659d6f" alt="image" loading="lazy">

<br>



<br>

https://x.com/madyagi/status/1783707796095316310?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QモデルアーキテクチャはTransformer Decoderをベースにしており、Llama2と比較して

<br>



<br>

・TokenizerのVocabサイズを128Kより効率的にテキストをエンコーディング可能に

<br>



<br>

・GQA 1271 を利用しInferenceを高速化 (Llama2の時点でGQAを使っていたが、70Bモデルだけだった)

<br>



<br>

・self-attentionが、ドキュメントを跨がないように学習context: 8192</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<span class="issue_date">Issue Date: 2024-04-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1281">Grok-1.5 Vision Preview, 2024</a>
<span class="snippet"><span>Comment</span><img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/88dd70ce-5874-4786-8e66-7484984c7a72" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-04-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1279">Mixtral-8x22B-v0.1, 2024</a>
<span class="snippet"><span>Comment</span>Apache-2.0ライセンス, 日本語非対応</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<span class="issue_date">Issue Date: 2024-04-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1278">Command R+, Cohere, 2024</a>
<span class="snippet"><span>Comment</span>Chatbot arenaでGPT-4-0314と同等の Elo Rate を獲得し（20240410時点）、日本語を含む10ヶ国語をサポート。コンテキストウィンドウサイズ128k。商用利用はAPIから、研究目的であればHuggingFaceから利用可能。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/9571e233-f936-4327-af60-3c2ce57aad71" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-04-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1277">Gemma: Open Models Based on Gemini Research and Technology, 2024</a>
<span class="snippet"><span>Comment</span>アーキテクチャはTransformer Decoderを利用。モデルのサイズは2Bと7B。

<br>



<br>

オリジナルのTransformer Decoderアーキテクチャから、下記改善を実施している：

<br>



<br>

・Multi Query Attention 1272 を利用

<br>



<br>

・RoPE Embedding 1310 を利用

<br>



<br>

・GeGLU 1311 の利用

<br>



<br>

・RMSNormの利用（学習を安定させるため; LLaMAと同様）

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/ef8dd419-fcce-49f5-8fd2-2acc4348d880" alt="image" loading="lazy">

<br>



<br>

Mistral 1309 よりも高い性能を示している：

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/24d6892b-ca8e-48bc-92bf-7eae71466918" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/4cf6b9c6-d517-4d9d-9cdb-526560d1a097" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2024-04-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1265">LLMの現在, 202404, Preffered Elements</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2024-03-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1260">Awesome LM with Tools</a>
<span class="snippet"><span>Comment</span>Toolを利用するLMに関するNeubig氏のグループによるSurvey。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/TextualInversion.html">#TextualInversion</a>
<span class="issue_date">Issue Date: 2024-03-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1258">repeng</a>
<span class="snippet"><span>Comment</span>LLMの出力のスタイルを数百個の事例だけで学習しチューニングできるライブラリ。promptで指定するのとは異なり、数値でスタイルの強さを指定することが可能らしい（元ツイート）。画像生成分野におけるTextual Inversionと同じ技術とのこと。

<br>



<br>

Textual Inversionとは、少量のサンプルを用いて、テキストエンコーダ部分に新たな「単語」を追加し、単語と対応する画像を用いてパラメータを更新することで、prompt中で「単語」を利用した場合に学習した画像のスタイルやオブジェクト（オリジナルの学習データに存在しなくても可）を生成できるようにする技術、らしい。

<br>



<br>

Huggiegface: https://huggingface.co/docs/diffusers/training/text_inversion

<br>

（参考）GPTに質問した際のログ: https://chat.openai.com/share/e4558c44-ce09-417f-9c77-6f3855e583fa

<br>

元ツイート: https://x.com/webbigdata/status/1770272397184389211?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-03-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1256">Open Release of Grok-1  March 17, 2024</a>
<span class="snippet"><span>Comment</span>Apache2.0ライセンス, 314Bパラメータでモデルの重み、Mixture-of-Expertsを採用している。学習データ、学習に利用したコードはおそらく公開されていない。Grok-1.5がリリース

<br>

https://x.ai/blog/grok-1.5

<br>



<br>

各種ベンチマークの性能、特にMathの性能が向上し、コンテキスト長が128kに

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/0e8f357f-f583-4a11-bf20-49e9886cf6e9" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-03-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1249">RAG-Research-Insights</a>
<span class="snippet"><span>Comment</span>RAGに関する研究が直近のものまでよくまとめられている</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-03-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1242">What are the most important LLMs to know about in March 2024?</a>
<span class="snippet"><span>Comment</span>2024年3月時点で知っておくべきLLMに関するスレッド</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2024-02-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1237">Mistral Large</a>
<span class="snippet"><span>Comment</span><img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/2d9066bd-05e5-4942-8d27-e5b50d129ade" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2024-02-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1229">RAGの性能を改善するための8つの戦略</a>
<span class="snippet"><span>Comment</span>めちゃめちゃ詳細にRAG性能向上の手法がreference付きでまとまっている。すごい。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/InformationExtraction.html">#InformationExtraction</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-01-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1209">LLMにおける情報抽出（文章から必要な事柄を読み取る）タスクについての調査, AIDB</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-01-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1203">Decoding Strategies that You Need to Know for Response Generation</a>
<span class="snippet"><span>Comment</span>言語モデルのdecodingの方法についてよくまとまっている。まとめられているdecoding方法は以下

<br>



<br>

・Greedy, BeamSearch, RandomSampling, Temperature, Top-K Sampling, Nucleus Samplingこちらの記事ではHuggingFaceでの実装や他のdecoding方法等、より実装面での詳細が記述されている：

<br>



<br>

https://note.com/npaka/n/n9a8c85f2ef7a</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-12-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1196">Structured Hierarchical Retrieval, llama-index</a>
<span class="snippet"><span>Comment</span>元ツイート: https://x.com/llama_index/status/1737515390664872040?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-12-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1188">optimize-llm, HuggingFace</a>
<span class="snippet"><span>Comment</span>LLMをoptimizeする実用的なチュートリアルこちらも有用なので参照のこと

<br>



<br>



<br>



<br>

【GPU inference】

<br>



<br>

https://huggingface.co/docs/transformers/main/perf_infer_gpu_one

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<span class="issue_date">Issue Date: 2023-12-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1187">【続】Flash Attentionを使ってLLMの推論を高速・軽量化できるか？</a>
<span class="snippet"><span>Comment</span>use_cacheがTrue/Falseの場合のFlashAttention2のinference timeとVRAM使用量の傾向をsequence_lengthごとに考察している。

<br>



<br>

use_cacheはKey Value cacheのオンオフを切り替えられるオプションである。autoregressiveなモデルのinference時には、何度も同じinput tokenに対するKVの計算が生じるため（M番目のトークンを生成した後、M+1番目のトークンの生成をする場合、M-1番目までのトークンのKVを再計算せねばならない）、cacheをすることで大幅に計算速度が改善される。

<br>



<br>

use_cacheをTrueにできるならFlashAttention2の恩恵は小さい（inference timeが少し早くなるのみ）ため、潤沢なVRAMがあるなら得られる恩恵は小さい。

<br>

逆にVRAM節約してuse_cacheをFalseにせざるを得ないのであれば、FlashAttention2によりVRAM使用量をsequence_legthの線形に抑えることができ、かつinference timeも短くなる。

<br>



<br>

↑上記はあくまでinferenceをする場合のみの話であり（train時はautoregressive modelではcausal maskを用い、teacher forcingで並列にトークンを生成するためそもそもKV-cacheする意味がない）、trainingをする場合FlashAttention2で大幅にVRAM使用量を減らせるので、そこは分けて考えること。

<br>

https://qiita.com/jovyan/items/ff3d0a49163c7afa33ceFlash Attentionを使ってLLMの推論を高速・軽量化できるか？

<br>

https://qiita.com/jovyan/items/11deb9d4601e4705a60d

<br>



<br>

こちらの記事も非常に勉強になる</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2023-12-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1183">A Review of Public Japanese Training Sets, shisa, 2023.12</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<span class="issue_date">Issue Date: 2023-12-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1181">Gemini, Google, 2023.12</a>
<span class="snippet"><span>Comment</span>多くのベンチマークでGPT4超えらしい

<br>



<br>

（追記1）

<br>

テクニカルレポートのp.44を見ると、ブログポスト中のGPT4のMMLUのスコアはGPT-4-0613のもののようなので、これが正しいとすると他のベンチマークのスコアも同モデルのものである可能性が高く、GPT-4-1163-preview（最新モデル）のスコアでは"ないかもしれない"点に注意。GPT4とどちらが実際に性能が良いか?については様子見した方が良さそう。

<br>



<br>

（追記2）

<br>

GSM8Kの結果も、GPT4に対してFair Comparisonではないかもしれない点に注意。Geminiは32個のCoTとSelf-Consistencyを利用しているが、GPT4では5-shotで単一のCoTのみであるため、prompting手法ではGeminiに有利な比較となっているように見える。ただしGPT4はGSM8Kの訓練データを事前学習時にMIXしている（SFT）ので、Geminiがこのようなことをしていないのであれば、この点ではGPT4が有利になっている“可能性”がある。

<br>



<br>

他にもFair Comparisonになっていないと推察されるものはTextモダリティでの評価の表の文言を見るとありそうなのでそこは念頭においた方が良さそうである。テクニカルレポート: https://storage.googleapis.com/deepmind-media/gemini/gemini_1_report.pdfGemini Summary

<br>

https://x.com/srush_nlp/status/1732427569352323401?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QMMLUでの同じprompting手法でのGPT-4-0613との比較。32個のCoTでのSelf-Consistencyで比較した場合、GPT-4-0613に負けているが、閾値を設けてconfidenceが閾値以上の場合はSelf-consistency, そうでない場合はgreedyに生成した結果を選択する、というUncertain-Routed CoT@32では、Geminiのパフォーマンスgainが大きくGPT-4-0613よりも高い性能を示している。

<br>

ブログポスト中のGPT4のスコアは5-shotのもの（reportedと書かれているのでOpenAIが公表している数値と推察）であり、Geminiの結果はUncertain-Routed CoT@32の結果であるため、Fair Comparisonになっていないかもしれない？点には注意。

<br>



<br>

レポート中ではSelf-consistencyという単語でこの部分は書かれていないが、実は少しやっていること違ってたりする…？

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/ab56b7e0-464a-4e29-84e7-7d1540ef2119" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-12-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1173">kaggle LLM コンペ 上位解法を自分なりにまとめてみた話</a>
<span class="snippet"><span>Comment</span>実践的な内容（チャンク生成時の工夫、クエリ生成時の工夫等）が網羅的にまとまっており非常に有用個人的に、コンペ主催者側から提供されたデータが少なく、上位のほとんどのチームがChatGPT（3.5, 4）を用いて、QAデータを生成していた、というのが興味深かった。プロンプトはたとえば下記:

<br>



<br>

[（5th-place-solution）](https://www.kaggle.com/competitions/kaggle-llm-science-exam/discussion/446293)より引用

<br>



<br>

```

<br>



<br>

system_content = """

<br>



<br>

Forget all the previous instruction and rigorously follow the rule specified by the user.

<br>



<br>

You are a professional scientist's assistant.

<br>



<br>

"""

<br>



<br>



<br>



<br>

user_content_template_qa = Template(

<br>



<br>

    """

<br>



<br>

Please consider 5 choices question and answer of the following TEXT.

<br>



<br>

The purpose of this question is to check respondent's deep science understanding of the TEXT.

<br>



<br>

We assume this question is for professional scientists, so consider super difficult question.

<br>



<br>

You can ask very detailed question, for example check specific sentence's understanding.

<br>



<br>

It is good practice to randomly choose specific sentence from given TEXT, and make QA based on this specific sentence.

<br>



<br>

You must make QA based on the fact written in the TEXT.

<br>



<br>

You may create wrong answers based on the correct answer's information, by modifying some parts of the correct answer.

<br>



<br>

Your response must be in following format, don't write any other information. 

<br>



<br>

You must not include "new line" in each Q), 1), 2), 3), 4), 5), and A):

<br>



<br>

Q) `question text comes here`

<br>



<br>

1) `answer candidate 1`

<br>



<br>

2) `answer candidate 2`

<br>



<br>

3) `answer candidate 3`

<br>



<br>

4) `answer candidate 4`

<br>



<br>

5) `answer candidate 5`

<br>



<br>

A) `answer`

<br>



<br>



<br>



<br>

where only 1 `answer candidate` is the correct answer and other 4 choices must be wrong answer.

<br>



<br>

Note1: I want to make the question very difficult, so please make wrong answer to be not trivial incorrect.

<br>



<br>

Note2: The answer candidates should be long sentences around 30 words, not the single word.

<br>



<br>

Note3: `answer` must be 1, 2, 3, 4 or 5. `answer` must not contain any other words.

<br>



<br>

Note4: Example of the question are "What is ...", "Which of the following statements ...", "What did `the person` do",

<br>



<br>

and "What was ...".

<br>



<br>

Note5: Question should be science, technology, engineering and mathematics related topic. 

<br>



<br>

If the given TEXT is completely difference from science, then just output "skip" instead of QA.

<br>



<br>



<br>



<br>



<br>



<br>

Here is an example of your response, please consider this kind of difficulty when you create Q&amp;A:

<br>



<br>

Q) Which of the following statements accurately describes the impact of Modified Newtonian Dynamics (MOND) on the observed "missing baryonic mass" discrepancy in galaxy clusters?"

<br>



<br>

1) MOND is a theory that reduces the observed missing baryonic mass in galaxy clusters by postulating the existence of a new form of matter called "fuzzy dark matter."

<br>



<br>

2) MOND is a theory that increases the discrepancy between the observed missing baryonic mass in galaxy clusters and the measured velocity dispersions from a factor of around 10 to a factor of about 20.

<br>



<br>

3) MOND is a theory that explains the missing baryonic mass in galaxy clusters that was previously considered dark matter by demonstrating that the mass is in the form of neutrinos and axions.

<br>



<br>

4) MOND is a theory that reduces the discrepancy between the observed missing baryonic mass in galaxy clusters and the measured velocity dispersions from a factor of around 10 to a factor of about 2.

<br>



<br>

5) MOND is a theory that eliminates the observed missing baryonic mass in galaxy clusters by imposing a new mathematical formulation of gravity that does not require the existence of dark matter.

<br>



<br>

A) 4

<br>



<br>



<br>



<br>

Let's start. Here is TEXT: $title\n$text

<br>



<br>

"""

<br>



<br>

)

<br>



<br>

```</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/AutomaticPromptEngineering.html">#AutomaticPromptEngineering</a>
<span class="issue_date">Issue Date: 2023-12-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1171">multimodal-maestro</a>
<span class="snippet"><span>Comment</span>Large Multimodal Model (LMM)において、雑なpromptを与えるても自動的に良い感じoutputを生成してくれるっぽい？

<br>



<br>



<br>



<br>

以下の例はリポジトリからの引用であるが、この例では、"Find dog." という雑なpromptから、画像中央に位置する犬に[9]というラベルを与えました、というresponseを得られている。pipelineとしては、Visual Promptに対してまずSAMを用いてイメージのsegmentationを行い、各セグメントにラベルを振る。このラベルが振られた画像と、"Find dog." という雑なpromptを与えるだけで良い感じに処理をしてくれるようだ。    

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/5220e62f-93f1-4eb9-b365-a9caaf933778" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/GenerativeAI.html">#GenerativeAI</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<span class="issue_date">Issue Date: 2023-12-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1170">LaVie: Text-to-Video generation, demo</a>
<span class="snippet"><span>Comment</span>デモのデフォルトで試してみたら、3秒ほどのprompt通りの動画が生成された。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/4343fa52-698c-4a59-bad0-758fcd30d3ac" alt="image" loading="lazy">

<br>



<br>

FF14の赤魔導士に変えたら、それっぽいの出てきた

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/07b6def8-01f2-4baf-9ba3-ab1ccc40c90e" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/TabularData.html">#TabularData</a>
<span class="issue_date">Issue Date: 2023-12-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1167">Table Transformer Demo</a>
<span class="snippet"><span>Comment</span>PDF中のテーブルとその構造（行列セル）をdetectするモデル

<br>



<br>

Exampleは以下のような感じ（日本語だとどれくらいできるのかな...）

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/7f62e16b-1ff8-46ad-b6df-7792981f8f58" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<span class="issue_date">Issue Date: 2023-11-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1156">ML Papers Explained</a>
<span class="snippet"><span>Comment</span>以下の分野の代表的な論文がまとめられている（基本的にはTransformer登場後のものが多い）

<br>



<br>

・言語モデル（Transformer, Elmoなど）

<br>

・Visionモデル（ViTなど）

<br>

・CNN（AlexNetなど）

<br>

・Single Stage Object Detectors

<br>

・Region-based Convolutional Neural Networks

<br>

・DocumentAI（TableNetなど）

<br>

・Layout Transformers

<br>

・Tabular Deeplearning</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2023-11-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1150">GPT4All, 2023</a>
<span class="snippet"><span>Comment</span>ローカルマシンでChatGPT likeなUIでチャットボットを動作させられるOpensource。

<br>

Mistral7BやGGUFフォーマットのモデルのよつな（おそらく量子化されたものも含む）ローカルマシンで動作させられる規模感のモデルがサポートされている。

<br>

https://gpt4all.io/index.html</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-11-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1149">Zephyr-7B-beta, RAG Perf.</a>
<span class="snippet"><span>Comment</span>Zephyr-7B-betaのRAGでの性能がデータセットで評価されている下記Xポストによるとgpt-3.5-turboと同等

<br>



<br>

https://x.com/rungalileo/status/1726638537767051436?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-11-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1136">ChatGPTに社内文書に基づいた回答を生成させる仕組みを構築しました, 2023</a>
<span class="snippet"><span>Comment</span>低コストで社内文書に対するRAGを実現することに注力している。

<br>

以下、図はブログから引用。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/5f71b0b7-14bb-442d-99c8-09a0b3840210" alt="image" loading="lazy">

<br>



<br>

基本的にはバッチジョブで社内文書をベクトル化しS3へ格納。アプリ起動時にS3から最新データを読み込み検索可能にしRAGするという流れ。

<br>

低コスト化のために、Embedding作成にOpenSourceの言語モデル（text-edbedding-ada002と同等の性能）を利用している。実装は基本的にllamaindexを利用している。特に日本語テキストにおいてはtext-embedding-ada002は 910 において、JSTSタスクにおいてあまり性能が高くない（ただし、910 での報告値は基本的にJSTSデータでfinetuningされてた結果と思われる）と言われているので、お金かけて無理して使う必要はないのかなという印象はある。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2023-11-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1134">LLaMA-Factory, 2023</a>
<span class="snippet"><span>Comment</span>簡単に利用できるLLaMAのfinetuning frameworkとのこと。

<br>

元ツイート: https://x.com/_akhaliq/status/1724456693378040195?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLLaMAベースなモデルなら色々対応している模様</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2023-11-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1130">Hallucination Leaderboard, 2023</a>
<span class="snippet"><span>Comment</span>1000個の短いドキュメントに対して、事実情報のみを用いて要約を生成させ、要約結果と原文書のFactual consistencyを別に訓練したモデルで測定して評価してリーダーボードを作成している。Claude2よりLLaMA2の方が性能が良いのが面白いし、Palmの性能があまり良くない。元ツイート: https://x.com/ashversex/status/1724240030170808392?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-11-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1119">Data-to-Text Datasetまとめ, Akihiko Watanabe, 2022</a>
<span class="snippet"><span>Comment</span>Data-to-Textのデータセットを自分用に調べていたのですが、せっかくなのでスライドにまとめてみました。特にMR-to-Text, Table-to-Textあたりは網羅的にサーベイし、データセットの概要を紹介しているので、全体像を把握するのに良いのかなぁと思います。ただし、2022年12月時点で作成したので2023年以後のデータセットは含まれていません😅</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2023-11-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1118">Retrieval-based LM （RAG System）ざっくり理解する, 2023</a>
<span class="snippet"><span>Comment</span>（以下スクショはスライドより引用）

<br>



<br>



<br>



<br>

次のスクショはRAGにかかわる周辺技術がよくまとまっていると思う。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/35f9f589-770c-435b-8d1b-81e615e86597" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

以下ざっくり私の中の認識として

<br>



<br>

・計画

<br>



<br>

    ・クエリ拡張

<br>



<br>

        ・クエリの質が悪い場合検索性能が劣化するため、クエリをより適切に検索ができるように修正（昔はキーワードしか与えられないときに情報を増やすから”拡張”という文言が用いられているが現在はこれに限らないと思う）する技術

<br>



<br>

    ・分解・抽象化

<br>



<br>

        ・複雑なクエリから分解することでマルチホップの質問をサブ質問に分解（今ならLLMを利用すれば比較的簡単にできる）したり、あるいは抽象化したクエリ（Step-back Promptnig 1076 ）を活用することで検索を改善する技術

<br>



<br>

    ・検索対象選定

<br>



<br>

        ・検索する対象そのものを選択し、検索対象をフィルタリングする技術

<br>



<br>

        ・資料中ではLLMを用いたフィルタリングやClassifierを用いたフィルタリングが紹介されているが、メタデータで絞り込むなどの単純な方法でも実現可能だと思われる（メタデータで絞り込む、はClassifierでのフィルタリングとリンクするかもしれないが）

<br>



<br>

    ・思考・行動

<br>



<br>

        ・518 のような自律的にLLMに思考とその結果に基づく行動をイテレーションさせる技術や、クエリを分解して回答へたどり着くために必要な推論を構築し、各推論の回答を検証しながら生成を繰り返す技術が紹介されている

<br>



<br>

        ・この辺の技術はクエリが非常に複雑な場合に有効ではあるが、シンプルな場合は必要ないかなという印象がある

<br>



<br>

        ・シンプルなユースケースの場合はどちらかというと泥臭い前処理とかが効きそう

<br>



<br>

・関連知識取得

<br>



<br>

    ・検索

<br>



<br>

        ・表層検索（TF-IDFベクトル, BM25）などの古典的な手法や、意味検索（Embeddingに基づく手法）が紹介されている

<br>



<br>

        ・例えばlangchainでは表層検索 + 意味検索の両者がサポートされており、簡単にハイブリッドな検索が実現できる

<br>



<br>

    ・知識文生成

<br>



<br>

        ・外部知識として検索された文書を利用するだけでなく、LLM自身が保持する知識を活用するためにLLMが生成した文書の両方を活用するとQAの正答率が向上することが紹介されている

<br>



<br>

    ・文書フィルタ

<br>



<br>

        ・検索でクエリに関連しない文書を取得してしまう応答品質が大幅に低下することが紹介されている

<br>



<br>

            ・個人的にはここが一番重要なパートだと考えている

<br>



<br>

        ・また、検索結果を要約する方法も紹介されている

<br>



<br>

    ・再帰・反復計算

<br>



<br>

        ・Retrierverから取得した結果に基づいてLLMが応答を生成し、生成した応答とoriginalのquestionの両方を組み合わせて追加でRetrieverから文書を取得し生成する手法などが紹介されている

<br>



<br>

    ・ リランキング

<br>



<br>

        ・検索結果のリランキングも古くから存在する技術であり、異なる知識を持つRankerによってリランキングさせることで性能が向上する場合がある

<br>



<br>

・回答

<br>



<br>

    ・回答抽出・生成

<br>



<br>

        ・回答となる部分のspanを抽出する手法と、spanではなくテキストを生成する手法が紹介されている

<br>



<br>

        ・この辺は文書要約におけるExtractive/Abstractive Summarization技術などもかなり応用が効くと思われる

<br>



<br>

・インデクシング

<br>



<br>

    ・不要文書のフィルタリングや、チャンク分割の戦略、資格情報をテキスト化する方法などが紹介されている

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/5ad62f76-e1b9-4c78-847a-45387fe5fb3e" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/634e5386-6ae4-4602-a214-cc8dc126daad" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/GenerativeAI.html">#GenerativeAI</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-11-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1115">生成AIが抱えるリスクと対策, LYCorp‘23</a>
<span class="snippet"><span>Comment</span>この資料をスタートにReferしている論文などを勉強すると、GenerativeAIのリスク周りに詳しくなれそう。この辺は疎いので勉強になる。

<br>

しかし、LLMのAlignmentが不十分だったり、Hallucinationを100%防ぐことは原理的に不可能だと思われるので、この辺とどう付き合っていくかがLLMと付き合っていく上で難しいところ。この辺は自分たちが活用したいユースケースに応じて柔軟に対応しなければならず、この辺の細かいカスタマイズをする地道な作業はずっと残り続けるのではないかなあ</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ImageCaptioning.html">#ImageCaptioning</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<span class="issue_date">Issue Date: 2023-11-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1114">Zero-shot Learning網羅的サーベイ: CLIPが切り開いたVision &amp; Languageの新しい世界</a>
<span class="snippet"><span>Comment</span>これはすごいまとめ…。まだ途中までしか読めていない。CLIPからスタートしてCLIPを引用している論文から重要なものを概要付きでまとめている。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-11-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1112">IBIS2023チュートリアル「大規模言語モデル活用技術の最前線」</a>
<span class="snippet"><span>Comment</span>LLMの応用研究やPromptingを中心としたチュートリアル。アノテーションや対話式推薦システムへの活用、ReAct、プロンプトの最適化技術、CoTの基本から応用まで幅広くまとまっているので、LLMの応用技術の概観や、CoTを実践したい人に非常に有用だと思う。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/FoundationModel.html">#FoundationModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-11-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1111">tsuzumi, NTT’23</a>
<span class="snippet"><span>Comment</span>NTT製のLLM。パラメータ数は7Bと軽量だが高性能。

<br>

MTBenchのようなGPT4に勝敗を判定させるベンチマークで、地理、歴史、政治、社会に関する質問応答タスク（図6）でgpt3.5turboと同等、国産LLMの中でトップの性能。GPT3.5turboには、コーディングや数学などの能力では劣るとのこと。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/d064e0dc-b598-4853-9466-f56f39986acc" alt="image" loading="lazy">

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/c8251b2e-f865-4069-a3b7-9bfb848554bb" alt="image" loading="lazy">

<br>

&gt; ＊6 Rakudaベンチマーク

<br>

日本語の言語モデルの性能を評価するベンチマークの一つで、日本の地理・政治・歴史・社会に関する質問応答タスクによって評価を行う。

<br>

URL：https://yuzuai.jp/benchmark

<br>



<br>

&gt;＊7 Japanese Vicuna QAベンチマーク

<br>

Rakudaよりもさらに幅広いカテゴリで言語モデルのQAや指示遂行の能力を問う評価方法。一般知識、ロールプレイなど多数の質問から構成される。

<br>

URL：https://github.com/hitoshizuku7/LLM_Judge_ku/blob/main/README.mdtsuzumiはアダプタを追加することで、モデル全体のパラメータを更新することなく、さまざまな知識を持たせたり、振る舞いを変えたりできるようになるとのこと（LoRAアダプタのようなものだと思われる）。

<br>

まて、将来的に視覚や聴覚などのマルチモーダル対応も実施。思想がLoRA Hub 917 に近く、アダプタを着脱すれば柔軟に生成を変えられるのは有用だと思う。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<a class="button" href="articles/Catastrophic%20Forgetting.html">#Catastrophic Forgetting</a>
<span class="issue_date">Issue Date: 2023-10-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1109">大規模言語モデルのFine-tuningによるドメイン知識獲得の検討</a>
<span class="snippet"><span>Comment</span>以下記事中で興味深かった部分を引用

<br>

&gt; まとめると、LoRAは、[3]で言われている、事前学習モデルは大量のパラメータ数にもかかわらず低い固有次元を持ち、Fine-tuningに有効な低次元のパラメータ化も存在する、という主張にインスパイアされ、ΔWにおける重みの更新の固有次元も低いという仮説のもとで、低ランク行列で学習する手法になります。

<br>



<br>

LoRAが拠り所とする仮説が説明されており、勉強になった。

<br>



<br>

&gt; こうしたニューラルネットワークを圧縮する他の技術には枝刈りや知識蒸留がありますが、量子化は、ほとんどの場合に枝刈りより優れているとされ[5]、蒸留よりも手軽に高精度なモデルが得られる可能性が高く、LLMにおいても有力な技術と考えられます。

<br>



<br>

これも知らなかったし、文献付きで記述されていることが大変ありがたい。

<br>



<br>

&gt; QLoRA以外のLoRAの派生手法としては、ランクを適応的に定めるAdaLoRA[7] やDyLoRA[8]、コンテキスト長を拡大できるLongLoRA[9]、行列Aの重みをfreezeすることでさらに軽量化を行うLoRA-FA、行列積をアダマール積やクロネッカー積で計算するLoHAやLoKRなどがあります（一部はLLMではなくStable Diffusionの学習で用いられる手法の通称です）。

<br>



<br>

この辺は実際にLoRAを使うことになったら勉強したい。

<br>



<br>

&gt; 言語モデルの学習は通常、Causal LMの場合は、Next Token PredictionにおけるPerplexityの最小化による教師なし学習によって最適化されます。

<br>



<br>

HuggingFaceの実装の話だと思うが、そうだろうなと思ってはいたがソースを確認できていなかったので勉強になった。

<br>



<br>

&gt; 7Bのモデルでは、以下のグラフのように、データの件数を増やすと学習がうまくいかないという結果が得られました。また、LoRAのランクは低い方が学習が安定することがわかりました。正答率が著しく低いものは、学習時のロス（交差エントロピー）が非常に大きくなっており、選択肢を間違えるというよりは言語モデルとしての機能が失われていました。

<br>



<br>

&gt; 他には、Instructionデータ（1つのクイズのQ&amp;A）が2500件を超えるとロスが悪化することや、2000件でも2epoch繰り返すとcatastrophic forgettingが見られ、言語モデルそのものの性能が失われ意味のない出力をしていました。[17] でも言及されていますが、日本語の学習では、数BのモデルにおけるLoRAによるInstruction Tuningはあまり効果が得られない可能性が高いと考えられます。

<br>



<br>

&gt; 一方、13Bのモデルでは、8、16、32、64いずれのランクでも大きな差は見られませんでした。

<br>

&gt; これらから、Addtional Trainingで学習させるデータがInstruction Tuningに対して膨大である場合には先に学習した方がよく、少数の場合は後に学習させてもInstruction Tuningの効果には悪影響がないということが示唆されました。

<br>



<br>

&gt; また学習は、初期学習率を小さくした方が安定する可能性が高いと思われます。LoRAの論文[2] ではGPTのFine-tuneは2e-4で行われており、hugging faceの実装でもデフォルトでは2e-4となっていますが、他の論文やブログでは3e-5での例などもあります。しかし、単に下げれば安定するということでもなく、１回の試行における計算コストとチューニングがトレードオフになる可能性はあります。

<br>



<br>

Additional TrainingとはFinetuningのことで便宜上の本ブログでの呼称。実際の文書中では図が複数個挟まれている。

<br>

こうした実際に手を動かした上でないと得られない知見を公開してくれるのは非常にありがたいことだし、日本語データでLoRAをする際に非常に参考になりそう。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-10-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1107">StableDiffusion, LLMのGPUメモリ削減のあれこれ</a>
<span class="snippet"><span>Comment</span>Gradient Accumulation, Gradient Checkpointingの説明が丁寧でわかりやすかった。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-10-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1103">LLMのプロンプト技術まとめ</a>
<span class="snippet"><span>Comment</span>ざっと見たが現時点で主要なものはほぼ含まれているのでは、という印象

<br>

実際のプロンプト例が載っているので、理解しやすいかもしれない。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-10-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1101">Evaluating RAG Pipelines</a>
<span class="snippet"><span>Comment</span>RAG pipeline （retrieval + generation）を評価するライブラリRagasについて紹介されている。

<br>



<br>

評価に活用される指標は下記で、背後にLLMを活用しているため、大半の指標はラベルデータ不要。ただし、context_recallを測定する場合はreference answerが必要。

<br>

Ragasスコアとしてどのメトリックを利用するかは選択することができ、選択したメトリックのharmonic meanでスコアが算出される。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/553e7f91-84cd-4aac-bef3-c84bc279547e" alt="image" loading="lazy">

<br>



<br>

各種メトリックの内部的な処理は下記:

<br>

・faithfullness

<br>

  ・questionと生成された回答に基づいて、statementのリストをLLMで生成する。statementは回答が主張している内容をLLMが解釈したものだと思われる。

<br>

  ・statementのリストとcontextが与えられたときに、statementがcontextにsupportされているかをLLMで評価する。

<br>

  ・num. of supported statements / num. of statements でスコアが算出される

<br>

・Answer Relevancy

<br>

  ・LLMで生成された回答から逆に質問を生成し、生成された質問と実際の質問の類似度を測ることで評価

<br>

・Context Relevancy

<br>

  ・どれだけcontextにノイズが含まれるかを測定する。

<br>

  ・LLMでcontextの各文ごとに回答に必要な文か否かを判断する

<br>

  ・回答に必要な文数 / 全文数 でスコアを算出

<br>

・Context Recall

<br>

  ・回答に必要な情報を全てretrieverが抽出できているか

<br>

  ・ground truthとなる回答からstatementをLLMで生成し、statementがcontextでどれだけカバーされているかで算出

<br>



<br>

また、LangSmithを利用して実験を管理する方法についても記述されている。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/3a30d238-ac48-401c-906b-4ddb5fca50be" alt="image" loading="lazy">

<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-10-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1100">LangChainのRAGの改善法, LayerX機械学習勉強会</a>
<span class="snippet"><span>Comment</span>以下リンクからの引用。LangChainから提供されているRetrieverのcontext抽出の性能改善のためのソリューション

<br>



<br>

&gt; Multi representation indexing：検索に適した文書表現（例えば要約）の作成

<br>

Query transformation：人間の質問を変換して検索を改善する方法

<br>

Query construction：人間の質問を特定のクエリ構文や言語に変換する方法

<br>



<br>

https://blog.langchain.dev/query-transformations/</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-10-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1096">日本語LLMのリーダーボード（LLM.jp）</a>
<span class="snippet"><span>Comment</span>LLM.jpによる日本語LLMのリーダーボード。4-shotsでの結果、かつinstructionを与えた場合の生成テキストに対する評価、という点には留意したい。たとえばゼロショットで活用したい、という場合にこのリーダーボードの結果がそのまま再現される保証はないと推察される。

<br>



<br>

1079 の知見でもあった通り、promptingの仕方によってもLLM間で順位が逆転する現象なども起こりうる。あくまでリーダーボードの値は参考値として留め、どのLLMを採用するかは、自分が利用するタスクやデータで検証した方がbetterだと思われる。

<br>



<br>

あとはそもそも本当にLLMを使う必要があるのか? 1024  のような手法ではダメなのか?みたいなところも考えられると良いのかもしれない。

<br>



<br>

以下サイトより引用

<br>

&gt; 評価手法・ツール

<br>

このダッシュボードの内容はllm-jpで公開している評価ツール、llm-jp-evalで各モデルに対して評価を行なった結果である。llm-jp-evalは、既存のリーダボードとは行われている評価とは、主に以下のところで違っている。

<br>

AlpacaやBig-Benchなどを参考にした、インストラクションチューニングよりのプロンプトを入力として与えて、その入力に対するモデルの生成結果を評価する

<br>

&gt;評価は基本、モデルが生成した文字列だけを使って行う

<br>

&gt;Few shotでの評価を行っており、このダッシュボードには4-shotsでの結果を載せている

<br>



<br>

&gt;評価手法・ツールの詳細はllm-jp-evalを是非参照されたい。

<br>



<br>

&gt;評価項目・データセット

<br>

評価項目として、まず4つのカテゴリーにおける平均スコアを算出した。さらにその4カテゴリーの平均値の平均値をとった値がAVGである。

<br>

MC (Multi-Choice QA)：jcommonsenseqa

<br>

NLI (Natural Language Inference)：jamp、janli、jnli、jsem、jsick

<br>

QA (Question Answering)：jemhopqa、niilc

<br>

RC (Reading Comprehension)：jsquad

<br>



<br>

&gt;それぞれのカテゴリの平均を出す方法に言語学的な意味はないため、最終的な平均値はあくまで参考値ということに注意されたい。JGlueを利用した日本語LLMのリーダーボードとして 1055 などもある</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-10-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1087">日本語大規模言語モデル「Japanese Stable LM 3B-4E1T」「Japanese Stable LM Gamma 7B」を公開しました, 2023</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-10-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1080">OpenSource LLM</a>
<span class="snippet"><span>Comment</span>zephyr-7B-alpha

<br>

・1/10のパラメータでLLaMA2-70Bw-chat超え

<br>

https://weel.co.jp/media/zephyr-7b-alpha・zephyr-7B-β

<br>

　・MTBenchでllama2-70B-chat超え

<br>

　・1099Zephyr-7B-betaが早くもTheBloke氏によってGPTQで量子化され、なんとモデル自体は4.5G程度しかVRAMを消費しない…

<br>

https://huggingface.co/TheBloke/zephyr-7B-beta-GPTQ・NVIDIA Nemotron-3 8B Models

<br>



<br>

    ・https://developer.nvidia.com/nemotron-3-8b\

<br>



<br>

    ・https://huggingface.co/nvidia/nemotron-3-8b-base-4k

<br>



<br>

    ・53言語対応、37プログラミング言語対応, base / chatがある ・Mixtral8x7B: LLaMA2-70B, GPT-3.5-turboと同等の性能

<br>



<br>

    ・MistralをSparse Mixture of Expertsしたモデルの模様

<br>



<br>

    ・名前の通り8つのFFNが存在しているが、Top-2のFFNが選択されその結果が集約され出力が決定される

<br>



<br>

https://mistral.ai/news/mixtral-of-experts/

<br>



<br>



<br>



<br>

・日本語まとめ

<br>



<br>

    ・https://note.com/npaka/n/n6043bc8b01bc</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/AutomaticPromptEngineering.html">#AutomaticPromptEngineering</a>
<span class="issue_date">Issue Date: 2023-10-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1079">日本語LLMベンチマークと自動プロンプトエンジニアリング</a>
<span class="snippet"><span>Comment</span>面白かった。特に、promptingによってrinnaとcyberのLLMの順位が逆転しているのが興味深かった。GAを使ったプロンプトチューニングは最近論文も出ていたが、日本語LLMで試されているのは面白かった。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-10-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1073">Large Language Model （in 2023）, OpenAI</a>
<span class="snippet"><span>Comment</span>LLMの研究開発動向を俯瞰するのに有用らしい</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2023-10-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1064">MentalLLaMA, 2023</a>
<span class="snippet"><span>Comment</span>メンタルヘルスの分析に対してinstruction tuningしたはじめてのLLM</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-10-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1058">Yasa-1</a>
<span class="snippet"><span>Comment</span>参考: https://x.com/jaguring1/status/1709557947813281865?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Sentence.html">#Sentence</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<span class="issue_date">Issue Date: 2023-10-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1057">Japanese Simple SimCSE</a>
<span class="snippet"><span>Comment</span>日本語の事前学習言語モデルと、日本語の学習データを利用してSimCSEを学習し網羅的に評価をした結果が記載されている。Supervised SimCSE, UnsupervisednSimCSEの両方で実験。また、学習するデータセットを変更したときの頑健性も検証。性能が良かったモデルはSentenceTransformersから利用可能な形で公開されている。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-10-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1055">Nejumi LLMリーダーボード</a>
<span class="snippet"><span>Comment</span>JGLUEを使ったLLMの日本語タスクベンチマークv4が公開:

<br>

https://wandb.ai/llm-leaderboard/nejumi-leaderboard4/reports/Nejumi-LLM-4--VmlldzoxMzc1OTk1MA

<br>



<br>

元ポスト:https://x.com/madyagi/status/1960525757874364462?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-09-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1053">LLM-as-a-judge</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ChatGPT.html">#ChatGPT</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<span class="issue_date">Issue Date: 2023-09-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1052">OpenAI、ChatGPTが画像を分析する『GPT-4V（ビジョン）』を発表。安全性、嗜好性、福祉機能を強化, AIDB, 2023.09</a>
<span class="snippet"><span>Comment</span>おう…やべえな…

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/3ee7dc96-af6f-47f9-98c0-c6be5d9384f1" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2023-09-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1049">Agents: An opensource framework for autonomous language agents</a>
<span class="snippet"><span>Comment</span>以下の特徴を持つLLMAgent開発のためのフレームワーク

<br>



<br>

・long-short term memory

<br>

・tool usage

<br>

・web navigation

<br>

・multi-agent communication

<br>

・human-agent interaction

<br>

・symbolic control

<br>



<br>

また、他のAgent frameworkと違い、ゴールを達成するだの細かいプランニングを策定（SOP; サブタスクとサブゴールを定義）することで、エージェントに対してきめ細かなワークフローを定義できる。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-09-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1036">SNLP2023:Is GPT-3 a Good Data Annotator?</a>
<span class="snippet"><span>Comment</span>GPT3でデータを作成したら、タスクごとに有効なデータ作成方法は異なったが、人手で作成したデータと同等の性能を達成するデータ（BERTでfinetuning）を、低コストで実現できたよ、という研究この辺の話はもはや 1024 を使えばいいのでは、という気がする。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<span class="issue_date">Issue Date: 2023-09-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1032">LangChain Cheet Sheet</a>
<span class="snippet"><span>Comment</span><img width="1315" alt="image" src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/6621fe24-d007-4590-b1a6-b861a6dec4ad">

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-09-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1031">大規模言語モデル, 岡崎先生, 2023</a>
<span class="snippet"><span>Comment</span>岡崎先生による大規模言語モデルのチュートリアル

<br>



<br>

最近のLLMまでの歴史、transformerなどの基礎的な内容から、最新の内容まで数式付きで詳細にまとまっている</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<span class="issue_date">Issue Date: 2023-08-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1027">LLMのファインチューニング で 何ができて 何ができないのか</a>
<span class="snippet"><span>Comment</span>&gt;LLMのファインチューニングは、「形式」の学習は効果的ですが、「事実」の学習は不得意です。

<br>



<br>

&gt; シェイクスピアの脚本のデータセット (tiny-shakespeare) の

<br>

「ロミオ」を「ボブ」に置き換えてファインチューニングして、新モデルの頭の中では「ロミオ」と「ボブ」をどう記憶しているかを確認します。

<br>



<br>

ファインチューニングしても、Bで始まるジュリエットが恋する人物について質問しても、ボブと答えてはくれない。

<br>

&gt; ロミオ」は「ジュリエット」が恋していたこの男性に関連付けられており、「ロミオ」を「ボブ」に置き換えるファインチューニングでは、ニューラルネットワークの知識ベースを変更することはできませんでした。

<br>



<br>

なるほど。参考: https://www.anyscale.com/blog/fine-tuning-is-for-form-not-facts?ref=blog.langchain.devimosさんのツイートを引用

<br>

&gt; 文章が悪かったので補足。追加学習を全体に十分なデータですれば知識は獲得しえます（が事前学習の知識を忘却するリスクは高い）。巷でよくファインチューニングと呼ばれるものは、知識を司るらしいMLP部を触らず自己注意機構部のみを更新するので、そもそも知識を増やすのは難しいという認識です。

<br>



<br>

元ツイート: https://x.com/imos/status/1696507787067756846?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<span class="issue_date">Issue Date: 2023-08-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1026">Metaの「Llama 2」をベースとした商用利用可能な日本語LLM「ELYZA-japanese-Llama-2-7b」を公開しました</a>
<span class="snippet"><span>Comment</span>商用利用可能、70億パラメータ。

<br>

ELYZA社が独自に作成した評価セットでは日本語のOpenLLMの中で最高性能。ただし、モデル選定の段階でこの評価データの情報を利用しているため、有利に働いている可能性があるとのこと。

<br>



<br>

一般的に利用される日本語の評価用データでは、なんとも言い難い。良いタスクもあれば悪いタスクもある。が、多分評価用データ自体もあまり整備は進んでいないと想像されるため、一旦触ってみるのが良いのだと思う。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<span class="issue_date">Issue Date: 2023-08-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1025">zeno-build</a>
<span class="snippet"><span>Comment</span>MTでのテクニカルレポート

<br>

https://github.com/zeno-ml/zeno-build/tree/main/examples/analysis_gpt_mt/reportLLMの実験管理を容易に実施するツールで、異なるハイパーパラメータ、異なるモデル、異なるプロンプトでの実験などを簡単に実施できる。評価結果を自動的に可視化し、interactiveに表示するブラウザベースのアプリケーションも作成可能？</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-08-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1021">Anti-hype LLM Reading list</a>
<span class="snippet"><span>Comment</span>LLNのサーベイ、BERT等の基盤モデルの論文、自前でLLMを学習するために必要な論文がコンパクトにまとめられたgist<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/0a5df5e6-0ed8-481b-9d5f-3f0397454371" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-08-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1003">走行動画を説明するLLMを作成し、80台のGPUで分散並列学習させた話</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-based.html">#Reference-based</a>
<span class="issue_date">Issue Date: 2023-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/947">Learning to Score System Summaries for Better Content Selection Evaluation, Peyard+, Prof. of the Workshop on New Frontiers in Summarization</a>
<span class="snippet"><span>Summary</span>本研究では、古典的な要約データセットを使用して、人間の判断に基づいた自動スコアリングメトリックの学習を提案します。既存のメトリックを組み込み、人間の判断と高い相関を持つ組み合わせを学習します。新しいメトリックの信頼性は手動評価によってテストされます。学習済みのメトリックはオープンソースのツールとして公開されます。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/STS%20(SemanticTextualSimilarity).html">#STS (SemanticTextualSimilarity)</a>
<span class="issue_date">Issue Date: 2023-07-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/910">OpenAI の Embeddings API はイケてるのか、定量的に調べてみる</a>
<span class="snippet"><span>Comment</span>[JSTSタスク](https://github.com/yahoojapan/JGLUE)では、[Tohoku BERT v3](https://github.com/cl-tohoku/bert-japanese/tree/mainmodel-performances) と [LUKE](https://github.com/studio-ousia/luke)が最も性能が良いらしい。

<br>



<br>

[SimCSE](https://huggingface.co/pkshatech/simcse-ja-bert-base-clcmlp)よりも性能が良いのは興味深い。

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<span class="issue_date">Issue Date: 2023-07-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/899">FlashAttention-2: Faster Attention with Better Parallelism and Work Partitioning, 2023</a>
<span class="snippet"><span>Summary</span>FlashAttention-2は、長いシーケンス長におけるTransformerのスケーリングの問題に対処するために提案された手法です。FlashAttention-2は、非対称なGPUメモリ階層を利用してメモリの節約とランタイムの高速化を実現し、最適化された行列乗算に比べて約2倍の高速化を達成します。また、FlashAttention-2はGPTスタイルのモデルのトレーニングにおいても高速化を実現し、最大225 TFLOPs/sのトレーニング速度に達します。</span>
<span class="snippet"><span>Comment</span>Flash Attention1よりも2倍高速なFlash Attention 2Flash Attention1はこちらを参照

<br>

https://arxiv.org/pdf/2205.14135.pdf

<br>



<br>

QK Matrixの計算をブロックに分けてSRAMに送って処理することで、3倍高速化し、メモリ効率を10-20倍を達成。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/935f61f3-97ce-4e76-826b-040f92ca567c" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/FoundationModel.html">#FoundationModel</a>
<span class="issue_date">Issue Date: 2023-07-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/897">Introducing CM3leon, a more efficient, state-of-the-art generative model for text and images, 2023</a>
<span class="snippet"><span>Summary</span>最近の自然言語処理の進歩により、生成型AIモデルへの関心と研究が加速しています。CM3leonは、テキストから画像への生成と画像からテキストへの生成を行う単一の基礎モデルです。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/Faithfulness.html">#Faithfulness</a>
<span class="issue_date">Issue Date: 2023-07-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/896">Measuring Faithfulness in Chain-of-Thought Reasoning, Anthropic, 2023</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）は、Chain-of-Thought（CoT）推論を生成することで質問に答える性能を向上させるが、その推論が実際の推論を忠実に表しているかは不明である。本研究では、CoT推論の忠実さを調査し、CoTに介入することでモデルの予測がどのように変化するかを調べる。結果は、モデルのサイズやタスクによってCoTの忠実さが異なることを示唆している。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<span class="issue_date">Issue Date: 2023-07-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/894">trl_trlx</a>
<span class="snippet"><span>Comment</span>TRL ・強化学習によるLLMの学習のためのライブラリ

<br>

https://note.com/npaka/n/nbb974324d6e1trlを使って日本語LLMをSFTからRLHFまで一通り学習させてみる

<br>

https://www.ai-shift.co.jp/techblog/3583</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Quantization.html">#Quantization</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/886">LLaMA2を3行で訓練</a>
<span class="snippet"><span>Comment</span>LLaMA2を3行で、1つのA100GPU、QLoRAで、自前のデータセットで訓練する方法</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/880">Quantized LLaMA2</a>
<span class="snippet"><span>Comment</span>LLaMA2をローカルで動作させるために、QLoRAで量子化したモデル</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/879">LLongMA2</a>
<span class="snippet"><span>Comment</span>LLaMA2のcontext windowを8kにして訓練。オリジナルのLLaMA2と同等の性能で8k contextを利用可能。元ツイート: https://twitter.com/enricoshippole/status/1682054848584228866?s=46&t=LJIgfuO352oK3zU2FKFpNA</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/DialogueGeneration.html">#DialogueGeneration</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/876">ChatBot Arenaのデータセット</a>
<span class="snippet"><span>Comment</span>33kのconversation、2つのレスポンスに対する人間のpreferenceスコア付き

<br>

20種類のSoTAモデルのレスポンスを含み、13kのユニークIPからのアクセスがあり、3Kのエキスパートによるアノテーション付き</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/NaturalLanguageUnderstanding.html">#NaturalLanguageUnderstanding</a>
<span class="issue_date">Issue Date: 2023-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/853">DataFinder: Scientific Dataset Recommendation from Natural Language Descriptions</a>
<span class="snippet"><span>Summary</span>データセットの推奨タスクを操作化し、DataFinderデータセットを構築した。DataFinderデータセットは、自動的に構築された大規模なトレーニングセットと専門家による評価セットを含んでいる。このデータセットを使用して、テキストベースのデータセット推奨のための優れたバイエンコーダリトリーバを提案し、関連する検索結果を見つけることができることを示した。データセットとモデルは一般に公開される。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Explanation.html">#Explanation</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-07-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/825">Are Human Explanations Always Helpful? Towards Objective Evaluation of Human Natural Language Explanations</a>
<span class="snippet"><span>Summary</span>本研究では、説明可能なNLPモデルのトレーニングにおいて、人間による注釈付けの説明の品質を評価する方法について検討しています。従来のSimulatabilityスコアに代わる新しいメトリックを提案し、5つのデータセットと2つのモデルアーキテクチャで評価しました。結果として、提案したメトリックがより客観的な評価を可能にする一方、Simulatabilityは不十分であることが示されました。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/MultiModal.html">#MultiModal</a>
<a class="button" href="articles/SpeechProcessing.html">#SpeechProcessing</a>
<span class="issue_date">Issue Date: 2023-07-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/784">Awesome Multimodal LLMs</a>
<span class="snippet"><span>Comment</span>マルチモーダルなLLMのリストがまとめられている</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<span class="issue_date">Issue Date: 2023-07-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/777">How Long Can Open-Source LLMs Truly Promise on Context Length?, 2023</a>
<span class="snippet"><span>Comment</span>LLMのcontext長を伸ばす際の方法と得られた知見がまとめられている</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/767">OpenLLaMA 13B, 2023</a>
<span class="snippet"><span>Comment</span><img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/4268eb3f-349f-4ebe-adeb-2cbfcb7cfe17" alt="image" loading="lazy">そもそもOpenLLaMAには、オリジナルのLLaMAと比較して、tokenizerがスペースを無視するというissueがある模様。スペースの情報がクリティカルなタスク、たとえばcode generationなどには要注意。

<br>



<br>

https://github.com/openlm-research/open_llama/issues/40</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-05-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/678">Prompt Engineering vs. Blind Prompting, 2023</a>
<span class="snippet"><span>Comment</span>experimentalな手法でprompt engineeringする際のoverview</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-05-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/676">open LLM Leaderboard</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/python.html">#python</a>
<span class="issue_date">Issue Date: 2023-05-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/675">Assisted Generation: a new direction toward low-latency text generation, 2023</a>
<span class="snippet"><span>Comment</span>1 line加えるとtransformerのgenerationが最大3倍程度高速化されるようになったらしい<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/fecc1c5e-b9e5-4844-af96-ba48c3d60fae" alt="image" loading="lazy">

<br>



<br>

assistant modelをロードしgenerateに引数として渡すだけ

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/7dabf3bf-cd32-469c-abba-f1269318576d" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<span class="issue_date">Issue Date: 2023-05-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/669">METEOR: An Automatic Metric for MT Evaluation with Improved Correlation with Human Judgments, Banerjee+, CMU, ACL Workshop on Intrinsic and Extrinsic Evaluation Measures for Machine Translation and_or Summarization</a>
<span class="snippet"><span>Comment</span>イントロ

<br>



<br>

MTの評価はBLEUが提案されてから過去2年間で注目されている。BLEUはNIST metricと関連しており、研究で利用されてきた。自動評価は素早く、より簡便に、human evaluationよりも安価に評価をすることができる。また、自動評価は他のシステムとの比較だけでなく、ongoingなシステムの改善にも使える。

<br>



<br>

過去MTの評価は人手で行われてきた。MTの評価で利用される指標はfairly intensiveでwell establishedな一方で、MTの評価全体は複雑さとタスク依存である。結果的にMTの評価そのものが研究分野となってきた。多くの評価指標が提案されてきたが、全てが簡単に定量化できるわけではない。近年のFEMTIといったフレームワークは、MT評価のための多面的なmeasureを効果的でユーザが調整可能な方法で考案しようとしている。一方、単一の1次元の数値メトリックは、MT評価の全てのaspectを捉えることができないが、このようなメトリックは未だ大きな価値が実用性の観点で存在する。効果的・かつ効率的であるために、MT評価の自動性能指標はいくつかの基本的な基準を満たす必要がある：

<br>



<br>

・MTの質に対する人間が定量化した指標と高い相関があること

<br>



<br>

・異なるシステム間、同じシステムの異なるバージョン間の品質の違いにできるだけsensitiveであること

<br>



<br>

・一貫性があり、信頼性があり、一般的である必要

<br>



<br>

  ・一貫性: 同じMTシステムが類似したテキストを翻訳したら類似したスコアを返す

<br>



<br>

  ・信頼性: 類似したスコアを持つMTシステムは似たように類似した動作をすること

<br>



<br>

  ・一般的: さまざまなドメインやシナリオのMTタスクに適用可能であること

<br>



<br>

これら指標を全て満たすことは困難であるが、これまでに提案された全ての指標は、要件の全てではないにせよ、ほとんどの要件に対して適切に対処できているわけではない。これらの要件を適切に定量化し、具体的なテスト尺度に変換すると、MTの評価指標を比較、および評価できる全体的な基準として扱える。

<br>



<br>

本研究では、METEORを提案する。METEORはBLEUのいくつかの弱点に対処した手法である。

<br>



<br>



<br>



<br>

METEOR Metric

<br>



<br>

METEORで対処するBLEUの弱点

<br>



<br>

BLEUはn-gramのprecisionを測る指標であり、recallを直接的に考慮していない。recallは翻訳文が正解文のcontentをどれだけcoverできているかを測定することができるため重要な指標である。BLEUは複数の参照訳を利用するため、recallの概念を定義することができない。代わりに、BLEUではbrevity penaltyを導入し、短すぎる翻訳にはペナルティを与えるようにしている。

<br>



<br>

NIST metricもコンセプト上はBLEUと同様の弱点を持っている。METEORが対処するBLEUやNISTは以下となる：

<br>



<br>

・The Lack of Recall:

<br>



<br>

  ・固定のbrevity penaltyを与えるだけでは、recallに対する適切な補償とはなっていない。実験結果がこれを強く示している。

<br>



<br>

・Use of Higher Order N-grams:

<br>



<br>

  ・BLEUにおけるhigher orderのN-gramの利用は、翻訳の文法的な良さを間接的に測定している。METEORではより直接的にgrammarticality（あるいはword order）を考慮する。実験結果では、human judgmentsとより良い相関を示した。

<br>



<br>

・Lack of Explicit Word-matching between Translation and Reference

<br>



<br>

  ・N-gramでは明示的なword-to-word matchingを必要しないため、結果的に正しくないマッチ、具体的には共通の機能語等のマッチをカウントしてしまう。

<br>



<br>

・Use of Geometric Averaging of N-grams

<br>



<br>

  ・BLEUは幾何平均（i.e. 1,2,3,4-gramそれぞれのprecisionの積の1/n乗根）をとっているため、n-gramのコンポーネントの1つでもゼロになると、幾何平均の結果もゼロとなる。結果的に、sentenceあるいはsegmentレベルでBLEUスコアを測ろうとすると意味のないものとなる（ゼロになるため）。BLEUは全体のテストセット（文レベルではなく）のカウントを集約するのみであるが、sentence levelのindicatorもメトリックとしては有用であると考えられる。実験結果によると、n-gramの算術平均をとるようにBLEUスコアを改変した場合、human judgmentsとの相関が改善した。

<br>



<br>



<br>



<br>

Meteor Metric

<br>



<br>

参照訳が複数ある場合は最もスコアが高いものを出力する。METEORはword-to-wordのマッチングに基づいた指標である。まず、参照訳と候補訳が与えられたときに単語同士のalignmentを作成する。このときunigramを利用してone-to-manyのmappingをする。wordnetの同義語を利用したり、porter-stemmerを利用しステミングした結果を活用しalignmentを作成することができる。続いて、それぞれのunigramのmapppingのうち、最も大きな部分集合のmappingを選択し、対応するunigramのalignmentとする。もしalignmentの候補として複数の候補があった場合、unigram mappingのcrossが少ない方を採用する。この一連の操作はstageとして定義され、各stageごとにmapping module（同義語使うのか、stemming結果使うのかなど）を定義する。そして、後段のstageでは、以前のstageでmappingされていなunigramがmappingの対象となる。たとえば、first stageにexact matchをmapping moduleとして利用し、次のstageでporter stemmerをmapping moduleとして利用すると、よりsurface formを重視したmappingが最初に作成され、surface formでマッチングしなかったものが、stemming結果によってマッピングされることになる。どの順番でstageを構成するか、何個のstageを構成するか、どのmapping moduleを利用するかは任意である。基本的には、1st-stageでは"exact match", 2nd-stageでは"porter stem", 3rd-stageでは"wordnet synonymy"を利用する。このようにして定義されたalignmentに基づいて、unigram PrecisionとRecallを計算する。

<br>



<br>

Precisionは、候補訳のunigramのうち、参照訳のunigramにマッピングされた割合となる。Recallは、参照訳のunigramのうち、候補訳からマッピングされた割合となる。そして、Precisionを1, Recallを9の重みとして、Recall-OrientedなF値を計算する。このF値はunigramマッチに基づいているので、より長い系列のマッチを考慮するために、alignmentに対して、ペナルティを計算する。具体的には、参照訳と候補訳で連続したunigramマッチとしてマッピングされているもの同士をchunkとして扱い、マッチングしたunigramに対するchunkの数に基づいてペナルティを計算する。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/b3aaf2f6-ebfc-4561-9b5e-c14a1c10a983" alt="image" loading="lazy">

<br>



<br>

チャンクの数が多ければ多いほどペナルティが増加する。そして、最終的にスコアは下記式で計算される：

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/e591c2e4-3d92-4f26-ae0a-5fd782346dbd" alt="image" loading="lazy">

<br>



<br>

最大でF値が50%まで減衰するようにペナルティがかかる。

<br>



<br>



<br>



<br>

評価

<br>



<br>

Data

<br>



<br>

DARPA/TIDES 2003 Arabic-to-English, Chinese-to-English データを利用。Chinese dataは920 sentences, Arabic datasetは664 sentencesで構成される。それぞれのsentenceには、それぞれのsentenceには、4種類のreferenceが付与されている。加えて、Chinese dataでは7種類のシステム、Arabic dataでは6種類のシステムの各sentenceに対する翻訳結果と、2名の独立したhuman judgmentsの結果が付与されている。human judgmentsは、AdequacyとFluency Scoreの2つで構成されている。それぞれのスコアは0--5のレンジで変化する。本評価では、Combined Score、すなわち2名のアノテーションによって付与されたAdequacy ScoreとFluency Scoreを平均したものを用いる。

<br>



<br>



<br>



<br>

本研究の目的としては、sentence単位での評価を行うことだが、BLEUやNISTはシステムレベルで評価を行う指標のため、まずシステムレベルでhuman judgeとのcorrelationを測定。correlationを測る際は、各システムごとにCombined Scoreの平均をとり、human judgmentの総合的な結果を1つのスコアとして計算。またシステムのすべての翻訳結果に対する各種metricを集約することで、システムごとに各種metricの値を1つずつ付与し、両者で相関を測った。結果は以下のようにMETEORが最も高い相関を示した。METEORのsubcomponentsもBLEUやNISTよりも高い相関を示している。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/7ffa4c3c-7698-4075-9e9a-9db199d535af" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

文レベルでhuman judgeとのcorrelationを測った結果は下記。文レベルで測る際は、システムごとに、システムが翻訳したすべての翻訳結果に対しMETEORスコアを計算し、fluencyとadequacyスコアの平均値との相関を測った。そして各データセットごとに、システムごとの相関係数の平均を算出した。

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/0264554c-4f21-47dc-aa58-c7ecfdd6aa47" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/b638a329-06a2-4c9f-9005-eae9fa38bf42" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

他のmetricとの比較結果は下記で、METEORが最も高い相関を示した。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/da31b9ca-dee4-4c59-8e10-ca765bc00b36" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/6718194c-c9e2-4b5d-b02c-00776a469f18" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

続いて、異なるword mapping設定でcorrelationを測った。結果は下記で、Exact, Porter, Wordnet-Synonymの順番で3-stageを構成する方法が最も高い相関を示した。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/428cdfdd-e20f-4a56-9e1e-06def83a8cab" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

最後に、文レベルの評価はannotator間のaggreementが低く、ノイジーであることがわかっている。このノイズを緩和するために、スコアをnormalizeしcorrelationを測定した。結果は下記で、normalizeしたことによってcorrelationが改善している。これは、human assessmentのノイズによって、automatic scoreとhuman assessmentのcorrelationに影響を与えることを示している。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/473085a1-1137-43d6-8f8e-1cdbc256ad55" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/FoundationModel.html">#FoundationModel</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2023-05-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/665">OpenSource PaLM, 2023</a>
<span class="snippet"><span>Comment</span>150m,410m,1bのモデルがある。Googleの540bには遠く及ばないし、emergent abilityも期待できないパラメータ数だが、どの程度の性能なのだろうか。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/FoundationModel.html">#FoundationModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<span class="issue_date">Issue Date: 2023-05-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/661">StarCoderBase_StarCoder, 2023</a>
<span class="snippet"><span>Comment</span>・15.5Bパラメータ

<br>

・80種類以上のプログラミング言語で訓練

<br>

・Multi Query Attentionを利用

<br>

・context window size 8192

<br>

・Fill in the middle objectiveを利用

<br>



<br>

Instruction tuningがされておらず、prefixとsuffixの間を埋めるような訓練のされ方をしているので、たとえば関数名をinputして、そのmiddle（関数の中身）を出力させる、といった使い方になる模様。paper: https://drive.google.com/file/d/1cN-b9GnWtHzQRoE7M7gAEyivY0kl4BYs/viewStarCoder:

<br>

https://huggingface.co/bigcode/starcoderStarCoderBaseを35Bのpython tokenでfinetuningしたモデル。

<br>

既存モデルよりも高性能と主張

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236622130-5e7aa6aa-5f9b-4b0e-9962-ff1beaa03225.jpeg" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-05-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/659">MPT-7B, 2023</a>
<span class="snippet"><span>Comment</span>新たなオープンソースLLM。

<br>

下記ツイートより引用:

<br>



<br>

・商用利用可能

<br>

・6万5000トークン使用可能

<br>

・7Bと比較的小さいモデルながら高性能

<br>

・日本語を扱え性能が高い

<br>



<br>

とのこと。

<br>



<br>

https://twitter.com/imai_eruel/status/1654629078878793729?s=46&t=nqpG5xvXzdg7yUPU4IfD3AChatGPTのLLMと比較すると、ざっと例を見た感じ質問応答としての能力はそこまで高くなさそうな印象。

<br>

finetuningしない限りはGPT3,GPT4で良さげ。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<span class="issue_date">Issue Date: 2023-05-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/653">SNAP: Web data: Amazon reviews</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<span class="issue_date">Issue Date: 2023-05-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/651">Personalized news filtering and summarization on the web, Xindong+, 2011 IEEE 23rd International Conference on Tools with Artificial Intelligence, 29</a>
<span class="snippet"><span>Comment</span>summarizationではなく、keyword extractionの話だった</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<a class="button" href="articles/review.html">#review</a>
<span class="issue_date">Issue Date: 2023-05-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/648">Personalized summarization of customer reviews based on user’s browsing history, Zehra+, International Journal on Computer Science and Information Systems 8.2, 12</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/Education.html">#Education</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<span class="issue_date">Issue Date: 2023-05-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/646">Towards personalized summaries in spanish based on learning styles theory, Uriel+, Res. Comput. Sci. 148.5, 1</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Education.html">#Education</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<span class="issue_date">Issue Date: 2023-05-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/645">Personalized Text Content Summarizer for Mobile Learning: An Automatic Text Summarization System with Relevance Based Language Model, Guangbing+, IEEE Fourth International Conference on Technology for Education, 2012, 22</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<span class="issue_date">Issue Date: 2023-05-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/644">Personalized text summarization based on important terms identification, Robert+, 23rd International Workshop on Database and Expert Systems Applications, 2012, 43</a>
<span class="snippet"><span>Comment</span>（あまりしっかりよめていない）

<br>



<br>

学習者のrevision（復習？）のための教材の要約手法の提案。personalizationするために、さまざまなRaterを定義し、Raterからの単語wに対する評価を集約し、最終的にuser-specificなsentence-term matrixを構築。 SVDを適用することで要約を作成する。personalizedな重み付けに活用されているものとしては、あるコンセプトiに対する学習者の習熟度に基づく重み付けや、学習者の教材に対するannnotationに関する情報などが、単語の重み付けに活用されている。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Assessment.html">#Assessment</a>
<span class="issue_date">Issue Date: 2023-05-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/623">ChatBot Arena, lmsys org, 2023.05</a>
<span class="snippet"><span>Comment</span>クラウドソーシング型のチャットボット評価するシステム。ユーザはシステムにアクセスすると、二つのanonymisedされたLLMと対話し、どちらが優れていたかをvotingする。すべてのシステムとユーザのinteractionはロギングされており、最終的にElo RatingでLLM.をランキング付けする。Arena-Hardと呼ばれるliveアリーナデータを用いたパイプラインを公開。MT-Benchよりも識別力が高く、Chatbot Arenaのランキングとのagreementが高いとのこと。

<br>



<br>

参考:https://x.com/lmsysorg/status/1782179997622649330?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/2faafce4-effd-40b1-8760-d9639d3df6aa" alt="image" loading="lazy">過去のデータについては 876 などもある</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/SpokenLanguageProcessing.html">#SpokenLanguageProcessing</a>
<a class="button" href="articles/SpokenLanguageGeneration.html">#SpokenLanguageGeneration</a>
<span class="issue_date">Issue Date: 2023-05-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/620">Bark</a>
<span class="snippet"><span>Comment</span>テキストプロンプトで音声生成ができるモデル。MIT License</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<span class="issue_date">Issue Date: 2023-05-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/618">OpenLLaMA</a>
<span class="snippet"><span>Comment</span>LLaMAと同様の手法を似たデータセットに適用し商用利用可能なLLaMAを構築した模様</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-05-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/616">LLM ecosystem graphs</a>
<span class="snippet"><span>Comment</span>様々なfonudation model、それらを利用したアプリケーション、依存関係がまとまったページPercy Liangのグループが運用してるっぽい？</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Assessment.html">#Assessment</a>
<span class="issue_date">Issue Date: 2023-04-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/603">PandaLM</a>
<span class="snippet"><span>Comment</span>異なるLLMを再現性のある形で評価するためのライブラリ

<br>

2つの異なるLLMのoutputを比較し、どちらが優れているか理由付きで説明する。人間が作成して1000サンプルの多様なアノテーションデータセットを使い評価できる。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<span class="issue_date">Issue Date: 2023-04-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/599">Personalized Extractive Summarization for a News Dialogue System, Takatsu+, SLT, 2021, 4</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/ChatGPT.html">#ChatGPT</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-04-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/562">HuggingChat, 2023</a>
<span class="snippet"><span>Comment</span>closedな世界で開発されるOpenAIのChatGPTに対して、Openなものが必要ということで、huggingfaceが出してきた例のアレです</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<span class="issue_date">Issue Date: 2023-04-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/560">Unleashing Infinite-Length Input Capacity for Large-scale Language Models with Self-Controlled Memory System, 2023</a>
<span class="snippet"><span>Comment</span>&gt; Our findings indicate that our system outperforms ChatGPT in handling ultra-long inputs or conversations.

<br>



<br>



<br>



<br>

と書いてあるが、定量評価の結果が全く書いていない模様。全くもって信用できない。読む必要なし。4/27時点だと記述されていなかったと思うが、現時点では定量評価が追加されている模様？</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2023-04-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/557">大規模言語モデル間の性能比較まとめ</a>
<span class="snippet"><span>Comment</span>参考になる現状だと研究用であればllama, 商用利用ならtext-davinci-003あるいはFlanT5-xxlあたりになりそうLLM Worksheet：

<br>



<br>

https://docs.google.com/spreadsheets/d/1kT4or6b0Fedd-W_jMwYpb63e1ZR3aePczz3zlbJW-Y4/editgid=0</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/DataDistillation.html">#DataDistillation</a>
<span class="issue_date">Issue Date: 2023-04-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/548">LaMini-instruction</a>
<span class="snippet"><span>Summary</span>私たちは、大規模言語モデルからの知識を抽出するために、文/オフライン蒸留を行います。具体的には、いくつかの既存のプロンプトリソースに基づいて、合計258万ペアの指示と応答を生成します。詳細は論文を参照してください。</span>
<span class="snippet"><span>Comment</span>既存のInstruction DatasetのInstructionをseedとして、gpt-3.5-turboで新たなInstructionとresponseを生成したデータセット

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/23a85991-6af9-4663-a293-c22a6cdba9f0" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<span class="issue_date">Issue Date: 2023-04-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/528">LoRA論文解説, Hayato Tsukagoshi, 2023.04</a>
<span class="snippet"><span>Comment</span>ベースとなる事前学習モデルの一部の線形層の隣に、低ランク行列A,Bを導入し、A,Bのパラメータのみをfinetuningの対象とすることで、チューニングするパラメータ数を激減させた上で同等の予測性能を達成し、推論速度も変わらないようにするfinetuning手法の解説LoRAを使うと、でかすぎるモデルだと、そもそもGPUに載らない問題や、ファインチューニング後のモデルファイルでかすぎワロタ問題が回避できる。

<br>



<br>

前者は事前学習済みモデルのBPのための勾配を保存しておく必要がなくなるため学習時にメモリ節約になる。後者はA,Bのパラメータだけ保存すればいいので、ストレージの節約になる。

<br>



<br>

かつ、学習速度が25%程度早くなる。既存研究であるAdapter（transformerの中に学習可能なMLPを差し込む手法）は推論コストが増加し、prefix tuningは学習が非常に難しく、高い性能を達成するためにprefixとして128 token入れたりしなければならない。huggingfaceがすでにLoRAを実装している

<br>

https://github.com/huggingface/peft</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/SpokenLanguageProcessing.html">#SpokenLanguageProcessing</a>
<span class="issue_date">Issue Date: 2023-04-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/527">CLAP</a>
<span class="snippet"><span>Comment</span>テキストとオーディオの大量のペアを事前学習することで、テキストとオーディオ間を同じ空間に写像し、類似度を測れるようにしたモデルたとえばゼロショットでaudio分類ができる

<br>

<img src="https://user-images.githubusercontent.com/12249301/234293138-20edf6cd-3259-4547-a2fc-69893273fa76.jpeg" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2023-04-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/521">Llamaindex</a>
<span class="snippet"><span>Comment</span>・LlamaIndexのインデックスを更新し、更新前後で知識がアップデートされているか確認してみた

<br>



<br>

  ・https://dev.classmethod.jp/articles/llama-index-insert-index/</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2023-04-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/520">LangChain</a>
<span class="snippet"><span>Comment</span>・LangChain の Googleカスタム検索 連携を試す

<br>



<br>

  ・https://note.com/npaka/n/nd9a4a26a8932・LangChainのGetting StartedをGoogle Colaboratoryでやってみる ④Agents

<br>



<br>

    ・https://zenn.dev/kun432/scraps/8216511783e3da</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<span class="issue_date">Issue Date: 2023-04-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/516">User-centred versus system-centred evaluation of a personalization system, Diaz+, Information Processing &amp; management, 2008</a>
<span class="snippet"><span>Comment</span>Introduction

<br>



<br>

本研究では、web contentsのPersonalizationシステムにおいて、user-centered evaluationとsystem-centered evaluationの評価の問題を議論している。目的としては両者の評価を組み合わせることで、それぞれを個別に評価するよりも、よりinsightfulな見解を得ることができることを述べる。

<br>



<br>



<br>



<br>

・system-oriented evaluationの例: Text Retrieval Conference (TREC)：

<br>



<br>

  ・クエリごとに専門家がドキュメントコレクションの中から、どれだけ該当文書が合致しているかをラベル付する

<br>



<br>

  ・=&gt; ユーザごとの実際のrelevance judgmentを用いるのではなく、専門家によるラベルを用いて評価する

<br>



<br>

  ・=&gt; クエリに関連づけられた文書の適合性は、クエリが実行されたコンテキストに依存するため、専門家によるrelevance judgmentは現実に対する近似として捉えられる

<br>



<br>

  ・=&gt; ユーザの参加は必須ではない

<br>



<br>

・user centered evaluation

<br>



<br>

  ・ユーザの意見を収集し、ユーザのシステムに対する印象を手に入れようとするuser-orientedも実施されている

<br>



<br>

  ・qualitative, quantitative (recall and precision)の両方を収集することを目的としている場合があり、ユーザの参加が必須</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Education.html">#Education</a>
<a class="button" href="articles/AES(AutomatedEssayScoring).html">#AES(AutomatedEssayScoring)</a>
<span class="issue_date">Issue Date: 2023-04-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/515">Exploring the Potential of Using an AI Language Model for Automated Essay Scoring, Mizumoto+, Research Methods in Applied Linguistics‘23</a>
<span class="snippet"><span>Comment</span>著者によるポスト: https://twitter.com/mizumotoatsushi/status/1641754298496471040?s=46&t=TIr1-wDC_j5MPU3TvCVWMg著者によるブログ:

<br>



<br>

https://mizumot.com/lablog/archives/1805</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<span class="issue_date">Issue Date: 2023-03-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/514">Publicly available instruction-tuned models</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<span class="issue_date">Issue Date: 2023-03-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/510">20B params chatgpt alternative</a>
<span class="snippet"><span>Comment</span>元ツイート

<br>

Apache2.0で公開

<br>



<br>

https://twitter.com/_philschmid/status/1634492396171071488?s=46&t=VvPwEQsB--BeXx0YbYQdxQ</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/DataAugmentation.html">#DataAugmentation</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2023-01-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/505">nlpaug</a>
<span class="snippet"><span>Comment</span>Data Augmentationのためのオープンソースライブラリ</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Explanation.html">#Explanation</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2022-12-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/499">Transformers Interpret, 2022</a>
<span class="snippet"><span>Comment</span>transformersのモデルをたった2行追加するだけで、explainableにするライブラリ

<br>



<br>

基本的にtextとvisionのclassificationをサポートしている模様

<br>

text classificationの場合、たとえばinput tokenの各トークンの分類に対する寄与度をoutputしてくれる。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<span class="issue_date">Issue Date: 2022-09-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/485">Transformerの最前線 〜 畳込みニューラルネットワークの先へ 〜, 牛久先生, 2022</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<span class="issue_date">Issue Date: 2022-08-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/473">The Power of Scale for Parameter-Efficient Prompt Tuning, Lester+, Google Research, EMNLP‘21</a>
<span class="snippet"><span>Comment</span>日本語解説: https://qiita.com/kts_plea/items/79ffbef685d362a7b6ce

<br>



<br>

T5のような大規模言語モデルに対してfinetuningをかける際に、大規模言語モデルのパラメータは凍結し、promptをembeddingするパラメータを独立して学習する手法

<br>



<br>

言語モデルのパラメータ数が増加するにつれ、言語モデルそのものをfinetuningした場合（Model Tuning）と同等の性能を示した。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Legal.html">#Legal</a>
<span class="issue_date">Issue Date: 2021-10-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/416">自然言語系AIサービスと著作権侵害, 柿沼太一, 2021</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<span class="issue_date">Issue Date: 2021-09-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/404">GPT-3から我々は何を学べば良いのか, 山本和英, Japio year book 2020</a>
<span class="snippet"><span>Comment</span>GPT-3の概要:

<br>



<br>

GPT-3はWebサイトから数年に渡って収集したCommon Crawlというデータセットから、570GBを抜粋し学習に利用。（英語ウィキペディアの約130倍）

<br>

ある単語列に後続する単語を予測するという方法（自己回帰型言語モデル）で教師なし学習を繰り返し、言語モデルを学習。GPT-3の特徴:

<br>

・モデルが巨大（1750億パラメータ, GPT-2は15億）

<br>

　・扱うトークン数が2048トークン（GPT-2の倍）

<br>

　・Word Embeddingの次元数12288（GPT2の倍

<br>

　・デコード層が98層（GPT2の倍

<br>

・基本的なモデル構造はTransformerと一緒

<br>



<br>

GPT-3の問題点:

<br>

・コーパス中の言語出力を模倣しているだけで、何ら理解をしておらず、常識も持ち合わせていない

<br>

　・e.g. 私の足に目はいくつある？と入力すると、2つと出力する等

<br>

　・整理された知識を獲得しているわけではない

<br>

・偏見や差別、誤った知識も学習する

<br>

・時間的、経済的負荷の大きさ

<br>

　・GPT-3を最大規模で計算するには5億円かかる

<br>

　・1台のGPUで355年必要な計算量

<br>

　→ 個人や小規模業者が実行できる範囲を超えており、大企業でもコストに見合った出力が得られるとは考えにくいGPT-3の産業応用

<br>

・GPT-3は言語モデルであり、言語生成器ではない

<br>

　・人間が書いて欲しいことをおおまかに伝えたらそれを書いてくれるわけではない（代筆）

<br>

　→ GPT-3が小論文や業務レポートを書けると考えるのは早計

<br>

　・入力として英文や英単語を入力するが、生成する文章の分野や話題を提示しただけであり、生成する文章にそれ以上の制御は行っていない

<br>



<br>

・生成内容を強く制御できないことは創作活動にとっては有用

<br>

　・俳句、短歌、詩の生成

<br>

　・キャッチコピーの自動生成

<br>

　・ダミー文章生成（ブログやツイート）

<br>

　・文章添削、校正に使える可能性（要研究;文章を正しく、綺麗に書く能力は高い）GPT-3でどこまでできそうなのか？というざっくりとした肌感が掴めたから良かった</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<span class="issue_date">Issue Date: 2021-06-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/389">Pre-Trained Models: Past, Present and Future, Han+, AI Open‘21</a>
<span class="snippet"><span>Summary</span>大規模な事前学習モデル（PTMs）は、AI分野での成功を収め、知識を効果的に捉えることができる。特に、転移学習や自己教師あり学習との関係を考察し、PTMsの重要性を明らかにする。最新のブレークスルーは、計算能力の向上やデータの利用可能性により、アーキテクチャ設計や計算効率の向上に寄与している。未解決問題や研究方向についても議論し、PTMsの将来の研究の進展を期待する。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/python.html">#python</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<span class="issue_date">Issue Date: 2021-06-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/386">最先端自然言語処理ライブラリの最適な選択と有用な利用方法 _ pycon-jp-2020</a>
<span class="snippet"><span>Comment</span>各形態素解析ライブラリの特徴や比較がされていて、自分の用途・目的に合わせてどの形態素解析器が良いか意思決定する際に有用<img src="https://user-images.githubusercontent.com/12249301/121644722-56025800-cace-11eb-9fe9-9d2f6b0eae5a.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2021-06-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/384">FastSeq: Make Sequence Generation Faster, Yan+, ACL’21</a>
<span class="snippet"><span>Comment</span>BART, DistilBART, T5, GPT2等のさまざまなTransformer-basedな手法で、4-9倍Inference speedを向上させる手法を提案。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<span class="issue_date">Issue Date: 2021-06-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/382">A survey of Transformers, Lin+, AI Open‘22</a>
<span class="snippet"><span>Summary</span>トランスフォーマーの多様なバリアント（X-formers）に関する体系的な文献レビューを提供。バニラトランスフォーマーの紹介後、新しい分類法を提案し、アーキテクチャの修正、事前学習、アプリケーションの観点からX-formersを紹介。今後の研究の方向性も概説。</span>
<span class="snippet"><span>Comment</span>Transformersの様々な分野での亜種をまとめた論文<img src="https://user-images.githubusercontent.com/12249301/121394765-a40f4280-c98c-11eb-8fac-0114715ec738.png" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/NAACL.html">#NAACL</a>
<span class="issue_date">Issue Date: 2021-06-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/375">Probing Word Translations in the Transformer and Trading Decoder for Encoder Layers, NAACL‘21</a>
<span class="snippet"><span>Comment</span>Transformerに基づいたNMTにおいて、Encoderが入力を解釈し、Decoderが翻訳をしている、という通説を否定し、エンコーディング段階、さらにはinput embeddingの段階でそもそも翻訳が始まっていることを指摘。

<br>

エンコーディングの段階ですでに翻訳が始まっているのであれば、エンコーダの層を増やして、デコーダの層を減らせば、デコーディング速度を上げられる。

<br>

通常はエンコーダ、デコーダともに6層だが、10-2層にしたらBLEUスコアは変わらずデコーディングスピードは2.3倍になった。

<br>

18-4層の構成にしたら、BLEUスコアも1.42ポイント増加しデコーディング速度は1.4倍になった。この研究は個人的に非常に興味深く、既存の常識を疑い、分析によりそれを明らかにし、シンプルな改善で性能向上およびデコーディング速度も向上しており、とても好き。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2021-06-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/372">Incorporating Copying Mechanism in Sequence-to-Sequence Learning, Gu+, ACL’16</a>
<span class="snippet"><span>Comment</span>371 と同様コピーメカニズムを提案した論文。Joint Copy ModelやCOPYNETと呼ばれる。

<br>



<br>

次の単語が "生成" されるのか "コピー" されるのかをスコアリングし、各単語がコピーされる確率と生成される確率をMixtureした同時確率分布で表現する（ 207 等でも説明されている）。

<br>



<br>

コピーメカニズムを導入せるなら引用すべき。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/120571719-ad148700-c455-11eb-8e93-8d9be799aad5.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

コピーメカニズム部分の説明

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/120571852-efd65f00-c455-11eb-9063-872103738e2f.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/120571874-fa90f400-c455-11eb-885f-5b1a08d7d528.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/120572859-a6870f00-c457-11eb-9744-e1ff5ab5d253.png" alt="image" loading="lazy">

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/120572917-bd2d6600-c457-11eb-8c76-5bb48988a5f9.png" alt="image" loading="lazy">

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/120572936-c585a100-c457-11eb-822b-e70f0e857ac9.png" alt="image" loading="lazy">

<br>



<br>

解説資料: http://www.lr.pi.titech.ac.jp/~sasano/acl2016suzukake/slides/08.pdf</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2021-06-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/371">Pointing the Unknown Words, Gulcehre+, ACL’16</a>
<span class="snippet"><span>Comment</span>Conditional Copy Model （Pointer Softmax）を提案した論文。

<br>

単語を生成する際に、語彙内の単語から生成する分布、原文の単語から生成する分布を求める。後者はattention distributionから。コピーするか否かを決める確率変数を導入し（sigmoid）、両生成確率を重み付けする。

<br>

コピーメカニズム入れるなら引用すべき。解説スライド:https://www.slideshare.net/hytae/pointing-the-unknown-words</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/SentimentAnalysis.html">#SentimentAnalysis</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<span class="issue_date">Issue Date: 2021-06-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/365">Sentiment analysis with deeply learned distributed representations of variable length texts, Hong+, Technical Report. Technical report, Stanford University, 2015</a>
<span class="snippet"><span>Comment</span>363 より、本論文を引用して「CNN ベースのモデルが、畳み込み演算により文から特定のローカルパターンを検出して抽出できるため、他のモデル（e.g. Recurrent Neural Network, Recursive Neural Network）よりも優れていることが経験的に示されている」とのこと</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2021-05-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/345">GLUE - 英語圏における自然言語処理の標準ベンチマーク, npaka, 2020</a>
<span class="snippet"><span>Comment</span>各タスクごとにサンプルとその説明が付与されており、ぱっと見でどんなタスクかすぐ分かる</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<span class="issue_date">Issue Date: 2021-05-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/344">MLP-like Architecture</a>
<span class="snippet"><span>Comment</span>gMLP:大規模なself-attentionが無いSpatial Gating Unitを搭載したシンプルなMLPでも、Transformerの性能に近づけたよ（特にCV）。つまり、self-attentionはessentialというわけではなさそうだよ。

<br>



<br>

NLPの場合はgMLPだとTransformerとperplexityでcomparable、一部downstreamタスクだと勝てなかったけど、single headのtiny attentionを追加したら、TransformerをperplexityとGLUEの一部タスクでoutperformしたよ。

<br>

つまり、Transformerみたいに大規模なself-attentionは必須ではなく、小規模のattentionで（cross sentenceの関係性を捉えるには）十分だよ。

<br>

スケーラビリティもTransformerを上回ったよ。

<br>



<br>

って感じ？

<br>



<br>

んーTransformerに勝ったみたいな言い方をSNSだと見かけるけど、評価してるタスクが少ないし、どちらかというとcomparableなdownstreamタスクが多いし、それは言い過ぎでは？

<br>

この論文が言いたいのは、大規模なself-attentionが性能を出す上でessentialなわけではないよ、ってことであり、

<br>



<br>

・CVの場合はself-attentionは必須ではない

<br>

・NLPでは、tiny attentionでも十分

<br>



<br>

という感じなのでは。

<br>

まあでもTransformerとcomparableなら、Transformer一強では無くなったよねSpatial Gating Unit（SGU）は、トークン間の関係性を捉えるためのゲートで、SGUが無いとgMLPブロックはただの二層のFFNとなる。

<br>



<br>

SGUは、入力をspatial dimensionに対して線形変換した値と、元の入力のelement-wiseな積で表現する。この線形変換をする際は、Wの値を0の近傍で初期化し、バイアス項を1に初期化することがクリティカルだった。これは、学習の初めでは線形変換はidentical mappingに近いものとなるため、gMLPブロックはFFNに近いものとなる。これが学習が進むにつれWの重みが調整され、cross tokenの関係性を捉えたブロックへと徐々に変化していくことになる。

<br>

また、SGUへの入力はGLUのようにchannel dimensionに二分割し、片方をelement-wise積に、もう一方をspatialな線形変換に利用する（4種類試した中で一番性能が良かった）。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2020-03-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/334">BERT 日本語Pre-trained Model, NICT, 2020</a>
<span class="snippet"><span>Comment</span>NICTが公開。既に公開されているBERTモデルとのベンチマークデータでの性能比較も行なっており、その他の公開済みBERTモデルをoutperformしている。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<span class="issue_date">Issue Date: 2020-01-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/332">BERT入門, Ken'ichi Matsui, 2020</a>
<span class="snippet"><span>Comment</span>自然言語処理の王様「BERT」の論文を徹底解説

<br>



<br>

https://qiita.com/omiita/items/72998858efc19a368e50Transformer関連 245 あたりを先に読んでからが読むと良い

<br>



<br>



<br>



<br>

要は

<br>



<br>

・Transformerをたくさん積んだモデル

<br>



<br>

・NSPとMLMで双方向性を持った事前学習タスクを実施することで性能向上

<br>



<br>

・pooler layer（Transformer Encoderの次にくっつくlayer）を切り替えることで、様々なタスクにfine-tuning可能（i.e. pooler layerは転移学習の対象外）

<br>



<br>

・予測する際は、[CLS]トークンに対応する位置の出力を用いて分類問題や複数文間の関係性を問う問題を解いたり、各トークン位置に対応する出力を用いてQAの正解spanを予測したり、色々できる

<br>



<br>

・gMLP 344 あたりの研究が進んでくると使われなくなってくる可能性有こっちの記事もわかりやすい。

<br>



<br>



<br>



<br>

BERTについて勉強したことまとめ (2)モデル構造について

<br>



<br>

https://engineering.mobalab.net/2020/06/12/bert%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E5%8B%89%E5%BC%B7%E3%81%97%E3%81%9F%E3%81%93%E3%81%A8%E3%81%BE%E3%81%A8%E3%82%81-2%E3%83%A2%E3%83%87%E3%83%AB%E6%A7%8B%E9%80%A0%E3%81%AB%E3%81%A4%E3%81%84/</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2020-01-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/331">10 ML &amp; NLP Research Highlights of 2019, Sebastian Ruder, 2020</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<span class="issue_date">Issue Date: 2019-11-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/330">EMNLP 2019 spec tutorial</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/LanguageModel.html">#LanguageModel</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2019-11-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/329">事前学習言語モデルの動向 _ Survey of Pretrained Language Models, Kyosuke Nishida, 2019</a>
<span class="snippet"><span>Comment</span>[2019/06まで]

<br>



<br>

・ELMo（双方向2層LSTM言語モデル）

<br>



<br>

・GPT（left-to-rightの12層Transformer自己回帰言語モデル）

<br>



<br>

・BERT（24層のTransformer双方向言語モデル）

<br>



<br>

・MT-DNN（BERTの上にマルチタスク層を追加した研究）

<br>



<br>

・XLM（パラレル翻訳コーパスを用いてクロスリンガルに穴埋めを学習）

<br>



<br>

・TransformerXL（系列長いに制限のあった既存モデルにセグメントレベルの再帰を導入し長い系列を扱えるように）

<br>



<br>

・GPT-2（48層Transformerの自己回帰言語モデル）

<br>



<br>

・ERNIE 1.0（Baidu, エンティティとフレーズの外部知識を使ってマスクに利用）

<br>



<br>

・ERNIE（Tsinghua, 知識グラフの情報をfusionしたLM）

<br>



<br>

・Glover（ドメイン、日付、著者などを条件とした生成を可能としたGPT）

<br>



<br>

・MASS（Encoder-Decoder型の生成モデルのための事前学習）

<br>



<br>

・UniLM（Sequence-to-Sequenceを可能にした言語モデル）

<br>



<br>

・XLNet（自己回帰（単方向）モデルと双方向モデルの両方の利点を得ることを目指す）

<br>



<br>



<br>



<br>

[2019/07~]

<br>



<br>

・SpanBERT（i.i.dではなく範囲でマスクし、同時に範囲の境界も予測する）

<br>



<br>

・ERNIE 2.0（Baidu, マルチタスク事前学習; 単語レベル・構造レベル・意味レベル）

<br>



<br>

・RoBERTa（BERTと同じ構造で工夫を加えることで性能向上）

<br>



<br>

　・より大きなバッチサイズを使う（256から8192）

<br>



<br>

　・より多くのデータを使う（16GBから160GB）

<br>



<br>

　・より長いステップ数の学習をする（BERT換算で16倍）

<br>



<br>

　・次文予測（NSP）は不要

<br>



<br>

　→ GLUEでBERT, XLNetをoutperform

<br>



<br>

・StructBERT (ALICE, NSPに代わる学習の目的関数を工夫)

<br>



<br>

　・マスクした上で単語の順番をシャッフルし元に戻す

<br>



<br>

　・ランダム・正順・逆順の3種類を分類

<br>



<br>

　→ BERTと同サイズ、同データでBERT, RoBERTa超え

<br>



<br>

・DistilBERT（蒸留により、12層BERTを6層に小型化（40%減））

<br>



<br>

　・BERTの出力を教師として、生徒が同じ出力を出すように学習

<br>



<br>

　・幅（隠れ層）サイズを減らすと、層数を経あｒスよりも悪化

<br>



<br>

　→ 推論は60%高速化、精度は95%程度を保持

<br>



<br>

・Q8BERT（精度を落とさずにfine-tuning時にBERTを8bit整数に量子化）

<br>



<br>

　・Embedding, FCは8bit化、softmax, LNorm, GELUは32bitをキープ

<br>



<br>

　→ モデルサイズ1/4, 速度3.7倍

<br>



<br>

・CTRL（条件付き言語モデル）

<br>



<br>

　・条件となる制御テキストを本文の前に与えて学習

<br>



<br>

　・48層/1280次元Transformer（パラメータ数1.6B）

<br>



<br>

・MegatronLM（72層、隠れ状態サイズ3072、長さ1024; BERTの24倍サイズ）

<br>



<br>

・ALBERT（BERTの層のパラメータをすべて共有することで学習を高速化; 2020年あたりのデファクト）

<br>



<br>

　・Largeを超えたモデルは学習が難しいため、表現は落ちるが学習しやすくした

<br>



<br>

　・単語埋め込みを低次元にすることでパラメータ数削減

<br>



<br>

　・次文予測を、文の順序入れ替え判定に変更

<br>



<br>

　→ GLUE, RACE, SQuADでSoTAを更新

<br>



<br>

・T5（NLPタスクをすべてtext-to-textとして扱い、Enc-Dec Transformerを745GBコーパスで事前学習して転移する）

<br>



<br>

　・モデルはEncoder-DecoderのTransformer

<br>



<br>

　・学習タスクをエンコーダ・デコーダに合わせて変更

<br>



<br>

　・エンコーダ側で範囲を欠落させて、デコーダ側で予測

<br>



<br>

　→ GLUE, SuperGLUE, SQuAD1.1, CNN/DMでSoTA更新

<br>



<br>

・BART（Seq2Seqの事前学習として、トークンマスク・削除、範囲マスク、文の入れ替え、文書の回転の複数タスクで学習）

<br>



<br>

　→ CNN/DMでT5超え、WMT'16 RO-ENで逆翻訳を超えてSoTAELMo, GPT, BERT, GPT-2, XLNet, RoBERTa, DistilBERT, ALBERT, T5あたりは良く見るような感各データセットでの各モデルの性能も後半に記載されており興味深い。

<br>



<br>



<br>



<br>

ちなみに、CNN/DailyMail Datasetでは、T5, BARTあたりがSoTA。

<br>



<br>

R2で比較すると

<br>



<br>

　・Pointer-Generator + Coverage Vectorが17,28

<br>



<br>

　・LEAD-3が17.62

<br>



<br>

　・BARTが21.28

<br>



<br>

　・T5が21.55

<br>



<br>

となっている</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/CommentGeneration.html">#CommentGeneration</a>
<span class="issue_date">Issue Date: 2019-09-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/326">Cross-domain personalized image captioning, Long+, 2019</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/Library.html">#Library</a>
<span class="issue_date">Issue Date: 2019-09-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/325">【黒橋研】BERT日本語Pretrainedモデル</a>
<span class="snippet"><span>Comment</span>【huggingface transformersで使える日本語モデルのまとめ】

<br>



<br>

https://tech.yellowback.net/posts/transformers-japanese-models</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<span class="issue_date">Issue Date: 2018-11-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/280">AllenNLP</a>
<span class="snippet"><span>Comment</span>https://docs.google.com/presentation/d/17NoJY2SnC2UMbVegaRCWA7Oca7UCZ3vHnMqBV4SUayc/preview?slide=id.g43b8d8e880_0_8 </span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<span class="issue_date">Issue Date: 2018-06-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/274">Pytorchによるtransformer実装チュートリアル</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<span class="issue_date">Issue Date: 2018-02-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/263">ニューラルネット勉強会（LSTM編）, Seitaro Shinagawa, 2016</a>
<span class="snippet"><span>Comment</span>LSTMの基礎から、実装する上でのTipsがまとまっている。

<br>



<br>

zero padding, dropoutのかけかた、normalizationの手法など。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/Extractive.html">#Extractive</a>
<span class="issue_date">Issue Date: 2018-01-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/240"> Machine-made index for technical literature: an experiment, IBM Journal of Research and Development, 1958.</a>
<span class="snippet"><span>Comment</span>初期の要約研究。Luhnらの研究よりはcitation countが少ない。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<span class="issue_date">Issue Date: 2018-01-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/236">ALAGIN 機械翻訳セミナー 単語アライメント, Graham Neubig</a>
<span class="snippet"><span>Comment</span>Neubigさんによる単語アライメントチュートリアル</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2018-01-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/235">自然言語処理のためのDeep Learning, Yuta Kikuchi</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/SentimentAnalysis.html">#SentimentAnalysis</a>
<a class="button" href="articles/OpinionMining.html">#OpinionMining</a>
<span class="issue_date">Issue Date: 2018-01-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/231">Opinion mining and sentiment analysis, Pang+, Foundations and Trends in Information Retrieval, 2008</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/SIGIR.html">#SIGIR</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2018-01-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/220">The Decomposition of Human-Written Summary Sentences. Hongyan Jing et al. SIGIR’99.</a>
<span class="snippet"><span>Comment</span>参照要約 ・原文書対が与えられた時に、参照要約中の単語と原文書中の単語のアライメントをとるHMMベースな手法を提案。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34812500-2d1d7d32-f6e9-11e7-8d9d-723804236081.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

outputはこんな感じ。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/SIGIR.html">#SIGIR</a>
<span class="issue_date">Issue Date: 2018-01-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/219">The automatic construction of large-scale corpora for summarization research. Daniel Marcu. SIGIR’99</a>
<span class="snippet"><span>Comment</span>&lt;Abstract, Text&gt;のタプルが与えられた時に、&lt;Abstract, Extract, Text&gt;のタプルを自動的に生成。ExtractはAbstractと対応するText中の重要部（節やsentence）。

<br>



<br>



<br>



<br>

&lt;Abstract, Extract, Text&gt;に含まれるExtractの情報を使えば、Extractiveな要約器の学習などに活用できる。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Multi.html">#Multi</a>
<a class="button" href="articles/Single.html">#Single</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/Unsupervised.html">#Unsupervised</a>
<a class="button" href="articles/GraphBased.html">#GraphBased</a>
<a class="button" href="articles/Extractive.html">#Extractive</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2018-01-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/215">LexRank: Graph-based Lexical Centrality as Salience in Text Summarization, Erkan+, Journal of Artificial Intelligence Research, 2004</a>
<span class="snippet"><span>Comment</span>代表的なグラフベースな(Multi) Document Summarization手法。

<br>



<br>

ほぼ 214 と同じ手法。

<br>



<br>



<br>



<br>

2種類の手法が提案されている：

<br>



<br>



<br>



<br>

 [LexRank] tf-idfスコアでsentenceのbag-of-wordsベクトルを作り、cosine similarityを計算し閾値以上となったsentenceの間にのみedgeを張る（重みは確率的に正規化）。その後べき乗法でPageRank。

<br>



<br>

 [ContinousLexRank] tf-idfスコアでsentenceのbag-of-wordsベクトルを作り、cosine similarityを用いてAffinity Graphを計算し、PageRankを適用（べき乗法）。

<br>



<br>



<br>



<br>

DUC2003, 2004（MDS）で評価。

<br>



<br>

Centroidベースドな手法をROUGE-1の観点でoutperform。

<br>



<br>

document clusterの17%をNoisyなデータにした場合も実験しており、Noisyなデータを追加した場合も性能劣化が少ないことも示している。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/Classic.html">#Classic</a>
<span class="issue_date">Issue Date: 2018-01-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/213">The automatic creation of literature abstracts, Luhn, IBM Journal of Research Development, 1958</a>
<span class="snippet"><span>Comment</span>文書要約研究初期の研究</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/StructuredLearning.html">#StructuredLearning</a>
<a class="button" href="articles/DomainAdaptation.html">#DomainAdaptation</a>
<a class="button" href="articles/Supervised.html">#Supervised</a>
<a class="button" href="articles/Extractive.html">#Extractive</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/141">転移学習による抽出型要約の精度向上, 西川+, 情報処理学会研究報告, 2011</a>
<span class="snippet"><span>Comment</span>構造学習を利用した文書要約モデル

<br>



<br>

126 なども利用し転移学習を行なっている。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Supervised.html">#Supervised</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/139">Text Summarization using a trainable summarizer and latent semantic analysis, Yeh+, Information Processing and Management 2005</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/129">A survey on Automatic Text Summarization, Das+, CMUの教材？</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Others.html">#Others</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/110">Automatically generated linguistic summaries of energy consumption data, van der Heide+, In Proceedings of the Ninth International Conference on Intelligent Systems Design and Applications, pages 553-559, 2009</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Others.html">#Others</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/109">A framework for automatic text generation of trends in physiological time series data, Banaee+, In Proceedings of the IEEE International Conference on Systems, Man, and Cybernetics, 2013</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/SingleFramework.html">#SingleFramework</a>
<a class="button" href="articles/ConceptToTextGeneration.html">#ConceptToTextGeneration</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/98">A Global Model for Concept-to-Text Generation, Konstas+, Journal of Artificial Intelligence Research, Vol. 48, pp.305--346, 2013</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/NAACL.html">#NAACL</a>
<span class="issue_date">Issue Date: 2017-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/88">What to talk about and how? Selective Generation using LSTMs with Coarse-to-Fine Alignment, Mei+, NAACL-HLT’16</a>
<span class="snippet"><span>Comment</span>content-selectionとsurface realizationをencoder-decoder alignerを用いて同時に解いたという話。

<br>



<br>

普通のAttention basedなモデルにRefinerとPre-Selectorと呼ばれる機構を追加。通常のattentionにはattentionをかける際のaccuracyに問題があるが、data2textではきちんと参照すべきレコードを参照し生成するのが大事なので、RefinerとPre-Selectorでそれを改善する。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34460874-1b5830a2-ee5f-11e7-9220-c67a806225d8.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Pre-selectorは、それぞれのレコードが選択される確率を推定する（通常のattentionはalignmentの尤度を計算するのみ）。

<br>



<br>

Refinerはaligner(attention)のweightをreweightingすることで、最終的にどのレコードを選択するか決定する。

<br>



<br>

加えて、ロス関数のRegularizationのかけかたを変え、最低一つのレコードがpreselectorに選ばれるようにバイアスをかけている。

<br>



<br>



<br>



<br>

ほぼ初期のNeural Network basedなData2Text研究</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/77">Teaching Machines to Read and Comprehend, Hermann+, NIPS 2015</a>
<span class="snippet"><span>Comment</span>だいぶ前に読んだので割とうろおぼえ。

<br>



<br>



<br>



<br>

CNN/DailyMailデータセットの作成を行なった論文（最近Neuralな文”書”要約の学習でよく使われるやつ）。

<br>



<br>

CNN/DailyMailにはニュース記事に対して、人手で作成した要約が付与されており、要約中のEntityを穴埋めにするなどして、穴埋め問題を作成。

<br>



<br>

言文書をNeuralなモデルに与えて、どれだけ回答できるかという話。

<br>



<br>



<br>



<br>

[スタンフォードによる追試がある](https://cs.stanford.edu/people/danqi/papers/acl2016.pdf)

<br>



<br>

[詳しい解説 by 久保さん](https://www.slideshare.net/takahirokubo7792/machine-comprehension)

<br>



<br>



<br>



<br>

追試によると、評価で使用している穴埋め問題は単純なモデルで提案モデルの性能を上回ったりしている。また、この穴埋め問題のうち54%は単純な質問とのマッチで回答可能であり、25%は人でも正解不能らしい（正解率のupper boundは75%）。by 久保さんのスライド

<br>



<br>

のちの研究で、ほぼこの上限に達する精度が達成されてしまったので、このデータセットはQAタスクではほぼ攻略された状態だという。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Snippets.html">#Snippets</a>
<a class="button" href="articles/SIGIR.html">#SIGIR</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/56">Web page summarization using clickthrough data, Sun et al., SIGIR’05,  2005</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Snippets.html">#Snippets</a>
<a class="button" href="articles/QueryBiased.html">#QueryBiased</a>
<a class="button" href="articles/CIKM.html">#CIKM</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/55">Learning query-biased web page summarization, Wang et al., CIKM’07, 2007</a>
<span class="snippet"><span>Comment</span>・従来のquery-biasedな要約におけるclassificationアプローチは，training内のdocumentの情報が未知のdocumentのsentenceのclassificationに役立つというものだった．これは，たとえば似たような情報を多く含むscientific articleだったら有用だが，様々な情報を含むweb pageにはあまり適切ではない（これはtraining set内のdocumentの情報とtarget pageの情報を比較するみたいなアプローチに相当する）．この研究では，target page内の’sentenceの中で’はスニペットに含めるべき文かどうかという比較ができるという仮定のもと，learning to rankを用いてスニペットを生成する．

<br>



<br>

・query biased summarizationではrelevanceとfidelityの両者が担保された要約が良いとされている．

<br>



<br>

relevanceとはクエリと要約の適合性，fidelityとは，要約とtarget documentとの対応の良さである．

<br>



<br>

・素性は，relevanceに関してはクエリとの関連度，fidelityに関しては，target page内のsentenceに関しては文の位置や，文の書式（太字）などの情報を使う．contextの文ではそういった情報が使えないので，タイトルやanchor textのフレーズを用いてfidelityを担保する（詳しくかいてない）．あとはterm occurence，titleとextracted title(先行研究によると，TRECデータの33.5%のタイトルが偽物だったというものがあるのでextracted titleも用いる)，anchor textの情報を使う．あまり深く読んでいない．

<br>



<br>

・全ての素性を組み合わせたほうがintrinsicなevaluationにおいて高い評価値．また，contextとcontent両方組み合わせたほうが良い結果がでた．</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Snippets.html">#Snippets</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/54">Enhanced web document summarization using hyperlinks, Delort et al., HT’03, 2003</a>
<span class="snippet"><span>Comment</span>・Genericなweb pageの要約をつくる

<br>



<br>

・要約を作る際に，ページの内容から作るわけではなく，contextを用いて作る．contextとは，target pageにリンクを張っているページにおけるリンクの周辺にある文のこと．

<br>



<br>

・contextを利用した要約では，partialityとtopicalityに関する問題が生じる．partialityとは，contextに含まれる情報がtarget pageに関する一部の情報しか含んでいない問題．topicalityとは，そもそもcontextに含まれる情報が，target pageのoverviewに関する情報を含んでいない問題

<br>



<br>

・partialityに関しては，contextに含まれる文を除くことで，contextのoverallな情報が失われない最小のsetを求めることで対応．setを求める際には，context内の2文の単語を比較し，identicalなrepresentationが含まれているかどうかを計算．重複するものは排除することでsetを求める．

<br>



<br>

・topicalityに関しては，target pageのtextual informationが取得できる場合は，context内の文中の単語がtarget page内に含まれる単語の比率を出すことでtopicality scoreを算出．topicality scoreが高いものを要約とする．一方，target pageのtextual informationが十分でない場合は，context内の文のクラスタリングを行い，各クラスタのcentroidと近い文を抽出．</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Snippets.html">#Snippets</a>
<a class="button" href="articles/QueryBiased.html">#QueryBiased</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/53">A task-oriented study on the influencing effects of query-biased summarization in web searching, White et al., Information Processing and Management, 2003</a>
<span class="snippet"><span>Comment</span>・search engineにおいてquery-biasedな要約の有用性を示したもの

<br>



<br>

・task-orientedな評価によって，提案手法がGoogleやAltaVistaのスニペットよりも良いことを示す．

<br>



<br>

・提案手法は文選択によるquery-biased summarization．スコアリングには，ページのタイトルに含まれる単語がどれだけ含まれているか，文のページ内での出現位置，クエリとの関連度，文の書式（太字）などの情報を使う．

<br>



<br>

・スニペットが作れないページに対しては，エラーメッセージを返したり，ページ内の最初のnon-textualな要素を返したりする．</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Temporal.html">#Temporal</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/49">HLTCOE at TREC 2013: Temporal Summarization, Xu et al, [TREC 2013]</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Temporal.html">#Temporal</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/48">BJUT at TREC 2013 Temporal Summarization Track, yang et al. [TREC2013]</a>
<span class="snippet"><span>Comment</span>・次のモジュールにより構成される。Preprocess, Retrieval, Information expansion, Sentence choosing and ranking

<br>



<br>



<br>



<br>

・Preprocess: GPGファイルをTXTファイルに変換。indexをはる。

<br>



<br>

・Retrieval: 検索エンジンとしてLemur searchを使っている。クエリ拡張と単語の重み付けができるため。（DocumentをRetrievalする）

<br>



<br>

・Information Expansion: 検索結果を拡張するためにK-meansを用いる。

<br>



<br>

・Sentence choosing and ranking: クラスタリング後に異なるクラスタの中心から要約を構築する。

<br>



<br>

 time factorとsimilarity factorによってsentenceがランク付けされる。（詳細なし）

<br>



<br>

・Retrievalにおいては主にTF-IDFとBM25を用いている。

<br>



<br>

・traditionalなretrieval methodだけではperform wellではないので、Information Expansionをする。k-meansをすることで、異なるイベントのトピックに基づいてクラスタを得ることができる。クラスタごとの中心のドキュメントのtop sentencesをとってきて、要約とする。最終的にイベントごとに50 sentencesを選択する。

<br>



<br>

・生成したSequential Update Summarizationからvalueを抜いてきて、Value Trackingをする。

<br>



<br>



<br>



<br>

・Updateの部分をどのように実装しているのか？</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Update.html">#Update</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/40">DUC 2007, Update Summarization Dataset</a>
<span class="snippet"><span>Comment</span>DUC 2007:https://duc.nist.gov/duc2007/tasks.html</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Update.html">#Update</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/39">Update Summary Update, Copeck et al., [TAC’08]</a>
<span class="snippet"><span>Comment</span>被引用数は少ないが、良い論文からreferされているイメージ</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Update.html">#Update</a>
<a class="button" href="articles/EACL.html">#EACL</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/38">DualSum: a Topic-Model based approach for update summarization, Delort et al., [EACL’12]</a>
<span class="snippet"><span>Comment</span>・大半のupdate summarizationの手法はdocument set Aがgivenのとき，document set Bのupdate summarizationをつくる際には，redundancy removalの問題として扱っている．

<br>



<br>

・この手法は，1つのsentenceの中にredundantな情報とnovelな情報が混在しているときに，そのsentenceをredundantなsentenceだと判別してしまう問題点がある．加えて，novel informationを含んでいると判別はするけれども，明示的にnovel informationがなんなのかということをモデル化していない．

<br>



<br>

・Bayesian Modelを使うことによって，他の手法では抜け落ちている確率的な取り扱いが可能にし, unsupervisedでできるようにする．</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Update.html">#Update</a>
<a class="button" href="articles/CIKM.html">#CIKM</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/37">Document Update Summarization Using Incremental Hierarchical Clustering, Wang et al.,　[CIKM’10]</a>
<span class="snippet"><span>Comment</span>・既存のMDSではdocumentをbatch処理するのが前提．typicalなクラスタリングベースの手法やグラフベースの手法はsentence-graphを構築して要約を行う．しかし，情報がsequentialに届き，realtimeで要約を行いたいときにこのような手法を使うと，毎回すでに処理したことがあるテキストを処理することになり，time consumingだし，無駄な処理が多い．特に災害時などでは致命的．このような問題に対処するために，ドキュメントがarriveしたときに，ただちにupdate summaryが生成できる手法を提案する．

<br>



<br>

・既存のヒューリスティックなfeature（tf-isfやキーワード数など）を用いたスコアリングは，existing sentencesとnewly coming sentencesが独立しているため，real world scenarioにおいて実用的でないし，hardly perform wellである．

<br>



<br>

・なので，incremental hierarchical clusteringの手法でsentence clusterをre-organizeすることで，効果的に要約のupdateを行う．このとき，sentence同士のhierarchical relationshipはreal timeにre-constructされる．

<br>



<br>

・TACのupdate summarizationとは定義が微妙に違うらしい．主に２点．TACではnewly coming documentsだけを対象にしているが，この研究　ではすべてのドキュメントを対象にする．さらに，TACでは一度だけupdate summarizationする（document set Bのみ）が，この研究ではdocumentsがsequenceでarriveするのを前提にする．なので，TACに対しても提案手法は適用可能．

<br>



<br>

・Sequence Update Summarizationの先駆け的な研究かもしれない．SUSがのshared taskになったのは2013だし．

<br>



<br>

・incremental hierarchical clusteringにはCOBWEB algorithm (かなりpopularらしい)を使う．COBWEBアルゴリズムは，新たなelementが現れたとき，Category Utilityと呼ばれるcriterionを最大化するように，4種類の操作のうち１つの操作を実行する（insert(クラスタにsentenceを挿入), create（新たなクラスタつくる）, merge(2クラスタを１つに)，split(existingクラスタを複数のクラスタに)）．ただ，もとのCOBWEBで使われているnormal attribute distributionはtext dataにふさわしくないので，Katz distributionをword occurrence distributionとして使う（Sahooらが提案している．）．元論文読まないと詳細は不明．

<br>



<br>

・要約の生成は，実施したoperationごとに異なる．

<br>



<br>



<br>



<br>

・Insertの場合: クラスタを代表するsentenceをクエリとのsimilarity, クラスタ内のsentenceとのintra similarityを計算して決めて出力する．

<br>



<br>

・createの場合: 新たに生成したクラスタcluster_kを代表する文を，追加したsentence s_newとする．

<br>



<br>

・mergeの場合: cluster_aとcluster_bをmergeして新たなcluster_cを作った場合，cluster_cを代表する文を決める．cluster_cを代表する文は，cluster_aとcluster_bを代表する文とクエリとのsimilarityをはかり，similarityが大きいものとする．

<br>



<br>

・splitの場合: cluster_aをsplitしてn個の新たなクラスタができたとき，各新たなn個のクラスタにおいて代表する文を，original subtreeの根とする．

<br>



<br>



<br>



<br>

・TAC08のデータとHurricane Wilma Releasesのデータ（disaster systemからtop 10 queryを取得，5人のアノテータに正解を作ってもらう）を使って評価．（要約の長さを揃えているのかが気になる。長さが揃っていないからROUGEのF値で比較している？）

<br>



<br>

・一応ROUGEのF値も高いし，速度もbaselineと比べて早い．かなりはやい．genericなMDSとTAC participantsと比較．TAC Bestと同等．GenericMDSより良い．document setAの情報を使ってredundancy removalをしていないのにTAC Bestを少しだけoutperform．おもしろい．

<br>



<br>

・かつ，TAC bestはsentence combinationを繰り返す手法らしく，large-scale online dataには適していないと言及．</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Update.html">#Update</a>
<a class="button" href="articles/CIKM.html">#CIKM</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/36">Incremental Update Summarization: Adaptive Sentence Selection based on Prevalence and Novelty, McCreadie et al., CIKM’14</a>
<span class="snippet"><span>Comment</span>・timelyなeventに対してupdate summarizationを適用する場合を考える．たとえば6日間続いたeventがあったときにその情報をユーザが追う為に何度もupdate summarizationシステムを用いる状況を考える．6日間のうち新しい情報が何も出てこない期間はirrelevantでredundantな内容を含む要約が出てきてしまう．これをなんとかする手法が必要だというのがmotivation．

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34404205-dac93b7e-ebef-11e7-9ca1-603e2461b9eb.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

・どのような手法かというと，news streamsからnovel updatesをtimely mannerで自動抽出し，一方で，抽出するupdatesはirrelevant, uninformative or redundant contentを最小化するようなもの手法

<br>



<br>

・手法は既存のUpdate Summarization手法(lambdaMART, learning to rank baseの手法)で10文を出力し，何文目までを残すか（rank-cut off problem）を解くことで，いらないsentenceをはぶいている．

<br>



<br>

・rank cut offをする際はlinear regressionとModel Treesを使っているが，linear regressionのような単純な手法だと精度があがらず，Model Treesを使ったほうがいい結果が出た．

<br>



<br>

・素性は主にprevalence (sentenceが要約したいトピックに沿っているか否か)，novelty（sentenceが新しい情報を含んでいるか），quality(sentenceがそもそも重要かどうか)の３種類の素性を使っている．気持ちとしては，prevalenceとnoveltyの両方が高いsentenceだけを残したいイメージ．つまり，トピックに沿っていて，なおかつ新しい情報を含んでいるsentence

<br>



<br>

・loss functionには，F値のような働きをするものを採用（とってきたrelevant updateのprecisionとrecallをはかっているイメージ）．具体的には，Expected Latency GainとLatency Comprehensivenessと呼ばれるTREC2013のquality measureに使われている指標を使っている．

<br>



<br>

・ablation testの結果を見ると，qualityに関する素性が最もきいている．次にnovelty，次点でprevalence

<br>



<br>

・提案手法はevent発生から時間が経過すると精度が落ちていく場合がある．

<br>



<br>

・classicalなupdate summarizationの手法と比較しているが，Classyがかなり強い，Model treesを使わない提案手法や，他のbaselineを大きくoutperform. ただ，classyはmodel treesを使ったAdaptive IUSには勝てていない．

<br>



<br>

・TREC 2013には，Sequantial Update Summarizationタスクなるものがあるらしい．ユーザのクエリQと10個のlong-runnning event（典型的には10日間続くもの，各イベントごとに800〜900万記事），正解のnuggetsとそのtimestampが与えられたときにupdate summarizationを行うタスクらしい．</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Update.html">#Update</a>
<a class="button" href="articles/CIKM.html">#CIKM</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/35">Update Summarization using Semi-Supervised Learning Based on Hellinger Distance, Wang et al., CIKM’15, 2015.10</a>
<span class="snippet"><span>Comment</span>・Hellinger Distanceを用いてSentence Graphを構築．ラベル伝搬により要約に含める文を決定する手法

<br>



<br>

・update summarizationの研究ではsimilarityをはかるときにcosine similarityを用いることが多い．

<br>



<br>

・cosine similarityはユークリッド距離から直接的に導くことができる．

<br>



<br>

・Vector Space Modelはnonnegativeなmatrixを扱うので，確率的なアプローチで取り扱いたいが，ユークリッド距離は確率を扱うときにあまり良いmetricではない．そこでsqrt-cos similarityを提案する．sqrt-cosは，Hellinger Distanceから求めることができ，Hellinger Distanceは対称的で三角不等式を満たすなど，IRにおいて良いdistance measureの性質を持っている．（Hellinger Distanceを活用するために結果的に類似度の尺度としてsqrt-cosが出てきたとみなせる）

<br>



<br>

・またHellinger DistanceはKL Divergenceのsymmetric middle pointとみなすことができ，文書ベクトル生成においてはtf_idfとbinary weightingのちょうど中間のような重み付けを与えているとみなせる．

<br>



<br>

・要約を生成する際は，まずはset Aの文書群に対してMMR 243 を適用する（redundancyの項がmaxではなくて平均になっている）．similarityはsqrt-cosを用いる．

<br>



<br>

・sqrt-cosと，set Aの要約結果を用いると，sentence graphを構築できる．sentence graphはset Aとset Bの各sentenceをノードとするグラフで，エッジの重みはsqrt-cosとなっている．このsentence graph上でset Aの要約結果のラベルをset B側のノードに伝搬させることで，要約に含めるべき文を選択する．

<br>



<br>

・ラベル伝搬にはGreen’s functionを用いる．set Bにlabel “1”がふられるものは，given topicとset Aのcontentsにrelevantなsentenceとなる．

<br>



<br>

・TAC2011のデータで評価した結果，standardなMMRを大幅にoutperform, co-ranking, Centroidベースの手法などよりも良い結果．</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Update.html">#Update</a>
<a class="button" href="articles/SIGIR.html">#SIGIR</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/34">TimedTextRank: Adding the Temporal Dimension to Multi-Document Summarization, Xiaojun Wan, SIGIR’07, 2007.07</a>
<span class="snippet"><span>Comment</span>・evolving topicsを要約するときは，基本的に新しい情報が重要だが，TextRankはそれが考慮できないので拡張したという話．

<br>



<br>

・dynamic document setのnew informationをより重視するTimedTextRankを提案

<br>



<br>

・TextRankのvoteの部分に重み付けをする．old sentenceからのvoteよりも，new documentsに含まれるsentenceからのvoteをより重要視

<br>



<br>

・評価のときは，news pageをクローリングし，incremental single-pass clustering algorithmでホットなトピックを抽出しユーザにみせて評価（ただしこれはPreliminary Evaluation）．</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Update.html">#Update</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/33">The LIA Update Summarization Systems at TAC-2008, Boudin et al. TAC’08, 2008.11</a>
<span class="snippet"><span>Comment</span>・Scalable MMR 32 とVariable length intersection gap n-term modelを組み合わせる．

<br>



<br>

・Variable length intersection gap n-term modelは，あるトピックのterm sequenceは他の異なる語と一緒にでてくる？という直感にもとづく．要は，drugs.treat.mental.illnessなどのパターンをとってきて活用する．このようなパターンをn-gram, n-stem, n-lemmaごとにつくり3種類のモデルを構築．この3種類のモデルに加え，coverage rate (topic vocabularyがセグメント内で一度でもみつかる割合)とsegmentのpositionの逆数を組みあわせて，sentenceのスコアを計算（先頭に近いほうが重要）．

<br>



<br>

・coherenceを担保するために，sentenceを抽出した後，以下のpost-processingを行う．

<br>



<br>



<br>



<br>

Acronym rewriting（初めてでてくるNATOなどの頭字語はfull nameにする）

<br>



<br>

Date and number rewriting（US standard formsにする）

<br>



<br>

Temporal references rewriting (next yearなどの曖昧なreferenceを1993などの具体的なものにする)

<br>



<br>

Discursive form rewriting (いきなりButがでてくるときとかは削るなど)

<br>



<br>

カッコやカギカッコは除き，句読点をcleanedする

<br>



<br>



<br>



<br>

・TAC 2008におけるROUGE-2の順位は72チーム中32位</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Update.html">#Update</a>
<a class="button" href="articles/COLING.html">#COLING</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/32">A Scalable MMR Approach to Sentence Scoring for Multi-Document Update Summarization, Boudin et al., COLING’08, 2008.08</a>
<span class="snippet"><span>Comment</span>・MMR 243 をupdate summarization用に拡張．History（ユーザが過去に読んだsentence）の数が多ければ多いほどnon-redundantな要約を出す （Queryに対するRelevanceよりもnon-redundantを重視する）

<br>



<br>

・Historyの大きさによって，redundancyの項の重みを変化させる．

<br>



<br>

・MMRのredundancyの項を1-max Sim2(s, s_history)にすることでnoveltyに変更．ORよりANDの方が直感的なので二項の積にする．

<br>



<br>

・MMRのQueryとのRelevanceをはかる項のSimilarityは，cossimとJaro-Winkler距離のinterpolationで決定. Jaro-Winkler距離とは，文字列の一致をはかる距離で，値が大きいほど近い文字列となる．文字ごとの一致だけでなく，ある文字を入れ替えたときにマッチ可能かどうかも見る．一致をはかるときはウィンドウを決めてはかるらしい．スペルミスなどの検出に有用．クエリ内の単語とselected sentences内の文字列のJaro-Winkler距離を計算．各クエリごとにこれらを求めクエリごとの最大値の平均をとる．

<br>



<br>

・冗長性をはかるSim2では，normalized longest common substringを使う．</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/IntegerLinearProgramming%20(ILP).html">#IntegerLinearProgramming (ILP)</a>
<a class="button" href="articles/Update.html">#Update</a>
<a class="button" href="articles/NAACL.html">#NAACL</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/31">Improving Update Summarization via Supervised ILP and Sentence Reranking, Li et al. NAACL’15, 2015.05</a>
<span class="snippet"><span>Comment</span>・update summarizationをILPで定式化．基本的なMDSのILPのterm weightingにsalienceの要素に加えてnoveltyの要素を加える．term weightingにはbigramを用いる．bigram使うとよくなることがupdate summarizationだと知られている．weightingは平均化パーセプトロンで学習

<br>



<br>

・ILPでcandidate sentencesを求めたあと，それらをSVRを用いてRerankingする．SVRのloss functionはROUGE-2を使う．

<br>



<br>

・Rerankingで使うfeatureはterm weightingした時のsentenceレベルのfeatureを使う．

<br>



<br>

・RerankingをするとROUGE-2スコアが改善する．2010, 2011のTAC Bestと同等，あるいはそれを上回る結果．novelty featureを入れると改善．

<br>



<br>

・noveltyのfeatureは，以下の通り．

<br>



<br>



<br>



<br>

Bigram Level

<br>



<br>

　-bigramのold datasetにおけるDF

<br>



<br>

　-bigram novelty value (new datasetのbigramのDFをold datasetのDFとDFの最大値の和で割ったもの)

<br>



<br>

　-bigram uniqueness value (old dataset内で出たbigramは0, すでなければ，new dataset内のDFをDFの最大値で割ったもの)

<br>



<br>

Sentence Level

<br>



<br>

　-old datasetのsummaryとのsentence similarity　interpolated n-gram novelty (n-gramのnovelty valueをinterpolateしたもの)

<br>



<br>

　-interpolated n-gram uniqueness (n-gramのuniqueness valueをinterpolateしたもの)

<br>



<br>



<br>



<br>

・TAC 2011の評価の値をみると，Wanらの手法よりかなり高いROUGE-2スコアを得ている．</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Update.html">#Update</a>
<a class="button" href="articles/COLING.html">#COLING</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/30">Update Summarization Based on Co-Ranking with Constraints, Wiaojun Wan, COLING’12, 2012.12</a>
<span class="snippet"><span>Comment</span>・PageRankの枠組みを拡張してold datasetとnew dataset内のsentenceをco-ranking

<br>



<br>

・co-rankingするときは，update scoreとconsistency scoreというものを求め相互作用させる．

<br>



<br>

・update scoreが高いsentenceは同じdataset内では正の関係，異なるdataset内では負の関係を持つ．

<br>



<br>

・consistency scoreが高いsentenceは同じdataset内では正の関係，異なるdataset内では正の関係を持つ．

<br>



<br>

・負の関係はdissimilarity matrixを用いて表現する．

<br>



<br>

・あとはupdate scoreとconsistency scoreを相互作用させながらPageRankでスコアを求める．デコーディングはupdate scoreをgreedyに．

<br>



<br>

・update scoreとconsistency scoreの和は定数と定義，この論文では定数をsentenceのinformative scoreとしている．これがタイトルにある制約．informative scoreはAffinity GraphにPageRankを適用して求める．

<br>



<br>

・制約が入ることで，consistency scoreが低いとupdate scoreは高くなるような効果が生まれる．逆もしかり．</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Multi.html">#Multi</a>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/26">Personalized Multi-Document Summarization using N-Gram Topic Model Fusion, Hennig+, [SPIM, 2010], 2010.05</a>
<span class="snippet"><span>Comment</span>・unigramの共起だけでなく，bigramの共起も考慮したPLSIモデルを提案し，jointで学習．与えられたクエリやnarrativeなどとsentenceの類似度（latent spaceで計算）を計算し重要文を決定。

<br>



<br>

・user-modelを使ったPersonalizationはしていない．</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Single.html">#Single</a>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/25">Segmentation Based, Personalized Web Page Summarization Model,  [Journal of advances in information technology, vol. 3, no.3, 2012], 2012.08</a>
<span class="snippet"><span>Comment</span>・Single-document

<br>



<br>

・ページ内をセグメントに分割し，どのセグメントを要約に含めるか選択する問題

<br>



<br>

・要約に含めるセグメントは4つのfactor（segment weight, luan’s significance factor, profile keywords, compression ratio）から決まる．基本的には，ページ内の高頻度語（stop-wordは除く）と，profile keywordsを多く含むようなセグメントが要約に含まれるように選択される．図の場合はAlt要素，リンクはアンカテキストなどから単語を取得しセグメントの重要度に反映する．</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Multi.html">#Multi</a>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/23">Personalized Multi-document Summarization in Information Retrieval, Yang+, [Machine Learning and Cybernetics, 08], 2008.07</a>
<span class="snippet"><span>Comment</span>・検索結果に含まれるページのmulti-document summarizationを行う．クエリとsentenceの単語のoverlap, sentenceの重要度を

<br>



<br>

　Affinity-Graphから求め，両者を結合しスコアリング．MMR 243 likeな手法で冗長性を排除し要約を生成する．

<br>



<br>

・4人のユーザに，実際にシステムを使ってもらい，5-scaleで要約の良さを評価（ベースラインなし）．relevance, importance, 　

<br>



<br>

　usefulness, complement of summaryの視点からそれぞれを5-scaleでrating．それぞれのユーザは，各トピックごとのドキュメントに

<br>



<br>

　全て目を通してもらい，その後に要約を読ませる．</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Multi.html">#Multi</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/Extractive.html">#Extractive</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/22">NewsInEssence: Summarizing ONLINE NEWS TOPICS, Radev+, [Communications of the ACM, 05], 2005.10</a>
<span class="snippet"><span>Comment</span>・Centroid-Basedな手法(MEADと同じ手法)で要約を生成

<br>



<br>

・Personalizationはかけていない</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Multi.html">#Multi</a>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/Search.html">#Search</a>
<a class="button" href="articles/NAACL.html">#NAACL</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/21">WebInEssence: A Personalized Web-Based Multi-Document Summarization and Recommendation System, Radev+, [NAACL, 01], 2001.06</a>
<span class="snippet"><span>Comment</span>・ドキュメントはオフラインでクラスタリングされており，各クラスタごとにmulti-document summarizationを行うことで，

<br>



<br>

ユーザが最も興味のあるクラスタを同定することに役立てる．あるいは検索結果のページのドキュメントの要約を行う．

<br>



<br>

要約した結果には，extractした文の元URLなどが付与されている．

<br>



<br>

・Personalizationをかけるためには，ユーザがドキュメントを選択し，タイトル・ボディなどに定数の重みをかけて，その情報を要約に使う．

<br>



<br>

・特に評価していない．システムのoutputを示しただけ．</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/COLING.html">#COLING</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/18">Automatic Text Summarization based on the Global Document Annotation, COLING-ACL, [Nagao+, 1998], 1998.08</a>
<span class="snippet"><span>Comment</span>Personalized summarizationの評価はしていない。提案のみ。以下の3種類の手法を提案

<br>



<br>

・keyword-based customization

<br>



<br>

  ・関心のあるキーワードをユーザが入力し、コーパスやwordnet等の共起関係から関連語を取得し要約に利用する

<br>



<br>

・文書の要素をinteractiveに選択することによる手法

<br>



<br>

  ・文書中の関心のある要素（e.g. 単語、段落等）

<br>



<br>

・browsing historyベースの手法

<br>



<br>

  ・ユーザのbrowsing historyのドキュメントから、yahooディレクトリ等からカテゴリ情報を取得し、また、トピック情報も取得し（要約技術を活用するとのこと）特徴量ベクトルを作成

<br>



<br>

  ・ユーザがアクセスするたびに特徴ベクトルが更新されることを想定している？</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/NAACL.html">#NAACL</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/17">A Study for Documents Summarization based on Personal Annotation, HLT-NAACL-DUC’03, [Zhang+, 2003], 2003.05</a>
<span class="snippet"><span>Comment</span>（過去に管理人が作成したスライドでの論文メモのスクショ）

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34402434-d521f19e-ebe4-11e7-82cf-2f3452fa4014.png" alt="image" loading="lazy">

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34402437-dbd6db9e-ebe4-11e7-8954-3a0754929ad3.png" alt="image" loading="lazy">

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34402439-e13bff9c-ebe4-11e7-97b6-dfeb97f7e6af.png" alt="image" loading="lazy">

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34402446-e8578e2c-ebe4-11e7-970a-f9db5ff0c548.png" alt="image" loading="lazy">

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34402454-f0c8867e-ebe4-11e7-9c4a-64a727388402.png" alt="image" loading="lazy">

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34402465-fa26e788-ebe4-11e7-82cd-80df4eb5e2b5.png" alt="image" loading="lazy">

<br>



<br>

重要論文だと思われる。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/16">Automatic Personalized Summarization using Non-negative Matrix Factorization and Relevance Measure, IWSCA, [Park+, 2008], 2008.07</a>
<span class="snippet"><span>Comment</span>15 と同様</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/15">Personalized Text Summarization using NMF and Cluster Refinement, ICTC, [Park+, 2011], 2011.09</a>
<span class="snippet"><span>Comment</span><img src="https://user-images.githubusercontent.com/12249301/34402356-5275f894-ebe4-11e7-93d7-2a3781a74b94.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/PRICAI.html">#PRICAI</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/14">Personalized Summarization Agent Using Non-negative Matrix Factorization, PRICAI, [Park, 2008], 2008.12</a>
<span class="snippet"><span>Comment</span><img src="https://user-images.githubusercontent.com/12249301/34402291-fb66cb96-ebe3-11e7-9635-790be0cf8b5d.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/GraphBased.html">#GraphBased</a>
<a class="button" href="articles/Comments.html">#Comments</a>
<a class="button" href="articles/Extractive.html">#Extractive</a>
<a class="button" href="articles/SIGIR.html">#SIGIR</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/9">Comments-Oriented Document Summarization: Understanding Documents with Reader’s Feedback, Hu+, SIGIR’08, 2008.07</a>
<button onclick="hideContent(0)" style="display: none;">hide</button>
&lt;/div&gt;
</number></entity></span></bos></span></think></span>
</div>


    </div>

</article>
<div class="post-nav">
<a class="previous" href="/paper_notes/articles/NAACL.html" title="NAACLに関する論文・技術記事メモの一覧">NAACLに関する論文・技術記事メモの一覧</a><a class="next" href="/paper_notes/articles/NaturalLanguageGeneration.html" title="NaturalLanguageGenerationに関する論文・技術記事メモの一覧">NaturalLanguageGenerationに関する論文・技術記事メモの一覧</a>
</div>
<div class="post-related">
      <div>Related Articles</div>
      <ul>
        <li class="">
          <a class="post-link" href="/paper_notes/articles/Mindset.html" title="Mindsetに関する論文・技術記事メモの一覧">
            Mindsetに関する論文・技術記事メモの一覧<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li>
<li class="">
          <a class="post-link" href="/paper_notes/articles/VerifiableRewards.html" title="VerifiableRewardsに関する論文・技術記事メモの一覧">
            VerifiableRewardsに関する論文・技術記事メモの一覧<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li>
<li class="">
          <a class="post-link" href="/paper_notes/articles/ImageCaptioning.html" title="ImageCaptioningに関する論文・技術記事メモの一覧">
            ImageCaptioningに関する論文・技術記事メモの一覧<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li>
<li class="">
          <a class="post-link" href="/paper_notes/articles/DPO.html" title="DPOに関する論文・技術記事メモの一覧">
            DPOに関する論文・技術記事メモの一覧<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li>
</ul>
    </div>
<div class="post-comments"></div></section>
</div>


  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">TOC</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/paper_notes/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
<div>Copyright © 2023-current AkihikoWATANABE. The header images and any thumbnail images for the posts were generated by ChatGPT's DALL-E3.</div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="https://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/paper_notes/feed.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
