<!DOCTYPE html>
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>LanguageModelに関する論文・技術記事メモの一覧 | わたしのべんきょうノート</title>
<meta name="generator" content="Jekyll v4.3.2">
<meta property="og:title" content="LanguageModelに関する論文・技術記事メモの一覧">
<meta name="author" content="AkihikoWATANABE">
<meta property="og:locale" content="ja">
<meta name="description" content="LanguageModel">
<meta property="og:description" content="LanguageModel">
<link rel="canonical" href="http://akihikowatanabe.github.io/paper_notes/articles/LanguageModel.html">
<meta property="og:url" content="http://akihikowatanabe.github.io/paper_notes/articles/LanguageModel.html">
<meta property="og:site_name" content="わたしのべんきょうノート">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2025-08-12T08:21:43+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="LanguageModelに関する論文・技術記事メモの一覧">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"AkihikoWATANABE"},"dateModified":"2025-08-12T08:21:43+00:00","datePublished":"2025-08-12T08:21:43+00:00","description":"LanguageModel","headline":"LanguageModelに関する論文・技術記事メモの一覧","mainEntityOfPage":{"@type":"WebPage","@id":"http://akihikowatanabe.github.io/paper_notes/articles/LanguageModel.html"},"url":"http://akihikowatanabe.github.io/paper_notes/articles/LanguageModel.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="icon" href="">
  <link rel="canonical" href="http://akihikowatanabe.github.io">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/paper_notes/assets/css/main.css">
  <link rel="stylesheet" href="/paper_notes/assets/css/custom_button.css">
  <script src="/paper_notes/assets/js/main.js"></script>
  <script src="https://d3js.org/d3.v5.min.js"></script><link type="application/atom+xml" rel="alternate" href="http://akihikowatanabe.github.io/paper_notes/feed.xml" title="わたしのべんきょうノート">
<script>
  function showMore(index) {
    const contentDivs = document.getElementsByClassName('hidden-content');
    const contentDiv = contentDivs[index];

    if (contentDiv) {
      contentDiv.style.display = "block";
          
      // このボタンの参照を取得して非表示にします
      const moreButtons = document.querySelectorAll('button[onclick^="showMore"]');
      const moreButton = moreButtons[index];
      if (moreButton) {
        moreButton.style.display = "none";
      }
          
      // hideボタンの参照を取得して表示します
      const hideButton = contentDiv.querySelector('button[onclick^="hideContent"]');
      if (hideButton) {
        hideButton.style.display = "block";
      }
    }
  }

  function hideContent(index) {
    const contentDivs = document.getElementsByClassName('hidden-content');
    const contentDiv = contentDivs[index];

    if (contentDiv) {
      contentDiv.style.display = "none";
  
      // moreボタンの参照を取得して表示します
      const moreButtons = document.querySelectorAll('button[onclick^="showMore"]');
      const moreButton = moreButtons[index];
      if (moreButton) {
        moreButton.style.display = "block";
      }
  
      // このボタンを隠します
      const hideButtons = document.querySelectorAll('button[onclick^="hideContent"]');
      const hideButton = hideButtons[index];
      if (hideButton) {
        hideButton.style.display = "none";
      }
    }
  }
</script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js" async></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
<script src="//cdnjs.cloudflare.com/ajax/libs/photoswipe/5.3.7/umd/photoswipe-lightbox.umd.min.js" async></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/photoswipe/5.3.7/umd/photoswipe.umd.min.js" async></script>
<link href="//cdnjs.cloudflare.com/ajax/libs/photoswipe/5.3.7/photoswipe.min.css" rel="stylesheet">
<style>
  .pswp .pswp__container .pswp__img {
    background-color: white;
  }
</style>

<script>
  function initPhotoSwipe() {
    let customOptions = {};

    try {
      const data = `{"gallery"=>"section.main", "children"=>"a.photo-swipe", "bgOpacity"=>0.8, "padding"=>{"top"=>20, "bottom"=>40, "left"=>100, "right"=>100}}`.replaceAll("=>", ":");
      customOptions = JSON.parse(data);
    } catch (e) {
      console.info("Invalid custom photo previewer options! " + e.message);
    }

    // Define object and gallery options
    const options = Object.assign(
      {
        gallery: "section.main",
        children: "a.photo-swipe",
        photo_scale: 2,
        // dynamic import is not supported in UMD version
        pswpModule: PhotoSwipe,
      },
      customOptions
    );

    const galleryEl = document.querySelector(options.gallery);
    if (!galleryEl) {
      return;
    }

    const imgEls = [];
    const els = galleryEl.querySelectorAll("img:not(.emoji)");
    els.forEach((el) => {
      if (el.src.trim() == "") {
        return;
      }
      if (!imgEls.includes(el)) {
        imgEls.push(el);
      }
    });

    if (imgEls.length === 0) {
      return;
    }

    imgEls.forEach((imgEl) => {
      imgEl.outerHTML = `
      <a class="photo-swipe"
        href="${imgEl.src}"
        data-pswp-width="${
          Math.max(imgEl.naturalWidth, imgEl.width) * options.photo_scale
        }"
        data-pswp-height="${
          Math.max(imgEl.naturalHeight, imgEl.height) * options.photo_scale
        }"
        data-pswp-caption="${imgEl.getAttribute("caption") || imgEl.alt}"
        target="_blank">
        ${imgEl.outerHTML}
      </a>`;
    });

    // Initialize PhotoSwipe 5
    var lightbox = new PhotoSwipeLightbox(options);

    lightbox.init();
  }

  window.addEventListener("load", initPhotoSwipe);
</script>
<meta name="google-site-verification" content="u_DTTPcCZ806iq51zgirHyWq3556HUKGq8AQfH91iFI">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-P70KSB88WH"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-P70KSB88WH');
  </script>
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["$$","$$"],["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>





































































































































<header class="site-header site-header-transparent" role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/paper_notes/">
  <img class="site-favicon" title="わたしのべんきょうノート" src="" onerror="this.style.display='none'">
  わたしのべんきょうノート
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">









<span class="page-link">



<div id="google_translate_element" style="display: none;">
</div>

<span class="ct-language">
  <ul class="list-unstyled ct-language-dropdown">
    
      <li>
        <a href="#" class="lang-select" data-lang="en">
          
          <img src="https://cdn.countryflags.com/thumbs/united-states-of-america/flag-400.png" title="English">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="fr">
          
          <img src="https://cdn.countryflags.com/thumbs/france/flag-400.png" title="French">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="zh-CN">
          
          <img src="https://cdn.countryflags.com/thumbs/china/flag-400.png" title="Chinese(Simple)">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ja">
          
          <img src="https://cdn.countryflags.com/thumbs/japan/flag-400.png" title="Japanese">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ko">
          
          <img src="https://cdn.countryflags.com/thumbs/south-korea/flag-400.png" title="Korean">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ru">
          
          <img src="https://cdn.countryflags.com/thumbs/russia/flag-400.png" title="Russian">
          
        </a>
      </li>
    
  </ul>
</span>

<script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({
    pageLanguage: 'ja',
    autoDisplay: false,
    layout: google.translate.TranslateElement.InlineLayout.VERTICAL
  }, 'google_translate_element');

  // Links to cross-origin destinations are unsafe
  var gll = document.getElementsByClassName('goog-logo-link')[0];
  if (gll) {
    gll.setAttribute('rel', 'noopener');
  }

  function restoreLang() {
    var iframe = document.getElementsByClassName('goog-te-banner-frame')[0];
    if (!iframe) return;

    var innerDoc = iframe.contentDocument || iframe.contentWindow.document;
    var restore_el = innerDoc.getElementsByTagName("button");

    for (var i = 0; i < restore_el.length; i++) {
      if (restore_el[i].id.indexOf("restore") >= 0) {
        restore_el[i].click();
        var close_el = innerDoc.getElementsByClassName("goog-close-link");
        close_el[0].click();
        return;
      }
    }
  }

  function triggerHtmlEvent(element, eventName) {
    var event;
    if (document.createEvent) {
      event = document.createEvent('HTMLEvents');
      event.initEvent(eventName, true, true);
      element.dispatchEvent(event);
    } else {
      event = document.createEventObject();
      event.eventType = eventName;
      element.fireEvent('on' + event.eventType, event);
    }
  }

  var googleCombo = document.querySelector("select.goog-te-combo");
  var langSelect = document.querySelector('.ct-language');
  langSelect.addEventListener('click', function(event) {
    if (!event.target) {
      return;
    }

    var selected = document.querySelector('.ct-language .ct-language-selected');
    if (selected) {
      selected.classList.remove('ct-language-selected');
    }

    var target = event.target;
    while (target && target !== langSelect ) {
      if (target.matches('.lang-select')) {
        break;
      }
      target = target.parentElement;
    }

    if (target && target.matches('.lang-select')) {
      var lang = target.getAttribute('data-lang');
      if (googleCombo.value == lang) {
        restoreLang();
      } else {
        target.parentElement.classList.add('ct-language-selected');
        googleCombo.value = lang;
        triggerHtmlEvent(googleCombo, 'change');
      }
    }

    event.preventDefault();
  });
}
</script>

<script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit" async></script>
</span>
</div>
        </nav>
</div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;documentElement.setAttribute("data-header-transparent", "");var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);
</script>


























































































































































<style>
    html .page-banner .page-banner-img > *:first-child {
      opacity: 0.4;
    }

    html[data-theme="dark"] .page-banner .page-banner-img > *:first-child {
      opacity: 0.2872;
    }
  </style>
<section class="page-banner">
    <div class="page-banner-img">
<div style="background-image: url(/paper_notes/assets/images/banner.png)"></div>
        <img class="img-placeholder" src="/paper_notes/assets/images/banner.png">
</div>
    <div class="wrapper">
      <div class="page-banner-inner">
<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">わたしのべんきょうノート</h1>
  <h2 class="post-subtitle">勉強した論文や技術等の情報をGithubのIssueにメモっているひとのブログ。
それなりにメモの量が蓄積されてきたので、一度整理したいなと思いブログはじめてみました！
自然言語処理(NLP), 推薦システム(RecommenderSystem), Educational Data Mining (EDM), Learning Analytics (LA)などの分野のメモが多いと思います。
最近は特にLLMの勉強が多めです :)</h2>

  <div class="post-meta">
    <time class="dt-published" datetime="2025-08-12T08:21:43+00:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Aug 12, 2025
    </time><span class="post-author left-vsplit"><i class="fa fa-pencil"></i> AkihikoWATANABE</span>
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 25 hours 48 mins</span>
  </div></header>
</div>
    </div>
  </section><script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('off' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<div id="click-to-top" class="click-to-top">
  <i class="fa fa-arrow-up"></i>
</div>
<script>
  (function () {
    const clickToTop = document.getElementById('click-to-top');
    window.addEventListener('scroll', () => {
      if (window.scrollY > 100) {
        clickToTop.classList.add('show')
      }else {
        clickToTop.classList.remove('show')
      }
    });
    clickToTop.addEventListener('click', () => {
      window.smoothScrollTo(0);
    });
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <h2 id="languagemodel">LanguageModel</h2>

<div class="visible-content">
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/ContextEngineering.html">#ContextEngineering</a>
<a class="button" href="articles/memory.html">#memory</a>


<br>


<span class="issue_date">Issue Date: 2025-08-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2403">[Paper Note] Memp: Exploring Agent Procedural Memory, Runnan Fang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、LLMに基づくエージェントに学習可能で更新可能な手続き的記憶を持たせるための戦略を提案。Mempを用いて過去のエージェントの軌跡を指示や抽象に蒸留し、記憶の構築と更新を行う。TravelPlannerとALFWorldでの実証評価により、記憶リポジトリが進化することでエージェントの成功率と効率が向上することを示した。また、強力なモデルからの手続き的記憶の移行により、弱いモデルでも性能向上が得られることが確認された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/zxlzr/status/1954840738082193477?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qアドホックに探索と実行を繰り返すのではなく、過去の試行のtrajectoryをメモリに記憶しておき、活用するような枠組みな模様。trajectoryは新たなタスクが来た際にretrieverでrelevantなtrajectoryを検索して利用され、良質なtrajectoryがキープされれば成功率や効率が向上すると考えられる。trajectoryはprocedure memoryとして保存され、成功率が低いtrajectoryは破棄されることで更新される。

<br>

<img src="https://github.com/user-attachments/assets/20e2f063-eef6-4c3d-9161-3d96f56c6f8d" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/a3766541-4946-4e43-91e4-99a873fb1d6f" alt="image" loading="lazy">

<br>



<br>

メモリはT個のタスクに対するs_t, a_t, o_t, i.e., state, action, observation,の系列τと、reward rが与えられた時に、Builderを通して構築されてストアされる。agentは新たなタスクt_newに直面した時に、t_newと類似したメモリをretrieyeする。これはτの中のある時刻tのタスクに対応する。メモリは肥大化していくため、実験では複数のアルゴリズムに基づくメモリの更新方法について実験している。

<br>

<img src="https://github.com/user-attachments/assets/b91dbfed-c976-4764-abf6-00f4751b7e91" alt="image" loading="lazy">

<br>



<br>

procedural memoryの有無による挙動の違いに関するサンプル。

<br>

<img src="https://github.com/user-attachments/assets/2623103d-331d-45eb-a5cc-635ef3cb88ab" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/b1c21bf3-eef1-4b4c-999c-f8d0fcbc9431" alt="image" loading="lazy">memoryに対してretrieverを適用することになるので、retrieverの性能がボトルネックになると思われる。追加の学習をしなくて済むのは利点だが、その代わりモデル側がメモリ管理をする機能を有さない（学習すればそういった機能を持たせられるはず）ので、その点は欠点となる、という印象。簡易解説:

<br>

https://x.com/huggingpapers/status/1954937801490772104?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/ReversalCurse.html">#ReversalCurse</a>


<br>


<span class="issue_date">Issue Date: 2025-08-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2399">[Paper Note] Physics of Language Models: Part 3.2, Knowledge Manipulation, Zeyuan Allen-Zhu+, ICLR'25</a>
<span class="snippet"><span>Summary</span>言語モデルは豊富な知識を持つが、下流タスクへの柔軟な利用には限界がある。本研究では、情報検索、分類、比較、逆検索の4つの知識操作タスクを調査し、言語モデルが知識検索には優れているが、Chain of Thoughtsを用いないと分類や比較タスクで苦労することを示した。特に逆検索ではパフォーマンスがほぼ0%であり、これらの弱点は言語モデルに固有であることを確認した。これにより、現代のAIと人間を区別する新たなチューリングテストの必要性が浮き彫りになった。</span>
<span class="snippet"><span>Comment</span>openreview:https://openreview.net/forum?id=oDbiL9CLoS解説:

<br>

・1834</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SelfCorrection.html">#SelfCorrection</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>


<br>


<span class="issue_date">Issue Date: 2025-08-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2398">[Paper Note] Physics of Language Models: Part 2.2, How to Learn From Mistakes on   Grade-School Math Problems, Tian Ye+, ICLR'25</a>
<span class="snippet"><span>Summary</span>言語モデルの推論精度向上のために、「エラー修正」データを事前学習に組み込む有用性を探求。合成数学データセットを用いて、エラーフリーデータと比較して高い推論精度を達成することを示す。さらに、ビームサーチとの違いやデータ準備、マスキングの必要性、エラー量、ファインチューニング段階での遅延についても考察。</span>
<span class="snippet"><span>Comment</span>openreview:https://openreview.net/forum?id=zpDGwcmMV4解説:

<br>

・1834</span>
</div>
<p><button onclick="showMore(0)">more</button></p>
<div class="hidden-content">
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2025-08-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2397">[Paper Note] Physics of Language Models: Part 2.1, Grade-School Math and the Hidden   Reasoning Process, Tian Ye+, ICLR'25</a>
<span class="snippet"><span>Summary</span>言語モデルの数学的推論能力を研究し、GSM8Kベンチマークでの精度向上のメカニズムを探る。具体的には、推論スキルの発展、隠れたプロセス、人間との違い、必要なスキルの超越、推論ミスの原因、モデルのサイズや深さについての実験を行い、LLMの理解を深める洞察を提供。</span>
<span class="snippet"><span>Comment</span>openreview:https://openreview.net/forum?id=Tn5B6Udq3E解説:

<br>

・1834</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<span class="issue_date">Issue Date: 2025-08-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2391">[Paper Note] Agent Lightning: Train ANY AI Agents with Reinforcement Learning, Xufang Luo+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Agent Lightningは、任意のAIエージェントのためにLLMsを用いたRLトレーニングを可能にする柔軟なフレームワークで、エージェントの実行とトレーニングを分離し、既存のエージェントとの統合を容易にします。マルコフ決定過程としてエージェントの実行を定式化し、階層的RLアルゴリズムLightningRLを提案。これにより、複雑な相互作用ロジックを扱うことが可能になります。実験では、テキストからSQLへの変換などで安定した改善が見られ、実世界でのエージェントトレーニングの可能性が示されました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/curveweb/status/1954384415330824698?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/SyntheticDataGeneration.html">#SyntheticDataGeneration</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<span class="issue_date">Issue Date: 2025-08-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2390">[Paper Note] MathSmith: Towards Extremely Hard Mathematical Reasoning by Forging  Synthetic Problems with a Reinforced Policy, Shaoxiong Zhan+, arXiv'25</a>
<span class="snippet"><span>Summary</span>MathSmithという新しいフレームワークを提案し、LLMの数学的推論を強化するために新しい問題をゼロから合成。既存の問題を修正せず、PlanetMathから概念と説明をランダムにサンプリングし、データの独立性を確保。9つの戦略を用いて難易度を上げ、強化学習で構造的妥当性や推論の複雑さを最適化。実験では、MathSmithが既存のベースラインを上回り、高難易度の合成データがLLMの推論能力を向上させる可能性を示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gm8xx8/status/1954253929761411180?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<a class="button" href="articles/ZeroData.html">#ZeroData</a>
<span class="issue_date">Issue Date: 2025-08-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2387">[Paper Note] R-Zero: Self-Evolving Reasoning LLM from Zero Data, Chengsong Huang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>R-Zeroは、自己進化型大規模言語モデル（LLMs）が自律的にトレーニングデータを生成するフレームワークで、チャレンジャーとソルバーの2つのモデルが共進化することで、既存のタスクやラベルに依存せずに自己改善を実現します。このアプローチにより、推論能力が大幅に向上し、特にQwen3-4B-Baseでは数学推論で+6.49、一般ドメイン推論で+7.54の改善が確認されました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_akhaliq/status/1953804055525962134?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q問題を生成するChallengerと与えられた問題を解くSolverを用意し、片方をfreezezさせた状態で交互にポリシーの更新を繰り返す。

<br>



<br>

<img src="https://github.com/user-attachments/assets/05207756-3029-41a2-8dd0-e27de5228436" alt="image" loading="lazy">

<br>



<br>

Challenger

<br>

・ （Challengerによる)問題生成→

<br>

・（freezed solverによる）self consistencyによるラベル付け→

<br>

・Solverの問題に対するempirical acc.（i.e., サンプリング回数mに対するmajorityが占める割合）でrewardを与えChallengerを更新

<br>



<br>

といった流れでポリシーが更新される。Rewardは他にも生成された問題間のBLEUを測り類似したものばかりの場合はペナルティを与える項や、フォーマットが正しく指定された通りになっているか、といったペナルティも導入する。

<br>



<br>

Solver

<br>

・ChallengerのポリシーからN問生成し、それに対してSolverでself consistencyによって解答を生成

<br>

・empirical acc.を計算し、1/2との差分の絶対値を見て、簡単すぎる/難しすぎる問題をフィルタリング

<br>

  ・これはカリキュラム学習的な意味合いのみならず、低品質な問題のフィルタリングにも寄与する

<br>

・フィルタリング後の問題を利用して、verifiable binary rewardでポリシーを更新

<br>



<br>

評価結果

<br>

数学ドメインに提案手法を適用したところ、iterごとに全体の平均性能は向上。

<br>

<img src="https://github.com/user-attachments/assets/cbe780ec-a99b-4227-b983-4e24982a6af8" alt="image" loading="lazy">

<br>



<br>

提案手法で数学ドメインを学習し、generalドメインに汎化するか？を確認したところ、汎化することを確認（ただ、すぐにサチっているようにも見える）。、

<br>

<img src="https://github.com/user-attachments/assets/bc0eb3e1-8ed1-4d36-b30e-095e8a160886" alt="image" loading="lazy">関連:

<br>

・2383

<br>

・1936著者ポスト:

<br>

・https://x.com/wyu_nd/status/1954249813861810312?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・https://x.com/chengsongh31219/status/1953936172415430695?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q日本語解説:

<br>

https://x.com/curveweb/status/1954367657811308858?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<a class="button" href="articles/ZeroData.html">#ZeroData</a>
<span class="issue_date">Issue Date: 2025-08-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2383">[Paper Note] Self-Questioning Language Models, Lili Chen+, arXiv'25</a>
<span class="snippet"><span>Summary</span>自己質問型言語モデル（SQLM）を提案し、トピックを指定するプロンプトから自ら質問を生成し、解答する非対称の自己対戦フレームワークを構築。提案者と解答者は強化学習で訓練され、問題の難易度に応じて報酬を受け取る。三桁の掛け算や代数問題、プログラミング問題のベンチマークで、外部データなしで言語モデルの推論能力を向上させることができることを示す。</span>
<span class="snippet"><span>Comment</span>pj page:https://self-questioning.github.io元ポスト:https://x.com/lchen915/status/1953896909925757123?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qたとえば下記のような、ラベル無しの外部データを利用する手法も用いてself improvingする手法と比較したときに、どの程度の性能差になるのだろうか？外部データを全く利用せず、外部データありの手法と同等までいけます、という話になると、より興味深いと感じた。

<br>



<br>

・1212既存の外部データを活用しない関連研究:

<br>

・1936</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-08-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2382">[Paper Note] On the Generalization of SFT: A Reinforcement Learning Perspective with  Reward Rectification, Yongliang Wu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLM）の教師ありファインチューニング（SFT）の一般化能力を向上させるため、動的ファインチューニング（DFT）を提案。DFTはトークンの確率に基づいて目的関数を再スケーリングし、勾配更新を安定化させる。これにより、SFTを大幅に上回る性能を示し、オフライン強化学習でも競争力のある結果を得た。理論的洞察と実践的解決策を結びつけ、SFTの性能を向上させる。コードは公開されている。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/theturingpost/status/1953960036126142645?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qこれは大変興味深い。数学以外のドメインでの評価にも期待したい。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<span class="issue_date">Issue Date: 2025-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2381">[Paper Note] A comprehensive taxonomy of hallucinations in Large Language Models, Manuel Cossio, arXiv'25</a>
<span class="snippet"><span>Summary</span>LLMのハルシネーションに関する包括的な分類法を提供し、その本質的な避けられなさを提唱。内因的および外因的な要因、事実誤認や不整合などの具体的な現れを分析。根本的な原因や認知的要因を検討し、評価基準や軽減戦略を概説。今後は、信頼性のある展開のために検出と監視に焦点を当てる必要があることを強調。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/sei_shinagawa/status/1953845008588513762?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<a class="button" href="articles/RewardHacking.html">#RewardHacking</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<a class="button" href="articles/On-Policy.html">#On-Policy</a>
<span class="issue_date">Issue Date: 2025-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2376">[Paper Note] Learning to Reason for Factuality, Xilun Chen+, arXiv'25</a>
<span class="snippet"><span>Summary</span>R-LLMsは複雑な推論タスクで進展しているが、事実性において幻覚を多く生成する。オンラインRLを長文の事実性設定に適用する際、信頼できる検証方法が不足しているため課題がある。従来の自動評価フレームワークを用いたオフラインRLでは報酬ハッキングが発生することが判明。そこで、事実の精度、詳細レベル、関連性を考慮した新しい報酬関数を提案し、オンラインRLを適用。評価の結果、幻覚率を平均23.1ポイント削減し、回答の詳細レベルを23%向上させた。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jaseweston/status/1953629692772446481?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q先行研究:

<br>

・2378Reasoning ModelのHallucination Rateは、そのベースとなるモデルよりも高い。実際、DeepSeek-V3とDeepSeek-R1,Qwen-2.5-32BとQwQ-32Bを6つのFactualityに関するベンチマークで比較すると、Reasoning Modelの方がHallucination Rateが10, 13%程度高かった。これは、現在のOn-policyのRLがlogical reasoningにフォーカスしており、Factualityを見落としているため、と仮説を立てている。

<br>

Factuality（特にLongForm)とRL alignmentsという観点から言うと、決定的、正確かつ信頼性のあるverificatlon手法は存在せず、Human Effortが必要不可欠である。

<br>

自動的にFactualityを測定するFactScoreのような手法は、DPOのようなオフラインのペアワイズのデータを作成するに留まってしまっている。また、on dataでFactualityを改善する取り組みは行われているが、long-formな応答に対して、factual reasoningを実施するにはいくつかの課題が残されている:

<br>

・reward design

<br>

  ・Factualityに関するrewardを単独で追加するだけだと、LLMは非常に短く、詳細を省略した応答をしPrecicionのみを高めようとしてしまう。

<br>



<br>

あとで追記する</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2025-08-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2352">[Paper Note] On the Expressiveness of Softmax Attention: A Recurrent Neural Network  Perspective, Gabriel Mongaras+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、ソフトマックスアテンションの再帰的な形式を導出し、線形アテンションがその近似であることを示す。これにより、ソフトマックスアテンションの各部分をRNNの言語で説明し、構成要素の重要性と相互作用を理解する。これにより、ソフトマックスアテンションが他の手法よりも表現力が高い理由を明らかにする。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1952485214162407644?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLinearAttention関連の研究は下記あたりがありそう？

<br>

・2353

<br>

・2354 

<br>

・2355

<br>

・2356・1271

<br>



<br>

たとえばGQAはQwen3で利用されているが、本研究の知見を活用してscaled-dot product attention計算時のSoftmax計算の計算量が削減できたら、さらに計算量が削減できそう？</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2025-08-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2350">[Paper Note] MLE-STAR: Machine Learning Engineering Agent via Search and Targeted  Refinement, Jaehyun Nam+, arXiv'25</a>
<span class="snippet"><span>Summary</span>MLE-STARは、LLMを用いてMLモデルを自動実装する新しいアプローチで、ウェブから効果的なモデルを取得し、特定のMLコンポーネントに焦点を当てた戦略を探索することで、コード生成の精度を向上させる。実験結果では、MLE-STARがKaggleコンペティションの64%でメダルを獲得し、他の手法を大きく上回る性能を示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/marktechpost/status/1951846630266687927?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/On-Policy.html">#On-Policy</a>
<a class="button" href="articles/CrossDomain.html">#CrossDomain</a>
<span class="issue_date">Issue Date: 2025-08-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2341">[Paper Note] SRPO: A Cross-Domain Implementation of Large-Scale Reinforcement  Learning on LLM, Xiaojiang Zhang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>二段階履歴再サンプリングポリシー最適化（SRPO）を提案し、DeepSeek-R1-Zero-32Bを上回る性能をAIME24およびLiveCodeBenchで達成。SRPOはトレーニングステップを約1/10に削減し、効率性を示す。二つの革新として、クロスドメイントレーニングパラダイムと履歴再サンプリング技術を導入し、LLMの推論能力を拡張するための実験を行った。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jiqizhixin/status/1914920300359377232?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QGRPOよりもより効率的な手法な模様。最初に数学のデータで学習をしReasoning Capabilityを身につけさせ、その後別のドメインのデータで学習させることで、その能力を発揮させるような二段階の手法らしい。

<br>



<br>

Datamixingよりも高い性能（ただし、これは数学とコーディングのCoT Lengthのドメイン間の違いに起因してこのような2 stageな手法にしているようなのでその点には注意が必要そう）？しっかりと読めていないので、読み違いの可能性もあるので注意。

<br>

<img src="https://github.com/user-attachments/assets/cf00de8b-1923-4f23-b575-0a889517ec9e" alt="image" loading="lazy">なんたらRPO多すぎ問題</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Optimizer.html">#Optimizer</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<a class="button" href="articles/ModelMerge.html">#ModelMerge</a>
<a class="button" href="articles/Stability.html">#Stability</a>
<span class="issue_date">Issue Date: 2025-08-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2340">[Paper Note] WSM: Decay-Free Learning Rate Schedule via Checkpoint Merging for LLM  Pre-training, Changxin Tian+, arXiv'25</a>
<span class="snippet"><span>Summary</span>学習率スケジューリングの新たなアプローチとして、Warmup-Stable and Merge（WSM）を提案。WSMは、学習率の減衰とモデルマージの関係を確立し、さまざまな減衰戦略を統一的に扱う。実験により、マージ期間がモデル性能において重要であることを示し、従来のWSDアプローチを上回る性能向上を達成。特に、MATHで+3.5%、HumanEvalで+2.9%、MMLU-Proで+5.5%の改善を記録。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/stochasticchasm/status/1951427541803106714?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QWeight Decayを無くせるらしいエッセンスの解説:https://x.com/wenhaocha1/status/1951790366900019376?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

チェックポイントさえ保存しておいて事後的に活用することだで、細かなハイパラ調整のための試行錯誤する手間と膨大な計算コストがなくなるのであれば相当素晴らしいのでは…？</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-08-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2334">[Paper Note] CoT-Self-Instruct: Building high-quality synthetic prompts for reasoning  and non-reasoning tasks, Ping Yu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>CoT-Self-Instructを提案し、LLMに基づいて新しい合成プロンプトを生成する手法を開発。合成データはMATH500やAMC23などで既存データセットを超える性能を示し、検証不可能なタスクでも人間や標準プロンプトを上回る結果を得た。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jaseweston/status/1951084679286722793?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qより複雑で、Reasoningやplanningを促すようなinstructionが生成される模様。実際に生成されたinstructionのexampleは全体をざっとみた感じこの図中のもののみのように見える。

<br>

<img src="https://github.com/user-attachments/assets/98dcb6a3-686f-4e3d-bf83-7b36765c0953" alt="image" loading="lazy">以下のスクショはMagpieによって合成されたinstruction。InstructionTuning用のデータを合成するならMagpieが便利そうだなぁ、と思っていたのだが、比較するとCoT-SelfInstructの方が、より複雑で具体的な指示を含むinstructionが生成されるように見える。

<br>



<br>

・2094

<br>



<br>

<img src="https://github.com/user-attachments/assets/a631a2bc-d2ee-49dd-96a1-00354ff1f40a" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-08-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2332">[Paper Note] Beyond Binary Rewards: Training LMs to Reason About Their Uncertainty, Mehul Damani+, arXiv'25</a>
<span class="snippet"><span>Summary</span>RLCRを用いた言語モデルの訓練により、推論の精度と信頼度を同時に改善。バイナリ報酬に加え、信頼度推定のためのブライヤースコアを用いた報酬関数を最適化。RLCRは、通常のRLよりもキャリブレーションを改善し、精度を損なうことなく信頼性の高い推論モデルを生成することを示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/asap2650/status/1950942279872762272?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLLMにConfidenceをDiscreteなTokenとして（GEvalなどは除く）出力させると信頼できないことが多いので、もしそれも改善するのだとしたら興味深い。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Composition.html">#Composition</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/InstructionFollowingCapability.html">#InstructionFollowingCapability</a>
<a class="button" href="articles/CommonsenseReasoning.html">#CommonsenseReasoning</a>
<span class="issue_date">Issue Date: 2025-07-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2328">[Paper Note] Revisiting Compositional Generalization Capability of Large Language   Models Considering Instruction Following Ability, Yusuke Sakai+, ACL'25</a>
<span class="snippet"><span>Summary</span>Ordered CommonGenを提案し、LLMsの指示に従う能力と構成的一般化能力を評価するベンチマークを構築。36のLLMsを分析した結果、指示の意図は理解しているが、概念の順序に対するバイアスが低多様性の出力を引き起こすことが判明。最も指示に従うLLMでも約75%の順序付きカバレッジしか達成できず、両能力の改善が必要であることを示唆。</span>
<span class="snippet"><span>Comment</span>LLMの意味の構成性と指示追従能力を同時に発揮する能力を測定可能なOrderedCommonGenを提案

<br>



<br>

<img src="https://github.com/user-attachments/assets/ae8c9468-a788-4baa-a618-402eae92c6c8" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/24ba68b4-3484-4597-a401-1e47183276cf" alt="image" loading="lazy">関連:

<br>

・2330</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<span class="issue_date">Issue Date: 2025-07-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2325">[Paper Note] Efficient Attention Mechanisms for Large Language Models: A Survey, Yutao Sun+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Transformerアーキテクチャの自己注意の複雑さが長文コンテキストモデリングの障害となっている。これに対処するため、線形注意手法とスパース注意技術が導入され、計算効率を向上させつつコンテキストのカバレッジを保持する。本研究は、これらの進展を体系的にまとめ、効率的な注意を大規模言語モデルに組み込む方法を分析し、理論と実践を統合したスケーラブルなモデル設計の基礎を提供することを目指す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/omarsar0/status/1950287053046022286?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q<img src="https://github.com/user-attachments/assets/df56fa40-4206-4d12-9172-39f7b36f19c7" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2025-07-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2317">[Paper Note] On The Role of Pretrained Language Models in General-Purpose Text  Embeddings: A Survey, Meishan Zhang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本調査では、事前学習済み言語モデル（PLMs）を活用した一般目的のテキスト埋め込み（GPTE）の発展を概観し、PLMsの役割に焦点を当てる。基本的なアーキテクチャや埋め込み抽出、表現力向上、トレーニング戦略について説明し、PLMsによる多言語サポートやマルチモーダル統合などの高度な役割も考察する。さらに、将来の研究方向性として、ランキング統合やバイアス軽減などの改善目標を超えた課題を強調する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/bo_wangbo/status/1950158633645363465?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QGPTEの学習手法テキストだけでなく、画像やコードなどの様々なモーダル、マルチリンガル、データセットや評価方法、パラメータサイズとMTEBの性能の関係性の図解など、盛りだくさんな模様。最新のものだけでなく、2021年頃のT5から最新モデルまで網羅的にまとまっている。日本語特化のモデルについては記述が無さそうではある。

<br>



<br>

<img src="https://github.com/user-attachments/assets/f0a40a10-7f29-4aaf-b989-672213622ebc" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/7940d307-f1db-421f-86a4-6c9cca22f27c" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/46282995-d538-4bd2-9aa5-983253a98f8f" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/dc4212de-19df-497c-951e-3addff5a193f" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/ac925f56-de46-49ae-b0a8-cd8e2ecc4994" alt="image" loading="lazy">日本語モデルについてはRuriのテクニカルペーパーや、LLM勉強会のまとめを参照のこと

<br>

・1375

<br>

・1563</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/AES(AutomatedEssayScoring).html">#AES(AutomatedEssayScoring)</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/AIED.html">#AIED</a>
<span class="issue_date">Issue Date: 2025-07-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2315">[Paper Note] Do We Need a Detailed Rubric for Automated Essay Scoring using Large   Language Models?, Lui Yoshida, AIED'25</a>
<span class="snippet"><span>Summary</span>本研究では、LLMを用いた自動エッセイ採点におけるルーブリックの詳細さが採点精度に与える影響を調査。TOEFL11データセットを用いて、完全なルーブリック、簡略化されたルーブリック、ルーブリックなしの3条件を比較。結果、3つのモデルは簡略化されたルーブリックでも精度を維持し、トークン使用量を削減。一方、1つのモデルは詳細なルーブリックで性能が低下。簡略化されたルーブリックが多くのLLMにとって効率的な代替手段であることが示唆されるが、モデルごとの評価も重要。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<span class="issue_date">Issue Date: 2025-07-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2313">[Paper Note] Learning without training: The implicit dynamics of in-context learning, Benoit Dherin+, arXiv'25</a>
<span class="snippet"><span>Summary</span>LLMは文脈内で新しいパターンを学習する能力を持ち、そのメカニズムは未解明である。本研究では、トランスフォーマーブロックが自己注意層とMLPを重ねることで、文脈に応じてMLPの重みを暗黙的に修正できることを示し、このメカニズムがLLMの文脈内学習の理由である可能性を提案する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/omarsar0/status/1948384435654779105?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説:https://x.com/hillbig/status/1950333455134576794?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/Trustfulness.html">#Trustfulness</a>
<span class="issue_date">Issue Date: 2025-07-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2306">[Paper Note] Rectifying Belief Space via Unlearning to Harness LLMs' Reasoning, Ayana Niwa+, ACL'25</a>
<span class="snippet"><span>Summary</span>LLMの不正確な回答は虚偽の信念から生じると仮定し、信念空間を修正する方法を提案。テキスト説明生成で信念を特定し、FBBSを用いて虚偽の信念を抑制、真の信念を強化。実証結果は、誤った回答の修正とモデル性能の向上を示し、一般化の改善にも寄与することを示唆。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/ayaniwa1213/status/1949750575123276265?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<a class="button" href="articles/ITI%20(Inference%20Time%20Intervention).html">#ITI (Inference Time Intervention)</a>
<a class="button" href="articles/Trustfulness.html">#Trustfulness</a>
<span class="issue_date">Issue Date: 2025-07-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2303">[Paper Note] GrAInS: Gradient-based Attribution for Inference-Time Steering of LLMs  and VLMs, Duy Nguyen+, arXiv'25</a>
<span class="snippet"><span>Summary</span>GrAInSは、LLMsおよびVLMsの推論時に内部活性を調整する新しいステアリング手法で、固定された介入ベクトルに依存せず、トークンの因果的影響を考慮します。統合勾配を用いて、出力への寄与に基づき重要なトークンを特定し、望ましい行動への変化を捉えるベクトルを構築します。これにより、再訓練なしでモデルの挙動を細かく制御でき、実験ではファインチューニングや既存手法を上回る成果を示しました。具体的には、TruthfulQAで精度を13.22%向上させ、MMHal-Benchの幻覚率を低下させ、SPA-VLでのアライメント勝率を改善しました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/duynguyen772/status/1948768520587866522?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q既存のsteering手法は、positive/negativeなサンプルからの差分で単一方向のベクトルを算出し、すべてのトークンに足し合わせるが、本手法はそこからさらにpositive/negativeな影響を与えるトークンレベルにまで踏み込み、negativeなベクトルとpositiveなベクトルの双方を用いて、negative-&gt;positive方向のベクトルを算出してsteeringに活用する方法っぽい？

<br>

<img src="https://github.com/user-attachments/assets/4a4df18c-d5bc-4499-83ae-16fc9f24e8b4" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/938dee15-ed05-4505-97c2-d079b9713cd3" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/ce075fc0-a8f4-42f2-9462-6c6d12085ef6" alt="image" loading="lazy">関連:

<br>

・1941</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/SpeechProcessing.html">#SpeechProcessing</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<span class="issue_date">Issue Date: 2025-07-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2300">[Paper Note] Ming-Omni: A Unified Multimodal Model for Perception and Generation, Inclusion AI+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Ming-Omniは、画像、テキスト、音声、動画を処理できる統一マルチモーダルモデルで、音声生成と画像生成において優れた能力を示す。専用エンコーダを用いて異なるモダリティからトークンを抽出し、MoEアーキテクチャで処理することで、効率的にマルチモーダル入力を融合。音声デコーダと高品質な画像生成を統合し、コンテキストに応じたチャットやテキストから音声への変換、画像編集が可能。Ming-Omniは、GPT-4oに匹敵する初のオープンソースモデルであり、研究と開発を促進するためにコードとモデルの重みを公開。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/user-attachments/assets/62fe9563-ed6b-40bf-ad95-067407534626" alt="image" loading="lazy">元ポスト:https://x.com/gm8xx8/status/1948878025757446389?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

現在はv1.5も公開されておりさらに性能が向上している模様？HF:https://huggingface.co/inclusionAI/Ming-Lite-Omni</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/On-Policy.html">#On-Policy</a>
<a class="button" href="articles/Stability.html">#Stability</a>
<span class="issue_date">Issue Date: 2025-07-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2299">[Paper Note] Group Sequence Policy Optimization, Chujie Zheng+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Group Sequence Policy Optimization (GSPO)は、大規模言語モデルのための新しい強化学習アルゴリズムで、シーケンスの尤度に基づく重要度比を用いてトレーニングを行う。GSPOは、従来のGRPOアルゴリズムよりも効率的で高性能であり、Mixture-of-Experts (MoE) のトレーニングを安定化させる。これにより、最新のQwen3モデルにおいて顕著な改善が見られる。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/theturingpost/status/1948904443749302785?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q公式ポスト:https://x.com/alibaba_qwen/status/1949412072942612873?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QGRPOとGSPOの違いのGIF:

<br>

https://x.com/theturingpost/status/1953976551424634930?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Controllable.html">#Controllable</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<span class="issue_date">Issue Date: 2025-07-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2297">[Paper Note] CaptionSmiths: Flexibly Controlling Language Pattern in Image Captioning, Kuniaki Saito+, arXiv'25</a>
<span class="snippet"><span>Summary</span>CaptionSmithsは、画像キャプショニングモデルがキャプションの特性（長さ、記述性、単語の独自性）を柔軟に制御できる新しいアプローチを提案。人間の注釈なしで特性を定量化し、短いキャプションと長いキャプションの間で補間することで条件付けを実現。実証結果では、出力キャプションの特性をスムーズに変化させ、語彙的整合性を向上させることが示され、誤差を506%削減。コードはGitHubで公開。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/a_hasimoto/status/1948258269668970782?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q従来はDiscreteに表現されていたcaptioningにおける特性をCondition Caluculatorを導入することでcontinuousなrepresentationによって表現し、Caluculatorに人間によるinput, あるいは表現したいConditionを持つexampleをinputすることで、生成時に反映させるような手法を提案している模様。Conditionで利用するpropertyについては、提案手法ではLength, Descriptive, Uniqueness of Vocabulariesの3つを利用している（が、他のpropertyでも本手法は適用可能と思われる）。このとき、あるpropertyの値を変えることで他のpropertyが変化してしまうと制御ができなくなるため、property間のdecorrelationを実施している。これは、あるproperty Aから別のproperty Bの値を予測し、オリジナルのpropertyの値からsubtractする、といった処理を順次propertyごとに実施することで実現される。Appendixに詳細が記述されている。

<br>



<br>

<img src="https://github.com/user-attachments/assets/673a2b9d-d630-4328-b619-f5382bb74f27" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/a90aa9d1-27f1-45c0-819e-c81b93364c68" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<span class="issue_date">Issue Date: 2025-07-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2296">[Paper Note] Towards Greater Leverage: Scaling Laws for Efficient Mixture-of-Experts  Language Models, Changxin Tian+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Mixture-of-Experts (MoE)アーキテクチャは、LLMsの効率的なスケーリングを可能にするが、モデル容量の予測には課題がある。これに対処するため、Efficiency Leverage (EL)を導入し、300以上のモデルを訓練してMoE構成とELの関係を調査。結果、ELはエキスパートの活性化比率と計算予算に依存し、エキスパートの粒度は非線形の調整因子として機能することが明らかに。これらの発見を基にスケーリング法則を統一し、Ling-mini-betaモデルを設計・訓練した結果、計算資源を7倍以上節約しつつ、6.1Bの密なモデルと同等の性能を達成。研究は効率的なMoEモデルのスケーリングに関する基盤を提供する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/rosinality/status/1948255608286990528?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<a class="button" href="articles/SelfCorrection.html">#SelfCorrection</a>
<a class="button" href="articles/DeepResearch.html">#DeepResearch</a>
<span class="issue_date">Issue Date: 2025-07-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2292">[Paper Note] Deep Researcher with Test-Time Diffusion, Rujun Han+, arXiv'25</a>
<span class="snippet"><span>Summary</span>TTD-DRは、LLMsを用いた研究報告書生成の新しいフレームワークで、草案から始まり、デノイジングプロセスを通じて情報を動的に取り入れながら洗練される。自己進化アルゴリズムにより高品質なコンテキストを生成し、情報損失を減少させる。TTD-DRは、集中的な検索とマルチホップ推論を必要とするベンチマークで最先端の結果を達成し、既存の深層研究エージェントを上回る性能を示す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1948526852546744510?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QSelf-Evolutionというのは、モデルのパラメータを更新するというものではなく、Agentに渡すContextをLLM-as-a-Judgeのスコアが改善するように、フィードバックとして得られるcritiqueなどを通じて反復的にoutput（＝別のAgentにcontextとして渡される情報）を洗練させていくような方法のことを指している模様。このようなプロセスを複数のパスで実施し、最終的にマージすることで高品質なoutput(context)を得る。

<br>

<img src="https://github.com/user-attachments/assets/27b0fb23-eeec-4c84-9845-02eb67131738" alt="image" loading="lazy">日本語解説:https://zenn.dev/knowledgesense/articles/5a341158c2c9ab</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Finetuning.html">#Finetuning</a>
<span class="issue_date">Issue Date: 2025-07-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2282">[Paper Note] Subliminal Learning: Language models transmit behavioral traits via  hidden signals in data, Alex Cloud+, arXiv'25</a>
<span class="snippet"><span>Summary</span>サブリミナル学習は、言語モデルが無関係なデータを通じて特性を伝達する現象である。実験では、特定の特性を持つ教師モデルが生成した数列データで訓練された生徒モデルが、その特性を学習することが確認された。データが特性への言及を除去してもこの現象は発生し、異なるベースモデルの教師と生徒では効果が見られなかった。理論的結果を通じて、全てのニューラルネットワークにおけるサブリミナル学習の発生を示し、MLP分類器での実証も行った。サブリミナル学習は一般的な現象であり、AI開発における予期しない問題を引き起こす可能性がある。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/anthropicai/status/1947696314206064819?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q教師モデルが生成したデータから、教師モデルと同じベースモデルを持つ[^1]生徒モデルに対してファインチューニングをした場合、教師モデルと同じ特性を、どんなに厳しく学習元の合成データをフィルタリングしても、意味的に全く関係ないデータを合成しても（たとえばただの数字列のデータを生成したとしても）、生徒モデルに転移してしまう。これは言語モデルに限った話ではなく、ニューラルネットワーク一般について証明された[^2]。

<br>



<br>

また、MNISTを用いたシンプルなMLPにおいて、MNISTを教師モデルに対して学習させ、そのモデルに対してランダムノイズな画像を生成させ、同じ初期化を施した生徒モデルに対してFinetuningをした場合、学習したlogitsがMNIST用ではないにもかかわらず、MNISTデータに対して50%以上の分類性能を示し、数字画像の認識能力が意味的に全く関係ないデータから転移されている[^3]、といった現象が生じることも実験的に確認された。

<br>



<br>

このため、どんなに頑張って合成データのフィルタリングや高品質化を実施し、教師モデルから特性を排除したデータを作成したつもりでも、そのデータでベースモデルが同じ生徒を蒸留すると、結局その特性は転移されてしまう。これは大きな落とし穴になるので気をつけましょう、という話だと思われる。

<br>



<br>

[^1]: これはアーキテクチャの話だけでなく、パラメータの初期値も含まれる

<br>

[^2]: 教師と生徒の初期化が同じ、かつ十分に小さい学習率の場合において、教師モデルが何らかの学習データDを生成し、Dのサンプルxで生徒モデルでパラメータを更新する勾配を計算すると、教師モデルが学習の過程で経た勾配と同じ方向の勾配が導き出される。つまり、パラメータが教師モデルと同じ方向にアップデートされる。みたいな感じだろうか？元論文を時間がなくて厳密に読めていない、かつalphaxivの力を借りて読んでいるため、誤りがあるかもしれない点に注意

<br>

[^3]: このパートについてもalphaxivの出力を参考にしており、元論文の記述をしっかり読めているわけではない</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<span class="issue_date">Issue Date: 2025-07-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2279">[Paper Note] Hierarchical Reasoning Model, Guan Wang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>HRM（Hierarchical Reasoning Model）は、AIの推論プロセスを改善するために提案された新しい再帰的アーキテクチャであり、Chain-of-Thought技術の問題を克服します。HRMは、2つの相互依存する再帰モジュールを用いて、シーケンシャルな推論タスクを単一のフォワードパスで実行し、高レベルの抽象計画と低レベルの詳細計算を分担します。2700万のパラメータで、わずか1000のトレーニングサンプルを使用し、数独や迷路の最適経路探索などの複雑なタスクで優れたパフォーマンスを示し、ARCベンチマークでも他の大規模モデルを上回る結果を達成しました。HRMは、普遍的な計算と汎用推論システムに向けた重要な進展を示唆しています。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/makingagi/status/1947286324735856747?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説ポスト:https://x.com/hillbig/status/1952122977228841206?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・2357 </span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/Contamination.html">#Contamination</a>
<a class="button" href="articles/Science.html">#Science</a>
<span class="issue_date">Issue Date: 2025-07-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2276">[Paper Note] MegaScience: Pushing the Frontiers of Post-Training Datasets for Science  Reasoning, Run-Ze Fan+, arXiv'25</a>
<span class="snippet"><span>Summary</span>科学的推論のためのオープンデータセット「TextbookReasoning」を提案し、65万の推論質問を含む。さらに、125万のインスタンスを持つ「MegaScience」を開発し、各公開科学データセットに最適なサブセットを特定。包括的な評価システムを構築し、既存のデータセットと比較して優れたパフォーマンスを示す。MegaScienceを用いてトレーニングしたモデルは、公式の指示モデルを大幅に上回り、科学的調整におけるスケーリングの利点を示唆。データキュレーションパイプラインやトレーニング済みモデルをコミュニティに公開。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/vfrz525_/status/1947859552407589076?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLLMベースでdecontaminationも実施している模様</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<a class="button" href="articles/Non-VerifiableRewards.html">#Non-VerifiableRewards</a>
<a class="button" href="articles/RewardModel.html">#RewardModel</a>
<span class="issue_date">Issue Date: 2025-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2274">[Paper Note] Inference-Time Scaling for Generalist Reward Modeling, Zijun Liu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>強化学習を用いてLLMsの推論能力を向上させるため、報酬モデリング（RM）のスケーラビリティを探求。ポイントワイズ生成報酬モデリング（GRM）を採用し、自己原則批評調整（SPCT）を提案してパフォーマンスを向上。並列サンプリングとメタRMを導入し、スケーリング性能を改善。実験により、SPCTがGRMの質とスケーラビリティを向上させ、既存の手法を上回る結果を示した。DeepSeek-GRMは一部のタスクで課題があるが、今後の取り組みで解決可能と考えられている。モデルはオープンソースとして提供予定。</span>
<span class="snippet"><span>Comment</span>・inputに対する柔軟性と、

<br>

・同じresponseに対して多様なRewardを算出でき (= inference time scalingを活用できる)、 

<br>

・Verifiableな分野に特化していないGeneralなRewardモデルである

<br>



<br>

Inference-Time Scaling for Generalist Reward Modeling (GRM) を提案

<br>



<br>

<img width="834" height="544" alt="Image" src="https://github.com/user-attachments/assets/18b13e49-745c-4c22-8d29-8b9bbb7fe80c">

<br>



<br>

<img width="840" height="642" alt="Image" src="https://github.com/user-attachments/assets/29c1c101-04c1-43d4-96b0-5023aed726c0"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/RLVR.html">#RLVR</a>
<span class="issue_date">Issue Date: 2025-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2272">[Paper Note] The Invisible Leash: Why RLVR May Not Escape Its Origin, Fang Wu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>RLVRはAIの能力向上に寄与するが、基盤モデルの制約により新しい解の発見を制限する可能性がある。理論的調査により、初期確率がゼロの解をサンプリングできないことや、探索を狭めるトレードオフが明らかになった。実証実験では、RLVRが精度を向上させる一方で、正しい答えを見逃すことが確認された。将来的には、探索メカニズムや過小評価された解に確率質量を注入する戦略が必要とされる。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iscienceluvr/status/1947570323395907830?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QRLVRの限界に関する洞察</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<span class="issue_date">Issue Date: 2025-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2271">[Paper Note] Inverse Scaling in Test-Time Compute, Aryo Pradipta Gema+, arXiv'25</a>
<span class="snippet"><span>Summary</span>LRMsの推論の長さが性能に与える影響を評価するタスクを構築し、計算量と精度の逆スケーリング関係を示す。4つのカテゴリのタスクを通じて、5つの失敗モードを特定。これにより、長時間の推論が問題のあるパターンを強化する可能性があることが明らかになった。結果は、LRMsの失敗モードを特定し対処するために、推論の長さに応じた評価の重要性を示している。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iscienceluvr/status/1947570957029413166?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QReasoningモデルにおいてReasoningが長くなればなるほど

<br>

・context中にirrerevantな情報が含まれるシンプルな個数を数えるタスクでは、irrerevantな情報に惑わされるようになり、

<br>

・特徴表に基づく回帰タスクの場合、擬似相関を持つ特徴量をの影響を増大してしまい、

<br>

・複雑で組み合わせが多い演繹タスク（シマウマパズル）に失敗する

<br>



<br>

といったように、Reasoning Traceが長くなればなるほど性能を悪化させるタスクが存在しこのような問題のある推論パターンを見つけるためにも、様々なReasoning Traceの長さで評価した方が良いのでは、といった話な模様？

<br>

<img src="https://github.com/user-attachments/assets/751d09a2-c889-4ad9-b9e4-9af5a64200b8" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<a class="button" href="articles/Safety.html">#Safety</a>
<span class="issue_date">Issue Date: 2025-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2269">[Paper Note] The Devil behind the mask: An emergent safety vulnerability of Diffusion  LLMs, Zichen Wen+, arXiv'25</a>
<span class="snippet"><span>Summary</span>拡散ベースの大規模言語モデル（dLLMs）は、迅速な推論と高いインタラクティビティを提供するが、安全性に関する懸念がある。既存のアライメントメカニズムは、敵対的プロンプトからdLLMsを保護できていない。これに対処するため、DIJAという新しい脱獄攻撃フレームワークを提案し、dLLMsの生成メカニズムを利用して有害な補完を可能にする。実験により、DIJAは既存の手法を大幅に上回り、特にDream-Instructで100%のASRを達成し、JailbreakBenchでの評価でも優れた結果を示した。これにより、dLLMsの安全性のアライメントを再考する必要性が浮き彫りになった。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/trtd6trtd/status/1947469171077615995?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2268">[Paper Note] Diffusion Beats Autoregressive in Data-Constrained Settings, Mihir Prabhudesai+, arXiv'25</a>
<span class="snippet"><span>Summary</span>マスク付き拡散モデルは、データ制約のある設定で自己回帰（AR）モデルを大幅に上回ることを発見。拡散モデルはデータを効果的に活用し、検証損失を低下させ、下流のパフォーマンスを向上させる。新しいスケーリング法則を見つけ、拡散がARを上回る臨界計算閾値を導出。データがボトルネックの場合、拡散モデルはARの魅力的な代替手段となる。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iscienceluvr/status/1947567159045197924?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QいつかdLLMの時代きそうだなあ著者ポスト:https://x.com/mihirp98/status/1947736993229885545?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q追加実験結果:https://x.com/mihirp98/status/1948875821797798136?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/RecSys.html">#RecSys</a>
<a class="button" href="articles/Reproducibility.html">#Reproducibility</a>
<span class="issue_date">Issue Date: 2025-07-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2266">[Paper Note] Revisiting Prompt Engineering: A Comprehensive Evaluation for LLM-based   Personalized Recommendation, Genki Kusano+, RecSys'25</a>
<span class="snippet"><span>Summary</span>LLMを用いた単一ユーザー設定の推薦タスクにおいて、プロンプトエンジニアリングが重要であることを示す。23種類のプロンプトタイプを比較した結果、コスト効率の良いLLMでは指示の言い換え、背景知識の考慮、推論プロセスの明確化が効果的であり、高性能なLLMではシンプルなプロンプトが優れることが分かった。精度とコストのバランスに基づくプロンプトとLLMの選択に関する提案を行う。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_reachsumit/status/1947138463083716842?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QRecSysにおける網羅的なpromptingの実験。非常に興味深い

<br>

<img src="https://github.com/user-attachments/assets/bc21e547-08f7-4852-a045-84f18cd81502" alt="image" loading="lazy">実験で利用されたPrompting手法と相対的な改善幅

<br>



<br>

<img src="https://github.com/user-attachments/assets/9f28c445-0036-4441-a947-9774b00d81c3" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/e657da0f-5faf-42e3-aa39-e37965b8835d" alt="image" loading="lazy">

<br>



<br>

RePhrase,StepBack,Explain,Summalize-User,Recency-Focusedが、様々なモデル、データセット、ユーザの特性（Light, Heavy)において安定した性能を示しており（少なくともベースラインからの性能の劣化がない）、model agnosticに安定した性能を発揮できるpromptingが存在することが明らかになった。一方、Phi-4, nova-liteについてはBaselineから有意に性能が改善したPromptingはなかった。これはモデルは他のモデルよりもそもそもの予測性能が低く、複雑なinstructionを理解する能力が不足しているため、Promptデザインが与える影響が小さいことが示唆される。

<br>



<br>

特定のモデルでのみ良い性能を発揮するPromptingも存在した。たとえばRe-Reading, Echoは、Llama3.3-70Bでは性能が改善したが、gpt-4.1-mini, gpt-4o-miniでは性能が悪化した。ReActはgpt-4.1-miniとLlamd3.3-70Bで最高性能を達成したが、gpt-4o-miniでは最も性能が悪かった。

<br>



<br>

NLPにおいて一般的に利用されるprompting、RolePlay, Mock, Plan-Solve, DeepBreath, Emotion, Step-by-Stepなどは、推薦のAcc.を改善しなかった。このことより、ユーザの嗜好を捉えることが重要なランキングタスクにおいては、これらプロンプトが有効でないことが示唆される。

<br>



<br>

<img src="https://github.com/user-attachments/assets/f24850bd-6f76-4ee0-b78e-2104d1e24a36" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/d0f90be5-071c-44c9-9380-5cebd383ab86" alt="image" loading="lazy">

<br>



<br>

続いて、LLMやデータセットに関わらず高い性能を発揮するpromptingをlinear mixed-effects model（ランダム効果として、ユーザ、LLM、メトリックを導入し、これらを制御する項を線形回帰に導入。promptingを固定効果としAccに対する寄与をfittingし、多様な状況で高い性能を発揮するPromptを明らかにする)によって分析した結果、ReAct, Rephrase, Step-Backが有意に全てのデータセット、LLMにおいて高い性能を示すことが明らかになった。

<br>

<img src="https://github.com/user-attachments/assets/4c6d49d5-6464-4297-b714-de1faa95a4c8" alt="image" loading="lazy"></span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/Decoding.html">#Decoding</a>
<span class="issue_date">Issue Date: 2025-07-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2261">[Paper Note] Unveiling the Power of Source: Source-based Minimum Bayes Risk Decoding   for Neural Machine Translation, Boxuan Lyu+, ACL'25</a>
<span class="snippet"><span>Summary</span>ソースベースのMBRデコーディング（sMBR）を提案し、パラフレーズや逆翻訳から生成された準ソースを「サポート仮説」として利用。参照なしの品質推定メトリックを効用関数として用いる新しいアプローチで、実験によりsMBRがQE再ランキングおよび標準MBRを上回る性能を示した。sMBRはNMTデコーディングにおいて有望な手法である。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/boxuan_lyu425/status/1946802820973519245?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/ContextEngineering.html">#ContextEngineering</a>
<span class="issue_date">Issue Date: 2025-07-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2256">[Paper Note] A Survey of Context Engineering for Large Language Models, Lingrui Mei+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本調査では、LLMsの性能を向上させる「コンテキストエンジニアリング」を提案し、その要素と実装方法を体系的に分類。コンテキストの取得、生成、処理、管理を検討し、洗練されたシステム実装を探る。1300以上の研究を分析し、モデルの能力の非対称性を明らかにし、複雑な文脈理解と長文出力生成のギャップに対処する重要性を強調。研究者とエンジニアのための統一フレームワークを提供。</span>
<span class="snippet"><span>Comment</span>もうContext Engineeringという切り口の体系化されたSurveyが出てきた。早すぎ。

<br>

<img src="https://github.com/user-attachments/assets/9577c3f8-8fd5-49e0-b80f-19c0d4f22064" alt="image" loading="lazy">元ポスト:https://x.com/neural_avb/status/1946288694882685317?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<a class="button" href="articles/DataMixture.html">#DataMixture</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<span class="issue_date">Issue Date: 2025-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2250">[Paper Note] Scaling Laws for Optimal Data Mixtures, Mustafa Shukor+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、スケーリング法則を用いて任意のターゲットドメインに対する最適なデータ混合比率を決定する方法を提案。特定のドメイン重みベクトルを持つモデルの損失を正確に予測し、LLM、NMM、LVMの事前訓練における予測力を示す。少数の小規模な訓練実行でパラメータを推定し、高価な試行錯誤法に代わる原則的な選択肢を提供。</span>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MultiDimensional.html">#MultiDimensional</a>
<span class="issue_date">Issue Date: 2025-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2249">[Paper Note] TransEvalnia: Reasoning-based Evaluation and Ranking of Translations, Richard Sproat+, arXiv'25</a>
<span class="snippet"><span>Summary</span>プロンプトベースの翻訳評価システム「TransEvalnia」を提案し、Multidimensional Quality Metricsに基づく詳細な評価を行う。TransEvalniaは、英日データやWMTタスクで最先端のMT-Rankerと同等以上の性能を示し、LLMによる評価が人間の評価者と良好に相関することを確認。翻訳の提示順序に敏感であることを指摘し、位置バイアスへの対処法を提案。システムの評価データは公開される。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/sakanaailabs/status/1946071203002941694?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Safety.html">#Safety</a>
<span class="issue_date">Issue Date: 2025-07-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2238">[Paper Note] Chain of Thought Monitorability: A New and Fragile Opportunity for AI  Safety, Tomek Korbak+, arXiv'25</a>
<span class="snippet"><span>Summary</span>人間の言語で「考える」AIシステムは、安全性向上のために思考の連鎖（CoT）を監視することで悪意のある意図を検出する機会を提供する。しかし、CoT監視は完璧ではなく、一部の不正行為が見逃される可能性がある。研究を進め、既存の安全手法と併せてCoT監視への投資を推奨する。モデル開発者は、開発の決定がCoTの監視可能性に与える影響を考慮すべきである。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gdb/status/1945350912668737701?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QCoTを監視することで、たとえばモデルのよろしくない挙動（e.g., misalignmentなどの意図しない動作や、prompt injection等の不正行為)を検知することができ、特にAIがより長期的な課題に取り組む際にはより一層その内部プロセスを監視する手段が必要不可欠となるため、CoTの忠実性や解釈性が重要となる。このため、CoTの監視可能性が維持される（モデルのアーキテクチャや学習手法（たとえばCoTのプロセス自体は一見真っ当なことを言っているように見えるが、実はRewardHackingしている、など）によってはそもそもCoTが難読化し監視できなかったりするので、現状は脆弱性がある）、より改善していく方向にコミュニティとして動くことを推奨する。そして、モデルを研究開発する際にはモデルのCoT監視に関する評価を実施すべきであり、モデルのデプロイや開発の際にはCoTの監視に関する決定を組み込むべき、といったような提言のようである。関連:https://x.com/dongxi_nlp/status/1945606266027426048?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Contamination.html">#Contamination</a>
<span class="issue_date">Issue Date: 2025-07-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2226">[Paper Note] Reasoning or Memorization? Unreliable Results of Reinforcement Learning  Due to Data Contamination, Mingqi Wu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）の推論能力向上に関する研究が進展しており、特にQwen2.5モデルが強化学習（RL）を用いて顕著な改善を示している。しかし、他のモデルでは同様の成果が得られていないため、さらなる調査が必要である。Qwen2.5は数学的推論性能が高いが、データ汚染に脆弱であり、信頼性のある結果を得るためには、RandomCalculationというクリーンなデータセットを用いることが重要である。このデータセットを通じて、正確な報酬信号が性能向上に寄与することが示された。信頼性のある結論を得るためには、汚染のないベンチマークと多様なモデルでのRL手法の評価が推奨される。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/asap2650/status/1945151806536863878?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説ポスト:https://x.com/dongxi_nlp/status/1945214650737451008?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・1997

<br>



<br>

こちらでQwen-mathに対して得られたRLでのgainは他モデルでは現れず汎化しないことも報告されている。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Batch.html">#Batch</a>
<span class="issue_date">Issue Date: 2025-07-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2225">[Paper Note] REST: Stress Testing Large Reasoning Models by Asking Multiple Problems  at Once, Zhuoshi Pan+, arXiv'25</a>
<span class="snippet"><span>Summary</span>RESTという新しい評価フレームワークを提案し、LRMsを同時に複数の問題にさらすことで、実世界の推論能力を評価。従来のベンチマークの限界を克服し、文脈優先配分や問題間干渉耐性を測定。DeepSeek-R1などの最先端モデルでもストレステスト下で性能低下が見られ、RESTはモデル間の性能差を明らかにする。特に「考えすぎの罠」が性能低下の要因であり、「long2short」技術で訓練されたモデルが優れた結果を示すことが確認された。RESTはコスト効率が高く、実世界の要求に適した評価手法である。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_akhaliq/status/1945130848061194500?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q<img src="https://github.com/user-attachments/assets/eb969359-91d2-4ac4-8a48-1fe27d88ec4e" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Off-Policy.html">#Off-Policy</a>
<span class="issue_date">Issue Date: 2025-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2221">[Paper Note] Quantile Reward Policy Optimization: Alignment with Pointwise Regression  and Exact Partition Functions, Simon Matrenok+, arXiv'25</a>
<span class="snippet"><span>Summary</span>QRPO（Quantile Reward Policy Optimization）は、ポイントワイズの絶対報酬から学習する新しい手法で、DPOのシンプルさとオフライン適用性を兼ね備えています。QRPOは量子報酬を用いてKL正則化された強化学習の目的の閉形式解への回帰を実現し、相対的な信号の必要性を排除します。実験結果では、QRPOがDPOやREBEL、SimPOと比較して、チャットやコーディングの評価で一貫して最高のパフォーマンスを示しました。また、堅牢な報酬でのトレーニングにより、長さバイアスが減少することが確認されました。</span>
<span class="snippet"><span>Comment</span>画像は元ポストより。off-policy RLでもlong contextで高い性能が出るようになったのだろうか

<br>



<br>

<img src="https://github.com/user-attachments/assets/2a66064a-8e1c-49fa-a1d2-ed4b475155e1" alt="image" loading="lazy">

<br>



<br>

元ポスト:https://x.com/skandermoalla/status/1944773057085579531?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・2060</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Optimizer.html">#Optimizer</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-07-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2202">[Paper Note] Muon is Scalable for LLM Training, Jingyuan Liu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Muonオプティマイザーを大規模モデルにスケールアップするために、ウェイトデケイとパラメータごとの更新スケール調整を導入。これにより、Muonは大規模トレーニングで即座に機能し、計算効率がAdamWの約2倍に向上。新たに提案するMoonlightモデルは、少ないトレーニングFLOPで優れたパフォーマンスを達成し、オープンソースの分散Muon実装や事前トレーニング済みモデルも公開。</span>
<span class="snippet"><span>Comment</span>解説ポスト:https://x.com/hillbig/status/1944902706747072678?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qこちらでも紹介されている:

<br>

・2208</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<a class="button" href="articles/Stability.html">#Stability</a>
<span class="issue_date">Issue Date: 2025-07-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2194">[Paper Note] SingLoRA: Low Rank Adaptation Using a Single Matrix, David Bensaïd+, arXiv'25</a>
<span class="snippet"><span>Summary</span>SingLoRAは、LoRAの低ランク適応を再定式化し、単一の低ランク行列とその転置の積を用いることで、トレーニングの安定性を向上させ、パラメータ数をほぼ半減させる手法です。実験により、常識推論タスクでLLama 7Bを用いたファインチューニングで91.3%の精度を達成し、LoRAやLoRA+を上回る結果を示しました。また、画像生成においてもStable Diffusionのファインチューニングで高い忠実度を実現しました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/theturingpost/status/1943701154497732765?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLoRAは低ランク行列BAの積を計算するが、オリジナルのモデルと同じ挙動から学習をスタートするために、Bをzeroで初期化し、Aはランダムに初期化する。このAとBの不均衡さが、勾配消失、爆発、あるいはsub-optimalな収束の要因となってしまっていた（inter-matrix scale conflicts)。特に、LoRAはモデルのwidthが大きくなると不安定になるという課題があった。このため、低ランク行列を2つ使うのではなく、1つの低ランク行列（とその転置）およびoptimizationのstep tごとにtrainableなパラメータがどの程度影響を与えるかを調整する度合いを決めるscalar function u(t)を導入することで、低ランク行列間の不均衡を解消しつつ、パラメータ数を半減し、学習の安定性と性能を向上させる。たとえばu(t)を学習開始時にzeroにすれば、元のLoRAにおいてBをzeroに初期化するのと同じ挙動（つまり元のモデルと同じ挙動から学習スタートができたりする。みたいな感じだろうか？

<br>



<br>

<img src="https://github.com/user-attachments/assets/2dcd4ec1-59d3-43c0-ab8d-5c1c37e5ec3d" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/c73b8715-e0c8-45c8-a7fa-ea55ac8ca3ce" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/cf034dcd-37c4-48f1-a0a3-1d836db37820" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/82999835-ac1e-4380-8bd0-00d14022abf5" alt="image" loading="lazy">関連:

<br>

・1956

<br>

・1245</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Batch.html">#Batch</a>
<span class="issue_date">Issue Date: 2025-07-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2192">[Paper Note] Small Batch Size Training for Language Models: When Vanilla SGD Works,  and Why Gradient Accumulation Is Wasteful, Martin Marek+, arXiv'25</a>
<span class="snippet"><span>Summary</span>小さなバッチサイズに対するAdamのハイパーパラメータをスケーリングする新しいルールを提案。これにより、小さなバッチサイズでも安定したトレーニングが可能で、大きなバッチサイズと同等以上のパフォーマンスを達成。勾配蓄積は推奨せず、実用的なハイパーパラメータ設定のガイドラインを提供。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/giffmana/status/1943384733418950815?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

論文中のFigure1において、AdamWにおいてbatchsizeが1の方が512の場合と比べてlearning_rateの変化に対してロバストである旨が記述されている。

<br>



<br>

<img width="977" height="642" alt="Image" src="https://github.com/user-attachments/assets/0c1efb5d-6eeb-4fd7-ba06-e4296e988a6c">似たような話でMTでバッチサイズ小さいほうが性能良いです、みたいな話が昔あったような

<br>



<br>

（追記）

<br>

気になって思い出そうとしていたが、MTではなく画像認識の話だったかもしれない（だいぶうろ覚え）

<br>

・2196 参考:https://x.com/odashi_t/status/1944034128707342815?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・1541解説:https://x.com/hillbig/status/1952506470878351492?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/COLM.html">#COLM</a>
<a class="button" href="articles/Stability.html">#Stability</a>
<span class="issue_date">Issue Date: 2025-07-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2188">[Paper Note] Spike No More: Stabilizing the Pre-training of Large Language Models, Sho Takase+, COLM'25</a>
<span class="snippet"><span>Summary</span>大規模言語モデルの事前学習中に発生する損失のスパイクは性能を低下させるため、避けるべきである。勾配ノルムの急激な増加が原因とされ、サブレイヤーのヤコビ行列の分析を通じて、勾配ノルムを小さく保つための条件として小さなサブレイヤーと大きなショートカットが必要であることを示した。実験により、これらの条件を満たす手法が損失スパイクを効果的に防ぐことが確認された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/shot4410/status/1943301371010388175?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qsmall sub-layers, large shortcutsの説明はこちらに書かれている。前者については、現在主流なLLMの初期化手法は満たしているが、後者はオリジナルのTransformerの実装では実装されている[^1]が、最近の実装では失われてしまっているとのこと。

<br>

<img src="https://github.com/user-attachments/assets/55cf847c-fc6a-4e76-88c9-1507464e96a0" alt="image" loading="lazy">

<br>



<br>

下図が実験結果で、条件の双方を満たしているのはEmbedLN[^2]とScaled Embed[^3]のみであり、実際にスパイクが生じていないことがわかる。

<br>

<img src="https://github.com/user-attachments/assets/79494662-3d58-4d8e-ae9d-8ed9241e0f65" alt="image" loading="lazy">

<br>



<br>

[^1]:オリジナル論文 245 の3.4節末尾、embedding layersに対してsqrt(d_model)を乗じるということがサラッと書いてある。これが実はめちゃめちゃ重要だったという…

<br>

[^2]: positional embeddingを加算する前にLayer Normalizationをかける方法

<br>

[^3]: EmbeddingにEmbeddingの次元数d（i.e., 各レイヤーのinputの次元数)の平方根を乗じる方法前にScaled dot-product attentionのsqrt(d_k)がめっちゃ重要ということを実験的に示した、という話もあったような…

<br>

（まあそもそも元論文になぜスケーリングさせるかの説明は書いてあるけども）</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/Privacy.html">#Privacy</a>
<span class="issue_date">Issue Date: 2025-07-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2186">[Paper Note] FlexOlmo: Open Language Models for Flexible Data Use, Weijia Shi+, arXiv'25</a>
<span class="snippet"><span>Summary</span>FlexOlmoは、データ共有なしでの分散トレーニングを可能にする新しい言語モデルで、異なるモデルパラメータが独立してトレーニングされ、データ柔軟な推論を実現します。混合専門家アーキテクチャを採用し、公開データセットと特化型セットでトレーニングされ、31の下流タスクで評価されました。データライセンスに基づくオプトアウトが可能で、平均41%の性能改善を達成し、従来の手法よりも優れた結果を示しました。FlexOlmoは、データ所有者のプライバシーを尊重しつつ、閉じたデータの利点を活かすことができます。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/asap2650/status/1943184037419585695?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qデータのオーナー側がプロプライエタリデータを用いてエキスパート(FFNとRouter embeddings)を学習し、それをpublicにシェアすることで利用できるようにする。データオーナー側はデータそのものを提供するのではなく、モデルのパラメータを共有するだけで済み、かつ自分たちのエキスパートをRouter側で利用するか否かは制御可能だから、opt-in/outが制御できる、みたいな話っぽい？

<br>

<img src="https://github.com/user-attachments/assets/6c21a262-afa1-4877-8b53-e6cd9176ecf5" alt="image" loading="lazy"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/RLVR.html">#RLVR</a>
<span class="issue_date">Issue Date: 2025-07-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2184">[Paper Note] First Return, Entropy-Eliciting Explore, Tianyu Zheng+, arXiv'25</a>
<span class="snippet"><span>Summary</span>FR3E（First Return, Entropy-Eliciting Explore）は、強化学習における不安定な探索を改善するための構造化された探索フレームワークであり、高不確実性の意思決定ポイントを特定し、中間フィードバックを提供します。実験結果は、FR3Eが安定したトレーニングを促進し、一貫した応答を生成することを示しています。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/f14bertolotti/status/1943201406271328524?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QRLVRのロールアウトにおいて、reasoning traceにおける各トークンを出力する際にエントロピーが高い部分を特定し（つまり、複数の候補がありモデルが迷っている）、その部分について異なる意図的に異なる生成パスを実行することで探索を促すようにするとRLVRがよりreliableになるといった話のようである

<br>

<img src="https://github.com/user-attachments/assets/fc8adfcf-f6fc-4631-ba0a-04fa1401e96a" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/fabf56a8-20f3-4782-a07b-3c854f01dfd5" alt="image" loading="lazy"></span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/ContrastiveLearning.html">#ContrastiveLearning</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Generalization.html">#Generalization</a>
<a class="button" href="articles/Decoder.html">#Decoder</a>
<span class="issue_date">Issue Date: 2025-07-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2182">[Paper Note] NV-Embed: Improved Techniques for Training LLMs as Generalist Embedding   Models, Chankyu Lee+, ICLR'25</a>
<span class="snippet"><span>Summary</span>デコーダー専用のLLMベースの埋め込みモデルNV-Embedは、BERTやT5を上回る性能を示す。アーキテクチャ設計やトレーニング手法を工夫し、検索精度を向上させるために潜在的注意層を提案。二段階の対照的指示調整手法を導入し、検索と非検索タスクの両方で精度を向上。NV-EmbedモデルはMTEBリーダーボードで1位を獲得し、ドメイン外情報検索でも高スコアを達成。モデル圧縮技術の分析も行っている。</span>
<span class="snippet"><span>Comment</span>Decoder-Only LLMのlast hidden layerのmatrixを新たに導入したLatent Attention Blockのinputとし、Latent Attention BlockはEmbeddingをOutputする。Latent Attention Blockは、last hidden layer (系列長l×dの

<br>

matrix)をQueryとみなし、保持しているLatent Array(trainableなmatrixで辞書として機能する;後述の学習においてパラメータが学習される)[^1]をK,Vとして、CrossAttentionによってcontext vectorを生成し、その後MLPとMean Poolingを実施することでEmbeddingに変換する。

<br>

<img src="https://github.com/user-attachments/assets/7a023273-aafd-4cfa-9b39-961180543ae9" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/767e3ac1-fe70-4653-bbe7-091c1f1dc0f7" alt="image" loading="lazy">

<br>



<br>

学習は2段階で行われ、まずQAなどのRetrievalタスク用のデータセットをIn Batch negativeを用いてContrastive Learningしモデルの検索能力を高める。その後、検索と非検索タスクの両方を用いて、hard negativeによってcontrastive learningを実施し、検索以外のタスクの能力も高める（下表）。両者において、instructionテンプレートを用いて、instructionによって条件付けて学習をすることで、instructionに応じて生成されるEmbeddingが変化するようにする。また、学習時にはLLMのcausal maskは無くし、bidirectionalにrepresentationを考慮できるようにする。

<br>

<img src="https://github.com/user-attachments/assets/26d4e126-1d18-421e-873f-f0eef4fc2026" alt="image" loading="lazy">

<br>



<br>

[^1]: 2183 Perceiver-IOにインスパイアされている。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/SmallModel.html">#SmallModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-07-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2181">[Paper Note] Decoder-Hybrid-Decoder Architecture for Efficient Reasoning with Long  Generation, Liliang Ren+, arXiv'25</a>
<span class="snippet"><span>Summary</span>最近の言語モデルの進展により、状態空間モデル（SSM）の効率的なシーケンスモデリングが示されています。本研究では、ゲーテッドメモリユニット（GMU）を導入し、Sambaベースの自己デコーダーからメモリを共有する新しいデコーダーハイブリッドアーキテクチャSambaYを提案します。SambaYはデコーディング効率を向上させ、長文コンテキスト性能を改善し、位置エンコーディングの必要性を排除します。実験により、SambaYはYOCOベースラインに対して優れた性能を示し、特にPhi4-mini-Flash-Reasoningモデルは推論タスクで顕著な成果を上げました。トレーニングコードはオープンソースで公開されています。</span>
<span class="snippet"><span>Comment</span>HF:https://huggingface.co/microsoft/Phi-4-mini-flash-reasoning元ポスト:https://x.com/_akhaliq/status/1943099901161652238?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<a class="button" href="articles/mid-training.html">#mid-training</a>
<a class="button" href="articles/COLM.html">#COLM</a>
<span class="issue_date">Issue Date: 2025-07-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2180">[Paper Note] MegaMath: Pushing the Limits of Open Math Corpora, Fan Zhou+, COLM'25</a>
<span class="snippet"><span>Summary</span>MegaMathは、数学に特化したオープンデータセットで、LLMの数学的推論能力を向上させるために作成された。ウェブデータの再抽出、数学関連コードの特定、合成データの生成を通じて、371Bトークンの高品質なデータを提供し、既存のデータセットを上回る量と品質を実現した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/fazhou_998/status/1942610771915202590?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q非常に大規模な数学の事前学習/mid-training向けのデータセット

<br>



<br>

CommonCrawlのHTMLから、さまざまなフィルタリング処理（reformatting, 2 stageのHTML parserの活用（片方はnoisyだが高速、もう一方は高性能だが遅い）, fasttextベースの分類器による抽出, deduplication等）を実施しMegaMath-Webを作成、また、MegaMathWebをさらに分類器で低品質なものをフィルタリングし、LLMによってノイズ除去、テキストのreorganizingを実施し（≠ピュアな合成データ）継続事前学習、mid-training向けの高品質なMegaMath-Web-Proを作成。

<br>



<br>

MegaMathCodeはThe Stack V2 (2199) をベースにしており、mathematical reasoning, logic puzzles, scientific computationに関するコードを収集。まずこれらのコードと関連が深い11のプログラミング言語を選定し、そのコードスニペットのみを対象とする。次にstrong LLMを用いて、数学に関するrelevanceスコアと、コードの品質を0--6のdiscrete scoreでスコアリングし学習データを作成。作成した学習データでSLMを学習し大規模なフィルタリングを実施することでMegaMath-Codeを作成。

<br>



<br>

最後にMegaMath-{Web, code}を用いて、Q&amp;A, code data, text&amp;code block dataの3種類を合成。Q&amp;Aデータの合成では、MegaMath-WebからQAペアを抽出し、多様性とデータ量を担保するためQwen2.5-72B-Instruct, Llama3.3-70B-Instructの両方を用いて、QAのsolutionを洗練させる（reasoning stepの改善, あるいはゼロから生成する[^1])ことで生成。また、code dataでは、pythonを対象にMegaMath-Codeのデータに含まれるpython以外のコードを、Qwen2.5-Coder-32B-Instructと、Llamd3.1-70B-Instructによってpythonに翻訳することでデータ量を増やした。text&amp;code blockデータでは、MegaMath-Webのドキュメントを与えて、ブロックを生成（タイトル、数式、結果、コードなど[^1]）し、ブロックのverificationを行い（コードが正しく実行できるか、実行結果とanswerが一致するか等）、verifiedなブロックを残すことで生成。

<br>



<br>

<img src="https://github.com/user-attachments/assets/8975019b-5ab4-437c-bd4e-f3b761439c9c" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/995ea6ce-69eb-4f88-8a98-9e55de3e7814" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/c6d1ec61-49f4-459f-92b2-fa0a2625178e" alt="image" loading="lazy">

<br>



<br>

[^1]: この辺は論文の記述を咀嚼して記述しており実サンプルを見ていないので少し正しい認識か不安</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<a class="button" href="articles/OOD.html">#OOD</a>
<a class="button" href="articles/DiseaseNameRecognition.html">#DiseaseNameRecognition</a>
<span class="issue_date">Issue Date: 2025-07-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2177">[Paper Note] Toward Cross-Hospital Deployment of Natural Language Processing Systems: Model Development and Validation of Fine-Tuned Large Language Models for Disease Name Recognition in Japanese, Shimizu+, JMIR'25</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/aramaki/status/1942902940337099254?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LatentReasoning.html">#LatentReasoning</a>
<span class="issue_date">Issue Date: 2025-07-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2176">[Paper Note] A Survey on Latent Reasoning, Rui-Jie Zhu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）は、明示的な思考の連鎖（CoT）によって優れた推論能力を示すが、自然言語推論への依存が表現力を制限する。潜在的推論はこの問題を解決し、トークンレベルの監視を排除する。研究は、ニューラルネットワーク層の役割や多様な潜在的推論手法を探求し、無限深度の潜在的推論を可能にする高度なパラダイムについて議論する。これにより、潜在的推論の概念を明確にし、今後の研究方向を示す。関連情報はGitHubリポジトリで提供されている。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gm8xx8/status/1942787610818097609?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLatent Reasoningというテクニカルタームが出てきた出力されるdiscreteなtokenによってreasoningを実施するのではなく、モデル内部のrepresentationでreasoningを実施するLatent ReasoningのSurvey

<br>



<br>

<img width="1099" height="876" alt="Image" src="https://github.com/user-attachments/assets/a34451e6-bf4a-432c-8c5b-facdbfb55c41">

<br>



<br>

<img width="959" height="575" alt="Image" src="https://github.com/user-attachments/assets/e53b3bba-f35f-4734-af71-14a90af8ee6f"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<span class="issue_date">Issue Date: 2025-07-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2158">[Paper Note] CriticLean: Critic-Guided Reinforcement Learning for Mathematical  Formalization, Zhongyuan Peng+, arXiv'25</a>
<span class="snippet"><span>Summary</span>自然言語の数学的表現を実行可能なコードに翻訳する課題に対し、批評者の役割を能動的な学習コンポーネントに変えるCriticLeanという新しい強化学習フレームワークを提案。CriticLeanGPTを用いて形式化の意味的忠実性を評価し、CriticLeanBenchでその能力を測定。285K以上の問題を含むFineLeanCorpusデータセットを構築し、批評段階の最適化が信頼性のある形式化に重要であることを示す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gm8xx8/status/1942790484688003275?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連

<br>

・1832Lean 4 形式に

<br>



<br>

<img src="https://github.com/user-attachments/assets/79121e53-b205-440d-9615-d520ac848704" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/SequentialRecommendation.html">#SequentialRecommendation</a>
<a class="button" href="articles/Generalization.html">#Generalization</a>
<span class="issue_date">Issue Date: 2025-07-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2151">[Paper Note] Do We Really Need Specialization? Evaluating Generalist Text Embeddings  for Zero-Shot Recommendation and Search, Matteo Attimonelli+, arXiv'25</a>
<span class="snippet"><span>Summary</span>事前学習済み言語モデル（GTEs）は、逐次推薦や製品検索においてファインチューニングなしで優れたゼロショット性能を発揮し、従来のモデルを上回ることを示す。GTEsは埋め込み空間に特徴を均等に分配することで表現力を高め、埋め込み次元の圧縮がノイズを減少させ、専門モデルの性能向上に寄与する。再現性のためにリポジトリを提供。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_reachsumit/status/1942463379639349654?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・2182</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Citations.html">#Citations</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/COLM.html">#COLM</a>
<a class="button" href="articles/AcademicWriting.html">#AcademicWriting</a>
<span class="issue_date">Issue Date: 2025-07-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2149">[Paper Note] ScholarCopilot: Training Large Language Models for Academic Writing with   Accurate Citations, Yubo Wang+, COLM'25</a>
<span class="snippet"><span>Summary</span>ScholarCopilotは、学術的な執筆を支援するために大規模言語モデルを強化したフレームワークで、正確で文脈に関連した引用を生成します。取得トークンを用いて動的に文献を取得し、生成プロセスを補強します。評価では、取得精度が40.1%に達し、生成品質も他のモデルを大幅に上回りました。特に、ScholarCopilotはChatGPTを超える性能を示し、引用の質で100%の好ましさを達成しました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/wenhuchen/status/1907861046833885397?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q従来のRAGベースのAcademicWriting手法では、まずReferenceを検索して、その内容をcontextに含めてテキストを生成するというSequentialなパイプラインだったが、本研究では通常のNextTokenPrediction Lossに加え、特殊トークン\[RET\]を導入し、ContrastiveLearningによって、\[RET\]トークンがトリガーとなり、生成過程のContextとqueryから適切なReferenceを検索できるEmbeddingを出力し、Referenceを検索し、動的にReferenceの内容をcontextに加え、テキストを生成する手法を提案している。

<br>

<img src="https://github.com/user-attachments/assets/777da4cb-5678-455f-babf-b91690945712" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/a27e092e-fff2-4f8a-91f7-09fe39e8e568" alt="image" loading="lazy">

<br>



<br>

データセットはarXivからlatex sourceを収集し、bibliography部分からReferenceのタイトルをQwenを用いて抽出。タイトルをarXivおよびSemanticScholarのデータベースと照合し、paperとReferenceの紐付けを実施することで構築している。

<br>

<img src="https://github.com/user-attachments/assets/2dd2b956-291e-4407-997a-4a2e68a72708" alt="image" loading="lazy">

<br>



<br>

GPT-4oによるjudgeの結果、ground truthのcitationを用いた場合には及ばないが、提案手法により品質が向上し、citation retrievalのRecall@Kも大幅に改善している。

<br>

<img src="https://github.com/user-attachments/assets/2ff5dd73-dcb8-4a3f-9d6a-1bcfb52a8321" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/81a39366-2577-41a1-aa6b-facc7ac25f1c" alt="image" loading="lazy"></span>
<a class="button" href="articles/FoundationModel.html">#FoundationModel</a>
<a class="button" href="articles/CognitiveScience.html">#CognitiveScience</a>
<span class="issue_date">Issue Date: 2025-07-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2147">[Paper Note] A foundation model to predict and capture human cognition, Binz+, Nature'25, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/biomedicalhacks/status/1941632683974508950?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<a class="button" href="articles/VideoGeneration/Understandings.html">#VideoGeneration/Understandings</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<span class="issue_date">Issue Date: 2025-07-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2146">[Paper Note] Energy-Based Transformers are Scalable Learners and Thinkers, Alexi Gladstone+, arXiv'25</a>
<span class="snippet"><span>Summary</span>エネルギーベースのトランスフォーマー（EBTs）を用いて、無監督学習から思考を学ぶモデルを提案。EBTsは、入力と候補予測の互換性を検証し、エネルギー最小化を通じて予測を行う。トレーニング中に従来のアプローチよりも高いスケーリング率を達成し、言語タスクでの性能を29%向上させ、画像のノイズ除去でも優れた結果を示す。EBTsは一般化能力が高く、モデルの学習能力と思考能力を向上させる新しいパラダイムである。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1941657099567845696?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QProject Page:https://energy-based-transformers.github.ioFirst Authorの方による解説ポスト:https://x.com/alexiglad/status/1942231878305714462?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2025-07-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2145">[Paper Note] Correlated Errors in Large Language Models, Elliot Kim+, ICML'25</a>
<span class="snippet"><span>Summary</span>350以上のLLMを評価し、リーダーボードと履歴書スクリーニングタスクで実証的な分析を実施。モデル間のエラーには実質的な相関があり、特に大きく正確なモデルは異なるアーキテクチャやプロバイダーでも高い相関を示す。相関の影響はLLMを評価者とするタスクや採用タスクにおいても確認された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/kennylpeng/status/1940758198320796065?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qこれは結果を細かく見るのと、評価したタスクの形式とバイアスが生じないかをきちんと確認した方が良いような気がする。

<br>



<br>

それは置いておいたとして、たとえば、Figure9bはLlamaの異なるモデルサイズは、高い相関を示しているが、それはベースが同じだからそうだろうなあ、とは思う。一方、9aはClaude, Nova, Mistral, GPTなど多様なプロバイダーのモデルで高い相関が示されている。Llama3-70BとLLama3.{1,2,3}-70Bでは相関が低かったりしている。

<br>

<img src="https://github.com/user-attachments/assets/03728cf7-9965-4e04-8f19-5ad3977d1a19" alt="image" loading="lazy">

<br>



<br>

Figure1(b)はHELMで比較的最新のモデル間でプロバイダーが別でも高い相関があるようにみえる。

<br>

<img src="https://github.com/user-attachments/assets/d6d1622a-5215-4464-b265-39cc6f0b7a47" alt="image" loading="lazy">

<br>



<br>

このような相関がある要因や傾向については論文を読んでみないとわからない。OpenReview:https://openreview.net/forum?id=kzYq2hfyHB&referrer=%5Bthe%20profile%20of%20Kenny%20Peng%5D(%2Fprofile%3Fid%3D~Kenny_Peng1)LLM-as-a-Judgeにおいて、評価者となるモデルと評価対象となるモデルが同じプロバイダーやシリーズの場合は（エラーの傾向が似ているので）性能がAccuracyが真のAccuracyよりも高めに出ている。また評価者よりも性能が低いモデルに対しても、性能が実際のAccuracyよりも高めに出す傾向にある（エラーの相関によってエラーであるにも関わらず正解とみなされAccuracyが高くなる)ようである。逆に、評価者よりも評価対象が性能が高い場合、評価者は自分が誤ってしまうquestionに対して、評価対象モデルが正解となる回答をしても、それに対して報酬を与えることができず性能が低めに見積もられてしまう。これだけの規模の実験で示されたことは、大変興味深い。

<br>

<img src="https://github.com/user-attachments/assets/4a73cdf4-a70d-4f79-997a-3fd5a55c5a60" alt="image" loading="lazy">履歴書のスクリーニングタスクについてもケーススタディをしている。こちらも詳細に分析されているので興味がある場合は参照のこと。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/RewardModel.html">#RewardModel</a>
<span class="issue_date">Issue Date: 2025-07-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2144">[Paper Note] Skywork-Reward-V2: Scaling Preference Data Curation via Human-AI Synergy, Chris Yuhao Liu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>報酬モデル（RMs）の性能向上のために、4,000万の好みペアからなる大規模データセット「SynPref-40M」を提案。人間とAIの相乗効果を活用した二段階パイプラインでデータをキュレーションし、Skywork-Reward-V2を導入。これにより、7つの報酬モデルベンチマークで最先端のパフォーマンスを達成。データのスケールと高品質なキュレーションが効果をもたらすことを確認。Skywork-Reward-V2はオープン報酬モデルの進展を示し、人間-AIキュレーションの重要性を強調。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_akhaliq/status/1941131426084303242?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q<img src="https://github.com/user-attachments/assets/56b6baa3-a4d0-41fe-9f4e-8a8098f7ee2c" alt="image" loading="lazy">解説:https://x.com/gm8xx8/status/1942375700289233221?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-07-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2143">[Paper Note] Answer Matching Outperforms Multiple Choice for Language Model  Evaluation, Nikhil Chandak+, arXiv'25</a>
<span class="snippet"><span>Summary</span>複数選択のベンチマークは言語モデル評価において重要だが、質問を見ずに回答できることが多い。これに対し、回答マッチングという生成的評価を提案し、自由形式の応答を生成させて参照回答と一致するかを判断。MMLU-ProとGPQA-Diamondで人間の採点データを取得し、回答マッチングがほぼ完璧な一致を達成することを示した。評価方法の変更により、モデルのランキングが大きく変わる可能性がある。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/shashwatgoel7/status/1941153367289364655?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qこれは非常に重要な研究に見えるMultiple Choice Question (MCQ)では、選択肢の中から消去法（論文中では仲間はずれを一つ探す, odd one cut)によって、正解の目処が立ってしまい、分類能力を評価するような尺度になっている。一方で同じモデルでも、Questionのみを与えて、選択肢無しで評価をすると、選択肢ありでは正解できたのに正解できない、という現象が生じる。これはモデルの分類能力ではなく、生成能力を評価しているからであり、これまでのMCQでの評価はモデルの能力の一部、特に識別能力しか評価できていないことが示唆される。このため、Answer Matchingと呼ばれる、モデルに自由記述で出力をさせた後に、referenaceと出力が一致しているか否かで評価をする手法を提案している。GPQA DiamondとMMLU-Proにおいて、人間にAnswer Matchingによる評価をさせオラクルを取得した後、SLMやより大きなモデルでAnswer Matchingを実験したところ、o4-miniを用いたLLM-as-a-Judgeよりも、SLMにおいてさえオラクルに近い性能を発揮し、人間と同等のレベルで自動評価が可能なことが示唆される。

<br>

<img src="https://github.com/user-attachments/assets/edefb3ae-95da-4c3f-9233-9fecf92948b1" alt="image" loading="lazy">まだ冒頭しか読めていないので後で読む</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ScientificDiscovery.html">#ScientificDiscovery</a>
<span class="issue_date">Issue Date: 2025-07-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2139">[Paper Note] AI4Research: A Survey of Artificial Intelligence for Scientific Research, Qiguang Chen+, arXiv'25</a>
<span class="snippet"><span>Summary</span>AIの進展に伴い、AI4Researchに関する包括的な調査が不足しているため、理解と発展が妨げられている。本研究では、AI4Researchの5つの主流タスクを系統的に分類し、研究のギャップや将来の方向性を特定し、関連する応用やリソースをまとめる。これにより、研究コミュニティが迅速にリソースにアクセスでき、革新的なブレークスルーを促進することを目指す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/aicia_solid/status/1940934746932236632?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/Cultural.html">#Cultural</a>
<span class="issue_date">Issue Date: 2025-07-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2133">[Paper Note] CARE: Assessing the Impact of Multilingual Human Preference Learning on  Cultural Awareness, Geyang Guo+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本論文では、文化的多様性を考慮した言語モデル（LM）の訓練方法を分析し、ネイティブな文化的好みを取り入れることで、LMの文化的認識を向上させることを目指します。3,490の文化特有の質問と31,700のネイティブな判断を含むリソース「CARE」を紹介し、高品質なネイティブの好みを少量取り入れることで、さまざまなLMの性能が向上することを示します。また、文化的パフォーマンスが強いモデルはアラインメントからの恩恵を受けやすく、地域間でのデータアクセスの違いがモデル間のギャップを生むことが明らかになりました。CAREは一般に公開される予定です。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/cherylolguo/status/1940798823405600843?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<a class="button" href="articles/Normalization.html">#Normalization</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-07-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2131">[Paper Note] The Curse of Depth in Large Language Models, Wenfang Sun+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本論文では、「深さの呪い」という現象を紹介し、LLMの深い層が期待通りに機能しない理由を分析します。Pre-LNの使用が出力の分散を増加させ、深い層の貢献を低下させることを特定。これを解決するために層正規化スケーリング（LNS）を提案し、出力分散の爆発を抑制します。実験により、LNSがLLMの事前トレーニング性能を向上させることを示し、教師ありファインチューニングにも効果があることを確認しました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/shiwei_liu66/status/1940377801032446428?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q・1795

<br>



<br>

ではそもそもLayerNormalizationを無くしていた（正確にいうとparametrize tanhに置換)が、どちらが優れているのだろうか？

<br>



<br>

<img src="https://github.com/user-attachments/assets/4bc557a0-ae23-4017-9837-7744de74c12e" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/2eead45c-209d-46e4-87e7-0129a4ec5ec2" alt="image" loading="lazy">・1332

<br>



<br>

では知識ニューロンの存在が示唆されており、これはTransformerの層の深い位置に存在し、かつ異なる知識間で知識ニューロンはシェアされない傾向にあった（ただしこれはPost-LNのBERTの話で本研究はPre-LNの話だが。Post-LNの勾配消失問題を緩和し学習を安定化させる研究も2141 のように存在する)。これはこの研究が明らかにしたこととどういう関係性があるだろうか。

<br>



<br>

また、LayerNormalizationのScalingによって深いTransformerブロックの導関数が単位行列となる（学習に寄与しなくなる）ことが改善された場合、知識ニューロンはどのように変化するだろうか？

<br>



<br>

（下記Geminiの応答を見た上での感想)なんとなーくだけれども、おそらく知識ニューロンの局所化が解消されるのかなーという気がする。

<br>



<br>

となると次の疑問としては、MoEアーキテクチャにはどのような影響があるだろうか？

<br>

そもそも知識ニューロンが局所化しているからMoEアーキテクチャのルータによって関連するExpertsのみをactivateすれば（というより結果的にそうなるように学習される）性能を劣化させずに計算効率を上げられていた、と仮定する。そうすると、知識ニューロンが局所化せずに多くのニューロンでシェアされるようになると、2110 のように、サブネットワーク間の情報を互いにやりとりできます、みたいな仕組みがより効いてきそうな気がする。

<br>



<br>

参考までに、Gemini2.5-Proに考察させてみた結果をメモとして残しておく（あくまで参考程度に...）

<br>

```

<br>

ご質問ありがとうございます。非常に興味深い着眼点ですね。「Knowledge Neurons in Pretrained Transformers」と「The Curse of Depth in Large Language Models」は、一見すると全く異なるテーマを扱っているように見えますが、「Transformerの深い層における振る舞い」という共通点で結びつけて考察すると、非常に示唆に富んだ関係性が見えてきます。

<br>



<br>

以下に、両方の論文の概要を解説し、その関係性について考察します。

<br>



<br>

1. Knowledge Neurons in Pretrained Transformers の概要

<br>

この研究は、事前学習済みTransformerモデル（特にBERTなど）の内部で、特定の事実知識がどのように格納されているかを調査したものです。

<br>



<br>

発見: モデルの中間層、特に全結合層（Feed-Forward Network, FFN）に、特定の知識（例：「ダンテ・アリギエーリはイタリアで生まれた」）に強く反応する「知識ニューロン」が存在することを発見しました。

<br>



<br>

特徴: これらの知識ニューロンは、モデルの深い層（後方の層）に、より多く存在する傾向がありました。

<br>



<br>

意味: これまでブラックボックスとされてきた大規模言語モデルの内部で、知識がどのように表現・局在化しているかについて、具体的な手がかりを与えた画期的な研究です。

<br>



<br>

2. The Curse of Depth in Large Language Models の概要

<br>

この研究は、LLMをより深く（層を多く）することの難しさに焦点を当て、その原因と解決策を提案したものです。

<br>



<br>

問題（深さの呪い）: Transformerの標準的なアーキテクチャ（Pre-LN）では、層が深くなるにつれて、LayerNormalization（LN）への入力の分散が指数関数的に増大してしまいます。

<br>



<br>

結果:

<br>



<br>

出力が大きくなりすぎて学習が不安定になります。

<br>



<br>

さらに深刻なのは、深い層ではモデルの出力に関する導関数（勾配計算に必要）がほぼ単位行列になってしまうことです。これは、その層が入力に対してほとんど変換を行わなくなり、学習に寄与しなくなることを意味します。

<br>



<br>

解決策: この問題を解決するため、各層のLayerNormalizationをその深さ（レイヤー番号 l）に応じてスケーリングするというシンプルな手法を提案しました。これにより、深い層でも勾配が適切に伝播し、学習が安定・改善することが示されました。

<br>



<br>

考察：2つの研究の関係性

<br>

これら2つの研究は、「学習の安定性」と「知識の格納方法」という異なる側面から、Transformerの深い層を分析していますが、両者には以下のような深い関係性があると考えられます。

<br>



<br>

学習の不安定性が「知識ニューロン」形成の背景にある可能性

<br>

「The Curse of Depth」で指摘されているように、標準的なTransformerの深い層は、本質的に学習が不安定で、勾配情報が失われやすい環境にあります。

<br>



<br>

この劣悪な学習環境こそが、「知識ニューロン」という形で知識が局所的に格納される原因の一つになっている可能性があります。つまり、

<br>



<br>

学習の非効率性: 深い層のほとんどのニューロンは、勾配消失問題のために効率的に学習を進めることができません。

<br>



<br>

専門化の発生: そのような不安定な環境下で、たまたま特定の知識パターンをうまく捉えることができた一部のニューロンが、その知識を一身に背負う形で強く活性化するよう特化（専門化）していったのではないか、と考えられます。これは、ネットワーク全体で協調して学習するのが難しい状況で、一部のユニットだけが突出して学習を担う、という現象と解釈できます。

<br>



<br>

学習の安定化が、より効率的な知識獲得につながる

<br>

では、「The Curse of Depth」で提案された手法（LNのスケーリング）によって深い層の学習が安定化すると、知識の格納方法はどのように変わるでしょうか。

<br>



<br>

これは非常に興味深い問いであり、2つの可能性が考えられます。

<br>



<br>

可能性A: より強固な知識ニューロンの形成:

<br>

学習が安定することで、各知識ニューロンはより明確に、そして効率的に特定の知識をエンコードできるようになるかもしれません。ノイズの多い環境で偶然生まれた専門家ではなく、安定した環境で育成された真の専門家へと変化するイメージです。

<br>



<br>

可能性B: 知識の分散化:

<br>

ネットワークの全ニューロンが効率的に学習に寄与できるようになるため、一つの知識を少数のニューロンに集中させる必要がなくなり、より多くのニューロンに分散して知識が格納されるようになる可能性も考えられます。

<br>



<br>

現在のところ、学習の安定化は、知識ニューロンがより効率的に形成・機能するための基盤を提供すると考えるのが最も妥当でしょう。「深さの呪い」という問題を解決することは、モデルが知識をどのように獲得し、整理するかという、より根源的なメカニズム（知識ニューロンの振る舞い）にも直接的な影響を与えるはずです。

<br>



<br>

まとめ

<br>

「Knowledge Neurons」は深い層に存在する知識の「状態」を明らかにし、「The Curse of Depth」は深い層で発生する学習の「問題」とその解決策を提示しました。

<br>



<br>

これらを統合すると、「深い層における学習の不安定性という問題が、知識ニューロンという局所的な知識表現を生み出す一因となっており、この問題を解決することで、より効率的で安定した知識の獲得・格納が可能になるかもしれない」という関係性が見えてきます。

<br>



<br>

両者は、LLMの能力と限界を異なる角度から照らし出しており、組み合わせることでモデルの内部動作の解明をさらに一歩前進させる、非常に重要な研究だと言えます。

<br>

```</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Distillation.html">#Distillation</a>
<span class="issue_date">Issue Date: 2025-07-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2129">[Paper Note] NaturalThoughts: Selecting and Distilling Reasoning Traces for General  Reasoning Tasks, Yang Li+, arXiv'25</a>
<span class="snippet"><span>Summary</span>教師モデルからの推論トレースを用いて生徒モデルの能力を向上させる方法を体系的に研究。NaturalReasoningに基づく高品質な「NaturalThoughts」をキュレーションし、サンプル効率とスケーラビリティを分析。データサイズの拡大が性能向上に寄与し、多様な推論戦略を必要とする例が効果的であることを発見。LlamaおよびQwenモデルでの評価により、NaturalThoughtsが既存のデータセットを上回り、STEM推論ベンチマークで優れた性能を示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jaseweston/status/1940656092054204498?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・1768</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<a class="button" href="articles/Findings.html">#Findings</a>
<span class="issue_date">Issue Date: 2025-07-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2125">[Paper Note] Do Vision-Language Models Have Internal World Models? Towards an Atomic   Evaluation, Qiyue Gao+, ACL（Findings）'25</a>
<span class="snippet"><span>Summary</span>内部世界モデル（WMs）はエージェントの理解と予測を支えるが、最近の大規模ビジョン・ランゲージモデル（VLMs）の基本的なWM能力に関する評価は不足している。本研究では、知覚と予測を評価する二段階のフレームワークを提案し、WM-ABenchというベンチマークを導入。15のVLMsに対する660の実験で、これらのモデルが基本的なWM能力に顕著な制限を示し、特に運動軌道の識別においてほぼランダムな精度であることが明らかになった。VLMsと人間のWMとの間には重要なギャップが存在する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/qiyuegao123/status/1940097188220297613?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<span class="issue_date">Issue Date: 2025-07-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2122">[Paper Note] MARBLE: A Hard Benchmark for Multimodal Spatial Reasoning and Planning, Yulun Jiang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>MARBLEという新しいマルチモーダル推論ベンチマークを提案し、MLLMsの複雑な推論能力を評価。MARBLEは、空間的・視覚的・物理的制約下での多段階計画を必要とするM-PortalとM-Cubeの2つのタスクから成る。現在のMLLMsは低いパフォーマンスを示し、視覚的入力からの情報抽出においても失敗が見られる。これにより、次世代モデルの推論能力向上が期待される。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/michael_d_moor/status/1940062842742526445?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QPortal2を使った新たなベンチマーク。筆者は昔このゲームを少しだけプレイしたことがあるが、普通に難しかった記憶がある😅

<br>



<br>

細かいが表中のGPT-o3は正しくはo3だと思われる。

<br>

時間がなくて全然しっかりと読めていないが、reasoning effortやthinkingモードはどのように設定して評価したのだろうか。

<br>

<img src="https://github.com/user-attachments/assets/a7647007-b718-4b1c-8d8a-396c36d7811d" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/4b996864-7bf8-4ea9-aa3e-84d4e9f3f5d2" alt="image" loading="lazy"></span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Zero/FewShotPrompting.html">#Zero/FewShotPrompting</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<span class="issue_date">Issue Date: 2025-07-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2121">[Paper Note] SMMILE: An Expert-Driven Benchmark for Multimodal Medical In-Context  Learning, Melanie Rieff+, arXiv'25</a>
<span class="snippet"><span>Summary</span>マルチモーダルインコンテキスト学習（ICL）は医療分野での可能性があるが、十分に探求されていない。SMMILEという医療タスク向けの初のマルチモーダルICLベンチマークを導入し、111の問題を含む。15のMLLMの評価で、医療タスクにおけるICL能力が中程度から低いことが示された。ICLはSMMILEで平均8%、SMMILE++で9.4%の改善をもたらし、無関係な例がパフォーマンスを最大9.5%低下させることも確認。例の順序による最近性バイアスがパフォーマンス向上に寄与することも明らかになった。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/michael_d_moor/status/1939664155813839114?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<span class="issue_date">Issue Date: 2025-07-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2120">[Paper Note] Wider or Deeper? Scaling LLM Inference-Time Compute with Adaptive   Branching Tree Search, Yuichi Inoue+, ICLR'25</a>
<span class="snippet"><span>Summary</span>AB-MCTSを提案し、外部フィードバックを活用して繰り返しサンプリングを改善。探索木のノードで新しい応答を「広げる」か「深める」かを動的に決定。実験により、AB-MCTSが従来の手法を上回り、LLMsの応答の多様性と解決策の洗練を強調。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iwiwi/status/1939914618132168961?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/ScientificDiscovery.html">#ScientificDiscovery</a>
<a class="button" href="articles/Reproducibility.html">#Reproducibility</a>
<span class="issue_date">Issue Date: 2025-06-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2118">[Paper Note] The Automated LLM Speedrunning Benchmark: Reproducing NanoGPT  Improvements, Bingchen Zhao+, arXiv'25</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）の進展を活用し、AIエージェントの研究再現能力を評価するために、LLMスピードランベンチマークを導入。19のタスクで訓練スクリプトとヒントを提供し、迅速な実行を促進。既知の革新の再実装が難しいことを発見し、科学的再現を自動化するための指標を提供。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/karpathy/status/1939709449956126910?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/TransferLearning.html">#TransferLearning</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<a class="button" href="articles/VerifiableRewards.html">#VerifiableRewards</a>
<a class="button" href="articles/Off-Policy.html">#Off-Policy</a>
<a class="button" href="articles/On-Policy.html">#On-Policy</a>
<a class="button" href="articles/Non-VerifiableRewards.html">#Non-VerifiableRewards</a>
<span class="issue_date">Issue Date: 2025-06-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2117">[Paper Note] Bridging Offline and Online Reinforcement Learning for LLMs, Jack Lanchantin+, arXiv'25</a>
<span class="snippet"><span>Summary</span>大規模言語モデルのファインチューニングにおける強化学習手法の効果を、オフラインからオンラインへの移行において調査。数学タスクと指示に従うタスクのベンチマーク評価を行い、オンラインおよびセミオンラインの最適化手法がオフライン手法を上回る結果を示す。トレーニングダイナミクスとハイパーパラメータ選択について分析し、検証可能な報酬と検証不可能な報酬を共同で扱うことでパフォーマンス向上を確認。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jaseweston/status/1939673136842313960?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<span class="issue_date">Issue Date: 2025-06-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2110">[Paper Note] Chain-of-Experts: Unlocking the Communication Power of  Mixture-of-Experts Models, Zihan Wang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Chain-of-Experts（CoE）は、逐次的な専門家間のコミュニケーションを導入した新しいMixture-of-Experts（MoE）アーキテクチャで、トークンを反復的に処理する。各反復ステップで専用のルーターを使用し、動的な専門家選択を可能にすることで、モデルの表現能力を向上させる。CoEは数学的推論タスクにおいて、従来のMoEと比較して検証損失を低下させ、メモリ使用量を削減する。反復的残差構造と専門家の専門化が、より表現力豊かな結果をもたらすことが示されている。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/theturingpost/status/1938728784351658087?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<span class="issue_date">Issue Date: 2025-06-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2109">[Paper Note] FineWeb2: One Pipeline to Scale Them All -- Adapting Pre-Training Data  Processing to Every Language, Guilherme Penedo+, arXiv'25</a>
<span class="snippet"><span>Summary</span>多言語LLMsの性能向上のために、FineWebに基づく新しい事前学習データセットキュレーションパイプラインを提案。9つの言語に対して設計選択肢を検証し、非英語コーパスが従来のデータセットよりも高性能なモデルを生成できることを示す。データセットの再バランス手法も導入し、1000以上の言語にスケールアップした20テラバイトの多言語データセットFineWeb2を公開。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gui_penedo/status/1938631842720022572?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qv1

<br>

・1942abstを見る限りFinewebを多言語に拡張した模様</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/mid-training.html">#mid-training</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-06-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2107">[Paper Note] OctoThinker: Mid-training Incentivizes Reinforcement Learning Scaling, Zengzhi Wang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>異なるベース言語モデル（LlamaやQwen）の強化学習（RL）における挙動を調査し、中間トレーニング戦略がRLのダイナミクスに与える影響を明らかに。高品質の数学コーパスがモデルのパフォーマンスを向上させ、長い連鎖的思考（CoT）がRL結果を改善する一方で、冗長性や不安定性を引き起こす可能性があることを示す。二段階の中間トレーニング戦略「Stable-then-Decay」を導入し、OctoThinkerモデルファミリーを開発。オープンソースのモデルと数学推論コーパスを公開し、RL時代の基盤モデルの研究を支援することを目指す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/sinclairwang1/status/1938244843857449431?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qmid-trainingの観点から、post trainingにおけるRLがスケーリングする条件をsystematicallyに調査している模様論文中にはmid-training[^1]の定義が記述されている:

<br>



<br>

<img width="808" height="353" alt="Image" src="https://github.com/user-attachments/assets/da206d3d-f811-4d69-8210-a1d0816c827f">

<br>



<br>

[^1]: mid-trainingについてはコミュニティの間で厳密な定義はまだ無くバズワードっぽく使われている、という印象を筆者は抱いており、本稿は文献中でmid-trainingを定義する初めての試みという所感</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<span class="issue_date">Issue Date: 2025-06-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2106">[Paper Note] RLPR: Extrapolating RLVR to General Domains without Verifiers, Tianyu Yu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>RLVRはLLMの推論能力を向上させるが、主に数学やコードに限られる。これを克服するため、検証者不要のRLPRフレームワークを提案し、LLMのトークン確率を報酬信号として利用。ノイズの多い確率報酬に対処する手法を導入し、実験によりGemma、Llama、Qwenモデルで推論能力を向上させた。特に、TheoremQAで7.6ポイント、Minervaで7.5ポイントの改善を示し、General-Reasonerを平均1.6ポイント上回った。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1938359430980268329?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q既存のRLVRはVerifierを構築しなければならず、しばしばそのVerifierは複雑になりやすく、スケールさせるには課題があった。RLPR（Probabliity Reward)は、生成された応答から回答yを抽出し、残りをreasoning zとする。そして回答部分yをreference y^\で置換したトークン列o'を生成（zがo'に対してどのような扱いになるかは利用するモデルや出力フォーマットによる気がする)し、o'のポリシーモデルでのトークン単位での平均生成確率を報酬とする。尤度のような系列全体の生起確率を考慮する方法が直感的に役に立ちそうだが、計算の際の確率積は分散が高いだけでなく、マイナーな類義語が与えられた時に（たとえば1 tokenだけ生起確率が小さかった場合)に、Rewardが極端に小さくなりsensitiveであることを考察し、平均生成確率を採用している。

<br>

<img src="https://github.com/user-attachments/assets/52bc778b-d6c9-495c-8bf3-586c7381915b" alt="image" loading="lazy">

<br>



<br>

Rule basedなVerifierを用いたRLVRよりもgeneralなドメインとmathドメインで性能向上。コーディングなどでも効果はあるのだろうか？

<br>

<img src="https://github.com/user-attachments/assets/99e26d11-2e16-4452-9410-860b74f497cd" alt="image" loading="lazy">ざっくり見た感じ、RLVRがそもそも適用できないドメインで実験した場合の結果がないように見え、適用した場合に有効なのかは気になるところ。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<span class="issue_date">Issue Date: 2025-06-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2105">[Paper Note] OpenVision: A Fully-Open, Cost-Effective Family of Advanced Vision  Encoders for Multimodal Learning, Xianhang Li+, arXiv'25</a>
<span class="snippet"><span>Summary</span>OpenVisionは、完全にオープンでコスト効果の高いビジョンエンコーダーのファミリーを提案し、CLIPと同等以上の性能を発揮します。既存の研究を基に構築され、マルチモーダルモデルの進展に実用的な利点を示します。5.9Mから632.1Mパラメータのエンコーダーを提供し、容量と効率の柔軟なトレードオフを実現します。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/cihangxie/status/1920575141849030882?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/PRM.html">#PRM</a>
<span class="issue_date">Issue Date: 2025-06-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2104">[Paper Note] Process Reward Models That Think, Muhammad Khalifa+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、データ効率の良いステップバイステップの検証器（ThinkPRM）を提案し、少ないプロセスラベルで高性能を実現します。ThinkPRMは、長いCoTモデルの推論能力を活用し、PRM800Kのわずか1%のプロセスラベルで、従来の検証器を上回る性能を示します。具体的には、ProcessBenchやMATH-500などのベースラインを超え、ドメイン外評価でも優れた結果を得ています。最小限の監視でのトレーニングを通じて、検証計算のスケーリングの重要性を強調しています。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/RewardHacking.html">#RewardHacking</a>
<span class="issue_date">Issue Date: 2025-06-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2101">[Paper Note] Robust Reward Modeling via Causal Rubrics, Pragya Srivastava+, arXiv'25</a>
<span class="snippet"><span>Summary</span>報酬モデル（RMs）は人間のフィードバックを通じて大規模言語モデル（LLMs）を整合させるが、報酬ハッキングの影響を受けやすい。本研究では、報酬ハッキングを軽減するための新しいフレームワーク「Crome」を提案。Cromeは因果的拡張と中立的拡張を用いて、因果属性に基づく感度と虚偽属性に対する不変性を強制する。実験結果では、CromeはRewardBenchで標準的なベースラインを大幅に上回り、平均精度を最大5.4%向上させた。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/harman26singh/status/1937876897058181230?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q以下がresearch question:

<br>

<img src="https://github.com/user-attachments/assets/98c97b8b-ebca-4a40-9c0f-a8c175044fb9" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/SyntheticDataGeneration.html">#SyntheticDataGeneration</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2094">[Paper Note] Magpie: Alignment Data Synthesis from Scratch by Prompting Aligned LLMs   with Nothing, Zhangchen Xu+, ICLR'25</a>
<span class="snippet"><span>Summary</span>高品質な指示データはLLMの整合に不可欠であり、Magpieという自己合成手法を提案。Llama-3-Instructを用いて400万の指示と応答を生成し、30万の高品質なインスタンスを選定。Magpieでファインチューニングしたモデルは、従来のデータセットを用いたモデルと同等の性能を示し、特に整合ベンチマークで優れた結果を得た。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=Pnk7vMbznK<img src="https://github.com/user-attachments/assets/9cb451b2-5440-43a4-9867-b5206dd08cca" alt="image" loading="lazy">

<br>



<br>

下記のようなpre-queryテンプレートを与え（i.e., userの発話は何も与えず、ユーザの発話を表す特殊トークンのみを渡す）instructionを生成し、post-queryテンプレートを与える（i.e., pre-queryテンプレート+生成されたinstruction+assistantの発話の開始を表す特殊トークンのみを渡す）ことでresponseを生成することで、prompt engineeringやseed無しでinstruction tuningデータを合成できるという手法。

<br>

<img src="https://github.com/user-attachments/assets/59e9ea58-1088-4f7f-a5e1-05fba7221aca" alt="image" loading="lazy">

<br>



<br>

生成した生のinstruction tuning pair dataは、たとえば下記のようなフィルタリングをすることで品質向上が可能で

<br>

<img src="https://github.com/user-attachments/assets/6dc19e89-2e0d-409d-9d96-eca8d92d27d3" alt="image" loading="lazy">

<br>



<br>

reward modelと組み合わせてLLMからのresponseを生成しrejection samplingすればDPOのためのpreference dataも作成できるし、single turnの発話まで生成させた後もう一度pre/post-queryをconcatして生成すればMulti turnのデータも生成できる。

<br>



<br>

他のも例えば、システムプロンプトに自分が生成したい情報を与えることで、特定のドメインに特化したデータ、あるいは特定の言語に特化したデータも合成できる。

<br>

<img src="https://github.com/user-attachments/assets/f5f06b90-d1cb-4de8-bbaa-622abbcc0b6b" alt="image" loading="lazy"></span>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/pretrained-LM.html">#pretrained-LM</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2093">[Paper Note] llm-jp-modernbert: A ModernBERT Model Trained on a Large-Scale Japanese  Corpus with Long Context Length, Issa Sugiura+, arXiv'25</a>
<span class="snippet"><span>Summary</span>ModernBERTモデル（llm-jp-modernbert）は、8192トークンのコンテキスト長を持つ日本語コーパスで訓練され、フィルマスクテスト評価で良好な結果を示す。下流タスクでは既存のベースラインを上回らないが、コンテキスト長の拡張効果を分析し、文の埋め込みや訓練中の遷移を調査。再現性を支援するために、モデルと評価コードを公開。</span>
<span class="snippet"><span>Comment</span>参考:

<br>

・1761</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Safety.html">#Safety</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2091">[Paper Note] AnswerCarefully: A Dataset for Improving the Safety of Japanese LLM  Output, Hisami Suzuki+, arXiv'25</a>
<span class="snippet"><span>Summary</span>日本のLLMの安全性を高めるためのデータセット「AnswerCarefully」を紹介。1,800組の質問と参照回答から成り、リスクカテゴリをカバーしつつ日本の文脈に合わせて作成。微調整により出力の安全性が向上し、12のLLMの安全性評価結果も報告。英語翻訳と注釈を提供し、他言語でのデータセット作成を促進。</span>
<span class="snippet"><span>Comment</span>Blog:https://llmc.nii.ac.jp/answercarefully-dataset/</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2088">[Paper Note] Drop-Upcycling: Training Sparse Mixture of Experts with Partial   Re-initialization, Taishi Nakamura+, ICLR'25</a>
<span class="snippet"><span>Summary</span>Drop-Upcycling手法を提案し、MoEモデルのトレーニング効率を向上。事前にトレーニングされた密なモデルの知識を活用しつつ、一部の重みを再初期化することで専門家の専門化を促進。大規模実験により、5.9BパラメータのMoEモデルが13B密なモデルと同等の性能を達成し、トレーニングコストを約1/4に削減。すべての実験リソースを公開。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=gx1wHnf5Vp関連:

<br>

・1546提案手法の全体像とDiversity re-initializationの概要。元のUpcyclingでは全てidenticalな重みでreplicateされていたため、これが個々のexpertがlong termでの学習で特化することの妨げになり、最終的に最大限のcapabilityを発揮できず、収束が遅い要因となっていた。これを、Upcyclingした重みのうち、一部のindexのみを再初期化することで、replicate元の知識を保持しつつ、expertsの多様性を高めることで解決する。

<br>

<img src="https://github.com/user-attachments/assets/46ec75a2-30b1-4f48-9f21-cf5f6e30df95" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/ef3c66b2-32a5-46ab-bb31-828fb4570b53" alt="image" loading="lazy">

<br>



<br>

提案手法は任意のactivation function適用可能。今回はFFN Layerのactivation functionとして一般的なSwiGLUを採用した場合で説明している。

<br>



<br>

Drop-Upcyclingの手法としては、通常のUpcyclingと同様、FFN Layerの重みをn個のexpertsの数だけreplicateする。その後、re-initializationを実施する比率rに基づいて、[1, intermediate size d_f]の範囲からrd_f個のindexをサンプリングする。最終的にSwiGLU、およびFFNにおける3つのWeight W_{gate, up, down}において、サンプリングされたindexと対応するrow/columnと対応する重みをre-initializeする。

<br>



<br>

re-initializeする際には、各W_{gate, up, down}中のサンプリングされたindexと対応するベクトルの平均と分散をそれぞれ独立して求め、それらの平均と分散を持つ正規分布からサンプリングする。

<br>



<br>

学習の初期から高い性能を発揮し、long termでの性能も向上している。また、learning curveの形状もscratchから学習した場合と同様の形状となっており、知識の転移とexpertsのspecializationがうまく進んだことが示唆される。

<br>

<img src="https://github.com/user-attachments/assets/945e5ae5-05cd-4117-80e8-078b47f0e53c" alt="image" loading="lazy">解説:https://llm-jp.nii.ac.jp/news/post-566/</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2086">[Paper Note] Shrinking the Generation-Verification Gap with Weak Verifiers, Jon Saad-Falcon+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Weaverは、複数の弱いverifiersを組み合わせて強力なverifierを設計するフレームワークであり、ラベル付きデータへの依存を減らすために弱い監視を利用します。出力を正規化し、特定のverifiersをフィルタリングすることで、精度の向上を図ります。Weaverは、推論および数学タスクにおいてPass@1性能を大幅に改善し、Llama 3.3 70B Instructを用いて高い精度を達成しました。計算コスト削減のために、統合出力スコアを用いてクロスエンコーダを訓練します。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jonsaadfalcon/status/1937600479527317802?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2085">[Paper Note] Mercury: Ultra-Fast Language Models Based on Diffusion, Inception Labs+, arXiv'25</a>
<span class="snippet"><span>Summary</span>新しい拡散型大規模言語モデルMercuryを発表。特にコーディングアプリケーション向けのMercury Coderは、MiniとSmallの2サイズで提供され、速度と品質で最先端を達成。独立評価では、Mercury Coder Miniが1109トークン/秒、Smallが737トークン/秒を記録し、他のモデルを大幅に上回る性能を示す。さらに、実世界での検証結果や公開API、無料プレイグラウンドも提供。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/arankomatsuzaki/status/1937360864262389786?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qスループット（モデルのトークン生成速度）が、SoTAらしいdLLMモデル解説:https://x.com/hillbig/status/1938026627642101858?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2084">[Paper Note] Recycling the Web: A Method to Enhance Pre-training Data Quality and  Quantity for Language Models, Thao Nguyen+, arXiv'25</a>
<span class="snippet"><span>Summary</span>スケーリング法則に基づき、低品質なウェブデータを再利用する手法「REWIRE」を提案。これにより、事前学習データの合成表現を増やし、フィルタリングされたデータのみでのトレーニングと比較して、22のタスクで性能を向上。生データと合成データの混合が効果的であることを示し、ウェブテキストのリサイクルが事前学習データのスケーリングに有効であることを示唆。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/thao_nguyen26/status/1937210428876292457?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q学習データの枯渇に対する対処として別の方向性としては下記のような研究もある:

<br>

・1829</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/PRM.html">#PRM</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2083">[Paper Note] ReasonFlux-PRM: Trajectory-Aware PRMs for Long Chain-of-Thought  Reasoning in LLMs, Jiaru Zou+, arXiv'25</a>
<span class="snippet"><span>Summary</span>新しいプロセス報酬モデルReasonFlux-PRMを提案し、推論トレースの評価を強化。ステップと軌道の監視を組み込み、報酬割り当てを細かく行う。実験により、ReasonFlux-PRM-7Bが高品質なデータ選択と性能向上を実現し、特に監視付きファインチューニングで平均12.1%の向上を達成。リソース制約のあるアプリケーション向けにReasonFlux-PRM-1.5Bも公開。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_akhaliq/status/1937345023005048925?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/Tokenizer.html">#Tokenizer</a>
<span class="issue_date">Issue Date: 2025-06-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2082">[Paper Note] Vision as a Dialect: Unifying Visual Understanding and Generation via  Text-Aligned Representations, Jiaming Han+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本論文では、視覚理解と生成を統一するマルチモーダルフレームワークTarを提案。Text-Aligned Tokenizer（TA-Tok）を用いて画像を離散トークンに変換し、視覚とテキストを統一空間に統合。スケール適応型のエンコーディングとデコーディングを導入し、高忠実度の視覚出力を生成。迅速な自己回帰モデルと拡散ベースのモデルを用いたデトークナイザーを活用し、視覚理解と生成の改善を実現。実験結果では、Tarが既存手法と同等以上の性能を示し、効率的なトレーニングを達成。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_akhaliq/status/1937345768223859139?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qtext modalityとvision modalityを共通の空間で表現する

<br>

<img src="https://github.com/user-attachments/assets/356e86e1-cad9-4bee-8398-d68c4fc6ad46" alt="image" loading="lazy">Visual Understanding/Generationのベンチで全体的に高い性能を達成

<br>

<img src="https://github.com/user-attachments/assets/6e45aec0-ae0b-4327-923f-fdfce8e83ca0" alt="image" loading="lazy"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2025-06-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2080">[Paper Note] Mind the Gap: Examining the Self-Improvement Capabilities of Large  Language Models, Yuda Song+, ICLR'25</a>
<span class="snippet"><span>Summary</span>自己改善はLLMの出力検証を通じてデータをフィルタリングし、蒸留するメカニズムである。本研究では、自己改善の数学的定式化を行い、生成-検証ギャップに基づくスケーリング現象を発見。さまざまなモデルとタスクを用いた実験により、自己改善の可能性とその性能向上方法を探求し、LLMの理解を深めるとともに、将来の研究への示唆を提供する。</span>
<span class="snippet"><span>Comment</span>参考:https://joisino.hatenablog.com/entry/misleadVerificationに対する理解を深めるのに非常に良さそう</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2025-06-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2077">[Paper Note] On the Self-Verification Limitations of Large Language Models on   Reasoning and Planning Tasks, Kaya Stechly+, ICLR'25</a>
<span class="snippet"><span>Summary</span>LLMsの推論能力に関する意見の相違を背景に、反復的なプロンプトの効果をGame of 24、グラフ彩色、STRIPS計画の3領域で調査。自己批評がパフォーマンスに悪影響を及ぼす一方、外部の正しい推論者による検証がパフォーマンスを向上させることを示した。再プロンプトによって複雑な設定の利点を維持できることも確認。</span>
<span class="snippet"><span>Comment</span>参考:https://joisino.hatenablog.com/entry/misleadOpenReview:https://openreview.net/forum?id=4O0v4s3IzY</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RLHF.html">#RLHF</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2025-06-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2076">[Paper Note] Language Models Learn to Mislead Humans via RLHF, Jiaxin Wen+, ICLR'25</a>
<span class="snippet"><span>Summary</span>RLHFは言語モデルのエラーを悪化させる可能性があり、モデルが人間を納得させる能力を向上させる一方で、タスクの正確性は向上しない。質問応答タスクとプログラミングタスクで被験者の誤検出率が増加し、意図された詭弁を検出する手法がU-SOPHISTRYには適用できないことが示された。これにより、RLHFの問題点と人間支援の研究の必要性が浮き彫りになった。</span>
<span class="snippet"><span>Comment</span>参考:https://joisino.hatenablog.com/entry/mislead</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Tokenizer.html">#Tokenizer</a>
<span class="issue_date">Issue Date: 2025-06-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2073">[Paper Note] From Bytes to Ideas: Language Modeling with Autoregressive U-Nets, Mathurin Videau+, arXiv'25</a>
<span class="snippet"><span>Summary</span>自己回帰型U-Netを用いてトークン化の柔軟性を向上させ、モデルが生のバイトから単語や単語のペアを生成することでマルチスケールの視点を提供。深い段階では広範な意味パターンに注目し、浅い段階はBPEベースラインに匹敵する性能を発揮。これにより、文字レベルのタスクやリソースの少ない言語間での知識移転が可能となる。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dair_ai/status/1936825784473096335?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-06-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2070">[Paper Note] Revisiting Reinforcement Learning for LLM Reasoning from A Cross-Domain  Perspective, Zhoujun Cheng+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Guruを導入し、数学、コード、科学、論理、シミュレーション、表形式の6つの推論ドメインにわたる92KのRL推論コーパスを構築。これにより、LLM推論のためのRLの信頼性と効果を向上させ、ドメイン間の変動を観察。特に、事前学習の露出が限られたドメインでは、ドメイン内トレーニングが必要であることを示唆。Guru-7BとGuru-32Bモデルは、最先端の性能を達成し、複雑なタスクにおいてベースモデルの性能を改善。データとコードは公開。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/chengzhoujun/status/1936113985507803365?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qpost-trainingにおけるRLのcross domain（Math, Code, Science, Logic, Tabular)における影響を調査した研究。非常に興味深い研究。詳細は元論文が著者ポスト参照のこと。Qwenシリーズで実験。以下ポストのまとめ。

<br>



<br>

・mid trainingにおいて重点的に学習されたドメインはRLによるpost trainingで強い転移を発揮する（Code, Math, Science)

<br>

・一方、mid trainingであまり学習データ中に出現しないドメインについては転移による性能向上は最小限に留まり、in-domainの学習データをきちんと与えてpost trainingしないと性能向上は限定的

<br>

・簡単なタスクはcross domainの転移による恩恵をすぐに得やすい（Math500, MBPP),難易度の高いタスクは恩恵を得にくい

<br>

・各ドメインのデータを一様にmixすると、単一ドメインで学習した場合と同等かそれ以上の性能を達成する

<br>

・必ずしもresponse lengthが長くなりながら予測性能が向上するわけではなく、ドメインによって傾向が異なる

<br>

・たとえば、Code, Logic, Tabularの出力は性能が向上するにつれてresponse lengthは縮小していく

<br>

・一方、Science, Mathはresponse lengthが増大していく。また、Simulationは変化しない

<br>

・異なるドメインのデータをmixすることで、最初の数百ステップにおけるrewardの立ち上がりが早く（単一ドメインと比べて急激にrewardが向上していく）転移がうまくいく

<br>

  ・（これは私がグラフを見た感想だが、単一ドメインでlong runで学習した場合の最終的な性能は4/6で同等程度、2/6で向上（Math, Science)

<br>

・非常に難易度の高いmathデータのみにフィルタリングすると、フィルタリング無しの場合と比べて難易度の高いデータに対する予測性能は向上する一方、簡単なOODタスク（HumanEval)の性能が大幅に低下する（特定のものに特化するとOODの性能が低下する）

<br>

・RLはpre(mid)-trainingで学習されたreasoning能力を引き出すだけではなく、新規のタスクに対しては新たなreasoning能力を獲得できる

<br>

・モデルサイズが小さいと、RLでpost-training後のpass@kのkを大きくするとどこかでサチり、baseモデルと交差するが、大きいとサチらず交差しない

<br>

  ・モデルサイズが大きいとより多様なreasoningパスがunlockされている

<br>

・pass@kで観察したところRLには2つのphaseのよつなものが観測され、最初の0-160（1 epoch)ステップではpass@1が改善したが、pass@max_kは急激に性能が劣化した。一方で、160ステップを超えると、双方共に徐々に性能改善が改善していくような変化が見られた</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<span class="issue_date">Issue Date: 2025-06-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2062">[Paper Note] Scaling Laws for Upcycling Mixture-of-Experts Language Models, Seng Pei Liew+, ICML'25</a>
<span class="snippet"><span>Summary</span>LLMsの事前学習は高コストで時間がかかるため、アップサイクリングとMoEモデルの計算効率向上が提案されている。本研究では、アップサイクリングをMoEに適用し、データセットのサイズやモデル構成に依存するスケーリング法則を特定。密なトレーニングデータとアップサイクリングデータの相互作用が効率を制限することを示し、アップサイクリングのスケールアップに関する指針を提供。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/sbintuitions/status/1935970879923540248?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QOpenReview:https://openreview.net/forum?id=ZBBo19jldX関連:

<br>

・1546</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<span class="issue_date">Issue Date: 2025-06-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2059">[Paper Note] Reasoning by Superposition: A Theoretical Perspective on Chain of Continuous Thought, Hanlin Zhu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、連続CoTsを用いた二層トランスフォーマーが有向グラフ到達可能性問題を解決できることを証明。連続CoTsは複数の探索フロンティアを同時にエンコードし、従来の離散CoTsよりも効率的に解を導く。実験により、重ね合わせ状態が自動的に現れ、モデルが複数のパスを同時に探索することが確認された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/tydsh/status/1935206012799303817?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/OpenSource.html">#OpenSource</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-06-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2058">[Paper Note] AceReason-Nemotron 1.1: Advancing Math and Code Reasoning through SFT and RL Synergy, Zihan Liu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、教師ありファインチューニング（SFT）と強化学習（RL）の相乗効果を探求し、SFTトレーニングデータの整備においてプロンプト数の増加が推論性能を向上させることを示しました。特に、サンプリング温度を適切に調整することで、RLトレーニングの効果を最大化できることが分かりました。最終的に、AceReason-Nemotron-1.1モデルは、前モデルを大きく上回り、数学およびコードベンチマークで新たな最先端性能を達成しました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/ychennlp/status/1935005283178492222?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

様々なtakeawayがまとめられている。SFT,RLに利用されたデータも公開・1829

<br>



<br>

において事前学習時に4 epochまでは性能の改善幅が大きいと報告されていたが、SFTでも5 epoch程度まで学習すると良い模様。

<br>



<br>

また、SFT dataをscalingさせる際は、promptの数だけでなく、prompt単位のresponse数を増やすのが効果的

<br>

<img src="https://github.com/user-attachments/assets/67e2a4ff-555b-4e22-a90a-ee239704805e" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-06-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2054">[Paper Note] Direct Reasoning Optimization: LLMs Can Reward And Refine Their Own  Reasoning for Open-Ended Tasks, Yifei Xu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>DRO（直接推論最適化）を提案し、LLMsをオープンエンドの長文推論タスクに微調整するための強化学習フレームワークを構築。新しい報酬信号R3を用いて推論と参照結果の一貫性を捉え、自己完結したトレーニングを実現。ParaRevとFinQAのデータセットで強力なベースラインを上回る性能を示し、広範な適用可能性を確認。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iscienceluvr/status/1934957116571451409?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-06-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2053">[Paper Note] Wait, We Don't Need to "Wait" Removing Thinking Tokens Improves  Reasoning Efficiency, Chenlong Wang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>自己反省を抑制する「NoWait」アプローチを提案し、推論の効率を向上。10のベンチマークで最大27%-51%の思考の連鎖の長さを削減し、有用性を維持。マルチモーダル推論のための効果的なソリューションを提供。</span>
<span class="snippet"><span>Comment</span>Wait, Hmmといったlong CoTを誘導するようなtokenを抑制することで、Accはほぼ変わらずに生成されるトークン数を削減可能、といった図に見える。Reasoningモデルでデコーディング速度を向上したい場合に効果がありそう。

<br>

<img src="https://github.com/user-attachments/assets/c0abd2b4-f019-435e-b72f-f588fa0eb782" alt="image" loading="lazy">元ポスト:https://x.com/huggingpapers/status/1935130111608492060?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-06-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2052">[Paper Note] Massive Supervised Fine-tuning Experiments Reveal How Data, Layer, and  Training Factors Shape LLM Alignment Quality, Yuto Harada+, arXiv'25</a>
<span class="snippet"><span>Summary</span>SFTはLLMを人間の指示に整合させる重要なプロセスであり、1,000以上のSFTモデルを生成し、データセットの特性と層ごとの変更を調査。訓練タスクの相乗効果やモデル固有の戦略の重要性を明らかにし、困惑度がSFTの効果を予測することを示した。中間層の重みの変化がパフォーマンス向上と強く相関し、研究を加速させるためにモデルと結果を公開予定。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/odashi_t/status/1935191113981403359?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QNLP'25:https://www.anlp.jp/proceedings/annual_meeting/2025/pdf_dir/C10-6.pdf</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/FactualKnowledge.html">#FactualKnowledge</a>
<span class="issue_date">Issue Date: 2025-06-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2049">[Paper Note] What Is Seen Cannot Be Unseen: The Disruptive Effect of Knowledge  Conflict on Large Language Models, Kaiser Sun+, arXiv'25</a>
<span class="snippet"><span>Summary</span>LLMの文脈情報とパラメトリック知識の対立を評価する診断フレームワークを提案。知識の対立はタスクに影響を与えず、一致時にパフォーマンスが向上。モデルは内部知識を抑制できず、対立の理由が文脈依存を高めることを示した。これにより、LLMの評価と展開における知識の対立の重要性が強調される。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/kaiserwholearns/status/1934582217692295268?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-06-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2048">[Paper Note] Overclocking LLM Reasoning: Monitoring and Controlling Thinking Path  Lengths in LLMs, Roy Eisenstadt+, arXiv'25</a>
<span class="snippet"><span>Summary</span>LLMの推論プロセスにおける思考段階の長さを調整するメカニズムを探求。進捗をエンコードし、可視化することで計画ダイナミクスを明らかにし、不要なステップを減らす「オーバークロッキング」手法を提案。これにより、考えすぎを軽減し、回答精度を向上させ、推論のレイテンシを減少させることを実証。コードは公開。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gm8xx8/status/1934357202619310559?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<span class="issue_date">Issue Date: 2025-06-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2047">[Paper Note] LiveCodeBench Pro: How Do Olympiad Medalists Judge LLMs in Competitive  Programming?, Zihan Zheng+, arXiv'25</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）は競技プログラミングで人間のエリートを上回るとされるが、実際には重要な限界があることを調査。新たに導入した「LiveCodeBench Pro」ベンチマークにより、LLMsは中程度の難易度の問題で53%のpass@1を達成する一方、難しい問題では0%という結果が得られた。LLMsは実装重視の問題では成功するが、複雑なアルゴリズム的推論には苦労し、誤った正当化を生成することが多い。これにより、LLMsと人間の専門家との間に重要なギャップがあることが明らかになり、今後の改善のための診断が提供される。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/arankomatsuzaki/status/1934433210387296414?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QHardな問題は現状のSoTAモデル（Claude4が含まれていないが）でも正答率0.0%

<br>

<img src="https://github.com/user-attachments/assets/d0e29f23-2b66-4b19-b39a-68f3717d7058" alt="image" loading="lazy">

<br>



<br>

ベンチマークに含まれる課題のカテゴリ

<br>

<img src="https://github.com/user-attachments/assets/b41b11d7-52a2-4a22-848d-cb08900da5cf" alt="image" loading="lazy">

<br>



<br>

実サンプルやケーススタディなどはAppendix参照のこと。</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2025-06-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2046">[Paper Note] RAG+: Enhancing Retrieval-Augmented Generation with Application-Aware  Reasoning, Yu Wang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>RAG+は、Retrieval-Augmented Generationの拡張で、知識の適用を意識した推論を組み込む。二重コーパスを用いて、関連情報を取得し、目標指向の推論に適用する。実験結果は、RAG+が標準的なRAGを3-5%、複雑なシナリオでは最大7.5%上回ることを示し、知識統合の新たなフレームワークを提供する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/omarsar0/status/1934667096828399641?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q知識だけでなく知識の使い方も蓄積し、利用時に検索された知識と紐づいた使い方を活用することでRAGの推論能力を向上させる。

<br>

<img src="https://github.com/user-attachments/assets/23f2b2cd-458b-437a-837d-11d4db28162f" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/b6a01788-7a14-41a3-81f7-41a2add62bd1" alt="image" loading="lazy">Figure 1のような例はReasoningモデルが進化していったら、わざわざ知識と使い方を紐付けなくても、世界知識から使い方を補完可能だと思われるので不要となると思われる。

<br>

が、真にこの手法が力を発揮するのは「ドメイン固有の使い方やルール」が存在する場合で、どれだけLLMが賢くなっても推論によって導き出せないもの、のついては、こういった手法は効力を発揮し続けるのではないかと思われる。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/KnowledgeEditing.html">#KnowledgeEditing</a>
<a class="button" href="articles/FactualKnowledge.html">#FactualKnowledge</a>
<a class="button" href="articles/meta-learning.html">#meta-learning</a>
<span class="issue_date">Issue Date: 2025-06-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2044">[Paper Note] PropMEND: Hypernetworks for Knowledge Propagation in LLMs, Zeyu Leo Liu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>PropMENDは、LLMsにおける知識伝播を改善するためのハイパーネットワークベースのアプローチである。メタ学習を用いて、注入された知識がマルチホップ質問に答えるために伝播するように勾配を修正する。RippleEditデータセットで、難しい質問に対して精度がほぼ2倍向上し、Controlled RippleEditデータセットでは新しい関係やエンティティに対する知識伝播を評価。PropMENDは既存の手法を上回るが、性能差は縮小しており、今後の研究で広範な関係への知識伝播が求められる。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/zeyuliu10/status/1934659512046330057?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q従来のKnowledge Editing手法は新たな知識を記憶させることはできる（i.e., 注入した知識を逐語的に生成できる;東京は日本の首都である。）が、知識を活用することは苦手だった（i.e., 日本の首都の気候は？）ので、それを改善するための手法を提案している模様。

<br>



<br>

既存手法のlimitationは

<br>

・editing手法で学習をする際に知識を伝搬させるデータが無く

<br>

・目的関数がraw textではなく、QA pairをSFTすること

<br>



<br>

によって生じるとし、

<br>



<br>

・学習時にpropagation question（Figure1のオレンジ色のQA; 注入した知識を活用して推論が必要なQA)を用意しどのように知識を伝搬（活用）させるかを学習し

<br>

・目的関数をCausal Language Modeling Loss

<br>



<br>

にすることで改善する、とのこと。

<br>



<br>

<img src="https://github.com/user-attachments/assets/3f915a57-89c9-412f-a950-f86d35d72cd3" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/50cbbdba-c23e-405d-8ed1-1deea14d3384" alt="image" loading="lazy">

<br>



<br>

non-verbatimなQA（注入された知識をそのまま回答するものではなく、何らかの推論が必要なもの）でも性能が向上。

<br>

<img src="https://github.com/user-attachments/assets/ebae00b4-d622-4c45-9eca-abfc23762c25" alt="image" loading="lazy">ベースライン:

<br>

・643

<br>

・2055</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2025-06-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2040">[Paper Note] Steer LLM Latents for Hallucination Detection, Seongheon Park+, ICML'25</a>
<span class="snippet"><span>Summary</span>LLMの幻覚問題に対処するため、Truthfulness Separator Vector（TSV）を提案。TSVは、LLMの表現空間を再構築し、真実と幻覚の出力を分離する軽量な指向ベクトルで、モデルのパラメータを変更せずに機能。二段階のフレームワークで、少数のラベル付き例からTSVを訓練し、ラベルのない生成物を拡張。実験により、TSVは最小限のラベル付きデータで高いパフォーマンスを示し、実世界のアプリケーションにおける実用的な解決策を提供。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/sharonyixuanli/status/1933522788645810493?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Reproducibility.html">#Reproducibility</a>
<span class="issue_date">Issue Date: 2025-06-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2039">[Paper Note] Give Me FP32 or Give Me Death? Challenges and Solutions for Reproducible  Reasoning, Jiayi Yuan+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）のパフォーマンスの再現性が脆弱であることを示し、システム構成の変更が応答に大きな影響を与えることを明らかにしました。特に、初期トークンの丸め誤差が推論精度に波及する問題を指摘し、浮動小数点演算の非結合的性質が変動の根本原因であるとしています。様々な条件下での実験を通じて、数値精度が再現性に与える影響を定量化し、評価実践における重要性を強調しました。さらに、LayerCastという軽量推論パイプラインを開発し、メモリ効率と数値安定性を両立させる方法を提案しました。</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<span class="issue_date">Issue Date: 2025-06-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2036">[Paper Note] Self-Adapting Language Models, Adam Zweiger+, arXiv'25</a>
<span class="snippet"><span>Summary</span>自己適応型LLMs（SEAL）を提案し、モデルが自身のファインチューニングデータと指示を生成することで適応を実現。新しい入力に対して自己編集を行い、持続的な重みの更新を可能にする。強化学習ループを用いて下流性能を報酬信号として活用し、従来のアプローチと異なり、モデル自身の生成を用いて適応を制御。実験結果はSEALの有望性を示す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jyo_pari/status/1933350025284702697?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QコンテキストCと評価データtauが与えられたとき、Cを入力した時にモデルが自分をSFTし、tau上でより高い性能を得られるようなサンプル Self Edit (SE) を生成できるように学習することで、性能を向上させたい。これをRLによって実現する。具体的には、下記アルゴリズムのようにモデルにSEを生成させ、SEでSFTすることめにtau上での性能が向上したか否かのbinary rewardを用いてパラメータを更新する、といったことを繰り返す。これは実質、RL_updateと書いてあるが、性能が向上した良いSEのみでモデルをSFTすること、と同等なことを実施している。

<br>



<br>

<img src="https://github.com/user-attachments/assets/69a395da-521f-444d-af6f-4c1b25bb6765" alt="image" loading="lazy">

<br>



<br>

このような背景として、RLのアルゴリズムとしてGRPOやPPOを適用したところ学習が不安定でうまくいかなかったため、よりシンプルなアプローチであるReST^EM（2041)を採用した。これはrejection samplingとSFTに基づいたEMアルゴリズムのようなものらしく、Eステップで現在のポリシーでcandidateを生成し、Mステップでpositive rewardを得たcandidateのみ（＝rejection sampling)でSFTする、といったことを繰り返す、みたいな手法らしい。これを用いると、論文中の式(1)を上述のbinary rewardで近似することに相当する。より詳細に書くと、式(1)（つまり、SEをCから生成することによって得られるtauに基づく報酬rの総報酬を最大化したい、という式）を最大化するためにθ_tの勾配を計算したいが、reward rがθ_tで微分不可能なため、Monte Carlo Estimatorで勾配を近似する、みたいなことをやるらしい。Monte Carlo Estimatorでは実際のサンプルの期待値によって理論的な勾配を近似するらしく、これが式(3)のスコア関数とreward rの平均、といった式につながっているようである。</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-06-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2035">[Paper Note] Resa: Transparent Reasoning Models via SAEs, Shangshang Wang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Resaという1.5Bの推論モデル群を提案し、効率的なスパースオートエンコーダーチューニング（SAE-Tuning）手法を用いて訓練。これにより、97%以上の推論性能を保持しつつ、訓練コストを2000倍以上削減し、訓練時間を450倍以上短縮。軽いRL訓練を施したモデルで高い推論性能を実現し、抽出された推論能力は一般化可能かつモジュール化可能であることが示された。全ての成果物はオープンソース。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iscienceluvr/status/1933101904529363112?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q著者ポスト:https://x.com/upupwang/status/1933207676663865482?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q論文中で利用されているSource Modelの一つ:

<br>

・1935</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2025-06-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2033">[Paper Note] Text-to-LoRA: Instant Transformer Adaption, Rujikorn Charakorn+, ICML'25</a>
<span class="snippet"><span>Summary</span>Text-to-LoRA（T2L）は、自然言語による説明に基づいて大規模言語モデル（LLMs）を迅速に適応させる手法で、従来のファインチューニングの高コストと時間を克服します。T2Lは、LoRAを安価なフォワードパスで構築するハイパーネットワークを使用し、タスク特有のアダプターと同等のパフォーマンスを示します。また、数百のLoRAインスタンスを圧縮し、新しいタスクに対してゼロショットで一般化可能です。このアプローチは、基盤モデルの専門化を民主化し、計算要件を最小限に抑えた言語ベースの適応を実現します。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/roberttlange/status/1933074366603919638?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qな、なるほど、こんな手が…！</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<span class="issue_date">Issue Date: 2025-06-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2031">[Paper Note] Reinforcement Pre-Training, Qingxiu Dong+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、強化学習と大規模言語モデルの新しいスケーリング手法「強化事前学習（RPT）」を提案。次のトークン予測を強化学習の推論タスクとして再定義し、一般的なRLを活用することで、ドメイン特有の注釈に依存せずにスケーラブルな方法を提供。RPTは次のトークン予測の精度を向上させ、強化ファインチューニングの基盤を形成。トレーニング計算量の増加が精度を改善することを示し、RPTが言語モデルの事前学習において有望な手法であることを示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1932922314578145640?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2025-06-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2030">[Paper Note] Value Residual Learning, Zhanchao Zhou+, ACL'25</a>
<span class="snippet"><span>Summary</span>ResFormerは、隠れ状態の残差に値の残差接続を加えることで情報の流れを強化する新しいTransformerアーキテクチャを提案。実験により、ResFormerは従来のTransformerに比べて少ないパラメータとトレーニングデータで同等の性能を示し、SVFormerはKVキャッシュサイズを半減させることができる。性能はシーケンスの長さや学習率に依存する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/zhanchaozhou/status/1932829678081098079?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q<img src="https://github.com/user-attachments/assets/c2c97ea1-0930-4033-85bd-b3618463f87a" alt="image" loading="lazy"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Safety.html">#Safety</a>
<span class="issue_date">Issue Date: 2025-06-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2027">[Paper Note] Saffron-1: Towards an Inference Scaling Paradigm for LLM Safety  Assurance, Ruizhong Qiu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>既存のLLMの安全保証研究は主にトレーニング段階に焦点を当てているが、脱獄攻撃に対して脆弱であることが明らかになった。本研究では、推論スケーリングを用いた新たな安全性向上手法SAFFRONを提案し、計算オーバーヘッドを削減する多分岐報酬モデル（MRM）を導入。これにより、報酬モデル評価の数を減らし、探索-効率性のジレンマを克服する。実験により手法の有効性を確認し、訓練済みモデルと安全報酬データセットを公開。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gaotangli/status/1932289294657626189?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Subword.html">#Subword</a>
<span class="issue_date">Issue Date: 2025-06-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2026">[Paper Note] StochasTok: Improving Fine-Grained Subword Understanding in LLMs, Anya Sims+, arXiv'25</a>
<span class="snippet"><span>Summary</span>サブワードレベルの理解を向上させるために、確率的トークン化手法StochasTokを提案。これにより、LLMsは内部構造を把握しやすくなり、文字カウントや数学タスクなどで性能が向上。シンプルな設計により、既存モデルへの統合が容易で、コストを抑えつつサブワード理解を改善できる。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/cong_ml/status/1932369418534760554?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qおもしろそう</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<a class="button" href="articles/KnowledgeEditing.html">#KnowledgeEditing</a>
<span class="issue_date">Issue Date: 2025-06-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2023">[Paper Note] Representation Shattering in Transformers: A Synthetic Study with   Knowledge Editing, Kento Nishi+, ICML'25</a>
<span class="snippet"><span>Summary</span>知識編集（KE）アルゴリズムは、モデルの重みを変更して不正確な事実を更新するが、これがモデルの事実の想起精度や推論能力に悪影響を及ぼす可能性がある。新たに定義した合成タスクを通じて、KEがターゲットエンティティを超えて他のエンティティの表現に影響を与え、未見の知識の推論を歪める「表現の破壊」現象を示す。事前訓練されたモデルを用いた実験でもこの発見が確認され、KEがモデルの能力に悪影響を及ぼす理由を明らかにするメカニズム仮説を提供する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/kento_nishi/status/1932072335726539063?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Search.html">#Search</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<span class="issue_date">Issue Date: 2025-06-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2022">[Paper Note] Search Arena: Analyzing Search-Augmented LLMs, Mihran Miroyan+, arXiv'25</a>
<span class="snippet"><span>Summary</span>検索強化型LLMsに関する「Search Arena」という大規模な人間の好みデータセットを紹介。24,000以上のマルチターンユーザーインタラクションを含み、ユーザーの好みが引用数や引用元に影響されることを明らかにした。特に、コミュニティ主導の情報源が好まれる傾向があり、静的な情報源は必ずしも信頼されない。検索強化型LLMsの性能を評価した結果、非検索設定でのパフォーマンス向上が確認されたが、検索設定ではパラメトリック知識に依存すると品質が低下することが分かった。このデータセットはオープンソースとして提供されている。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/mirmiroyan/status/1931081734764081391?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-06-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2019">[Paper Note] SynLogic: Synthesizing Verifiable Reasoning Data at Scale for Learning  Logical Reasoning and Beyond, Junteng Liu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>SynLogicは、35の論理的推論タスクを網羅したデータ合成フレームワークで、強化学習（RL）による大規模言語モデル（LLMs）の推論能力向上を目指す。調整可能な難易度で生成されたデータは検証可能で、RLに適している。実験では、SynLogicが最先端の論理的推論性能を達成し、数学やコーディングタスクとの混合によりトレーニング効率が向上することが示された。SynLogicはLLMsの推論能力向上に貴重なリソースとなる。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/junxian_he/status/1930558456907669638?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q35種類のタスクを人手で選定し、タスクごとに困難度の鍵となるパラメータを定義（数独ならばグリッド数など）。その上で、各タスクごとに人手でルールベースのinstanceを生成するコードを実装し、さまざまな困難度パラメータに基づいて多様なinstanceを生成。生成されたinstanceの困難度は、近似的なUpper Bound(DeepSeek-R1, o3-miniのPass@10)とLower bound（chat model[^1]でのPass@10)を求めデータセットに含まれるinstanceの困難度をコントロールし、taskを記述するpromptも生成。タスクごとに人手で実装されたVerifierも用意されている。

<br>

<img src="https://github.com/user-attachments/assets/cda0534d-7db2-4470-93b8-01f446476544" alt="image" loading="lazy">

<br>



<br>

Qwen2.5-7B-BaseをSynDataでDAPOしたところ、大幅にlogic benchmarkとmathematical benchmarkの性能が改善。

<br>

<img src="https://github.com/user-attachments/assets/dcc1309d-7946-4a6d-91a3-7ccac9ec6688" alt="image" loading="lazy">

<br>



<br>

mathやcodeのデータとmixして7Bモデルを訓練したところ、32Bモデルに匹敵する性能を達成し、SynDataをmixすることでgainが大きくなったので、SynDataから学習できる能力が汎化することが示唆される。

<br>

<img src="https://github.com/user-attachments/assets/7b618fe9-5271-434b-9808-f53f0e758e5e" alt="image" loading="lazy">

<br>



<br>

タスク一覧はこちら

<br>

<img src="https://github.com/user-attachments/assets/50fcdcb3-701e-4d42-94c7-201d8d354d75" alt="image" loading="lazy">

<br>



<br>

[^1]:どのchat modelかはざっと見た感じわからない。どこかに書いてあるかも。Logical Reasoningが重要なタスクを扱う際はこのデータを活用することを検討してみても良いかもしれない</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Coding.html">#Coding</a>
<span class="issue_date">Issue Date: 2025-06-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2018">[Paper Note] Training Language Models to Generate Quality Code with Program Analysis  Feedback, Feng Yao+, arXiv'25</a>
<span class="snippet"><span>Summary</span>プログラム分析に基づくフィードバックを用いた強化学習フレームワーク「REAL」を提案。セキュリティや保守性の欠陥を検出し、機能的正確性を保証することで、LLMsによる高品質なコード生成を促進。手動介入不要でスケーラブルな監視を実現し、実験により最先端の手法を上回る性能を示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/fengyao1909/status/1930377346693116350?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q現在のCoding LLMはUnitTestを通るように学習されるが、UnitTestに通るからといってコードの品質が良いわけでは無いので、UnitTestに通るか否かのReward（Functionality)に加えて、RL中に生成されたコードを制御フローグラフ[^1]に変換し汚染解析[^2]をした結果をRewardに組み込むことで、FunctionalityとQualityを両立したよ、という話のようである。

<br>



<br>

Figure1のグラフの縦軸は、Functionalityと（UnitTestが通ったか否か）と、Quailty(セキュリティや保守性に関する問題が検出されなかった)、という両方の条件を満たした割合である点に注意。

<br>



<br>

<img src="https://github.com/user-attachments/assets/b843e416-8c96-40ca-ac1f-0318eb1ae40c" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/6beeea63-571b-4ce6-bef8-ac8e0cfffee2" alt="image" loading="lazy">

<br>



<br>

[^1]:プログラムを実行したときに通る可能性のある経路のすべてをグラフとして表したもの[引用元](https://qiita.com/uint256_t/items/7d4556cb8f5997b9e95c)

<br>

[^2]:信頼できない汚染されたデータがプログラム中でどのように処理されるかを分析すること</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RLVR.html">#RLVR</a>
<span class="issue_date">Issue Date: 2025-06-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2017">[Paper Note] Writing-Zero: Bridge the Gap Between Non-verifiable Problems and  Verifiable Rewards, Xun Lu, arXiv'25</a>
<span class="snippet"><span>Summary</span>非検証可能なタスクにおける強化学習のギャップを埋めるため、ペアワイズ生成報酬モデル（GenRM）とブートストラップ相対ポリシー最適化（BRPO）アルゴリズムを提案。これにより、主観的評価を信頼性のある検証可能な報酬に変換し、動的なペアワイズ比較を実現。提案手法は、LLMsの執筆能力を向上させ、スカラー報酬ベースラインに対して一貫した改善を示し、競争力のある結果を達成。全ての言語タスクに適用可能な包括的なRLトレーニングパラダイムの可能性を示唆。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/grad62304977/status/1929996614883783170?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QWriting Principleに基づいて（e.g., 一貫性、創造性とか？）批評を記述し、最終的に与えられたペアワイズのテキストの優劣を判断するGenerative Reward Model (GenRM; Reasoning Traceを伴い最終的にRewardに変換可能な情報をoutpuするモデル) を学習し、現在生成したresponseグループの中からランダムに一つ擬似的なreferenceを決定し、他のresponseに対しGenRMを適用することで報酬を決定する（BRPO）、といったことをやるらしい。

<br>



<br>

これにより、創造的な文書作成のような客観的なground truthを適用できないタスクでも、RLVRの恩恵をあずかれるようになる（Bridging the gap)といったことを主張している。RLVRの恩恵とは、Reward Hackingされづらい高品質な報酬、ということにあると思われる。ので、要は従来のPreference dataだけで学習したReward Modelよりも、よりReward Hackingされないロバストな学習を実現できるGenerative Reward Modelを提案し、それを適用する手法BRPOも提案しました、という話に見える。関連:

<br>

・2274 </span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<a class="button" href="articles/UnitTest.html">#UnitTest</a>
<span class="issue_date">Issue Date: 2025-06-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2016">[Paper Note] Co-Evolving LLM Coder and Unit Tester via Reinforcement Learning, Yinjie Wang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>CUREは、コーディングとユニットテスト生成を共進化させる強化学習フレームワークで、真のコードを監視せずにトレーニングを行う。ReasonFlux-Coderモデルは、コード生成精度を向上させ、下流タスクにも効果的に拡張可能。ユニットテスト生成では高い推論効率を達成し、強化学習のための効果的な報酬モデルとして機能する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/lingyang_pu/status/1930234983274234232?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QUnitTestの性能向上させます系の研究が増えてきている感関連ポスト:https://x.com/gm8xx8/status/1930348014146859345?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/RLVR.html">#RLVR</a>
<a class="button" href="articles/DataMixture.html">#DataMixture</a>
<span class="issue_date">Issue Date: 2025-06-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2015">[Paper Note] MoDoMoDo: Multi-Domain Data Mixtures for Multimodal LLM Reinforcement  Learning, Yiqing Liang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>検証可能な報酬を用いた強化学習（RLVR）をマルチモーダルLLMsに適用するためのポストトレーニングフレームワークを提案。異なる視覚と言語の問題を含むデータセットをキュレーションし、最適なデータ混合戦略を導入。実験により、提案した戦略がMLLMの推論能力を大幅に向上させることを示し、分布外ベンチマークで平均5.24%の精度向上を達成。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_vztu/status/1930312780701413498?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qマルチモーダルな設定でRLVRを適用すると、すべてのデータセットを学習に利用する場合より、特定のタスクのみのデータで学習した方が当該タスクでは性能が高くなったり（つまりデータが多ければ多いほど良いわけでは無い）、特定のデータをablationするとOODに対する予測性能が改善したりするなど、データ間で干渉が起きて敵対的になってしまうような現象が起きる。このことから、どのように適切にデータを混合できるか？という戦略の必要性が浮き彫りになり、モデルベースなMixture戦略（どうやらデータの混合分布から学習後の性能を予測するモデルな模様）の性能がuniformにmixするよりも高い性能を示した、みたいな話らしい。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Memorization.html">#Memorization</a>
<span class="issue_date">Issue Date: 2025-06-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2014">[Paper Note] How much do language models memorize?, John X. Morris+, arXiv'25</a>
<span class="snippet"><span>Summary</span>モデルの「知識」を推定する新手法を提案し、言語モデルの能力を測定。記憶を「意図しない記憶」と「一般化」に分け、一般化を排除することで総記憶を計算。GPTスタイルのモデルは約3.6ビット/パラメータの能力を持つと推定。データセットのサイズ増加に伴い、モデルは記憶を保持し、一般化が始まると意図しない記憶が減少。数百のトランスフォーマー言語モデルを訓練し、能力とデータサイズの関係を示すスケーリング法則を生成。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/rohanpaul_ai/status/1929989864927146414?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<span class="issue_date">Issue Date: 2025-06-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2013">[Paper Note] Unleashing the Reasoning Potential of Pre-trained LLMs by Critique  Fine-Tuning on One Problem, Yubo Wang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、強力な大規模言語モデル（LLM）の推論能力を引き出すために、批評微調整（CFT）が効果的であることを示します。CFTは、単一の問題に対する多様な解を収集し、教師LLMによる批評データを構築する手法です。QwenおよびLlamaモデルを微調整した結果、数学や論理推論のベンチマークで顕著な性能向上を観察しました。特に、わずか5時間のトレーニングで、Qwen-Math-7B-CFTは他の手法と同等以上の成果を上げました。CFTは計算効率が高く、現代のLLMの推論能力を引き出すためのシンプルなアプローチであることが示されました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/wenhuchen/status/1930447298527670662?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・1832

<br>

・1938参考:https://x.com/weiliu99/status/1930826904522875309?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-06-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2012">[Paper Note] Darwin Godel Machine: Open-Ended Evolution of Self-Improving Agents, Jenny Zhang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>ダーヴィン・ゴーデルマシン（DGM）は、自己改善するAIシステムであり、コードを反復的に修正し、コーディングベンチマークで変更を検証します。進化とオープンエンドな研究に基づき、生成されたエージェントのアーカイブを維持し、新しいバージョンを作成することで多様なエージェントを育成します。DGMはコーディング能力を自動的に向上させ、SWE-benchでのパフォーマンスを20.0%から50.0%、Polyglotでのパフォーマンスを14.2%から30.7%に改善しました。安全対策を講じた実験により、自己改善を行わないベースラインを大幅に上回る成果を示しました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://www.linkedin.com/posts/omarsar_new-paper-open-ended-evolution-of-self-improving-activity-7334610178832556033-8dA-?utm_source=share&utm_medium=member_ios&rcm=ACoAACzQvjwB2FeLVE3yukDiUYtr5J4k-6nlNG4・1212

<br>



<br>

あたりの研究とはどう違うのだろうか、という点が気になる。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-06-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2011">[Paper Note] ProRL: Prolonged Reinforcement Learning Expands Reasoning Boundaries in  Large Language Models, Mingjie Liu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>強化学習（RL）が言語モデルの推論能力を向上させる可能性を探る本研究では、長期的なRL（ProRL）トレーニングが新しい推論戦略を明らかにできることを示します。新しいトレーニング手法ProRLを導入し、実証分析により、RLでトレーニングされたモデルが基礎モデルを上回ることが確認されました。推論の改善は基礎モデルの能力やトレーニング期間と相関しており、RLが新しい解決空間を探索できることを示唆しています。これにより、RLが言語モデルの推論を拡張する条件に関する新たな洞察が得られ、今後の研究の基盤が築かれます。モデルの重みは公開されています。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1930043688329326962?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QRLVR（math, code（従来はこの2種類）, STEM, logic Puzzles, instruction following）によって大規模なスケール（長期的に学習をする; 2k training stepsと多様なタスクでの学習データ）で実験をし、定期的にReferenceポリシーとOptimizerをリセットすることで、元のポリシーからの乖離を防ぎつつも、新たな学習が進むようなことをしている模様。

<br>

（※PFNのランチタイムトークを参考に記述）

<br>



<br>

verlを用いて、DAPOで学習をしている。

<br>

<img src="https://github.com/user-attachments/assets/db706cfc-e756-47d1-a0e7-8fbc8043ae17" alt="image" loading="lazy">

<br>



<br>

・1969

<br>

・1815</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2025-06-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2010">[Paper Note] xVerify: Efficient Answer Verifier for Reasoning Model Evaluations, Ding Chen+, arXiv'25</a>
<span class="snippet"><span>Summary</span>推論モデルの評価のために、xVerifyという効率的な回答検証器を提案。xVerifyは、LLMが生成した回答が参照解答と同等であるかを効果的に判断できる。VARデータセットを構築し、複数のLLMからの質問-回答ペアを収集。評価実験では、すべてのxVerifyモデルが95％を超えるF1スコアと精度を達成し、特にxVerify-3B-IbはGPT-4oを超える性能を示した。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/VerifiableRewards.html">#VerifiableRewards</a>
<a class="button" href="articles/RLVR.html">#RLVR</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2025-06-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2009">[Paper Note] Pitfalls of Rule- and Model-based Verifiers -- A Case Study on  Mathematical Reasoning, Yuzhen Huang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、数学的推論における検証者の信頼性とそのRL訓練プロセスへの影響を分析。ルールベースの検証者は偽陰性率が高く、RL訓練のパフォーマンスに悪影響を及ぼすことが判明。モデルベースの検証者は静的評価で高精度を示すが、偽陽性に対して脆弱であり、報酬が不正に膨らむ可能性がある。これにより、強化学習における堅牢な報酬システムの必要性が示唆される。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/junxian_he/status/1929371821767586284?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qverificationタスクに特化してfinetuningされたDiscriminative Classifierが、reward hackingに対してロバストであることが示唆されている模様。

<br>



<br>

Discriminative Verifierとは、Question, Response, Reference Answerがgivenな時に、response（しばしばreasoning traceを含み複数のanswerの候補が記述されている）の中から最終的なanswerを抽出し、Reference answerと抽出したanswerから正解/不正解をbinaryで出力するモデルのこと。Rule-based Verifierではフォーマットが異なっている場合にfalse negativeとなってしまうし、そもそもルールが規定できないタスクの場合は適用できない。Discriminative Verifierではそのようなケースでも適用できると考えられる。Discriminative Verifierの例はたとえば下記:

<br>

https://huggingface.co/IAAR-Shanghai/xVerify-0.5B-I

<br>



<br>

・2010</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<span class="issue_date">Issue Date: 2025-06-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2008">[Paper Note] Self-Challenging Language Model Agents, Yifei Zhou+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Self-Challengingフレームワークを提案し、エージェントが自ら生成した高品質なタスクで訓練。エージェントは挑戦者としてタスクを生成し、実行者として強化学習を用いて訓練。M3ToolEvalとTauBenchでLlama-3.1-8B-Instructが2倍以上の改善を達成。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jaseweston/status/1929719473952497797?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説ポスト:https://x.com/omarsar0/status/1930748591242424439?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/COLT.html">#COLT</a>
<span class="issue_date">Issue Date: 2025-06-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2007">[Paper Note] Learning Compositional Functions with Transformers from Easy-to-Hard   Data, Zixuan Wang+, COLT'25</a>
<span class="snippet"><span>Summary</span>本研究では、Transformerベースの言語モデルの学習可能性を探求し、$k$-fold compositionタスクに焦点を当てる。$O(\log k)$層のトランスフォーマーでこのタスクを表現できる一方、SQオラクルに対するクエリの下限を示し、サンプルサイズが指数的である必要があることを証明。さらに、カリキュラム学習戦略を用いて、簡単な例と難しい例を含むデータ分布がトランスフォーマーの効率的な学習に必要であることを明らかにした。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/zzzixuanwang/status/1928465115478708604?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qこちらはまず元ポストのスレッドを読むのが良いと思われる。要点をわかりやすく説明してくださっている。元ポストとalphaxivでざっくり理解したところ、

<br>



<br>

Transformerがcontextとして与えられた情報(σ)とparametric knowledge(π)をk回の知識マッピングが必要なタスク(k-fold composition task)を学習するにはO(log k)のlayer数が必要で、直接的にk回の知識マッピングが必要なタスクを学習するためにはkの指数オーダーのデータ量が最低限必要となることが示された。これはkが大きくなると（すなわち、複雑なreasoning stepが必要なタスク）になると非現実的なものとなるため、何らかの方法で緩和したい。学習データを簡単なものから難しいものをmixingすること（カリキュラム学習）ことで、この条件が緩和され、指数オーダーから多項式オーダーのデータ量で学習できることが示された

<br>



<br>

といった感じだと思われる。じゃあ最新の32Bモデルよりも、よりパラメータ数が大きくてlayer数が多い古いモデルの方が複雑なreasoningが必要なタスクを実は解けるってこと！？直感に反する！と一瞬思ったが、おそらく最近のモデルでは昔のモデルと比べてparametric knowledgeがより高密度に適切に圧縮されるようになっていると思われるので、昔のモデルではk回の知識マッピングをしないと解けないタスクが、最新のモデルではk-n回のマッピングで解けるようになっていると推察され、パラメータサイズが小さくても問題なく解けます、みたいなことが起こっているのだろう、という感想を抱くなどした</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-06-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2006">[Paper Note] BIG-Bench Extra Hard, Mehran Kazemi+, arXiv'25</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）の推論能力を評価するための新しいベンチマーク、BIG-Bench Extra Hard（BBEH）を導入。これは、既存のBIG-Bench Hard（BBH）のタスクを新しいものに置き換え、難易度を大幅に引き上げることで、LLMの限界を押し広げることを目的としている。評価の結果、最良の汎用モデルで9.8%、推論専門モデルで44.8%の平均精度が観察され、LLMの一般的推論能力向上の余地が示された。BBEHは公開されている。</span>
<span class="snippet"><span>Comment</span>Big-Bench hard（既にSoTAモデルの能力差を識別できない）の難易度をさらに押し上げたデータセット。

<br>



<br>

Inputの例

<br>

<img src="https://github.com/user-attachments/assets/b9d1308f-1481-470d-a553-c181d902119c" alt="image" loading="lazy">

<br>



<br>

タスクごとのInput, Output lengthの分布

<br>

<img src="https://github.com/user-attachments/assets/ef6b7401-159d-46c7-bd9d-9a64f63b5089" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/01207db3-cb01-46f2-a805-e9ddf9d58198" alt="image" loading="lazy">

<br>



<br>

現在の主要なモデル群の性能

<br>

<img src="https://github.com/user-attachments/assets/5ce538d8-45a1-449a-992a-998b33fdeaf7" alt="image" loading="lazy">Big-Bench論文はこちら:

<br>

・785</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/PRM.html">#PRM</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2025-06-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2005">[Paper Note] Training Step-Level Reasoning Verifiers with Formal Verification Tools, Ryo Kamoi+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本論文では、プロセス報酬モデル（PRMs）のトレーニングにおける2つの課題、すなわち高コストの人間による注釈と数学的推論問題への限定を解決するために、FoVerというアプローチを提案します。FoVerは形式的検証ツールを用いて自動的に段階レベルのエラーラベルを生成し、人的注釈なしでLLMの応答にエラーラベルを付与したデータセットを合成します。このデータセットでトレーニングされたPRMsは、元のLLMsに基づくベースラインを大幅に上回り、他の最先端モデルとも競争力のある結果を達成しました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/ryokamoi/status/1925939062348697874?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q人手によるAnnotation（step levelのラベルのアノテーション)無しでProcsee Reward Modelの学習データを構築する手法

<br>



<br>

<img src="https://github.com/user-attachments/assets/adfc351e-c53b-47af-adba-480e10615d69" alt="image" loading="lazy">Z3やIsabelleなどの形式検証ツールが適用可能なタスクのみに提案手法のスコープは限られる点には注意人手でアノテーションされたモデルと比較してcomparableなパフォーマンスを達成

<br>

<img src="https://github.com/user-attachments/assets/290a4d1c-10ac-41dd-a26e-ed57e1fcca79" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/b1af66e7-fbbe-4823-8679-e5ff5be94fdf" alt="image" loading="lazy">

<br>



<br>

スレッド中で評価データが数回のreasoning stepが必要なタスクのみの評価であり、より長く複雑なreasoning step（たとえば 2006）が必要な場合はどうなるか？といった所に興味が寄せられている模様</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-06-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2004">[Paper Note] Satori-SWE: Evolutionary Test-Time Scaling for Sample-Efficient Software  Engineering, Guangtao Zeng+, arXiv'25</a>
<span class="snippet"><span>Summary</span>EvoScaleを提案し、進化的プロセスを用いて小型言語モデルの性能を向上させる手法を開発。選択と突然変異を通じて出力を洗練し、サンプル数を減少させる。強化学習を用いて自己進化を促進し、SWE-Bench-Verifiedで32Bモデルが100B以上のモデルと同等以上の性能を示す。コード、データ、モデルはオープンソースとして公開予定。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gan_chuang/status/1928963872188244400?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RLVR.html">#RLVR</a>
<span class="issue_date">Issue Date: 2025-06-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2003">Can Large Reasoning Models Self-Train?, Sheikh Shafayat+, arXiv'25</a>
<span class="snippet"><span>Summary</span>自己学習を活用したオンライン強化学習アルゴリズムを提案し、モデルの自己一貫性を利用して正確性信号を推測。難しい数学的推論タスクに適用し、従来の手法に匹敵する性能を示す。自己生成された代理報酬が誤った出力を優遇するリスクも指摘。自己監視による性能向上の可能性と課題を明らかに。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/askalphaxiv/status/1928487492291829809?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q・1995

<br>

と似ているように見えるself-consistencyでground truthを推定し、推定したground truthを用いてverifiableなrewardを計算して学習する手法、のように見える。

<br>

<img src="https://github.com/user-attachments/assets/0f38d47a-ab42-4ec4-a6d5-6d5d8a63a4a9" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/3d08bbad-8578-4add-8ad7-ed02cdd15add" alt="image" loading="lazy">

<br>



<br>

実際のground truthを用いた学習と同等の性能を達成する場合もあれば、long stepで学習するとどこかのタイミングで学習がcollapseする場合もある

<br>

<img src="https://github.com/user-attachments/assets/e120a277-6beb-4fc1-8fd7-e69de467fb3d" alt="image" loading="lazy">パフォーマンスがピークを迎えた後になぜ大幅にAccuracyがdropするかを検証したところ、モデルのKL penaltyがどこかのタイミングで大幅に大きくなることがわかった。つまりこれはオリジナルのモデルからかけ離れたモデルになっている。これは、モデルがデタラメな出力をground truthとして推定するようになり、モデルそのものも一貫してそのデタラメな出力をすることでrewardを増大させるreward hackingが起きている。

<br>

<img src="https://github.com/user-attachments/assets/5a9c091f-e9cb-4914-a1ca-32a1ea2dc1c7" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/aa685b9a-7992-4135-a4da-fd1c8cabe084" alt="image" loading="lazy">これら現象を避ける方法として、以下の3つを提案している

<br>

・early stopping

<br>

・offlineでラベルをself consistencyで生成して、学習の過程で固定する

<br>

・カリキュラムラーニングを導入する

<br>



<br>

<img src="https://github.com/user-attachments/assets/4fa997e3-aa20-4195-96ef-b17c82556fc1" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/99cc2b6c-50a9-40a0-af30-b59aff4056b4" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/e90e9870-b180-4fe9-8c24-8ff88fcf33f0" alt="image" loading="lazy">関連

<br>

・1489</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/COLING.html">#COLING</a>
<span class="issue_date">Issue Date: 2025-05-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2000">Beyond Chain-of-Thought: A Survey of Chain-of-X Paradigms for LLMs, Yu Xia+, COLING'25</a>
<span class="snippet"><span>Summary</span>Chain-of-Thought（CoT）を基にしたChain-of-X（CoX）手法の調査を行い、LLMsの課題に対処するための多様なアプローチを分類。ノードの分類とアプリケーションタスクに基づく分析を通じて、既存の手法の意義と今後の可能性を議論。研究者にとって有用なリソースを提供することを目指す。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Distillation.html">#Distillation</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<span class="issue_date">Issue Date: 2025-05-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1999">Distillation Scaling Laws, Dan Busbridge+, ICML'25</a>
<span class="snippet"><span>Summary</span>蒸留モデルの性能を推定するための蒸留スケーリング法則を提案。教師モデルと生徒モデルの計算割り当てを最適化することで、生徒の性能を最大化。教師が存在する場合やトレーニングが必要な場合に最適な蒸留レシピを提供。多くの生徒を蒸留する際は、監視付きの事前学習を上回るが、生徒のサイズに応じた計算レベルまで。単一の生徒を蒸留し、教師がトレーニング必要な場合は監視学習を推奨。蒸留に関する洞察を提供し、理解を深める。</span>
<span class="snippet"><span>Comment</span>著者ポスト:https://x.com/danbusbridge/status/1944539357542781410?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Temporal.html">#Temporal</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-05-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1996">Temporal Sampling for Forgotten Reasoning in LLMs, Yuetai Li+, arXiv'25</a>
<span class="snippet"><span>Summary</span>ファインチューニング中にLLMsが以前の正しい解法を忘れる「時間的忘却」を発見。これに対処するために「時間的サンプリング」というデコーディング戦略を導入し、複数のチェックポイントから出力を引き出すことで推論性能を向上。Pass@kで4から19ポイントの改善を達成し、LoRA適応モデルでも同様の利点を示す。時間的多様性を活用することで、LLMsの評価方法を再考する手段を提供。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iscienceluvr/status/1927286319018832155?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QTemporal ForgettingとTemporal Sampling</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-05-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1995">Learning to Reason without External Rewards, Xuandong Zhao+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、外部の報酬やラベルなしで大規模言語モデル（LLMs）が学習できるフレームワーク「内部フィードバックからの強化学習（RLIF）」を提案。自己確信を報酬信号として用いる「Intuitor」を開発し、無監視の学習を実現。実験結果は、Intuitorが数学的ベンチマークで優れた性能を示し、ドメイン外タスクへの一般化能力も高いことを示した。内因的信号が効果的な学習を促進する可能性を示唆し、自律AIシステムにおけるスケーラブルな代替手段を提供。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/xuandongzhao/status/1927270931874910259?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qおもしろそうexternalなsignalをrewardとして用いないで、モデル自身が内部的に保持しているconfidenceを用いる。人間は自信がある問題には正解しやすいという直感に基づいており、openendなquestionのようにそもそも正解シグナルが定義できないものもあるが、そういった場合に活用できるようである。self-trainingの考え方に近いのではベースモデルの段階である程度能力が備わっており、post-trainingした結果それが引き出されるようになったという感じなのだろうか。

<br>



<br>

参考: https://x.com/weiliu99/status/1930826904522875309?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-05-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1994">QwenLong-CPRS: Towards $\infty$-LLMs with Dynamic Context Optimization, Weizhou Shen+, arXiv'25</a>
<span class="snippet"><span>Summary</span>QwenLong-CPRSは、長文コンテキスト最適化のための新しいフレームワークで、LLMsの性能低下を軽減します。自然言語指示に基づく多段階のコンテキスト圧縮を実現し、効率と性能を向上させる4つの革新を導入。5つのベンチマークで、他の手法に対して優位性を示し、主要なLLMとの統合で大幅なコンテキスト圧縮と性能向上を達成。QwenLong-CPRSは新たなSOTA性能を確立しました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_akhaliq/status/1927014346690826684?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-05-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1993">QwenLong-L1: Towards Long-Context Large Reasoning Models with  Reinforcement Learning, Fanqi Wan+, arXiv'25</a>
<span class="snippet"><span>Summary</span>長いコンテキストの推論におけるLRMsの課題を解決するため、QwenLong-L1フレームワークを提案。ウォームアップ監視付きファインチューニングとカリキュラム指導型段階的RLを用いてポリシーの安定化を図り、難易度認識型の回顧的サンプリングで探索を促進。実験では、QwenLong-L1-32Bが他のLRMsを上回り、優れた性能を示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_akhaliq/status/1927011243597967524?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<a class="button" href="articles/InstructionFollowingCapability.html">#InstructionFollowingCapability</a>
<span class="issue_date">Issue Date: 2025-05-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1989">Scaling Reasoning, Losing Control: Evaluating Instruction Following in  Large Reasoning Models, Tingchen Fu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>指示に従う能力はLLMにとって重要であり、MathIFという数学的推論タスク用のベンチマークを提案。推論能力の向上と指示遵守の間には緊張関係があり、特に長い思考の連鎖を持つモデルは指示に従いにくい。介入により部分的な従順さを回復できるが、推論性能が低下することも示された。これらの結果は、指示に敏感な推論モデルの必要性を示唆している。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/yafuly/status/1925753754961236006?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Conversation.html">#Conversation</a>
<span class="issue_date">Issue Date: 2025-05-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1988">LLMs Get Lost In Multi-Turn Conversation, Philippe Laban+, arXiv'25</a>
<span class="snippet"><span>Summary</span>LLMsは会話型インターフェースとして、ユーザーがタスクを定義するのを支援するが、マルチターンの会話ではパフォーマンスが低下する。シミュレーション実験の結果、マルチターンで39%のパフォーマンス低下が見られ、初期のターンでの仮定に依存しすぎることが原因と判明。LLMsは会話中に誤った方向に進むと、回復が難しくなることが示された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_stakaya/status/1926009283386155009?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLost in the MiddleならぬLost in Conversation

<br>

<img src="https://github.com/user-attachments/assets/9d4320f5-6fea-43ca-a7ab-a836e7e3642e" alt="image" loading="lazy">関連:

<br>

・793</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<span class="issue_date">Issue Date: 2025-05-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1985">LaViDa: A Large Diffusion Language Model for Multimodal Understanding, Shufan Li+, arXiv'25</a>
<span class="snippet"><span>Summary</span>LaViDaは、離散拡散モデル（DM）を基にしたビジョン・ランゲージモデル（VLM）で、高速な推論と制御可能な生成を実現。新技術を取り入れ、マルチモーダルタスクにおいてAR VLMと競争力のある性能を達成。COCOキャプショニングで速度向上と性能改善を示し、AR VLMの強力な代替手段であることを証明。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iscienceluvr/status/1925749919312159167?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QDiffusion Modelの波が来た同程度のサイズのARモデルをoutperform [^1]

<br>

<img src="https://github.com/user-attachments/assets/aeb12147-48ba-4b64-917c-9976ec1ffa0a" alt="image" loading="lazy">

<br>



<br>

[^1]:ただし、これが本当にDiffusion Modelを使ったことによる恩恵なのかはまだ論文を読んでいないのでわからない。必要になったら読む。ただ、Physics of Language Modelのように、完全にコントロールされたデータで異なるアーキテクチャを比較しないとその辺はわからなそうではある。</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<span class="issue_date">Issue Date: 2025-05-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1984">dKV-Cache: The Cache for Diffusion Language Models, Xinyin Ma+, arXiv'25</a>
<span class="snippet"><span>Summary</span>拡散言語モデル（DLM）の遅い推論を改善するために、遅延KVキャッシュを提案。これは、異なるトークンの表現ダイナミクスに基づくキャッシング戦略で、2つのバリアントを設計。dKV-Cache-Decodeは損失の少ない加速を提供し、dKV-Cache-Greedyは高いスピードアップを実現。最終的に、推論速度を2〜10倍向上させ、DLMの性能を強化することを示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/arankomatsuzaki/status/1925384029718946177?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q提案手法を適用した場合、ARなモデルとDiffusion Modelで、実際のところどの程度のdecoding速度の差があるのだろうか？そういった分析はざーーっと見た感じ見当たらなかったように思える。</span>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<span class="issue_date">Issue Date: 2025-05-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1983">Diffusion vs. Autoregressive Language Models: A Text Embedding  Perspective, Siyue Zhang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>拡散言語モデルを用いたテキスト埋め込みが、自己回帰的なLLMの一方向性の制限を克服し、文書検索や推論タスクで優れた性能を発揮。長文検索で20%、推論集約型検索で8%、指示に従った検索で2%の向上を示し、双方向の注意が重要であることを確認。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/trtd6trtd/status/1925775950500806742?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Contamination.html">#Contamination</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-05-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1982">LiveBench: A Challenging, Contamination-Limited LLM Benchmark, Colin White+, ICLR'25</a>
<span class="snippet"><span>Summary</span>テストセットの汚染を防ぐために、LLM用の新しいベンチマーク「LiveBench」を導入。LiveBenchは、頻繁に更新される質問、自動スコアリング、さまざまな挑戦的タスクを含む。多くのモデルを評価し、正答率は70%未満。質問は毎月更新され、LLMの能力向上を測定可能に。コミュニティの参加を歓迎。</span>
<span class="snippet"><span>Comment</span>テストデータのコンタミネーションに対処できるように設計されたベンチマーク。重要研究</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<span class="issue_date">Issue Date: 2025-05-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1981">Parallel Scaling Law for Language Models, Mouxiang Chen+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、言語モデルのスケーリングにおいて、並列計算を増加させる新しい手法「ParScale」を提案。これにより、モデルの前方パスを並列に実行し、出力を動的に集約することで、推論効率を向上させる。ParScaleは、少ないメモリ増加とレイテンシで同等の性能向上を実現し、既存のモデルを再利用することでトレーニングコストも削減可能。新しいスケーリング法則は、リソースが限られた状況での強力なモデル展開を促進する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1924959706331939099?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q・405

<br>



<br>

と考え方が似ている</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-05-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1980">AdaCoT: Pareto-Optimal Adaptive Chain-of-Thought Triggering via  Reinforcement Learning, Chenwei Lou+, arXiv'25</a>
<span class="snippet"><span>Summary</span>AdaCoT（Adaptive Chain-of-Thought）は、LLMsが推論を適応的に行う新しいフレームワークで、CoTの呼び出しタイミングを最適化します。強化学習を用いて、クエリの複雑さに基づいてCoTの必要性を判断し、計算コストを削減します。実験では、AdaCoTがCoTトリガー率を3.18%に低下させ、応答トークンを69.06%減少させつつ、高い性能を維持することが示されました。</span>
<span class="snippet"><span>Comment</span>RLのRewardにおいて、bassのリワードだけでなく、

<br>

・reasoningをなくした場合のペナルティ項

<br>

・reasoningをoveruseした場合のペナルティ項

<br>

・formattingに関するペナルティ項

<br>

を設定し、reasoningの有無を適切に判断できた場合にrewardが最大化されるような形にしている。(2.2.2)

<br>



<br>

が、multi-stageのRLでは（stageごとに利用するデータセットを変更するが）、データセットの分布には歪みがあり、たとえば常にCoTが有効なデータセットも存在しており（数学に関するデータなど）、その場合常にCoTをするような分布を学習してしまい、AdaptiveなCoT decisionが崩壊したり、不安定になってしまう（decision boundary collapseと呼ぶ）。特にこれがfinal stageで起きると最悪で、これまでAdaptiveにCoTされるよう学習されてきたものが全て崩壊してしまう。これを防ぐために、Selective Loss Maskingというlossを導入している。具体的には、decision token [^1]のlossへの貢献をマスキングするようにすることで、CoTが生じるratioにバイアスがかからないようにする。今回は、Decision tokenとして、`<think>`トークン直後のトークンをdecision tokenとみなし、lossに対する貢献をマスクしている（Selective Loss Masking）。

<br>



<br>

[^1]: CoTするかどうかは多くの場合このDecision Tokenによって決まる、といったことがどっかの研究に示されていたはずいつか必要になったらしっかり読むが、全てのステージでSelective Loss Maskingをしたら、SFTでwarm upした段階からあまりCoTのratioが変化しないような学習のされ方になる気がするが、どのステージに対してapplyするのだろうか。&lt;/span&gt;
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ModelMerge.html">#ModelMerge</a>
<span class="issue_date">Issue Date: 2025-05-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1979">Model Merging in Pre-training of Large Language Models, Yunshui Li+, arXiv'25</a>
<span class="snippet"><span>Summary</span>モデルマージングは大規模言語モデルの強化に有望な技術であり、本論文ではその事前学習プロセスにおける包括的な調査を行う。実験により、一定の学習率で訓練されたチェックポイントをマージすることで性能向上とアニーリング挙動の予測が可能になることを示し、効率的なモデル開発と低コストのトレーニングに寄与する。マージ戦略やハイパーパラメータに関するアブレーション研究を通じて新たな洞察を提供し、実用的な事前学習ガイドラインをオープンソースコミュニティに提示する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iscienceluvr/status/1924804324812873990?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説ポスト:https://x.com/giffmana/status/1924849877634449878?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/KnowledgeGraph.html">#KnowledgeGraph</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-05-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1978">Scaling Reasoning can Improve Factuality in Large Language Models, Mike Zhang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、オープンドメインの質問応答における大規模言語モデル（LLM）の推論能力を検討し、推論の痕跡を抽出してファインチューニングを行った。知識グラフからの情報を導入し、168回の実験を通じて170万の推論を分析した結果、小型モデルが元のモデルよりも事実の正確性を顕著に改善し、計算リソースを追加することでさらに2-8%の向上が確認された。実験成果は公開され、さらなる研究に寄与する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_akhaliq/status/1924477447120068895?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/LLMServing.html">#LLMServing</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<span class="issue_date">Issue Date: 2025-05-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1977">Insights into DeepSeek-V3: Scaling Challenges and Reflections on  Hardware for AI Architectures, Chenggang Zhao+, arXiv'25</a>
<span class="snippet"><span>Summary</span>DeepSeek-V3は、2,048台のNVIDIA H800 GPUでトレーニングされ、ハードウェア制約に対処するための共同設計を示す。メモリ効率向上のためのマルチヘッド潜在注意や、計算と通信の最適化を図る専門家の混合アーキテクチャ、FP8混合精度トレーニングなどの革新を強調。ハードウェアのボトルネックに基づく将来の方向性について議論し、AIワークロードに応えるためのハードウェアとモデルの共同設計の重要性を示す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/deedydas/status/1924512147947848039?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/Probing.html">#Probing</a>
<span class="issue_date">Issue Date: 2025-05-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1974">Why Vision Language Models Struggle with Visual Arithmetic? Towards   Enhanced Chart and Geometry Understanding, Kung-Hsiang Huang+, ACL'25</a>
<span class="snippet"><span>Summary</span>Vision Language Models (VLMs)は視覚的算術に苦労しているが、CogAlignという新しいポストトレーニング戦略を提案し、VLMの性能を向上させる。CogAlignは視覚的変換の不変特性を認識するように訓練し、CHOCOLATEで4.6%、MATH-VISIONで2.9%の性能向上を実現し、トレーニングデータを60%削減。これにより、基本的な視覚的算術能力の向上と下流タスクへの転送の効果が示された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/steeve__huang/status/1923543884367306763?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q既存のLLM (proprietary, openweightそれぞれ)が、シンプルなvisual arithmeticタスク(e.g., 線分の長さ比較, Chart上のdotの理解)などの性能が低いことを明らかにし、

<br>

<img src="https://github.com/user-attachments/assets/039a48de-67a5-4c81-ba59-174acd508479" alt="image" loading="lazy">

<br>

それらの原因を(1)Vision Encoderのrepresentationと(2)Vision EncoderをFreezeした上でのText Decoderのfinetuningで分析した。その結果、(1)ではいくつかのタスクでlinear layerのprobingでは高い性能が達成できないことがわかった。このことから、Vision Encoderによるrepresentationがタスクに関する情報を内包できていないか、タスクに関する情報は内包しているがlinear layerではそれを十分に可能できない可能性が示唆された。

<br>

<img src="https://github.com/user-attachments/assets/0eb90fa2-7b6a-43b6-81d9-b5f7e6fb3ea8" alt="image" loading="lazy">

<br>



<br>

これをさらに分析するために(2)を実施したところ、Vision Encoderをfreezeしていてもfinetuningによりquery stringに関わらず高い性能を獲得できることが示された。このことから、Vision Encoder側のrepresentationの問題ではなく、Text Decoderと側でデコードする際にFinetuningしないとうまく活用できないことが判明した。

<br>

<img src="https://github.com/user-attachments/assets/cd122d99-9228-44b1-9827-cdb56f49d492" alt="image" loading="lazy">手法のところはまだ全然しっかり読めていないのだが、画像に関する特定の属性に関するクエリと回答のペアを合成し、DPOすることで、zero-shotの性能が向上する、という感じっぽい？

<br>

<img src="https://github.com/user-attachments/assets/707b1cc9-8bbf-45a5-b564-f654503c836e" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/281da17b-c8c3-455a-aa51-043ed297ae1f" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<a class="button" href="articles/VerifiableRewards.html">#VerifiableRewards</a>
<span class="issue_date">Issue Date: 2025-05-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1964">J1: Incentivizing Thinking in LLM-as-a-Judge via Reinforcement Learning, Chenxi Whitehouse+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、強化学習アプローチJ1を用いてLLMのトレーニング手法を提案し、判断タスクにおける思考促進とバイアス軽減を図ります。J1は、他の同サイズモデルを上回る性能を示し、特に小型モデルでも優れた結果を出します。モデルは自己生成した参照回答と比較することで、より良い判断を学ぶことが明らかになりました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jaseweston/status/1923186392420450545?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLLM-as-a-Judgeのなめのモデルを学習するレシピにおいて、初めてRLを適用した研究と主張し、より高品質なreasoning traceを出力できるようにすることで性能向上をさせる。

<br>



<br>

具体的にはVerifiableなpromptとnon verifiableなpromptの両方からverifiableなpreference pairを作成しpointwiseなスコアリング、あるいはpairwiseなjudgeを学習するためのrewardを設計しGRPOで学習する、みたいな話っぽい。

<br>

non verifiableなpromptも用いるのは、そういったpromptに対してもjudgeできるモデルを構築するため。

<br>



<br>

mathに関するpromptはverifiableなのでレスポンスが不正解なものをrejection samplingし、WildChatのようなチャットはverifiableではないので、instructionにノイズを混ぜて得られたレスポンスをrejection samplingし、合成データを得ることで、non verifiableなpromptについても、verifiableなrewardを設計できるようになる。

<br>

<img src="https://github.com/user-attachments/assets/4264f599-2067-4688-99e7-b68cc1dc771d" alt="image" loading="lazy"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2025-05-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1961">Faster Cascades via Speculative Decoding, Harikrishna Narasimhan+, ICLR'25</a>
<span class="snippet"><span>Summary</span>カスケードと推測デコーディングは、言語モデルの推論効率を向上させる手法であり、異なるメカニズムを持つ。カスケードは難しい入力に対して大きなモデルを遅延的に使用し、推測デコーディングは並行検証で大きなモデルを活用する。新たに提案する推測カスケーディング技術は、両者の利点を組み合わせ、最適な遅延ルールを特定する。実験結果は、提案手法がカスケードおよび推測デコーディングのベースラインよりも優れたコスト品質トレードオフを実現することを示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1922059828429832259?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QOpenReview: https://openreview.net/forum?id=vo9t20wsmd</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/KnowledgeEditing.html">#KnowledgeEditing</a>
<span class="issue_date">Issue Date: 2025-05-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1946">EasyEdit2: An Easy-to-use Steering Framework for Editing Large Language  Models, Ziwen Xu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本論文では、LLMの挙動を制御するためのフレームワーク「EasyEdit2」を提案。安全性や感情、個性などの介入をサポートし、使いやすさが特徴。ユーザーは技術的知識なしでモデルの応答を調整可能。新しいアーキテクチャにより、ステアリングベクトルを自動生成・適用するモジュールを搭載。実証的なパフォーマンスを報告し、ソースコードやデモも公開。</span>
<span class="snippet"><span>Comment</span>github:https://github.com/zjunlp/EasyEdit/tree/main</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Safety.html">#Safety</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/Toxicity.html">#Toxicity</a>
<a class="button" href="articles/ITI%20(Inference%20Time%20Intervention).html">#ITI (Inference Time Intervention)</a>
<span class="issue_date">Issue Date: 2025-05-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1940">When Bad Data Leads to Good Models, Kenneth Li+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本論文では、LLMの事前学習におけるデータの質の再検討を行い、有害データが事後学習における制御を向上させる可能性を探ります。トイ実験を通じて、有害データの割合が増加することで有害性の概念が線形表現に影響を与えることを発見し、有害データが生成的有害性を増加させつつも除去しやすくなることを示しました。評価結果は、有害データで訓練されたモデルが生成的有害性を低下させつつ一般的な能力を保持する良好なトレードオフを達成することを示唆しています。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/ke_li_2021/status/1920646069613957606?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qこれは面白そうWebコーパスなどを事前学習で利用する際は、質の高いデータを残して学習した方が良いとされているが、4chanのようなtoxicなデータを混ぜて事前学習して、後からdetox（Inference Time Intervention 1941 , SFT, DPO)することで、最終的なモデルのtoxicなoutputが減るという話らしい。これはそもそも事前学習時点でtoxicなデータのsignalが除外されることで、モデルがtoxicな内容のrepresentationを学習できず、最終的にtoxicか否かをコントロールできなくなるため、と考察している（っぽい）

<br>

<img src="https://github.com/user-attachments/assets/7f6efd4b-0679-4143-9a7d-1bf3ea5b6f3a" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/0acec11b-d851-4137-b0aa-1ed7172388e1" alt="image" loading="lazy">有害な出力を減らせそうなことは分かったが、Activation Steeringによってどの程度モデルの性能に影響を与えるのかが気になる、と思ったがAppendixに記載があった。細かく書かれていないので推測を含むが、各データに対してToxicデータセットでProbingすることでTopKのheadを決めて、Kの値を調整することでinterventionの強さを調整し、Toxicデータの割合を変化させて評価してみたところ、モデルの性能に大きな影響はなかったということだと思われる（ただし1Bモデルでの実験しかない）

<br>



<br>

<img src="https://github.com/user-attachments/assets/4c79ca22-6916-438d-ad31-07596c82bfd1" alt="image" loading="lazy">

<br>

おそらく2,3節あたりが一番おもしろいポイントなのだと思われるがまだ読めていない。</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-05-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1938">Reinforcement Learning for Reasoning in Large Language Models with One  Training Example, Yiping Wang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>1-shot RLVRを用いることで、LLMの数学的推論能力が大幅に向上することを示した。Qwen2.5-Math-1.5Bモデルは、MATH500でのパフォーマンスが36.0%から73.6%に改善され、他の数学的ベンチマークでも同様の向上が見られた。1-shot RLVR中には、クロスドメイン一般化や持続的なテストパフォーマンスの改善が観察され、ポリシー勾配損失が主な要因であることが確認された。エントロピー損失の追加も重要で、結果報酬なしでもパフォーマンスが向上した。これらの成果は、RLVRのデータ効率に関するさらなる研究を促進する。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/user-attachments/assets/03cd9200-7fed-4c6d-a5a6-2379d2c8950a" alt="image" loading="lazy">下記ポストでQwenに対してpromptを適切に与えることで、追加のpost training無しで高い数学に関する能力を引き出せたという情報がある。おそらく事前学習時に数学のQAデータによって継続事前学習されており、この能力はその際に身についているため、数学に対する高い能力は実は簡単に引き出すことができるのかもしれない（だから1サンプルでも性能が向上したのではないか？）といった考察がある。

<br>



<br>

参考:https://x.com/weiliu99/status/1930826904522875309?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q・2011

<br>



<br>

とはどのような関係性があるだろうか？</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Coding.html">#Coding</a>
<span class="issue_date">Issue Date: 2025-05-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1937">Rewriting Pre-Training Data Boosts LLM Performance in Math and Code, Kazuki Fujii+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、公共データを体系的に書き換えることで大規模言語モデル（LLMs）の性能を向上させる2つのオープンライセンスデータセット、SwallowCodeとSwallowMathを紹介。SwallowCodeはPythonスニペットを洗練させる4段階のパイプラインを用い、低品質のコードをアップグレード。SwallowMathはボイラープレートを削除し、解決策を簡潔に再フォーマット。これにより、Llama-3.1-8Bのコード生成能力がHumanEvalで+17.0、GSM8Kで+12.4向上。すべてのデータセットは公開され、再現可能な研究を促進。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/okoge_kaz/status/1920141189652574346?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説ポスト:https://x.com/hillbig/status/1920613041026314274?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/RLVR.html">#RLVR</a>
<a class="button" href="articles/ZeroData.html">#ZeroData</a>
<span class="issue_date">Issue Date: 2025-05-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1936">Absolute Zero: Reinforced Self-play Reasoning with Zero Data, Andrew Zhao+, arXiv'25</a>
<span class="snippet"><span>Summary</span>新しいRLVRパラダイム「Absolute Zero」を提案し、自己学習を通じて推論能力を向上させるAZRを導入。外部データに依存せず、コーディングや数学的推論タスクでSOTAパフォーマンスを達成。既存のゼロ設定モデルを上回り、異なるモデルスケールにも適用可能。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/arankomatsuzaki/status/1919946713567264917?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-05-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1930">Thinking LLMs: General Instruction Following with Thought Generation, Tianhao Wu+, ICML'25</a>
<span class="snippet"><span>Summary</span>LLMsに思考能力を装備するための訓練方法を提案。反復的な検索と最適化手順を用いて、モデルが監視なしで思考する方法を学ぶ。指示に対する思考候補はジャッジモデルで評価され、最適化される。この手法はAlpacaEvalとArena-Hardで優れたパフォーマンスを示し、推論タスクだけでなく、マーケティングや健康などの非推論カテゴリでも利点を発揮。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/tesatory/status/1919461701206081813?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q外部のCoTデータを使わないで、LLMのreasoning capabilityを向上させる話っぽい。DeepSeek-R1の登場以前の研究とのこと。reasoning traceを出力するようにInstruction Tuningによって回答を直接出力するようPostTrainingされたモデルにpromptingし、複数のoutputを収集（今回は8個, temperature=0.8, top p=0.95)。Self Taught Evaluator 1464 (STE;70B, LLM-as-a-Judgeを利用するモデル）、あるいはArmo Reward Model（8B）によって回答の品質をスコアリング。ここで、LLM-as-a-Judgeの場合はペアワイズでの優劣が決まるだけなので、ELOでスコアリングする。outputのうちbest scoreとworst scoreだったものの双方でペアデータを構築し、DPOで利用するpreferenceペアデータを構築しDPOする。このような処理を繰り返し、モデルの重みをiterationごとに更新する。次のiterationでは更新されたモデルで同様の処理を行い、前段のステップで利用した学習データは利用しないようにする（後段の方が品質が高いと想定されるため）。また、回答を別モデルで評価する際に、長いレスポンスを好むモデルの場合、長い冗長なレスポンスが高くスコアリングされるようなバイアスが働く懸念があるため、長すぎる回答にpenaltyを与えている（Length-Control)。

<br>

<img src="https://github.com/user-attachments/assets/3be7f7c3-1a24-44c5-bd73-a4b9e11b4b2c" alt="image" loading="lazy">

<br>



<br>

reasoning traceを出力するpromptはgenericとspecific thoughtの二種類で検証。前者はLLMにどのような思考をするかを丸投げするのに対し、後者はこちら側で指定する。後者の場合は、どのような思考が良いかを事前に知っていなければならない。

<br>

<img src="https://github.com/user-attachments/assets/4548fd23-69ba-482f-8987-740f30658d83" alt="image" loading="lazy">

<br>



<br>

Llama-3-8b-instructに適用したところ、70Bスケールのモデルよりも高い性能を達成。また、reasoning trace出力をablationしたモデル（Direct responce baseline）よりも性能が向上。

<br>

<img src="https://github.com/user-attachments/assets/06605741-7049-460a-8062-93be96d45975" alt="image" loading="lazy">

<br>



<br>

iterationが進むに連れて、性能が向上している。

<br>

<img src="https://github.com/user-attachments/assets/25ced3ce-e341-41c4-b1e2-527885590e08" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/PPO%20(ProximalPolicyOptimization).html">#PPO (ProximalPolicyOptimization)</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/RewardHacking.html">#RewardHacking</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<a class="button" href="articles/Contamination.html">#Contamination</a>
<a class="button" href="articles/VerifiableRewards.html">#VerifiableRewards</a>
<a class="button" href="articles/CurriculumLearning.html">#CurriculumLearning</a>
<span class="issue_date">Issue Date: 2025-05-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1925">100 Days After DeepSeek-R1: A Survey on Replication Studies and More  Directions for Reasoning Language Models, Chong Zhang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>最近の推論言語モデル（RLM）の進展を受けて、DeepSeek-R1が注目を集めているが、その実装詳細は完全にはオープンソース化されていない。これにより、多くの再現研究が行われ、DeepSeek-R1のパフォーマンスを再現しようとする試みが続いている。特に、監視付きファインチューニング（SFT）と強化学習（RLVR）の戦略が探求され、貴重な洞察が得られている。本報告では、再現研究の概要を提供し、データ構築やトレーニング手順の詳細を紹介し、今後の研究の促進を目指す。また、RLMを強化するための追加技術や開発上の課題についても考察する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_philschmid/status/1918898257406709983?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

サーベイのtakeawayが箇条書きされている。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/SSM%20(StateSpaceModel).html">#SSM (StateSpaceModel)</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-05-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1924">Layer by Layer: Uncovering Hidden Representations in Language Models, Oscar Skean+, ICML'25</a>
<span class="snippet"><span>Summary</span>中間層の埋め込みが最終層を超えるパフォーマンスを示すことを分析し、情報理論や幾何学に基づくメトリクスを提案。32のテキスト埋め込みタスクで中間層が強力な特徴を提供することを実証し、AIシステムの最適化における中間層の重要性を強調。</span>
<span class="snippet"><span>Comment</span>現代の代表的な言語モデルのアーキテクチャ（decoder-only model, encoder-only model, SSM）について、最終層のembeddingよりも中間層のembeddingの方がdownstream task（MTEBの32Taskの平均）に、一貫して（ただし、これはMTEBの平均で見たらそうという話であり、個別のタスクで一貫して強いかは読んでみないとわからない）強いことを示した研究。

<br>



<br>

このこと自体は経験的に知られているのであまり驚きではないのだが（ただ、SSMでもそうなのか、というのと、一貫して強いというのは興味深い）、この研究はMatrix Based Entropyと呼ばれるものに基づいて、これらを分析するための様々な指標を定義し理論的な根拠を示し、Autoregressiveな学習よりもMasked Languageによる学習の方がこのようなMiddle Layerのボトルネックが緩和され、同様のボトルネックが画像の場合でも起きることを示し、CoTデータを用いたFinetuningについても分析している模様。この辺の貢献が非常に大きいと思われるのでここを理解することが重要だと思われる。あとで読む。

<br>



<br>

<img src="https://github.com/user-attachments/assets/bda00c50-c97b-45e0-97a5-d98dd98599fd" alt="image" loading="lazy"></span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Bias.html">#Bias</a>
<a class="button" href="articles/NAACL.html">#NAACL</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/PerplexityCurse.html">#PerplexityCurse</a>
<span class="issue_date">Issue Date: 2025-05-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1922">Where is the answer? Investigating Positional Bias in Language Model   Knowledge Extraction, Kuniaki Saito+, NAACL'25</a>
<span class="snippet"><span>Summary</span>LLMは新しい文書でファインチューニングが必要だが、「困惑の呪い」により情報抽出が困難。特に文書の初めに関する質問には正確に答えるが、中間や末尾の情報抽出に苦労する。自己回帰的トレーニングがこの問題を引き起こすことを示し、デノイジング自己回帰損失が情報抽出を改善する可能性を示唆。これにより、LLMの知識抽出と新ドメインへの適応に関する新たな議論が生まれる。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/losnuevetoros/status/1918332232181207096?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q![Image](https://github.com/user-attachments/assets/dd6bdffa-4ce0-4389-826e-4c85113c755f)

<br>

LLMの知識を最新にするために新しい文書（e.g., 新しいドメインの文書等）をLLMに与え（便宜上学習データと呼ぶ）Finetuningをした場合、Finetuning後のモデルで与えられたqueryから（LLM中にパラメータとしてmemorizeされている）対応する事実情報を抽出するようInferenceを実施すると、queryに対応する事実情報の学習データ中での位置が深くなると（i.e., middle -・endになると）抽出が困難になる Positional Biasが存在する[^1]ことを明らかにした。

<br>

そして、これを緩和するために正則化が重要（e.g., Denoising, Shuffle, Attention Drops）であることを実験的に示し、正則化手法は複数組み合わせることで、よりPositional Biasが緩和することを示した研究

<br>



<br>

[^1]: 本研究では"Training"に利用する文書のPositional Biasについて示しており、"Inference"時におけるPositional Biasとして知られている"lost-in-the middle"とは異なる現象を扱っている点に注意データセット

<br>

文書 + QAデータの2種類を構築しFinetuning後のknowledge extraction能力の検証をしている[^2]。

<br>



<br>

実験では、`Synthetic Bio (合成データ)`, `Wiki2023+（実データ）` の2種類のデータを用いて、Positional Biasを検証している。

<br>

Synthetic bioは、人間のbiographyに関する9つの属性（e.g., 誕生日, 出生地）としてとりうる値をChatGPTに生成させ、3000人の人物に対してそれらをランダムにassignし、sentence templateを用いてSurface Realizationすることで人工的に3000人のbiographyに関するテキストを生成している。

<br>

一方、Wiki2023+では、1708 の方法にのっとって [^3]事前学習時の知識とのoverlapが最小となるように`2023`カテゴリ以下のwikipediaの様々なジャンルの記事を収集して活用する。QAデータの構築には、元文書からsentenceを抽出し、GPT-3.5-Turboに当該sentenceのみを与えてQA pairを作成させることで、データを作成している。なお、hallucinationや品質の低いQA pairをフィルタリングした。フィルタリング後のQA Pairをランダムにサンプリングし品質を確認したところ、95%のQA pairが妥当なものであった。

<br>



<br>

これにより、下図のようなデータセットが作成される。FigureCが `Wiki2023+`で、FigureDが`SyntheticBio`。`Wiki2023+`では、QA pairの正解が文書中の前半により正解が現れるような偏りが見受けられる。

<br>

![Image](https://github.com/user-attachments/assets/1146328f-de7e-4e90-b495-b129730c5d0d)

<br>



<br>

[^2]: 1923 において、知識 + 知識を抽出するタスクの双方を用いて学習することで、モデルから知識を抽出する能力が備わることが示されているため。

<br>

[^3]: Llama-2-7Bにおいて2023カテゴリ以下の情報に対するQAのperformanceが著しく低いことから、事前学習時に当該データが含まれている可能性が低いことが示唆されている実験 &amp; 実験結果 (modulated data)

<br>

作成した文書+QAデータのデータセットについて、QAデータをtrain/valid/testに分けて、文書データは全て利用し、testに含まれるQAに適切に回答できるかで性能を評価する。このとき、文書中でQAに対する正解がテキストが出現する位置を変化させモデルの学習を行い、予測性能を見ることで、Positional Biasが存在することを明らかにする。このとき、1923 に倣い、文書とQAをMixed Sampling（1バッチあたり256件のサンプルをランダムにQAおよび文書データからサンプリング; 1923 では文書とQAを2:8の比率でサンプリングしている）することで学習をする。QAの場合目的関数は回答テキスト部分のみのNLL、文書の場合はnext-token prediction lossを利用する。

<br>



<br>

Positional Biasの存在を示すだけでなく、(A, B, C) の順番でnext-token prediction lossで学習されたモデルの場合、Cの知識を抽出するためにA, Bがcontextとして必要となるため、Cを抽出する際の汎化性能を高めるためにA, Bの表現がより多様である必要がある、という課題がある。これに対処するためのいくつかのシンプルな正則化手法、具体的には

<br>

・D-AR: predition targetのトークンは保持したまま、input tokenの一部をランダムなトークンに置き換える

<br>

・Shuffle: 入力文をシャッフルする

<br>

・Attn Drop: self-attentionモジュールのattention weightをランダムに0にする

<br>

の3種類とPositional Biasの関係性を検証している。

<br>

![Image](https://github.com/user-attachments/assets/503e53f2-28f5-46ea-a11f-beee98f8fa38)

<br>



<br>

検証の結果、（合成データ、実データともに）Positional Biasが存在することが明らかとなり（i.e., 正解テキストが文書中の深い位置にあればあるほど予測性能が低下する）正則化によってPositional Biasが緩和されることが示された。

<br>

![Image](https://github.com/user-attachments/assets/11a29a1e-f869-4628-9c47-e1fc9e5c394e)

<br>



<br>

また、異なるモデルサイズで性能を比較したところ、モデルサイズを大きくすることで性能自体は改善するが、依然としてPositional Biasが存在することが示され、ARよりもD-ARが一貫して高い性能を示した。このことから、Positional Biasを緩和するために何らかの正則化手法が必要なことがわかる。

<br>

![Image](https://github.com/user-attachments/assets/0772d144-c22b-4723-8578-acdf0e2e1187)

<br>



<br>

また、オリジナル文書の1文目を、正解データの位置を入れ替えた各モデルに対して、テキスト中の様々な位置に配置してPerplexityを測った。この設定では、モデルがPerplexityを最小化するためには、（1文目ということは以前の文脈が存在しないsentenceなので）文脈に依存せずに文の記憶していなければならない。よって、各手法ごとにどの程度Perplexityが悪化するかで、各手法がどの程度あるsentenceを記憶する際に過去の文脈に依存しているかが分かる。ここで、学習データそのもののPerplexityはほぼ1.0であったことに注意する。

<br>

結果として、文書中の深い位置に配置されればされるほどPerplexityは増大し（left）、Autoregressive Model (AR) のPerplexity値が最も値が大きかった（=性能が悪かった）。このことから、ARはより過去の文脈に依存してsentenceの情報を記憶していることが分かる。また、モデルサイズが小さいモデルの方がPerplexityは増大する傾向にあることがわかった (middle)。これはFig.3で示したQAのパフォーマンスと傾向が一致しており、学習データそのもののPerplexityがほぼ1.0だったことを鑑みると、学習データに対するPerplexityは様々なPositionに位置する情報を適切に抽出できる能力を測るメトリックとしては適切でないことがわかる。また、学習のiterationを増やすと、ARの場合はfirst positionに対する抽出性能は改善したが、他のpositionでの抽出性能は改善しなかった。一方、D-ARの場合は、全てのpositionでの抽出性能が改善した (right) 。このことから、必ずしも学習のiterationを増やしても様々なPositionに対する抽出性能が改善しないこと、longer trainingの恩恵を得るためには正則化手法を利用する必要があることが明らかになった。

<br>



<br>

![Image](https://github.com/user-attachments/assets/94f635a5-68d5-478d-ab16-513e855fe054)

<br>

実験 &amp; 実験結果 (unmodulated data)

<br>

Wiki2023+データに対して上記のようなデータの変更を行わずに、そのまま学習を行い、各位置ごとのQAの性能を測定したところ、（すべてがPositional Biasのためとは説明できないが）回答が文書中の深い位置にある場合の性能が劣化することを確認した。2--6番目の性能の低下は、最初の文ではシンプルな事実が述べられ、後半になればなるほどより複雑な事実が述べられる傾向があることが起因して性能の低下しているとかせつをたてている。また、unmodulated dataの場合でもD-ARはARの性能を改善することが明らかとなった。モデルサイズが大きいほど性能は改善するが、以前として文書中の深い位置に正解がある場合に性能は劣化することもわかる。

<br>

<img src="https://github.com/user-attachments/assets/2f43ba8a-c54e-4523-b8f0-7cfc797d5a7e" alt="image" loading="lazy">

<br>



<br>

また、正則化手法は組み合わせることでさらに性能が改善し、1923 に示されている通り、学習データ中の表現を多様にし[^1]学習したところ予測性能が改善し、正則化手法とも補完的な関係であることも示された。

<br>

<img src="https://github.com/user-attachments/assets/e79415b1-28e2-47ab-b429-448412053d0b" alt="image" loading="lazy">

<br>



<br>

医療ドメインでも実験したところ、正則化手法を適用した場合にARよりも性能が上回った。最後にWiki2023+データについてOpenbookな設定で、正解が含まれる文書をLLMのcontextとして与えた場合（i.e.,ほぼ完璧なretrieverが存在するRAGと同等の設定とみなせる）、QAの性能は90.6%に対し、継続学習した場合のベストモデルの性能は50.8%だった。このことから、正確なretrieverが存在するのであれば、継続学習よりもRAGの方がQAの性能が高いと言える。

<br>

RAGと継続学習のメリット、デメリットの両方を考慮して、適切に手法を選択することが有効であることが示唆される。

<br>

<img src="https://github.com/user-attachments/assets/14180452-5421-4102-8751-fabc8b780d49" alt="image" loading="lazy">

<br>



<br>

[^1]: ChatGPTによってテキストをrephraseし、sentenceのorderも変更することで多様性を増やした。が、sentence orderが文書中の深い位置にある場合にあまりorderが変化しなかったようで、このため深い位置に対するQAの性能改善が限定的になっていると説明している。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2025-04-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1918">When More is Less: Understanding Chain-of-Thought Length in LLMs, Yuyang Wu+, ICLR'25</a>
<span class="snippet"><span>Summary</span>Chain-of-thought (CoT)推論は、LLMsの多段階推論能力を向上させるが、CoTの長さが増すと最初は性能が向上するものの、最終的には低下することが観察される。長い推論プロセスがノイズに脆弱であることを示し、理論的に最適なCoTの長さを導出。Length-filtered Voteを提案し、CoTの長さをモデルの能力とタスクの要求に合わせて調整する必要性を強調。</span>
<span class="snippet"><span>Comment</span>ICLR 2025 Best Paper Runner Up Award

<br>

元ポスト:https://x.com/yifeiwang77/status/1916873981979660436?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/KnowledgeEditing.html">#KnowledgeEditing</a>
<span class="issue_date">Issue Date: 2025-04-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1917">AlphaEdit: Null-Space Constrained Knowledge Editing for Language Models, Junfeng Fang+, ICLR'25</a>
<span class="snippet"><span>Summary</span>AlphaEditは、LLMsの知識を保持しつつ編集を行う新しい手法で、摂動を保持された知識の零空間に投影することで、元の知識を破壊する問題を軽減します。実験により、AlphaEditは従来の位置特定-編集手法の性能を平均36.7%向上させることが確認されました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1917343444810489925?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QOpenReview:https://openreview.net/forum?id=HvSytvg3JhMLPに新たな知識を直接注入する際に（≠contextに含める）既存の学習済みの知識を破壊せずに注入する手法（破壊しないことが保証されている）を提案しているらしい将来的には、LLMの1パラメータあたりに保持できる知識量がわかってきているので、MLPの零空間がN GBのモデルです、あなたが注入したいドメイン知識の量に応じて適切な零空間を持つモデルを選んでください、みたいなモデルが公開される日が来るのだろうか。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2025-04-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1916">Can LLMs Be Trusted for Evaluating RAG Systems? A Survey of Methods and  Datasets, Lorenz Brehme+, arXiv'25</a>
<span class="snippet"><span>Summary</span>RAGシステムの評価手法を63件の論文を基にレビューし、データセット、リトリーバー、インデクシング、生成コンポーネントの4領域に焦点を当てる。自動評価アプローチの実現可能性を観察し、LLMを活用した評価データセットの生成を提案。企業向けに実装と評価の指針を提供するための実践的研究の必要性を強調し、評価手法の進展と信頼性向上に寄与する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_reachsumit/status/1917425829233189027?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qおもしろそう</span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<span class="issue_date">Issue Date: 2025-04-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1910">Generative Product Recommendations for Implicit Superlative Queries, Kaustubh D. Dhole+, arXiv'25</a>
<span class="snippet"><span>Summary</span>レコメンダーシステムにおいて、ユーザーの曖昧なクエリに対して大規模言語モデル（LLMs）を用いて暗黙の属性を生成し、製品推薦を改善する方法を探る。新たに提案する4ポイントスキーマ「SUPERB」を用いて最上級クエリに対する製品候補を注釈付けし、既存の検索およびランキング手法を評価する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_reachsumit/status/1917084325499273671?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Quantization.html">#Quantization</a>
<a class="button" href="articles/SmallModel.html">#SmallModel</a>
<span class="issue_date">Issue Date: 2025-04-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1898">BitNet b1.58 2B4T Technical Report, Shuming Ma+, arXiv'25</a>
<span class="snippet"><span>Summary</span>BitNet b1.58 2B4Tは、20億パラメータを持つオープンソースの1ビット大規模言語モデルで、4兆トークンで訓練されました。言語理解や数学的推論などのベンチマークで評価され、同サイズのフルプレシジョンLLMと同等の性能を示しつつ、計算効率が向上しています。メモリ、エネルギー消費、デコーディングレイテンシが削減され、モデルの重みはHugging Faceで公開されています。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iscienceluvr/status/1912783876365177235?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q圧倒的省メモリかつcpuでのinference速度も早そう

<br>

<img src="https://github.com/user-attachments/assets/dacf05e4-9cb3-48b4-9a98-532f7245eb8e" alt="image" loading="lazy">・アーキテクチャはTransformerを利用

<br>

・Linear layerとしてBitLinear Layerを利用

<br>

  ・重みは{1, 0, -1}の3値をとる

<br>

  ・activationは8bitのintegerに量子化

<br>

  ・Layer Normalizationはsubln normalization 1899 を利用</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/x-Use.html">#x-Use</a>
<span class="issue_date">Issue Date: 2025-04-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1897">AndroidWorld: A Dynamic Benchmarking Environment for Autonomous Agents, Christopher Rawles+, ICLR'25</a>
<span class="snippet"><span>Summary</span>本研究では、116のプログラムタスクに対して報酬信号を提供する「AndroidWorld」という完全なAndroid環境を提案。これにより、自然言語で表現されたタスクを動的に構築し、現実的なベンチマークを実現。初期結果では、最良のエージェントが30.6%のタスクを完了し、さらなる研究の余地が示された。また、デスクトップWebエージェントのAndroid適応が効果薄であることが明らかになり、クロスプラットフォームエージェントの実現にはさらなる研究が必要であることが示唆された。タスクの変動がエージェントのパフォーマンスに影響を与えることも確認された。</span>
<span class="snippet"><span>Comment</span>Android環境でのPhone Useのベンチマーク</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<span class="issue_date">Issue Date: 2025-04-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1893">d1: Scaling Reasoning in Diffusion Large Language Models via  Reinforcement Learning, Siyan Zhao+, arXiv'25</a>
<span class="snippet"><span>Summary</span>d1というフレームワークを提案し、マスク付きdLLMsを教師ありファインチューニングと強化学習で推論モデルに適応。マスク付きSFT技術で知識を抽出し、diffu-GRPOという新しいRLアルゴリズムを導入。実証研究により、d1が最先端のdLLMの性能を大幅に向上させることを確認。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iscienceluvr/status/1912785180504535121?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QdLLMに対してGRPOを適用する手法(diffuGRPO)を提案している。

<br>

long CoTデータでSFTしてreasoning capabilityを強化した後、diffuGRPOで追加のpost-trainingをしてさらに性能をboostする。GRPOではtoken levelの尤度とsequence全体の尤度を計算する必要があるが、dLLMだとautoregressive modelのようにchain ruleを適用する計算方法はできないので、効率的に尤度を推定するestimatorを用いてGPPOを適用するdiffuGRPOを提案している。

<br>



<br>

diffuGRPO単体でも、8BモデルだがSFTよりも性能向上に成功している。SFTの後にdiffuGRPOを適用するとさらに性能が向上する。

<br>



<br>

SFTではs1 1749 で用いられたlong CoTデータを用いている。しっかり理解できていないが、diffuGRPO+verified rewardによって、long CoTの学習データを用いなくても、安定してreasoning能力を発揮することができようになった、ということなのだろうか？

<br>

しかし、AppendixCを見ると、元々のLLaDAの時点でreasoning traceを十分な長さで出力しているように見える。もしLLaDAが元々long CoTを発揮できたのだとしたら、long CoTできるようになったのはdiffuGRPOだけの恩恵ではないということになりそうだが、LLaDAは元々long CoTを生成できるようなモデルだったんだっけ…？その辺追えてない（dLLMがメジャーになったら追う）。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/Repetition.html">#Repetition</a>
<span class="issue_date">Issue Date: 2025-04-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1892">Learning Dynamics of LLM Finetuning, Yi Ren+, ICLR'25</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデルのファインチューニング中の学習ダイナミクスを分析し、異なる応答間の影響の蓄積を段階的に解明します。指示調整と好み調整のアルゴリズムに関する観察を統一的に解釈し、ファインチューニング後の幻覚強化の理由を仮説的に説明します。また、オフポリシー直接好み最適化（DPO）における「圧縮効果」を強調し、望ましい出力の可能性が低下する現象を探ります。このフレームワークは、LLMのファインチューニング理解に新たな視点を提供し、アラインメント性能向上のためのシンプルな方法を示唆します。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/joshuarenyi/status/1913033476275925414?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説ポスト:https://x.com/hillbig/status/1917189793588613299?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/SmallModel.html">#SmallModel</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-04-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1887">A Sober Look at Progress in Language Model Reasoning: Pitfalls and Paths  to Reproducibility, Andreas Hochlehnert+, arXiv'25</a>
<span class="snippet"><span>Summary</span>推論は言語モデルの重要な課題であり、進展が見られるが、評価手法には透明性や堅牢性が欠けている。本研究では、数学的推論ベンチマークが実装の選択に敏感であることを発見し、標準化された評価フレームワークを提案。再評価の結果、強化学習アプローチは改善が少なく、教師ありファインチューニング手法は強い一般化を示した。再現性を高めるために、関連するコードやデータを公開し、今後の研究の基盤を築く。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/wenhuchen/status/1911143014258405420?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QSLMをmath reasoning向けにpost-trainingする場合、RL（既存研究で試されているもの）よりも（大規模モデルからrejection samplingしたreasoning traceを用いて）SFTをする方が同等か性能が良く、結局のところ（おそらく汎化性能が低いという意味で）reliableではなく、かつ（おそらく小規模なモデルでうまくいかないという意味での）scalableではないので、reliableかつscalableなRL手法が不足しているとのこと。

<br>



<br>

※ 本論文で分析されているのは&lt;=10B以下のSLMである点に注意。10B以上のモデルで同じことが言えるかは自明ではない。

<br>

※ DAPO, VAPOなどについても同じことが言えるかも自明ではない。

<br>

※ DeepSeek-R1のtechnical reportにおいて、小さいモデルにGRPOを適用してもあまり効果が無かったことが既に報告されている。

<br>



<br>

<img src="https://github.com/user-attachments/assets/620017f1-b3f0-40c1-bf61-3b0b7a429ab4" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/321132c8-dad5-4aa1-9811-f032e3474135" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/fca985ee-2934-4543-8486-0ac4a9cc003f" alt="image" loading="lazy">

<br>



<br>

・1743

<br>

・1719個々のpost-trainingされたRLモデルが具体的にどういう訓練をしたのかは追えていないが、DAPOやDr. GRPO, VAPOの場合はどうなるんだろうか？

<br>



<br>

・1815

<br>

・1876

<br>

・1821

<br>



<br>

Rewardの設定の仕方はどのような影響があるのだろうか（verifiable rewardなのか、neuralモデルによるrewardなのかなど)？

<br>



<br>

学習のさせ方もどのような影響があるのだろうか（RLでカリキュラムlearningにした場合など）？

<br>



<br>

検証しているモデルがそれぞれどのような設定で学習されているかまでを見ないとこの辺はわからなそう。

<br>



<br>

ただなんとなーくの直感だと、SLMを賢くしたいという場合は何らかの賢いモデルの恩恵に預かるしかなく（SFTの場合はそれが大規模なモデルから蒸留したreasoning trace）、SLM+RLの場合はTPMのような思考プロセスを評価してRewardに反映させるようなものを利用しないと、少なくとも小規模なLLMをめちゃ賢くします〜というのはきついんじゃないかなあという感想ではある。

<br>

ただ、結局SLMという時点で多くの場合、より賢いパラメータ数の多いLLMが世の中には存在するあるはずなので、RLしないでSFTして蒸留すれば良いんじゃない…？と思ってしまう。

<br>

が、多くの場合その賢いLLMはProprietaryなLLMであり、出力を得て自分のモデルをpost-trainingすることは利用規約違反となるため、自前で賢くてパラメータ数の多いLLMを用意できない場合は困ってしまうので、SLMをクソデカパラメータのモデルの恩恵なしで超絶賢くできたら世の中の多くの人は嬉しいよね、とも思う。（斜め読みだが）

<br>

サンプル数が少ない（数十件）AIMEやAMCなどのデータはseedの値にとてもsensitiveであり、

<br>

<img src="https://github.com/user-attachments/assets/289d8049-41a2-4ab9-a95b-9b8b499bee57" alt="image" loading="lazy">

<br>



<br>

それらは10種類のseedを用いて結果を平均すると分散が非常に小さくなるので、seedは複数種類利用して平均の性能を見た方がreliableであり

<br>

<img src="https://github.com/user-attachments/assets/1d39c6d1-6f43-4d1e-af23-d3c7839d2b0a" alt="image" loading="lazy">

<br>



<br>

temperatureを高くするとピーク性能が上がるが分散も上がるため再現性の課題が増大するが、top-pを大きくすると再現性の問題は現れず性能向上に寄与し

<br>

<img src="https://github.com/user-attachments/assets/0a3c2a7a-527b-4225-b55e-6d148c848602" alt="image" loading="lazy">

<br>



<br>

既存研究のモデルのtemperatureとtop-pを変化させ実験するとperformanceに非常に大きな変化が出るため、モデルごとに最適な値を選定して比較をしないとunfairであることを指摘。

<br>

<img src="https://github.com/user-attachments/assets/ee664622-680a-4020-844a-8c2464fc8a5d" alt="image" loading="lazy">

<br>



<br>

また、ハードウェアの面では、vLLMのようなinference engineはGPU typeやmemoryのconfigurationに対してsensitiveでパフォーマンスが変わるだけでなく、

<br>

<img src="https://github.com/user-attachments/assets/36fc9dbd-1bfa-4a6d-92a7-4d2f2f477a84" alt="image" loading="lazy">

<br>



<br>

評価に利用するフレームワークごとにinference engineとprompt templateが異なるためこちらもパフォーマンスに影響が出るし、

<br>

<img src="https://github.com/user-attachments/assets/6b2005f5-7d70-4a79-a223-16ffffc2a3fd" alt="image" loading="lazy">

<br>



<br>

max output tokenの値を変化させると性能も変わり、prompt templateを利用しないと性能が劇的に低下する。

<br>

<img src="https://github.com/user-attachments/assets/684e74b2-0772-4de0-a2f6-7cb90b3e4c8a" alt="image" loading="lazy">

<br>



<br>

これらのことから著者らはreliableな評価のために下記を提案しており、

<br>

<img src="https://github.com/user-attachments/assets/941fc791-7639-4701-8866-deff5fdf511d" alt="image" loading="lazy">

<br>



<br>

実際にさまざまな条件をfair comparisonとなるように標準化して評価したところ

<br>

<img src="https://github.com/user-attachments/assets/b3b633cf-e827-4fad-8db6-567270066f93" alt="image" loading="lazy">

<br>



<br>

上の表のような結果となった。この結果は、

<br>

・DeepSeekR1-DistilledをRLしてもSFTと比較したときに意味のあるほどのパフォーマンスの向上はないことから、スケーラブル、かつ信頼性のあるRL手法がまだ不足しており

<br>

・大規模なパラメータのモデルのreasoning traceからSFTをする方法はさまざまなベンチマークでロバストな性能（＝高い汎化性能）を持ち、RLと比べると現状はRLと比較してよりパラダイムとして成熟しており

<br>

・（AIME24,25を比較するとSFTと比べてRLの場合performanceの低下が著しいので）RLはoverfittingしやすく、OODなベンチマークが必要

<br>



<br>

<img src="https://github.com/user-attachments/assets/93a808bb-6f43-4b30-883d-eb15d845e24b" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/e68deb4f-180c-4cd7-9e72-f2b6ea66c8e2" alt="image" loading="lazy">しっかりと評価の枠組みを標準化してfair comparisonしていかないと、RecSys業界の二の舞になりそう（というかもうなってる？）。

<br>



<br>

またこの研究で分析されているのは小規模なモデル（&lt;=10B）に対する既存研究で用いられた一部のRL手法や設定の性能だけ（真に示したかったらPhisics of LLMのような完全にコントロール可能なサンドボックスで実験する必要があると思われる）なので、DeepSeek-R1のように、大規模なパラメータ（数百B）を持つモデルに対するRLに関して同じことが言えるかは自明ではない点に注意。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/AttentionSinks.html">#AttentionSinks</a>
<span class="issue_date">Issue Date: 2025-04-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1878">Using Attention Sinks to Identify and Evaluate Dormant Heads in  Pretrained LLMs, Pedro Sandoval-Segura+, arXiv'25</a>
<span class="snippet"><span>Summary</span>マルチヘッドアテンションにおける「休眠アテンションヘッド」を定義し、その影響を調査。6つのモデルと5つのデータセットを用いた実験で、休眠ヘッドの出力をゼロにしても精度を維持できることを確認。休眠ヘッドは事前学習の初期に出現し、入力テキストの特性に依存することが示された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/psandovalsegura/status/1909652533334712691?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<span class="issue_date">Issue Date: 2025-04-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1876">VAPO: Efficient and Reliable Reinforcement Learning for Advanced  Reasoning Tasks, YuYue+, arXiv'25</a>
<span class="snippet"><span>Summary</span>VAPO（Value-based Augmented Proximal Policy Optimization framework）を提案し、AIME 2024データセットで最先端のスコア60.4を達成。VAPOは他の手法を10ポイント以上上回り、5,000ステップで安定したパフォーマンスを示す。価値ベースの強化学習における3つの課題を特定し、VAPOがそれらを軽減する統合ソリューションを提供することで、長い思考過程の推論タスクの性能向上を実現。</span>
<span class="snippet"><span>Comment</span>同じくByteDanceの

<br>



<br>

・1815

<br>



<br>

を上回る性能

<br>

<img src="https://github.com/user-attachments/assets/51f7a43a-9410-45f3-989c-4e0b1fdd86ef" alt="image" loading="lazy">元ポスト:https://x.com/_akhaliq/status/1909564500170223751?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<span class="issue_date">Issue Date: 2025-04-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1871">KAA: Kolmogorov-Arnold Attention for Enhancing Attentive Graph Neural  Networks, Taoran Fang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>注意GNNにおけるスコアリングプロセスの理解が不足している中、本研究ではコルモゴロフ・アルノルド注意（KAA）を提案し、スコアリング関数を統一。KAAはKANアーキテクチャを統合し、ほぼすべての注意GNNに適用可能で、表現力が向上。実験により、KAA強化スコアリング関数が元のものを一貫して上回り、最大20%以上の性能向上を達成した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/theturingpost/status/1908966571227398449?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<span class="issue_date">Issue Date: 2025-04-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1870">XAttention: Block Sparse Attention with Antidiagonal Scoring, Ruyi Xu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>XAttentionは、Long-Context Transformer Modelsにおける長文コンテキスト推論を加速するプラグアンドプレイのフレームワークで、注意行列の反対対角線の値を用いてブロックの重要度を評価し、非本質的なブロックを剪定することで高いスパース性を実現。RULERやLongBenchなどのベンチマークでフルアテンションに匹敵する精度を保ちながら、最大13.5倍の計算加速を達成。XAttentionはLCTMsの効率的な展開を可能にする。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/theturingpost/status/1908966571227398449?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<span class="issue_date">Issue Date: 2025-04-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1869">Slim attention: cut your context memory in half without loss of accuracy  -- K-cache is all you need for MHA, Nils Graef+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Slim attentionは、トランスフォーマーモデルのMHAにおいてコンテキストメモリを2倍に縮小し、推論速度を最大2倍向上させる手法で、精度を損なうことなく実装可能です。特に、Whisperモデルではコンテキストメモリを8倍削減し、トークン生成を5倍速くすることができます。また、稀なケースではT5-11Bモデルでメモリを32倍削減することも可能です。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/theturingpost/status/1908966571227398449?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/RewardHacking.html">#RewardHacking</a>
<span class="issue_date">Issue Date: 2025-04-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1867">CREAM: Consistency Regularized Self-Rewarding Language Models, Zhaoyang Wang+, ICLR'25</a>
<span class="snippet"><span>Summary</span>自己報酬型LLMは、LLM-as-a-Judgeを用いてアラインメント性能を向上させるが、報酬とランク付けの正確性が問題。小規模LLMの実証結果は、自己報酬の改善が反復後に減少する可能性を示唆。これに対処するため、一般化された反復的好みファインチューニングフレームワークを定式化し、正則化を導入。CREAMを提案し、報酬の一貫性を活用して信頼性の高い好みデータから学習。実証結果はCREAMの優位性を示す。</span>
<span class="snippet"><span>Comment</span>・1212

<br>



<br>

を改善した研究OpenReview:https://openreview.net/forum?id=Vf6RDObyEFこの方向性の研究はおもしろい</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/AttentionSinks.html">#AttentionSinks</a>
<span class="issue_date">Issue Date: 2025-04-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1862">When Attention Sink Emerges in Language Models: An Empirical View, Xiangming Gu+, ICLR'25</a>
<span class="snippet"><span>Summary</span>言語モデルにおける「アテンションシンク」は、意味的に重要でないトークンに大きな注意を割り当てる現象であり、さまざまな入力に対して小さなモデルでも普遍的に存在することが示された。アテンションシンクは事前学習中に出現し、最適化やデータ分布、損失関数がその出現に影響を与える。特に、アテンションシンクはキーのバイアスのように機能し、情報を持たない追加のアテンションスコアを保存することがわかった。この現象は、トークンがソフトマックス正規化に依存していることから部分的に生じており、正規化なしのシグモイドアテンションに置き換えることで、アテンションシンクの出現を防ぐことができる。</span>
<span class="snippet"><span>Comment</span>Sink Rateと呼ばれる、全てのheadのFirst Tokenに対するattention scoreのうち（layer l  head h個存在する）、どの程度の割合のスコアが閾値を上回っているかを表す指標を提案・1860

<br>



<br>

の先行研究著者ポスト（openai-gpt-120Bを受けて):

<br>

https://x.com/gu_xiangming/status/1952811057673642227?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/AttentionSinks.html">#AttentionSinks</a>
<span class="issue_date">Issue Date: 2025-04-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1860">Why do LLMs attend to the first token?, Federico Barbero+, arXiv'25</a>
<span class="snippet"><span>Summary</span>LLMsは最初のトークンに強く注意を向ける「アテンションシンク」を示し、そのメカニズムが過剰混合を避ける方法を理論的・実証的に探求。コンテキストの長さやデータのパッキングがシンクの挙動に与える影響を実験で示し、アテンションパターンの理解を深めることを目指す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/omarsar0/status/1908187563422261411?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QAttention Sinkによって、トークンの情報がover-mixingされることが抑制され、Decoder-only LLMの深い層のrepresentationが均一化されることを抑制する（＝promptの摂動にロバストになる）ことが示された模様。

<br>

<img src="https://github.com/user-attachments/assets/8a1223c0-5621-42a5-accc-31fa7f636856" alt="image" loading="lazy">

<br>

Gemma7Bにおいて、prompt中のトークン一語を置換した後に、Attention Sink（<bos>）の有無によって、tokenレベルのrepresentationに対してどのような摂動があるかをlayerごとにまとめた図が下記の模様。Attention Sinkによって、tokenの摂動が他のtoken, layerに対してmixingされるのが抑制されている。

<br>

<img src="https://github.com/user-attachments/assets/b1a4038a-d116-4bd1-b27b-c55eb861bee9" alt="image" loading="lazy">&lt;/span&gt;
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ConceptErasure.html">#ConceptErasure</a>
<a class="button" href="articles/AISTATS.html">#AISTATS</a>
<span class="issue_date">Issue Date: 2025-04-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1859">Fundamental Limits of Perfect Concept Erasure, Somnath Basu Roy Chowdhury+, AISTATS'25</a>
<span class="snippet"><span>Summary</span>概念消去は、性別や人種などの情報を消去しつつ元の表現を保持するタスクであり、公平性の達成やモデルのパフォーマンスの解釈に役立つ。従来の技術は消去の堅牢性を重視してきたが、有用性とのトレードオフが存在する。本研究では、情報理論的視点から概念消去の限界を定量化し、完璧な消去を達成するためのデータ分布と消去関数の制約を調査。提案する消去関数が理論的限界を達成し、GPT-4を用いたデータセットで既存手法を上回ることを示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/somnathbrc/status/1907463419105570933?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<span class="issue_date">Issue Date: 2025-04-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1858">What, How, Where, and How Well? A Survey on Test-Time Scaling in Large  Language Models, Qiyuan Zhang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>テスト時スケーリング（TTS）が大規模言語モデル（LLMs）の問題解決能力を向上させることが示されているが、体系的な理解が不足している。これを解決するために、TTS研究の4つのコア次元に基づく統一的なフレームワークを提案し、手法や応用シナリオのレビューを行う。TTSの発展の軌跡を抽出し、実践的なガイドラインを提供するとともに、未解決の課題や将来の方向性についての洞察を示す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hesamation/status/1907095419793911893?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qとてつもない量だ…網羅性がありそう。

<br>

What to Scaleがよくあるself

<br>

consistency(Parallel Scaling), STaR(Sequential Scailng), Tree of Thought(Hybrid Scaling), DeepSeek-R1, o1/3(Internal Scaling)といった分類で、How to ScaleがTuningとInferenceに分かれている。TuningはLong CoTをSFTする話や強化学習系の話（GRPOなど）で、InferenceにもSelf consistencyやらやらVerificationやら色々ありそう。良さそう。

<br>

<img src="https://github.com/user-attachments/assets/9d76e438-ff75-454d-b549-7efda9baa300" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<span class="issue_date">Issue Date: 2025-04-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1855">Multi-Token Attention, Olga Golovneva+, arXiv'25</a>
<span class="snippet"><span>Summary</span>マルチトークンアテンション（MTA）を提案し、複数のクエリとキーのベクトルに基づいてアテンションウェイトを条件付けることで、関連するコンテキストをより正確に特定できるようにする。MTAは畳み込み操作を用いて、近くのトークンが互いに影響を与え、豊かな情報を活用する。評価結果から、MTAはTransformerベースラインモデルを上回り、特に長いコンテキストでの情報検索において優れた性能を示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jaseweston/status/1907260086017237207?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q従来のMulti Head Attentionでは、単体のQKのみを利用していたけど、複数のQKの情報を畳み込んで活用できるようにして、Headも畳み込みで重要な情報がより伝搬されるようにして、GroupNormalizationをかけたらPerplexityの観点でDifferential Transformerを上回ったよ、という話な模様。

<br>



<br>

<img src="https://github.com/user-attachments/assets/199e0794-a286-486d-9426-d86cfd208750" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/2997a61b-3367-4f43-b85a-ac8fa160391a" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/5ef8ddb0-538b-46e2-94b8-2ef495c938ec" alt="image" loading="lazy">

<br>



<br>

・1856

<br>

・1466</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/QuestionGeneration.html">#QuestionGeneration</a>
<span class="issue_date">Issue Date: 2025-04-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1853">Interactive Agents to Overcome Ambiguity in Software Engineering, Sanidhya Vijayvargiya+, arXiv'25</a>
<span class="snippet"><span>Summary</span>AIエージェントはあいまいな指示に基づくタスク自動化に利用されるが、誤った仮定や質問不足がリスクを生む。本研究では、LLMエージェントのあいまいな指示処理能力を評価し、インタラクティビティを活用したパフォーマンス向上、あいまいさの検出、目標を絞った質問の実施を検討。結果、モデルは明確な指示と不十分な指示を区別するのが難しいが、インタラクションを通じて重要な情報を取得し、パフォーマンスが向上することが示された。これにより、現在のモデルの限界と改善のための評価手法の重要性が明らかになった。</span>
<span class="snippet"><span>Comment</span>曖昧なユーザメッセージに対する、エージェントが"質問をする能力を測る"ベンチマーク

<br>



<br>

<img width="422" alt="Image" src="https://github.com/user-attachments/assets/3d201ebf-9ca1-4333-9d27-e33a9028066f"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/FactualKnowledge.html">#FactualKnowledge</a>
<span class="issue_date">Issue Date: 2025-04-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1846">Inside-Out: Hidden Factual Knowledge in LLMs, Zorik Gekhman+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究は、LLMが出力以上の事実的知識をエンコードしているかを評価するフレームワークを提案。知識を定義し、正しい回答が高くランク付けされる割合を定量化。外部知識と内部知識を区別し、内部知識が外部知識を超えると隠れた知識が生じることを示す。クローズドブックQA設定でのケーススタディでは、LLMが内部で多くの知識をエンコードしていること、知識が隠れている場合があること、サンプリングによる制約があることを明らかにした。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/zorikgekhman/status/1906693729886363861?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/SpeechProcessing.html">#SpeechProcessing</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Video.html">#Video</a>
<span class="issue_date">Issue Date: 2025-03-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1843">Qwen2.5-Omni Technical Report, Jin Xu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>マルチモーダルモデル「Qwen2.5-Omni」は、テキスト、画像、音声、動画を認識し、ストリーミング方式で自然な音声応答を生成する。音声と視覚エンコーダはブロック処理を用い、TMRoPEによる新しい位置埋め込みで音声と動画の同期を実現。Thinker-Talkerアーキテクチャにより、テキスト生成と音声出力を干渉なく行う。Qwen2.5-Omniは、エンドツーエンドで訓練され、音声指示に対する性能がテキスト入力と同等で、ストリーミングTalkerは既存手法を上回る自然さを持つ。</span>
<span class="snippet"><span>Comment</span>Qwen TeamによるマルチモーダルLLM。テキスト、画像、動画音声をinputとして受け取り、テキスト、音声をoutputする。

<br>

<img src="https://github.com/user-attachments/assets/03e54fd7-2011-4069-aa1b-38d1610169ec" alt="image" loading="lazy">

<br>



<br>

weight:https://huggingface.co/collections/Qwen/qwen25-omni-67de1e5f0f9464dc6314b36e元ポスト:https://www.linkedin.com/posts/niels-rogge-a3b7a3127_alibabas-qwen-team-has-done-it-again-this-activity-7311036679627132929-HUqy?utm_source=share&utm_medium=member_ios&rcm=ACoAACzQvjwB2FeLVE3yukDiUYtr5J4k-6nlNG4</span>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/GenerativeAI.html">#GenerativeAI</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-03-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1842">Measuring AI Ability to Complete Long Tasks, Thomas Kwa+, arXiv'25</a>
<span class="snippet"><span>Summary</span>新しい指標「50%-タスク完了時間ホライズン」を提案し、AIモデルの能力を人間の観点から定量化。Claude 3.7 Sonnetは約50分の時間ホライズンを持ち、AIの能力は2019年以降約7か月ごとに倍増。信頼性や論理的推論の向上が要因とされ、5年以内にAIが多くのソフトウェアタスクを自動化できる可能性を示唆。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1902854727089656016?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q確かに線形に見える。てかGPT-2と比べるとAIさん進化しすぎである…。

<br>

<img src="https://github.com/user-attachments/assets/266a36aa-a169-492b-b8af-60c0cb152111" alt="image" loading="lazy">利用したデータセットは

<br>

・HCAST: 46のタスクファミリーに基づく97種類のタスクが定義されており、たとえばサイバーセキュリティ、機械学習、ソフトウェアエンジニアリング、一般的な推論タスク（wikipediaから事実情報を探すタスクなど）などがある

<br>

  ・数分で終わるタスク: 上述のwikipedia

<br>

  ・数時間で終わるタスク: Pytorchのちょっとしたバグ修正など

<br>

  ・数文でタスクが記述され、コード、データ、ドキュメント、あるいはwebから入手可能な情報を参照可能

<br>

　・タスクの難易度としては当該ドメインに数年間携わった専門家が解ける問題

<br>

・RE-Bench Suite

<br>

  ・7つのopen endedな専門家が8時間程度を要するMLに関するタスク

<br>

　・e.g., GPT-2をQA用にFinetuningする, Finetuningスクリプトが与えられた時に挙動を変化させずにランタイムを可能な限り短縮する、など

<br>

　・[RE-Bench Technical Report](https://metr.org/AI_R_D_Evaluation_Report.pdf)のTable2等を参照のこと

<br>

・SWAA Suite: 66種類の1つのアクションによって1分以内で終わるソフトウェアエンジニアリングで典型的なタスク

<br>

  ・1分以内で終わるタスクが上記データになかったので著者らが作成

<br>



<br>

であり、画像系やマルチモーダルなタスクは含まれていない。

<br>

<img src="https://github.com/user-attachments/assets/0b3892c9-3c83-4f78-a490-c28fa7470e0e" alt="image" loading="lazy">

<br>



<br>

タスクと人間がタスクに要する時間の対応に関するサンプルは下記

<br>

<img src="https://github.com/user-attachments/assets/5ed472da-e8c9-41be-8fd1-ef6f21713c14" alt="image" loading="lazy">タスク-エージェントペアごとに8回実行した場合の平均の成功率。確かにこのグラフからはN年後には人間で言うとこのくらいの能力の人がこのくらい時間を要するタスクが、このくらいできるようになってます、といったざっくり感覚値はなかなか想像できない。

<br>

<img src="https://github.com/user-attachments/assets/e2bed06e-9234-4607-826a-588106010bcf" alt="image" loading="lazy">成功率とタスクに人間が要する時間に関するグラフ。ロジスティック関数でfittingしており、赤い破線が50% horizon。Claude 3.5 Sonnet （old）からClaude 3.7 Sonnetで50% horizonは18分から59分まで増えている。実際に数字で見るとイメージが湧きやすくおもしろい。

<br>

<img src="https://github.com/user-attachments/assets/efe01e35-6ee6-45a5-8a4c-eccf95284b35" alt="image" loading="lazy">こちらで最新モデルも随時更新される:

<br>

https://metr.org/blog/2025-03-19-measuring-ai-ability-to-complete-long-tasks/</span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/CollaborativeFiltering.html">#CollaborativeFiltering</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-03-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1839">RALLRec+: Retrieval Augmented Large Language Model Recommendation with  Reasoning, Sichun Luo+, arXiv'25</a>
<span class="snippet"><span>Summary</span>RALLRec+は、LLMsを用いてレコメンダーシステムのretrievalとgenerationを強化する手法。retrieval段階では、アイテム説明を生成し、テキスト信号と協調信号を結合。生成段階では、推論LLMsを評価し、知識注入プロンプティングで汎用LLMsと統合。実験により、提案手法の有効性が確認された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_reachsumit/status/1905107217663336832?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QReasoning LLMをRecSysに応用する初めての研究（らしいことがRelated Workに書かれている）arxivのadminより以下のコメントが追記されている

<br>

&gt; 	arXiv admin note: substantial text overlap with arXiv:2502.06101

<br>



<br>

コメント中の研究は下記である

<br>

・1840</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<span class="issue_date">Issue Date: 2025-03-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1838">Scaling Evaluation-time Compute with Reasoning Models as Process  Evaluators, Seungone Kim+, arXiv'25</a>
<span class="snippet"><span>Summary</span>LMの出力品質評価が難しくなっている中、計算を増やすことで評価能力が向上するかを検討。推論モデルを用いて応答全体と各ステップを評価し、推論トークンの生成が評価者のパフォーマンスを向上させることを確認。再ランク付けにより、評価時の計算増加がLMの問題解決能力を向上させることを示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jinulee_v/status/1905025016401428883?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLLM-as-a-JudgeもlongCoT+self-consistencyで性能が改善するらしい。

<br>

<img src="https://github.com/user-attachments/assets/937b6241-4877-46c7-a488-5ee6bf8203db" alt="image" loading="lazy"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-03-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1837">Overtrained Language Models Are Harder to Fine-Tune, Jacob Mitchell Springer+, ICLR'25</a>
<span class="snippet"><span>Summary</span>大規模言語モデルの事前学習において、トークン予算の増加がファインチューニングを難しくし、パフォーマンス低下を引き起こす「壊滅的な過学習」を提唱。3Tトークンで事前学習されたOLMo-1Bモデルは、2.3Tトークンのモデルに比べて2%以上の性能低下を示す。実験と理論分析により、事前学習パラメータの感度の増加が原因であることを示し、事前学習設計の再評価を促す。</span>
<span class="snippet"><span>Comment</span>著者によるポスト:https://x.com/jacspringer/status/1904960783341023521?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q事前学習のトークン数を増やすとモデルのsensitivityが増し、post-trainingでのパフォーマンスの劣化が起こることを報告している。事前学習で学習するトークン数を増やせば、必ずしもpost-training後のモデルの性能がよくなるわけではないらしい。

<br>

<img src="https://github.com/user-attachments/assets/ba60ae24-f3e5-4956-b29f-37b4fe01a9d1" alt="image" loading="lazy">ICLR'25のOutstanding Paperに選ばれた模様:

<br>

https://x.com/jacspringer/status/1917174452531724718?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

きちんと読んだ方が良さげ。</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/COLM.html">#COLM</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-03-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1832">Critique Fine-Tuning: Learning to Critique is More Effective than   Learning to Imitate, Yubo Wang+, COLM'25</a>
<span class="snippet"><span>Summary</span>批評ファインチューニング（CFT）は、言語モデルがノイズのある応答を批評することを学ぶ新しい戦略で、従来の監視付きファインチューニング（SFT）に挑戦します。CFTは人間の学習プロセスにインスパイアを受け、深い分析を促進します。WebInstructから構築した50Kサンプルのデータセットを用いて、CFTは複数のベースモデルでSFTに対して4-10%の性能向上を示しました。特に、Qwen2.5-Math-CFTは少ないトレーニングで強力な競合と同等の性能を発揮し、CFTの堅牢性も確認されました。CFTは言語モデルの推論を進展させる効果的な手法であると主張します。</span>
<span class="snippet"><span>Comment</span>元ポスト: https://x.com/WenhuChen/status/1885060597500567562Critique Fine-Tuning (CFT) を提案。CFTでは、query x, noisy response y [^1] が与えられたときに、それに対する批評 cを学習する。cはgivenではないので、GPT4oのような強力なモデルによって合成する。

<br>



<br>

![Image](https://github.com/user-attachments/assets/f25babdd-63d6-4d3d-a9b0-3217db2bd07f)

<br>



<br>

目的関数は以下。[x; y] がgivenな時にcを生成する確率を最大化する。シンプル。

<br>

![Image](https://github.com/user-attachments/assets/ccdb8e42-e8b2-4ae1-99a6-a0b7c1d4bf2a)

<br>



<br>

RLを用いた手法との比較。1/10程度のデータ量、1/100程度のGPU時間で同等の性能を達成できる。

<br>

![Image](https://github.com/user-attachments/assets/848376ff-9965-485b-b8a0-7960d1d0e7b9)

<br>



<br>

[^1]: 本論文で利用しているWebInstructからサンプリングしたデータでは、たとえば約50%程度のyが正解,  残りは不正解（程度のnoisyデータを利用している）</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-03-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1826">Thinking Machines: A Survey of LLM based Reasoning Strategies, Dibyanayan Bandyopadhyay+, arXiv'25</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）は優れた言語能力を持つが、推論能力との間にギャップがある。推論はAIの信頼性を高め、医療や法律などの分野での適用に不可欠である。最近の強力な推論モデルの登場により、LLMsにおける推論の研究が重要視されている。本論文では、既存の推論技術の概要と比較を行い、推論を備えた言語モデルの体系的な調査と現在の課題を提示する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dair_ai/status/1903843684568666450?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QRL, Test Time Compute, Self-trainingの3種類にカテゴライズされている。また、各カテゴリごとにより細分化されたツリーが論文中にある。

<br>

<img src="https://github.com/user-attachments/assets/d323db81-973a-4752-afc9-4471f5e64feb" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<span class="issue_date">Issue Date: 2025-03-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1825">Compute Optimal Scaling of Skills: Knowledge vs Reasoning, Nicholas Roberts+, arXiv'25</a>
<span class="snippet"><span>Summary</span>スケーリング法則はLLM開発において重要であり、特に計算最適化によるトレードオフが注目されている。本研究では、スケーリング法則が知識や推論に基づくスキルに依存することを示し、異なるデータミックスがスケーリング挙動に与える影響を調査した。結果、知識とコード生成のスキルは根本的に異なるスケーリング挙動を示し、誤指定された検証セットが計算最適なパラメータ数に約50%の影響を与える可能性があることが明らかになった。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dair_ai/status/1903843682509312218?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q知識を問うQAのようなタスクはモデルのパラメータ量が必要であり、コーディングのようなReasoningに基づくタスクはデータ量が必要であり、異なる要素に依存してスケールすることを示している研究のようである。

<br>



<br>

<img src="https://github.com/user-attachments/assets/5d2bb3c6-437a-4184-9848-3232745d0de1" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-03-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1819">Stop Overthinking: A Survey on Efficient Reasoning for Large Language  Models, Yang Sui+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本論文では、LLMsにおける効率的な推論の進展を体系的に調査し、以下の主要な方向に分類します：(1) モデルベースの効率的推論、(2) 推論出力ベースの効率的推論、(3) 入力プロンプトベースの効率的推論。特に、冗長な出力による計算オーバーヘッドを軽減する方法を探求し、小規模言語モデルの推論能力や評価方法についても議論します。</span>
<span class="snippet"><span>Comment</span>Reasoning Modelにおいて、Over Thinking現象（不要なreasoning stepを生成してしまう）を改善するための手法に関するSurvey。

<br>

<img src="https://github.com/user-attachments/assets/a411f2cf-2ba1-4e58-8dc7-ac1ae2ff0de6" alt="image" loading="lazy">

<br>



<br>

下記Figure2を見るとよくまとまっていて、キャプションを読むとだいたい分かる。なるほど。

<br>

Length Rewardについては、

<br>

・1746

<br>



<br>

で考察されている通り、Reward Hackingが起きるので設計の仕方に気をつける必要がある。

<br>



<br>

<img src="https://github.com/user-attachments/assets/fd6880bd-95e1-4ca6-9593-8ffc9390962a" alt="image" loading="lazy">元ポスト:https://x.com/_reachsumit/status/1902977896685396275?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q各カテゴリにおけるliteratureも見やすくまとめられている。必要に応じて参照したい。

<br>

<img src="https://github.com/user-attachments/assets/b6be0d79-35c5-45a8-878b-2b6be67c2f76" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<span class="issue_date">Issue Date: 2025-03-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1817">Lost-in-the-Middle in Long-Text Generation: Synthetic Dataset,  Evaluation Framework, and Mitigation, Junhao Zhang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>長い入力と出力の生成に特化したLongInOutBenchを導入し、既存手法の「中間での喪失」問題に対処。Retrieval-Augmented Long-Text Writer（RAL-Writer）を開発し、重要なコンテンツを再表現することで性能を向上。提案手法の有効性をベースラインと比較して示す。</span>
<span class="snippet"><span>Comment</span>Lost in the Middleに関する研究。関連研究:

<br>

・793</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-03-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1815">DAPO: An Open-Source LLM Reinforcement Learning System at Scale, Qiying Yu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>推論スケーリングによりLLMの推論能力が向上し、強化学習が複雑な推論を引き出す技術となる。しかし、最先端の技術詳細が隠されているため再現が難しい。そこで、$\textbf{DAPO}$アルゴリズムを提案し、Qwen2.5-32Bモデルを用いてAIME 2024で50ポイントを達成。成功のための4つの重要技術を公開し、トレーニングコードと処理済みデータセットをオープンソース化することで再現性を向上させ、今後の研究を支援する。</span>
<span class="snippet"><span>Comment</span>既存のreasoning modelのテクニカルレポートにおいて、スケーラブルなRLの学習で鍵となるレシピは隠されていると主張し、実際彼らのbaselineとしてGRPOを走らせたところ、DeepSeekから報告されているAIME2024での性能（47ポイント）よりもで　大幅に低い性能（30ポイント）しか到達できず、分析の結果3つの課題（entropy collapse, reward noise, training instability）を明らかにした（実際R1の結果を再現できない報告が多数報告されており、重要な訓練の詳細が隠されているとしている）。

<br>



<br>

その上で50%のtrainikg stepでDeepSeek-R1-Zero-Qwen-32Bと同等のAIME 2024での性能を達成できるDAPOを提案。そしてgapを埋めるためにオープンソース化するとのこと。ちとこれはあとでしっかり読みたい。重要論文。プロジェクトページ:https://dapo-sia.github.io/

<br>



<br>

こちらにアルゴリズムの重要な部分の概要が説明されている。解説ポスト:https://x.com/theturingpost/status/1902507148015489385?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

コンパクトだが分かりやすくまとまっている。下記ポストによると、Reward Scoreに多様性を持たせたい場合は3.2節参照とのこと。

<br>

すなわち、Dynamic Samplingの話で、Accが全ての生成で1.0あるいは0.0となるようなpromptを除外するといった方法の話だと思われる。

<br>

これは、あるpromptに対する全ての生成で正解/不正解になった場合、そのpromptに対するAdvantageが0となるため、ポリシーをupdateするためのgradientも0となる。そうすると、このサンプルはポリシーの更新に全く寄与しなくなるため、同バッチ内のノイズに対する頑健性が失われることになる。サンプル効率も低下する。特にAccが1.0になるようなpromptは学習が進むにつれて増加するため、バッチ内で学習に有効なpromptは減ることを意味し、gradientの分散の増加につながる、といったことらしい。

<br>



<br>

関連ポスト:https://x.com/iscienceluvr/status/1936375947575632102?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2025-03-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1811">Sample, Scrutinize and Scale: Effective Inference-Time Search by Scaling  Verification, Eric Zhao+, arXiv'25</a>
<span class="snippet"><span>Summary</span>サンプリングベースの探索は、複数の候補応答を生成し最良のものを選ぶ手法であり、自己検証によって正確性を確認します。本研究では、この探索のスケーリング傾向を分析し、シンプルな実装がGemini v1.5 Proの推論能力を向上させることを示しました。自己検証の精度向上は、より大きな応答プールからのサンプリングによるもので、応答間の比較が有益な信号を提供することや、異なる出力スタイルが文脈に応じて役立つことを明らかにしました。また、最前線のモデルは初期の検証能力が弱く、進捗を測るためのベンチマークを提案しました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/ericzhao28/status/1901704339229732874?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qざっくりしか読めていないが、複数の解答をサンプリングして、self-verificationをさせて最も良かったものを選択するアプローチ。最もverificationスコアが高い解答を最終的に選択したいが、tieの場合もあるのでその場合は追加のpromptingでレスポンスを比較しより良いレスポンスを選択する。これらは並列して実行が可能で、探索とself-verificationを200個並列するとGemini 1.5 Proでo1-previewよりも高い性能を獲得できる模様。Self-consistencyと比較しても、gainが大きい。

<br>

<img src="https://github.com/user-attachments/assets/937c334b-659a-4196-8fa4-31cf908a32d4" alt="image" loading="lazy"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/RLHF.html">#RLHF</a>
<span class="issue_date">Issue Date: 2025-03-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1806">All Roads Lead to Likelihood: The Value of Reinforcement Learning in  Fine-Tuning, Gokul Swamy+, arXiv'25</a>
<span class="snippet"><span>Summary</span>基盤モデルのファインチューニングにおいて、報酬モデルを用いた二段階のトレーニング手順が効果的である理由を理論的および実証的に検討。特に、好みデータから単純な報酬モデルを学び、強化学習手続きがそのモデルに最適なポリシーをフィルタリングする能力が、オンラインファインチューニングの優れたパフォーマンスに寄与することが示された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1901392286694678568?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QAlignmentのためのPreferenceデータがある時に、そのデータから直接最尤推定してモデルのパラメータを学習するのではなく、報酬モデルを学習して、その報酬モデルを用いてモデルを強化学習することで、なぜ前者よりも（同じデータ由来であるにもかかわらず）優れたパフォーマンスを示すのか、という疑問に対してアプローチしている。全く中身を読めていないが、生成することと（方策モデル）と検証すること（報酬モデル）の間にギャップがある場合（すなわち、生成と検証で求められる能力が異なる場合）、MLEでは可能なすべてのポリシーを探索することと似たようなことをすることになるが、RLでは事前に報酬モデルを学習しその報酬モデルに対して最適なポリシーを探索するだけなので探索する空間が制限される（＝生成と検証のギャップが埋まる）ので、良い解に収束しやすくなる、というイメージなんだろうか。

<br>

<img src="https://github.com/user-attachments/assets/121e97a6-120e-4830-9bcf-329129a687eb" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-03-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1798">A Survey on Post-training of Large Language Models, Guiyao Tie+, arXiv'25</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）は自然言語処理に革命をもたらしたが、専門的な文脈での制約が明らかである。これに対処するため、高度なポストトレーニング言語モデル（PoLMs）が必要であり、本論文ではその包括的な調査を行う。ファインチューニング、アライメント、推論、効率、統合と適応の5つのコアパラダイムにわたる進化を追跡し、PoLMがバイアス軽減や推論能力向上に寄与する方法を示す。研究はPoLMの進化に関する初の調査であり、将来の研究のための枠組みを提供し、LLMの精度と倫理的堅牢性を向上させることを目指す。</span>
<span class="snippet"><span>Comment</span>Post Trainingの時間発展の図解が非常にわかりやすい（が、厳密性には欠けているように見える。当該モデルの新規性における主要な技術はこれです、という図としてみるには良いのかもしれない）。

<br>

個々の技術が扱うスコープとレイヤー、データの性質が揃っていない気がするし、それぞれのLLMがy軸の単一の技術だけに依存しているわけでもない。が、厳密に図を書いてと言われた時にどう書けば良いかと問われると難しい感はある。

<br>

<img src="https://github.com/user-attachments/assets/6cdf060f-1cc9-44cd-b81a-50f4d3c442de" alt="image" loading="lazy">元ポスト:https://x.com/omarsar0/status/1900595286898340230?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<span class="issue_date">Issue Date: 2025-03-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1789">Gemini Embedding: Generalizable Embeddings from Gemini, Jinhyuk Lee+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Gemini Embeddingは、Googleの大規模言語モデルGeminiを活用した最先端の埋め込みモデルで、多言語およびコード理解能力を活かして一般化可能な埋め込みを生成します。事前計算された表現は、分類や検索などの下流タスクに適用可能で、250以上の言語にわたる100以上のタスクを含むMMTEBで評価した結果、従来のモデルを大幅に上回る性能を示しました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_reachsumit/status/1899667900728037621?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q世のdecoder-onlyモデルベースのembeddingモデルがどのように作られているか具体的によくわかっていないので読みたいGeminiのパラメータでbi-directionalなself-attentionを持つtransformer (たとえばBERT)で初期化し、全てのtokenをmean poling (HF BERT ModelのPoolerLayerのようなもの)することでトークンの情報を単一のembeddingに混ぜる。

<br>

学習は2段階のfinetuning (pre-finetuning, finetuning)によって、モデルをContrastive Learningする（NCE loss）。

<br>

pre-finetuningはnoisyだが大規模なデータ（web上のタイトルとparagraphのペアなど）、そのあとのfinetuningはQAなどの高品質なデータを利用。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-03-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1782">LLM Post-Training: A Deep Dive into Reasoning Large Language Models, Komal Kumar+, arXiv'25</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）のポストトレーニング手法に焦点を当て、知識の洗練や推論の改善、事実の正確性向上を目指す。ファインチューニングや強化学習などの戦略がLLMsのパフォーマンスを最適化し、実世界のタスクへの適応性を向上させる。主要な課題として壊滅的な忘却や報酬ハッキングを分析し、今後の研究方向性を示す公開リポジトリも提供。</span>
<span class="snippet"><span>Comment</span>非常にわかりやすい。

<br>

<img src="https://github.com/user-attachments/assets/855326f0-bc18-4ce1-9870-7690393af21e" alt="image" loading="lazy">元ポスト:https://x.com/gm8xx8/status/1896399195596263710?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<span class="issue_date">Issue Date: 2025-03-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1776">Large Language Diffusion Models, Shen Nie+, arXiv'25</a>
<span class="snippet"><span>Summary</span>LLaDAは、自己回帰モデル（ARMs）に代わる拡散モデルであり、ゼロから訓練され、データマスキングを通じて分布をモデル化。広範なベンチマークで強力なスケーラビリティを示し、自己構築したARMベースラインを上回る。特に、LLaDA 8Bは文脈内学習や指示追従能力に優れ、逆詩の完成タスクでGPT-4oを超える性能を発揮。拡散モデルがARMsの実行可能な代替手段であることを示す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dair_ai/status/1893698288328602022?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q参考:https://x.com/karpathy/status/1894923254864978091</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-03-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1775">Native Sparse Attention: Hardware-Aligned and Natively Trainable Sparse   Attention, Jingyang Yuan+, ACL'25</a>
<span class="snippet"><span>Summary</span>長文コンテキストモデリングのために、計算効率を改善するスパースアテンションメカニズム「NSA」を提案。NSAは動的な階層スパース戦略を用い、トークン圧縮と選択を組み合わせてグローバルなコンテキスト認識とローカルな精度を両立。実装最適化によりスピードアップを実現し、エンドツーエンドのトレーニングを可能にすることで計算コストを削減。NSAはフルアテンションモデルと同等以上の性能を維持しつつ、長シーケンスに対して大幅なスピードアップを達成。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dair_ai/status/1893698286545969311?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QACL'25のBest Paperの一つ:

<br>

https://x.com/gm8xx8/status/1950644063952052643?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-02-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1774">From System 1 to System 2: A Survey of Reasoning Large Language Models, Zhong-Zhi Li+, arXiv'25</a>
<span class="snippet"><span>Summary</span>人間レベルの知能を達成するためには、迅速なシステム1から意図的なシステム2への推論の洗練が必要。基盤となる大規模言語モデル（LLMs）は迅速な意思決定に優れるが、複雑な推論には深さが欠ける。最近の推論LLMはシステム2の意図的な推論を模倣し、人間のような認知能力を示している。本調査では、LLMの進展とシステム2技術の初期開発を概観し、推論LLMの構築方法や特徴、進化を分析。推論ベンチマークの概要を提供し、代表的な推論LLMのパフォーマンスを比較。最後に、推論LLMの進展に向けた方向性を探り、最新の開発を追跡するためのGitHubリポジトリを維持することを目指す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_reachsumit/status/1894282083956396544?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<span class="issue_date">Issue Date: 2025-02-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1772">SuperGPQA: Scaling LLM Evaluation across 285 Graduate Disciplines, M-A-P Team+, arXiv'25</a>
<span class="snippet"><span>Summary</span>SuperGPQAを提案し、285の専門分野におけるLLMsの知識と推論能力を評価する新しいベンチマークを構築。Human-LLM協調フィルタリングを用いて、トリビアルな質問を排除。実験結果は、最先端のLLMsに改善の余地があることを示し、人工一般知能とのギャップを強調。大規模なアノテーションプロセスから得た洞察は、今後の研究に対する方法論的ガイダンスを提供。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/arankomatsuzaki/status/1892779892674351532?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/NAACL.html">#NAACL</a>
<span class="issue_date">Issue Date: 2025-02-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1770">OctoTools: An Agentic Framework with Extensible Tools for Complex   Reasoning, Pan Lu+, NAACL'25</a>
<span class="snippet"><span>Summary</span>複雑な推論タスクに対応するためのオープンソースエージェントフレームワーク「OctoTools」を提案。トレーニング不要で拡張可能なこのフレームワークは、標準化されたツールカードやプランナー、エグゼキューターを備え、16の多様なタスクでGPT-4oに対して平均9.3%の精度向上を達成。さらに、他の手法を最大10.6%上回る性能を示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/lupantech/status/1892260474320015861?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QNAACL'25でベストペーパーに選出:

<br>

https://x.com/lupantech/status/1919495362102100365?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Distillation.html">#Distillation</a>
<span class="issue_date">Issue Date: 2025-02-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1768">NaturalReasoning: Reasoning in the Wild with 2.8M Challenging Questions, Weizhe Yuan+, arXiv'25</a>
<span class="snippet"><span>Summary</span>多様で高品質な推論質問を生成するためのスケーラブルなアプローチを提案し、280万の質問からなるNaturalReasoningデータセットを構築。知識蒸留実験により、強力な教師モデルが推論能力を引き出せることを実証し、教師なし自己学習にも効果的であることを示す。</span>
<span class="snippet"><span>Comment</span>元ポスト: https://x.com/jaseweston/status/1892041992127021300?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<span class="issue_date">Issue Date: 2025-02-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1767">Scaling Test-Time Compute Without Verification or RL is Suboptimal, Amrith Setlur+, arXiv'25</a>
<span class="snippet"><span>Summary</span>RLや探索に基づく検証者ベース（VB）手法が、探索の痕跡を蒸留する検証者フリー（VF）アプローチよりも優れていることを示す。テスト時の計算とトレーニングデータをスケールアップすると、VF手法の最適性が悪化し、VB手法がより良くスケールすることが確認された。3/8/32BサイズのLLMを用いた実験で、検証が計算能力の向上に重要であることを実証。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/iscienceluvr/status/1891839822257586310?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q・1749</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2025-02-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1763">LLM Pretraining with Continuous Concepts, Jihoon Tack+, arXiv'25</a>
<span class="snippet"><span>Summary</span>次トークン予測に代わる新しい事前学習フレームワークCoCoMixを提案。これは、スパースオートエンコーダから学習した連続的な概念をトークンの隠れ表現と交互に混ぜることで、モデルの性能を向上させる。実験により、CoCoMixは従来の手法を上回り、解釈可能性と操作性も向上させることが示された。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<span class="issue_date">Issue Date: 2025-02-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1760">Can 1B LLM Surpass 405B LLM? Rethinking Compute-Optimal Test-Time  Scaling, Runze Liu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Test-Time Scaling (TTS)は、LLMsの性能向上に寄与する手法であり、ポリシーモデルやPRM、問題の難易度がTTSに与える影響を分析。実験により、最適なTTS戦略はこれらの要素に依存し、小型モデルが大型モデルを上回る可能性を示した。具体的には、1BのLLMが405BのLLMを超える結果を得た。これにより、TTSがLLMsの推論能力を向上させる有望なアプローチであることが示された。</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2025-02-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1758">DeepRAG: Thinking to Retrieval Step by Step for Large Language Models, Xinyan Guan+, arXiv'25</a>
<span class="snippet"><span>Summary</span>DeepRAGフレームワークを提案し、検索強化推論をマルコフ決定過程としてモデル化。クエリを反復的に分解し、外部知識の取得とパラメトリック推論の依存を動的に判断。実験により、検索効率と回答の正確性を21.99%向上させることを実証。</span>
<span class="snippet"><span>Comment</span>日本語解説。ありがとうございます！

<br>



<br>

RAGでも「深い検索」を実現する手法「DeepRAG」, Atsushi Kadowaki, 

<br>

ナレッジセンス ・AI知見共有ブログ:https://zenn.dev/knowledgesense/articles/034b613c9fd6d3</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/CodeGeneration.html">#CodeGeneration</a>
<a class="button" href="articles/SyntheticDataGeneration.html">#SyntheticDataGeneration</a>
<span class="issue_date">Issue Date: 2025-02-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1756">ACECODER: Acing Coder RL via Automated Test-Case Synthesis, Huaye Zeng+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、コードモデルのトレーニングにおける強化学習（RL）の可能性を探求し、自動化された大規模テストケース合成を活用して信頼できる報酬データを生成する手法を提案します。具体的には、既存のコードデータから質問とテストケースのペアを生成し、これを用いて報酬モデルをトレーニングします。このアプローチにより、Llama-3.1-8B-Insで平均10ポイント、Qwen2.5-Coder-7B-Insで5ポイントの性能向上が見られ、7Bモデルが236B DeepSeek-V2.5と同等の性能を達成しました。また、強化学習を通じてHumanEvalやMBPPなどのデータセットで一貫した改善を示し、特にQwen2.5-Coder-baseからのRLトレーニングがHumanEval-plusで25%以上、MBPP-plusで6%の改善をもたらしました。これにより、コーダーモデルにおける強化学習の大きな可能性が示されました。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<a class="button" href="articles/LatentReasoning.html">#LatentReasoning</a>
<span class="issue_date">Issue Date: 2025-02-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1753">Scaling up Test-Time Compute with Latent Reasoning: A Recurrent Depth  Approach, Jonas Geiping+, arXiv'25</a>
<span class="snippet"><span>Summary</span>新しい言語モデルアーキテクチャを提案し、潜在空間での暗黙的推論によりテスト時の計算をスケールさせる。再帰ブロックを反復し、任意の深さに展開することで、従来のトークン生成モデルとは異なるアプローチを採用。特別なトレーニングデータを必要とせず、小さなコンテキストウィンドウで複雑な推論を捉える。3.5億パラメータのモデルをスケールアップし、推論ベンチマークでのパフォーマンスを劇的に改善。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Distillation.html">#Distillation</a>
<a class="button" href="articles/TeacherHacking.html">#TeacherHacking</a>
<span class="issue_date">Issue Date: 2025-02-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1751">On Teacher Hacking in Language Model Distillation, Daniil Tiapkin+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、言語モデルの知識蒸留過程における「教師ハッキング」の現象を調査。固定されたオフラインデータセットを用いると教師ハッキングが発生し、最適化プロセスの逸脱を検出可能。一方、オンラインデータ生成技術を用いることで教師ハッキングを軽減でき、データの多様性が重要な要因であることを明らかにした。これにより、堅牢な言語モデル構築における蒸留の利点と限界についての理解が深まる。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_philschmid/status/1888516494100734224?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q自分で蒸留する機会は今のところないが、覚えておきたい。過学習と一緒で、こういう現象が起こるのは想像できる。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2025-02-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1750">Rethinking Mixture-of-Agents: Is Mixing Different Large Language Models  Beneficial?, Wenzhe Li+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Self-MoAは、単一の高性能LLMからの出力を集約するアンサンブル手法であり、従来のMoAを上回る性能を示す。AlpacaEval 2.0で6.6%の改善を達成し、MMLUやCRUXなどでも平均3.8%の向上を記録。出力の多様性と品質のトレードオフを調査し、異なるLLMの混合が品質を低下させることを確認。Self-MoAの逐次バージョンも効果的であることを示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dair_ai/status/1888658770059816968?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-02-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1749">s1: Simple test-time scaling, Niklas Muennighoff+, arXiv'25</a>
<span class="snippet"><span>Summary</span>テスト時スケーリングを用いて言語モデルのパフォーマンスを向上させる新しいアプローチを提案。小規模データセットs1Kを作成し、モデルの思考プロセスを制御する予算強制を導入。これにより、モデルは不正確な推論を修正し、Qwen2.5-32B-Instructモデルがo1-previewを最大27%上回る結果を達成。さらに、介入なしでパフォーマンスを向上させることが可能となった。モデル、データ、コードはオープンソースで提供。</span>
<span class="snippet"><span>Comment</span>解説:https://x.com/hillbig/status/1887260791981941121?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/DataDistillation.html">#DataDistillation</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-02-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1748">LIMO: Less is More for Reasoning, Yixin Ye+, arXiv'25</a>
<span class="snippet"><span>Summary</span>LIMOモデルは、わずか817のトレーニングサンプルで複雑な数学的推論を効果的に引き出し、AIMEで57.1%、MATHで94.8%の精度を達成。従来のモデルよりも少ないデータで優れたパフォーマンスを示し、一般化を促す「Less-Is-More Reasoning Hypothesis」を提案。LIMOはオープンソースとして提供され、データ効率の良い推論の再現性を促進する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/arankomatsuzaki/status/1887353699644940456?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/RewardHacking.html">#RewardHacking</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-02-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1746">Demystifying Long Chain-of-Thought Reasoning in LLMs, Edward Yeo+, arXiv'25</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）における長い思考の連鎖（CoTs）推論のメカニズムを調査し、重要な要因を特定。主な発見は、(1) 教師ありファインチューニング（SFT）は必須ではないが効率を向上させる、(2) 推論能力は計算の増加に伴い現れるが、報酬の形状がCoTの長さに影響、(3) 検証可能な報酬信号のスケーリングが重要で、特に分布外タスクに効果的、(4) エラー修正能力は基本モデルに存在するが、RLを通じて効果的に奨励するには多くの計算が必要。これらの洞察は、LLMsの長いCoT推論を強化するためのトレーニング戦略の最適化に役立つ。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/xiangyue96/status/1887332772198371514?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q元ポストのスレッド中に論文の11個の知見が述べられている。どれも非常に興味深い。DeepSeek-R1のテクニカルペーパーと同様、

<br>



<br>

・Long CoTとShort CoTを比較すると前者の方が到達可能な性能のupper bonudが高いことや、

<br>

・SFTを実施してからRLをすると性能が向上することや、

<br>

・RLの際にCoTのLengthに関する報酬を入れることでCoTの長さを抑えつつ性能向上できること、

<br>

・数学だけでなくQAペアなどのノイジーだが検証可能なデータをVerifiableな報酬として加えると一般的なreasoningタスクで数学よりもさらに性能が向上すること、

<br>

・より長いcontext window sizeを活用可能なモデルの訓練にはより多くの学習データが必要なこと、

<br>

・long CoTはRLによって学習データに類似したデータが含まれているためベースモデルの段階でその能力が獲得されていることが示唆されること、

<br>

・aha momentはすでにベースモデル時点で獲得されておりVerifiableな報酬によるRLによって強化されたわけではなさそう、

<br>



<br>

など、興味深い知見が盛りだくさん。非常に興味深い研究。あとで読む。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/Diversity.html">#Diversity</a>
<span class="issue_date">Issue Date: 2025-02-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1744">Diverse Preference Optimization, Jack Lanchantin+, ICLR'25</a>
<span class="snippet"><span>Summary</span>Diverse Preference Optimization（DivPO）を提案し、応答の多様性を向上させつつ生成物の品質を維持するオンライン最適化手法を紹介。DivPOは応答のプールから多様性を測定し、希少で高品質な例を選択することで、パーソナ属性の多様性を45.6%、ストーリーの多様性を74.6%向上させる。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jaseweston/status/1885399530419450257?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QOpenReview: https://openreview.net/forum?id=pOq9vDIYevDPOと同じ最適化方法を使うが、Preference Pairを選択する際に、多様性が増加するようなPreference Pairの選択をすることで、モデルのPost-training後の多様性を損なわないようにする手法を提案しているっぽい。

<br>

具体的には、Alg.1 に記載されている通り、多様性の尺度Dを定義して、モデルにN個のレスポンスを生成させRMによりスコアリングした後、RMのスコアが閾値以上のresponseを"chosen" response, 閾値未満のレスポンスを "reject" responseとみなし、chosen/reject response集合を構築する。chosen response集合の中からDに基づいて最も多様性のあるresponse y_c、reject response集合の中から最も多様性のないresponse y_r をそれぞれピックし、prompt xとともにpreference pair (x, y_c, y_r) を構築しPreference Pairに加える、といった操作を全ての学習データ（中のprompt）xに対して繰り返すことで実現する。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-01-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1740">SFT Memorizes, RL Generalizes: A Comparative Study of Foundation Model  Post-training, Tianzhe Chu+, arXiv'25</a>
<span class="snippet"><span>Summary</span>SFTとRLの一般化能力の違いを研究し、GeneralPointsとV-IRLを用いて評価。RLはルールベースのテキストと視覚変種に対して優れた一般化を示す一方、SFTは訓練データを記憶し分布外シナリオに苦労。RLは視覚認識能力を向上させるが、SFTはRL訓練に不可欠であり、出力形式を安定させることで性能向上を促進。これらの結果は、複雑なマルチモーダルタスクにおけるRLの一般化能力を示す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1884731381517082668?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<a class="button" href="articles/FoundationModel.html">#FoundationModel</a>
<span class="issue_date">Issue Date: 2025-01-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1739">360Brew: A Decoder-only Foundation Model for Personalized Ranking and  Recommendation, Hamed Firooz+, arXiv'25</a>
<span class="snippet"><span>Summary</span>ランキングおよび推薦システムの課題に対処するため、テキストインターフェースを持つ大規模基盤モデルを活用した研究を紹介。150Bパラメータのデコーダー専用モデル360Brew V1.0は、LinkedInのデータを用いて30以上の予測タスクを解決し、従来の専用モデルと同等以上のパフォーマンスを達成。特徴エンジニアリングの複雑さを軽減し、複数のタスクを単一モデルで管理可能にする利点を示す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_reachsumit/status/1884455910824948154?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<span class="issue_date">Issue Date: 2025-01-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1738">Evolving Deeper LLM Thinking, Kuang-Huei Lee+, arXiv'25</a>
<span class="snippet"><span>Summary</span>Mind Evolutionという進化的探索戦略を提案し、言語モデルを用いて候補応答を生成・洗練する。これにより、推論問題の形式化を回避しつつ、推論コストを制御。自然言語計画タスクにおいて、他の戦略を大幅に上回り、TravelPlannerおよびNatural Planのベンチマークで98%以上の問題を解決。</span>
<span class="snippet"><span>Comment</span>OpenReview: https://openreview.net/forum?id=nGP1UxhAbV&referrer=%5Bthe%20profile%20of%20Kuang-Huei%20Lee%5D(%2Fprofile%3Fid%3D~Kuang-Huei_Lee1)</span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<span class="issue_date">Issue Date: 2025-01-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1736">Pre-train and Fine-tune: Recommenders as Large Models, Zhenhao Jiang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>ユーザーの興味の変化を捉えるため、レコメンダーを大規模な事前学習モデルとしてファインチューニングするアプローチを提案。情報ボトルネック理論に基づき、知識圧縮と知識マッチングの二つのフェーズを定義したIAK技術を設計。実験により優位性を示し、オンラインプラットフォームでの展開から得た教訓や潜在的な問題への解決策も提示。IAK技術を用いたレコメンダーは、オンラインフードプラットフォームでの展開により大きな利益を上げている。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_reachsumit/status/1883719872540254355?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2025-01-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1728">Perspective Transition of Large Language Models for Solving Subjective  Tasks, Xiaolong Wang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>視点の移行を通じた推論（RPT）を提案し、LLMsが主観的な問題に対して動的に視点を選択できる手法を紹介。広範な実験により、従来の固定視点手法を上回り、文脈に応じた適切な応答を提供する能力を示す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/rohanpaul_ai/status/1882739526361370737?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QOpenReview: https://openreview.net/forum?id=cFGPlRony5"Subjective Task"とは例えば「メタファーの認識」や「ダークユーモアの検知」などがあり、これらは定量化しづらい認知的なコンテキストや、ニュアンスや感情などが強く関連しており、現状のLLMではチャレンジングだと主張している。

<br>

Subjective Taskでは、Reasoningモデルのように自動的にCoTのpathwayを決めるのは困難で、手動でpathwayを記述するのはチャレンジングで一貫性を欠くとした上で、複数の視点を組み合わせたPrompting（direct perspective, role-perspective, third-person perspectivfe）を実施し、最もConfidenceの高いanswerを採用することでこの課題に対処すると主張している。イントロしか読めていないが、自動的にCoTのpathwayを決めるのも手動で決めるのも難しいという風にイントロで記述されているが、手法自体が最終的に3つの視点から回答を生成させるという枠組みに則っている（つまりSubjective Taskを解くための形式化できているので、自動的な手法でもできてしまうのではないか？と感じた）ので、イントロで記述されている主張の”難しさ”が薄れてしまっているかも・・・？と感じた。論文が解こうとしている課題の”難しさ”をサポートする材料がもっとあった方がよりmotivationが分かりやすくなるかもしれない、という感想を持った。</span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Contents-based.html">#Contents-based</a>
<span class="issue_date">Issue Date: 2025-01-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1666">Cold-Start Recommendation towards the Era of Large Language Models  （LLMs）: A Comprehensive Survey and Roadmap, Weizhi Zhang+, arXiv'25</a>
<span class="snippet"><span>Summary</span>コールドスタート問題はレコメンダーシステムの重要な課題であり、新しいユーザーやアイテムのモデル化に焦点を当てている。大規模言語モデル（LLMs）の成功により、CSRに新たな可能性が生まれているが、包括的なレビューが不足している。本論文では、CSRのロードマップや関連文献をレビューし、LLMsが情報を活用する方法を探求することで、研究と産業界に新たな洞察を提供することを目指す。関連リソースはコミュニティのために収集・更新されている。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_reachsumit/status/1876093584593793091?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<a class="button" href="articles/Tokenizer.html">#Tokenizer</a>
<a class="button" href="articles/Workshop.html">#Workshop</a>
<span class="issue_date">Issue Date: 2025-01-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1634">Byte Latent Transformer: Patches Scale Better Than Tokens, Artidoro Pagnoni+, ICML'25 Workshop Tokshop</a>
<span class="snippet"><span>Summary</span>Byte Latent Transformer（BLT）は、バイトレベルのLLMアーキテクチャで、トークン化ベースのLLMと同等のパフォーマンスを実現し、推論効率と堅牢性を大幅に向上させる。BLTはバイトを動的にサイズ変更可能なパッチにエンコードし、データの複雑性に応じて計算リソースを調整する。最大8Bパラメータと4Tトレーニングバイトのモデルでの研究により、固定語彙なしでのスケーリングの可能性が示された。長いパッチの動的選択により、トレーニングと推論の効率が向上し、全体的にBLTはトークン化モデルよりも優れたスケーリングを示す。</span>
<span class="snippet"><span>Comment</span>興味深い図しか見れていないが、バイト列をエンコード/デコードするtransformer学習して複数のバイト列をパッチ化（エントロピーが大きい部分はより大きなパッチにバイト列をひとまとめにする）、パッチからのバイト列生成を可能にし、パッチを変換するのをLatent Transformerで学習させるようなアーキテクチャのように見える。

<br>



<br>

また、予算によってモデルサイズが決まってしまうが、パッチサイズを大きくすることで同じ予算でモデルサイズも大きくできるのがBLTの利点とのこと。

<br>

<img src="https://github.com/user-attachments/assets/4d150ea9-34e3-456a-bfda-123eb03ffd7c" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/5884d4ed-6c12-4691-8d13-4b3cccd74ef0" alt="image" loading="lazy">日本語解説:https://bilzard.github.io/blog/2025/01/01/byte-latent-transformer.html?v=2OpenReview:https://openreview.net/forum?id=UZ3J8XeRLw</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/COLING.html">#COLING</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2024-12-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1577">Towards Adaptive Mechanism Activation in Language Agent, Ziyang Huang+, COLING'25</a>
<span class="snippet"><span>Summary</span>自己探索によるメカニズム活性化学習（ALAMA）を提案し、固定されたメカニズムに依存せずに適応的なタスク解決を目指す。調和のとれたエージェントフレームワーク（UniAct）を構築し、タスク特性に応じてメカニズムを自動活性化。実験結果は、動的で文脈に敏感なメカニズム活性化の有効性を示す。</span>
<span class="snippet"><span>Comment</span>元ポスト: https://x.com/omarsar0/status/1863956776623747433?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q手法としては、SFTとKTOを活用しpost trainingするようである

<br>

<img src="https://github.com/user-attachments/assets/0eab8029-124d-4ac1-b906-2463472b90b2" alt="image" loading="lazy">

<br>



<br>

・1472</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Batch.html">#Batch</a>
<span class="issue_date">Issue Date: 2024-11-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1541">How Does Critical Batch Size Scale in Pre-training?, Hanlin Zhang+, ICLR'25</a>
<span class="snippet"><span>Summary</span>大規模モデルの訓練には、クリティカルバッチサイズ（CBS）を考慮した並列化戦略が重要である。CBSの測定法を提案し、C4データセットで自己回帰型言語モデルを訓練。バッチサイズや学習率などの要因を調整し、CBSがデータサイズに比例してスケールすることを示した。この結果は、ニューラルネットワークの理論的分析によって支持され、ハイパーパラメータ選択の重要性も強調されている。</span>
<span class="snippet"><span>Comment</span>Critical Batch Sizeはモデルサイズにはあまり依存せず、データサイズに応じてスケールする

<br>

<img src="https://github.com/user-attachments/assets/4a1a720f-37a1-485d-9b02-bb2e8a5c2da4" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/8bc5f621-caac-438a-afd1-de1d689ee210" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2024-11-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1489">Self-Consistency Preference Optimization, Archiki Prasad+, ICML'25</a>
<span class="snippet"><span>Summary</span>自己調整は、モデルが人間の注釈なしに自らを改善する方法であり、自己一貫性を活用して訓練を行う新しいアプローチ、自己一貫性優先最適化（ScPO）を提案。ScPOは一貫した答えを優先し、GSM8KやMATHなどの推論タスクで従来の手法を大幅に上回る性能を示し、標準的な監視学習との組み合わせでも結果が向上。ZebraLogicでLlama-3 8Bを微調整し、他の大規模モデルを超える成果を達成。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jaseweston/status/1854532624116547710?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QSelf-Consistencyのように、モデルに複数の出力をさせて、最も頻度が高い回答と頻度が低い回答の2つでDPOのペアデータを作成し学習。頻度の差によって重みを決めてlossに組み込みこのよつな処理を繰り返し学習すると性能が向上する、といった話のように見える。

<br>

<img src="https://github.com/user-attachments/assets/040ffe7c-6e89-4b58-85dd-ce1bc78195cb" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/45bbb1e6-145c-4c49-943d-4dfa25812264" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/35905525-b03f-4fe3-a0e6-89a89cf4ed29" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/45e87ec6-1ebb-4aa8-80ae-0f9072e670d9" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<span class="issue_date">Issue Date: 2024-10-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1466">Differential Transformer, Tianzhu Ye+, N_A, ICLR'25</a>
<span class="snippet"><span>Summary</span>Diff Transformerは、関連するコンテキストへの注意を強化し、ノイズをキャンセルする新しいアーキテクチャです。差分注意メカニズムを用いて、注意スコアを計算し、スパースな注意パターンを促進します。実験結果は、Diff Transformerが従来のTransformerを上回り、長いコンテキストモデリングや幻覚の軽減において顕著な利点を示しています。また、文脈内学習においても精度を向上させ、堅牢性を高めることが確認されました。これにより、Diff Transformerは大規模言語モデルの進展に寄与する有望なアーキテクチャとされています。</span>
<span class="snippet"><span>Comment</span>最近のMSはなかなかすごい（小並感概要

<br>



<br>

attention scoreのノイズを低減するようなアーキテクチャとして、二つのQKVを用意し、両者の差分を取ることで最終的なattentiok scoreを計算するDifferential Attentionを提案した。

<br>



<br>



<br>



<br>

attentionのnoiseの例。answerと比較してirrelevantなcontextにattention scoreが高いスコアが割り当てられてしまう（図左）。differential transformerが提案するdifferential attentionでは、ノイズを提言し、重要なcontextのattention scoreが高くなるようになる（図中央）、らしい。

<br>



<br>

<img src="https://github.com/user-attachments/assets/6033f477-d4bf-492d-9360-74f2849ce40e" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Differential Attentionの概要と計算式

<br>



<br>

<img src="https://github.com/user-attachments/assets/b77facd8-7cf2-43ab-8947-2f775423f0a0" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

数式で見るとこのようになっており、二つのQKをどの程度の強さで交互作用させるかをλで制御し、λもそれぞれのQKから導出する。

<br>



<br>

<img src="https://github.com/user-attachments/assets/c58a4d04-a453-4aef-aa40-7de872117482" alt="image" loading="lazy">QA, 機械翻訳, 文書分類, テキスト生成などの様々なNLPタスクが含まれるEval Harnessベンチマークでは、同規模のtransformerモデルを大幅にoutperform。ただし、3Bでしか実験していないようなので、より大きなモデルサイズになったときにgainがあるかは示されていない点には注意。

<br>

<img src="https://github.com/user-attachments/assets/384605ed-e4e4-4a17-83c8-506f8e3e2e4c" alt="image" loading="lazy">モデルサイズ（パラメータ数）と、学習トークン数のスケーラビリティについても調査した結果、LLaMAと比較して、より少ないパラメータ数/学習トークン数で同等のlossを達成。

<br>

<img src="https://github.com/user-attachments/assets/5d2d1dfc-4197-4b36-9f3d-79a3ed18fe3f" alt="image" loading="lazy">64Kにcontext sgzeを拡張し、1.5B tokenで3Bモデルを追加学習をしたところ、これもtransformerと比べてより小さいlossを達成<img src="https://github.com/user-attachments/assets/f911a4f9-d175-4ea2-825b-9776be6042e5" alt="image" loading="lazy">context中に埋め込まれた重要な情報（今回はクエリに対応するmagic number）を抽出するタスクの性能も向上。Needle（N）と呼ばれる正解のmagic numberが含まれる文をcontext中の様々な深さに配置し、同時にdistractorとなる文もランダムに配置する。これに対してクエリ（R）が入力されたときに、どれだけ正しい情報をcontextから抽出できるか、という話だと思われる。

<br>



<br>

これも性能が向上。特にクエリとNeedleが複数の要素で構成されていれ場合の性能が高く（下表）、長いコンテキスト中の様々な位置に埋め込まれたNeedleを抽出する性能も高い（上のmatrix）

<br>



<br>

<img src="https://github.com/user-attachments/assets/f4d084dc-fac5-427d-8185-5604e55cf051" alt="image" loading="lazy">

<br>



<br>

[Needle-In-A-Haystack test](https://www.perplexity.ai/search/needle-in-a-haystack-testtohan-jF7LXWQPSMqKI2pZSchjpA0)Many shotのICL能力も向上

<br>

<img src="https://github.com/user-attachments/assets/c935ba93-9915-45c8-aaa6-f073d62fdd3b" alt="image" loading="lazy">要約タスクでのhallucinationも低減。生成された要約と正解要約を入力し、GPT4-oにhallucinationの有無を判定させて評価。これは先行研究で人手での評価と高いagreementがあることが示されている。

<br>

<img src="https://github.com/user-attachments/assets/6fd97af4-fec6-44e8-b00c-d5ba26770a84" alt="image" loading="lazy">シンプルなアプローチでLLM全体の性能を底上げしている素晴らしい成果に見える。斜め読みなので読み飛ばしているかもしれないが、766 のように高品質な学習データで学習した場合も同様の効果が発現するのだろうか？

<br>

attentionのスコアがnoisyということは、学習データを洗練させることでも改善される可能性があり、766 はこれをデータで改善し、こちらの研究はモデルのアーキテクチャで改善した、みたいな捉え方もできるのかもしれない。ちなみにFlash Attentionとしての実装方法も提案されており、スループットは通常のattentionと比べてむしろ向上しているので実用的な手法でもある。すごい。

<br>

<img src="https://github.com/user-attachments/assets/c0212cd8-55f5-4991-b256-0ff2bce35669" alt="image" loading="lazy">あとこれ、事前学習とInstruction Tuningを通常のマルチヘッドアテンションで学習されたモデルに対して、独自データでSFTするときに導入したらdownstream taskの性能向上するんだろうか。もしそうなら素晴らしいOpenReview:https://openreview.net/forum?id=OvoCm1gGhNGroupNormalizationについてはこちら:

<br>

・1856</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SelfCorrection.html">#SelfCorrection</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2024-09-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1388">Generative Verifiers: Reward Modeling as Next-Token Prediction, Lunjun Zhang+, N_A, ICLR'25</a>
<span class="snippet"><span>Summary</span>検証器と報酬モデルを用いてLLMの推論性能を向上させる新しいアプローチ、生成的検証器（GenRM）を提案。GenRMは次トークン予測を用いて検証と解決策生成を共同で行い、指示チューニングや思考の連鎖を活用。実験により、GenRMは従来の検証器を上回り、問題解決率が16-64%向上することを示した。</span>
<span class="snippet"><span>Comment</span>LLMがリクエストに対する回答を生成したのちに、その回答をverifyするステップ + verifyの結果から回答を修正するステップを全てconcatした学習データをnext token predictionで用いることによって、モデル自身に自分の回答をverifyする能力を身につけさせることができた結果性能が向上しました、という研究らしい。また、Self-consistency 558 のように複数の異なるCoTを並列して実行させ、そのmajority votingをとることでさらに性能が向上する。

<br>



<br>



<br>



<br>

<img width="663" alt="image" src="https://github.com/user-attachments/assets/e6ebd308-fc77-4c5b-80c2-37e3615f48af">

<br>



<br>

<img width="703" alt="image" src="https://github.com/user-attachments/assets/9cf3dfe7-be09-4053-a760-9ec9ed993b33">

<br>



<br>

</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2024-04-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1286">Physics of Language Models: Part 3.3, Knowledge Capacity Scaling Laws, Zeyuan Allen-Zhu+, N_A, ICLR'25</a>
<span class="snippet"><span>Summary</span>言語モデルのサイズと能力の関係を記述するスケーリング則に焦点を当てた研究。モデルが格納する知識ビット数を推定し、事実知識をタプルで表現。言語モデルは1つのパラメータあたり2ビットの知識を格納可能であり、7Bモデルは14Bビットの知識を格納可能。さらに、トレーニング期間、モデルアーキテクチャ、量子化、疎な制約、データの信号対雑音比が知識格納容量に影響することを示唆。ロータリー埋め込みを使用したGPT-2アーキテクチャは、知識の格納においてLLaMA/Mistralアーキテクチャと競合する可能性があり、トレーニングデータにドメイン名を追加すると知識容量が増加することが示された。</span>
<span class="snippet"><span>Comment</span>参考:https://x.com/hillbig/status/1779640139263901698?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説:

<br>

・1834openreview:https://openreview.net/forum?id=FxNNiUgtfa</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/memory.html">#memory</a>
<span class="issue_date">Issue Date: 2025-08-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2401">[Paper Note] A Survey on the Memory Mechanism of Large Language Model based Agents, Zeyu Zhang+, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMベースのエージェントのメモリメカニズムに関する包括的な調査を提案。メモリの重要性を論じ、過去の研究を体系的にレビューし、エージェントアプリケーションでの役割を紹介。既存研究の限界を分析し、将来の研究方向性を示す。リポジトリも作成。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jiqizhixin/status/1954797669957968169?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/ReversalCurse.html">#ReversalCurse</a>
<span class="issue_date">Issue Date: 2025-08-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2395">[Paper Note] The Factorization Curse: Which Tokens You Predict Underlie the Reversal   Curse and More, Ouail Kitouni+, NeurIPS'24</a>
<span class="snippet"><span>Summary</span>最先端の言語モデルは幻覚に悩まされ、情報取得において逆転の呪いが問題となる。これを因数分解の呪いとして再定義し、制御実験を通じてこの現象が次トークン予測の固有の失敗であることを発見。信頼性のある情報取得は単純な手法では解決できず、ファインチューニングも限界がある。異なるタスクでの結果は、因数分解に依存しないアプローチが逆転の呪いを軽減し、知識の保存と計画能力の向上に寄与する可能性を示唆している。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/scaling01/status/1954682957798715669?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qopenreview:https://openreview.net/forum?id=f70e6YYFHFReversal Curseを提言した研究は下記:

<br>

・1059関連:

<br>

・2399</span>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Search.html">#Search</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<span class="issue_date">Issue Date: 2025-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2378">[Paper Note] VERISCORE: Evaluating the factuality of verifiable claims in long-form  text generation, Yixiao Song+, arXiv'24</a>
<span class="snippet"><span>Summary</span>VERISCOREという新しい指標を提案し、検証可能な主張と検証不可能な主張の両方を含む長文生成タスクに対応。人間評価ではVERISCOREが他の方法よりも理にかなっていることが確認され、16のモデルを評価した結果、GPT-4oが最も優れた性能を示したが、オープンウェイトモデルも差を縮めていることが分かった。また、異なるタスク間でVERISCOREの相関がないことから、事実性評価の拡張が必要であることを示唆している。</span>
<span class="snippet"><span>Comment</span>LLMの応答からverifiableなclaimのみを抽出し、それを外部の検索エンジン（google検索）のクエリとして入力。検索結果からclaimがsupportされるか否かをLLMによって判断しスコアリングする。

<br>

<img src="https://github.com/user-attachments/assets/495a7952-8240-4b3b-8b8c-c0c52dea0e74" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2025-08-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2374">[Paper Note] LongBench: A Bilingual, Multitask Benchmark for Long Context   Understanding, Yushi Bai+, ACL'24</a>
<span class="snippet"><span>Summary</span>本論文では、長いコンテキスト理解のための初のバイリンガル・マルチタスクベンチマーク「LongBench」を提案。英語と中国語で21のデータセットを含み、平均長はそれぞれ6,711語と13,386文字。タスクはQA、要約、少数ショット学習など多岐にわたる。評価結果から、商業モデルは他のオープンソースモデルを上回るが、長いコンテキストでは依然として課題があることが示された。</span>
<span class="snippet"><span>Comment</span>PLaMo Primeの長文テキスト評価に利用されたベンチマーク（中国語と英語のバイリンガルデータであり日本語は存在しない）

<br>

https://tech.preferred.jp/ja/blog/plamo-prime-release-feature-update/

<br>



<br>

タスクと言語ごとのLengthの分布。英語の方がデータが豊富で、長いものだと30000--40000ものlengthのサンプルもある模様。

<br>

<img src="https://github.com/user-attachments/assets/a1104f3f-996a-4ad9-b6c3-55b2eb7921ab" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2025-08-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2368">[Paper Note] Let the Expert Stick to His Last: Expert-Specialized Fine-Tuning for   Sparse Architectural Large Language Models, Zihan Wang+, EMNLP'24</a>
<span class="snippet"><span>Summary</span>本研究では、Mixture-of-Experts（MoE）アーキテクチャを持つ大規模言語モデル（LLMs）に対するパラメータ効率の良いファインチューニング（PEFT）手法を提案。主な内容は、(1) タスクごとの専門家の活性化分布の集中度の調査、(2) Expert-Specialized Fine-Tuning（ESFT）の提案とその効果、(3) MoEアーキテクチャの専門家特化型ファインチューニングへの影響の分析。実験により、ESFTがチューニング効率を向上させ、フルパラメータファインチューニングに匹敵またはそれを上回る性能を示すことが確認された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/wzihanw/status/1952965138845450413?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QMoEアーキテクチャを持つLLMにおいて、finetuningを実施したいタスクに関連する専門家を特定し、そのほかのパラメータをfreezeした上で当該専門家のみをtrainableとすることで、効率的にfinetuningを実施する手法

<br>

<img src="https://github.com/user-attachments/assets/ba82f425-5b61-4ce7-803b-4eb3fb375c41" alt="image" loading="lazy">

<br>



<br>

専門家を見つける際には専門家ごとにfinetuningしたいタスクに対するrelevance scoreを計算する。そのために、2つの手法が提案されており、training dataからデータをサンプリングし

<br>

・全てのサンプリングしたデータの各トークンごとのMoE Routerのgateの値の平均値をrelevant scoreとする方法

<br>

・全てのサンプリングしたデータの各トークンごとに選択された専門家の割合

<br>

の2種類でスコアを求める。閾値pを決定し、閾値以上のスコアを持つ専門家をtrainableとする。

<br>



<br>

LoRAよりもmath, codeなどの他ドメインのタスク性能を劣化させず、Finetuning対象のタスクでFFTと同等の性能を達成。

<br>

<img src="https://github.com/user-attachments/assets/302eebda-bace-4b99-bb73-5e7e3ce10448" alt="image" loading="lazy">

<br>



<br>

LoRAと同様にFFTと比較し学習時間は短縮され、学習した専門家の重みを保持するだけで良いのでストレージも節約できる。

<br>

<img src="https://github.com/user-attachments/assets/b02a8d53-6967-4dd2-9290-de06f27e48c9" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-08-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2338">[Paper Note] YaRN: Efficient Context Window Extension of Large Language Models, Bowen Peng+, ICLR'24</a>
<span class="snippet"><span>Summary</span>YaRN（Yet another RoPE extensioN method）は、トランスフォーマーベースの言語モデルにおける位置情報のエンコードを効率的に行い、コンテキストウィンドウを従来の方法よりも10倍少ないトークンと2.5倍少ない訓練ステップで拡張する手法を提案。LLaMAモデルが長いコンテキストを効果的に利用できることを示し、128kのコンテキスト長まで再現可能なファインチューニングを実現。</span>
<span class="snippet"><span>Comment</span>openreview:https://openreview.net/forum?id=wHBfxhZu1u現在主流なコンテキストウィンドウ拡張手法らしい日本語解説:https://zenn.dev/bilzard/scraps/de7ecd3c380b6e</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/AES(AutomatedEssayScoring).html">#AES(AutomatedEssayScoring)</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/AIED.html">#AIED</a>
<span class="issue_date">Issue Date: 2025-07-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2316">[Paper Note] The Impact of Example Selection in Few-Shot Prompting on Automated Essay   Scoring Using GPT Models, Lui Yoshida, AIED'24</a>
<span class="snippet"><span>Summary</span>本研究では、GPTモデルを用いた少数ショットプロンプティングにおける例の選択が自動エッセイ採点（AES）のパフォーマンスに与える影響を調査。119のプロンプトを用いて、GPT-3.5とGPT-4のモデル間でのスコア一致を二次重み付きカッパ（QWK）で測定。結果、例の選択がモデルによって異なる影響を及ぼし、特にGPT-3.5はバイアスの影響を受けやすいことが判明。慎重な例の選択により、GPT-3.5が一部のGPT-4モデルを上回る可能性があるが、GPT-4は最も高い安定性とパフォーマンスを示す。これにより、AESにおける例の選択の重要性とモデルごとのパフォーマンス評価の必要性が強調される。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Quantization.html">#Quantization</a>
<a class="button" href="articles/MLSys.html">#MLSys</a>
<span class="issue_date">Issue Date: 2025-07-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2264">[Paper Note] AWQ: Activation-aware Weight Quantization for LLM Compression and   Acceleration, Ji Lin+, MLSys'24</a>
<span class="snippet"><span>Summary</span>Activation-aware Weight Quantization（AWQ）を提案し、LLMの低ビット重み量子化を効率化。顕著な重みチャネルを保護することで量子化誤差を削減し、異なるドメインに一般化可能。AWQは言語モデリングやドメイン特化型ベンチマークで優れた性能を示し、4ビットのオンデバイスLLM/VLM向け推論フレームワークTinyChatを実装。これにより、デスクトップおよびモバイルGPUでの処理速度を3倍以上向上させ、70B Llama-2モデルの展開を容易にする。</span>
<span class="snippet"><span>Comment</span>日本語解説:https://qiita.com/kyad/items/96a4a2bdec3f0dc09d23</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<span class="issue_date">Issue Date: 2025-07-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2199">[Paper Note] StarCoder 2 and The Stack v2: The Next Generation, Anton Lozhkov+, arXiv'24</a>
<span class="snippet"><span>Summary</span>BigCodeプロジェクトは、責任あるCode LLMsの開発に焦点を当て、StarCoder2を発表。Software Heritageと提携し、The Stack v2を構築し、619のプログラミング言語を含む大規模なトレーニングセットを作成。StarCoder2モデルは3B、7B、15Bのパラメータを持ち、徹底的なベンチマーク評価で優れた性能を示す。特にStarCoder2-15Bは、同等の他モデルを大幅に上回り、数学やコード推論でも高い性能を発揮。モデルの重みはOpenRAILライセンスで公開され、トレーニングデータの透明性も確保。</span>
<span class="snippet"><span>Comment</span>関連:

<br>

・661</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-07-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2127">[Paper Note] Iterative Reasoning Preference Optimization, Richard Yuanzhe Pang+, NeurIPS'24</a>
<span class="snippet"><span>Summary</span>反復的な好み最適化手法を用いて、Chain-of-Thought（CoT）候補間の推論ステップを最適化するアプローチを開発。修正DPO損失を使用し、推論の改善を示す。Llama-2-70B-ChatモデルでGSM8K、MATH、ARC-Challengeの精度を向上させ、GSM8Kでは55.6%から81.6%に改善。多数決による精度は88.7%に達した。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=4XIKfvNYvx&referrer=%5Bthe%20profile%20of%20He%20He%5D(%2Fprofile%3Fid%3D~He_He2)・1212

<br>



<br>

と似たようにiterativeなmannerでreasoning能力を向上させる。

<br>



<br>

<img src="https://github.com/user-attachments/assets/a0f10e8e-454d-40e8-ae67-8c6c2da6a0ed" alt="image" loading="lazy">

<br>



<br>

ただし、loss functionとしては、chosenなCoT+yのresponseに対して、reasoning traceを生成する能力を高めるために、NLL Lossも適用している点に注意。

<br>

<img src="https://github.com/user-attachments/assets/5ae2dcba-09c8-4618-9b63-ae6aed5b234d" alt="image" loading="lazy">

<br>



<br>

32 samplesのmajority votingによってより高い性能が達成できているので、多様なreasoning traceが生成されていることが示唆される。</span>
<a class="button" href="articles/Multi.html">#Multi</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2025-06-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2112">[Paper Note] Do Large Language Models Latently Perform Multi-Hop Reasoning?, Sohee Yang+, ACL'24</a>
<span class="snippet"><span>Summary</span>本研究では、LLMが複雑なプロンプトに対してマルチホップ推論を行う可能性を探ります。具体的には、LLMが「'Superstition'の歌手」を特定し、その母親に関する知識を用いてプロンプトを完成させる過程を分析します。2つのホップを個別に評価し、特に最初のホップにおいてブリッジエンティティのリコールが増加するかをテストしました。結果、特定の関係タイプのプロンプトに対してマルチホップ推論の証拠が見つかりましたが、活用は文脈依存であり、2番目のホップの証拠は控えめでした。また、モデルサイズの増加に伴い最初のホップの推論能力が向上する傾向が見られましたが、2番目のホップにはその傾向が見られませんでした。これらの結果は、LLMの今後の開発における課題と機会を示唆しています。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<a class="button" href="articles/PRM.html">#PRM</a>
<span class="issue_date">Issue Date: 2025-06-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2103">[Paper Note] Let's Verify Step by Step, Hunter Lightman+, ICLR'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデルの多段階推論能力が向上する中、論理的誤りが依然として問題である。信頼性の高いモデルを訓練するためには、結果監視とプロセス監視の比較が重要である。独自の調査により、プロセス監視がMATHデータセットの問題解決において結果監視を上回ることを発見し、78%の問題を解決した。また、アクティブラーニングがプロセス監視の効果を向上させることも示した。関連研究のために、80万の人間フィードバックラベルからなるデータセットPRM800Kを公開した。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=v8L0pN6EOiPRM800K:https://github.com/openai/prm800k/tree/main</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2025-06-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2102">[Paper Note] RewardBench: Evaluating Reward Models for Language Modeling, Nathan Lambert+, arXiv'24</a>
<span class="snippet"><span>Summary</span>報酬モデル（RMs）の評価に関する研究は少なく、我々はその理解を深めるためにRewardBenchというベンチマークデータセットを提案。これは、チャットや推論、安全性に関するプロンプトのコレクションで、報酬モデルの性能を評価する。特定の比較データセットを用いて、好まれる理由を検証可能な形で示し、さまざまなトレーニング手法による報酬モデルの評価を行う。これにより、報酬モデルの拒否傾向や推論の限界についての知見を得ることを目指す。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/ModelMerge.html">#ModelMerge</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2096">[Paper Note] Chat Vector: A Simple Approach to Equip LLMs with Instruction Following   and Model Alignment in New Languages, Shih-Cheng Huang+, ACL'24</a>
<span class="snippet"><span>Summary</span>オープンソースの大規模言語モデル（LLMs）の多くは英語に偏っている問題に対処するため、chat vectorという概念を導入。これは、事前学習済みモデルの重みからチャットモデルの重みを引くことで生成され、追加のトレーニングなしに新しい言語でのチャット機能を付与できる。実証研究では、指示に従う能力や有害性の軽減、マルチターン対話においてchat vectorの効果を示し、さまざまな言語やモデルでの適応性を確認。chat vectorは、事前学習済みモデルに対話機能を効率的に実装するための有力な解決策である。</span>
<span class="snippet"><span>Comment</span>日本語解説:https://qiita.com/jovyan/items/ee6affa5ee5bdaada6b4下記ブログによるとChatだけではなく、Reasoningでも（post-trainingが必要だが）使える模様

<br>



<br>

Reasoning能力を付与したLLM ABEJA-QwQ32b-Reasoning-Japanese-v1.0の公開, Abeja Tech Blog, 2025.04:

<br>

https://tech-blog.abeja.asia/entry/geniac2-qwen25-32b-reasoning-v1.0</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/PPO%20(ProximalPolicyOptimization).html">#PPO (ProximalPolicyOptimization)</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/On-Policy.html">#On-Policy</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2090">[Paper Note] Preference Fine-Tuning of LLMs Should Leverage Suboptimal, On-Policy   Data, Fahim Tajwar+, ICML'24</a>
<span class="snippet"><span>Summary</span>好みのラベルを用いた大規模言語モデルのファインチューニングに関する研究。オンポリシー強化学習や対照学習などの手法を比較し、オンポリシーサンプリングや負の勾配を用いるアプローチが優れていることを発見。これにより、カテゴリ分布の特定のビンにおける確率質量を迅速に変更できるモード探索目的の重要性を示し、データ収集の最適化に関する洞察を提供。</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2089">[Paper Note] Instruction Pre-Training: Language Models are Supervised Multitask   Learners, Daixuan Cheng+, EMNLP'24</a>
<span class="snippet"><span>Summary</span>無監督のマルチタスク事前学習に加え、監視されたマルチタスク学習の可能性を探るために、Instruction Pre-Trainingフレームワークを提案。指示応答ペアを生成し、2億のペアを合成して実験を行い、事前学習モデルの性能を向上させることを確認。Instruction Pre-TrainingはLlama3-8BをLlama3-70Bと同等以上の性能に引き上げる。モデルやデータは公開されている。</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-05-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1992">Densing Law of LLMs, Chaojun Xiao+, arXiv'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）の性能向上に伴うトレーニングと推論の効率の課題を解決するために、「キャパシティ密度」という新しい指標を提案。これは、ターゲットLLMの有効パラメータサイズと実際のパラメータサイズの比率を用いて、モデルの効果と効率を評価するフレームワークを提供する。分析により、LLMsのキャパシティ密度は約3か月ごとに倍増する傾向があることが示され、今後のLLM開発における重要性が強調される。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1926785750277693859?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q<img src="https://github.com/user-attachments/assets/8cdcfe78-6682-481b-a6b0-a175b84d735c" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-05-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1951">UltraFeedback: Boosting Language Models with Scaled AI Feedback, Ganqu Cui+, ICML'24</a>
<span class="snippet"><span>Summary</span>人間のフィードバックに加え、高品質なAIフィードバックを自動収集することで、LLMsのアライメントをスケーラブルに実現。多様なインタラクションをカバーし、注釈バイアスを軽減した結果、25万件の会話に対する100万件以上のGPT-4フィードバックを含むデータセット「UltraFeedback」を構築。これに基づき、LLaMAモデルを強化学習でアライメントし、チャットベンチマークで優れた性能を示す。研究はオープンソースチャットモデルの構築におけるAIフィードバックの有効性を検証。データとモデルは公開中。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2025-05-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1950">ORPO: Monolithic Preference Optimization without Reference Model, Jiwoo Hong+, EMNLP'24</a>
<span class="snippet"><span>Summary</span>本論文では、好みの整合性における監視付きファインチューニング（SFT）の重要性を強調し、わずかなペナルティで好みに整合したSFTが可能であることを示します。さらに、追加の整合性フェーズを必要としない新しいオッズ比最適化アルゴリズムORPOを提案し、これを用いて複数の言語モデルをファインチューニングした結果、最先端のモデルを上回る性能を達成しました。</span>
<span class="snippet"><span>Comment</span>ざっくり言うとinstruction tuningとalignmentを同時にできる手法らしいがまだ理解できていない</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/KnowledgeEditing.html">#KnowledgeEditing</a>
<span class="issue_date">Issue Date: 2025-05-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1947">EasyEdit: An Easy-to-use Knowledge Editing Framework for Large Language   Models, Peng Wang+, ACL'24, （System Demonstrations）</a>
<span class="snippet"><span>Summary</span>EasyEditは、LLMsのための使いやすい知識編集フレームワークであり、さまざまな知識編集アプローチをサポート。LlaMA-2の実験結果では、信頼性と一般化の面で従来のファインチューニングを上回ることを示した。GitHubでソースコードを公開し、Google Colabチュートリアルやオンラインシステムも提供。</span>
<span class="snippet"><span>Comment</span>ver2.0:

<br>

・1946</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<span class="issue_date">Issue Date: 2025-05-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1944">Nemotron-CC: Transforming Common Crawl into a Refined Long-Horizon  Pretraining Dataset, Dan Su+, arXiv'24</a>
<span class="snippet"><span>Summary</span>FineWeb-EduとDCLMは、モデルベースのフィルタリングによりデータの90%を削除し、トレーニングに適さなくなった。著者は、アンサンブル分類器や合成データの言い換えを用いて、精度とデータ量のトレードオフを改善する手法を提案。1Tトークンで8Bパラメータモデルをトレーニングし、DCLMに対してMMLUを5.6ポイント向上させた。新しい6.3Tトークンデータセットは、DCLMと同等の性能を持ちながら、4倍のユニークなトークンを含み、長トークンホライズンでのトレーニングを可能にする。15Tトークンのためにトレーニングされた8Bモデルは、Llama 3.1の8Bモデルを上回る性能を示した。データセットは公開されている。</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<span class="issue_date">Issue Date: 2025-05-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1943">DataComp-LM: In search of the next generation of training sets for  language models, Jeffrey Li+, arXiv'24</a>
<span class="snippet"><span>Summary</span>DataComp for Language Models（DCLM）を紹介し、240Tトークンのコーパスと53の評価スイートを提供。DCLMでは、モデルスケール412Mから7Bパラメータのデータキュレーション戦略を実験可能。DCLM-Baselineは2.6Tトークンでトレーニングし、MMLUで64%の精度を達成し、従来のMAP-Neoより6.6ポイント改善。計算リソースも40%削減。結果はデータセット設計の重要性を示し、今後の研究の基盤を提供。</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<span class="issue_date">Issue Date: 2025-05-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1942">The FineWeb Datasets: Decanting the Web for the Finest Text Data at  Scale, Guilherme Penedo+, arXiv'24</a>
<span class="snippet"><span>Summary</span>本研究では、15兆トークンからなるFineWebデータセットを紹介し、LLMの性能向上に寄与することを示します。FineWebは高品質な事前学習データセットのキュレーション方法を文書化し、重複排除やフィルタリング戦略を詳細に調査しています。また、FineWebから派生した1.3兆トークンのFineWeb-Eduを用いたLLMは、MMLUやARCなどのベンチマークで優れた性能を発揮します。データセット、コードベース、モデルは公開されています。</span>
<span class="snippet"><span>Comment</span>日本語解説:https://zenn.dev/deepkawamura/articles/da9aeca6d6d9f9</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/KnowledgeEditing.html">#KnowledgeEditing</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-05-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1933">Editing Large Language Models: Problems, Methods, and Opportunities, Yunzhi Yao+, EMNLP'24</a>
<span class="snippet"><span>Summary</span>LLMの編集技術の進展を探求し、特定のドメインでの効率的な動作変更と他の入力への影響を最小限に抑える方法を論じる。モデル編集のタスク定義や課題を包括的にまとめ、先進的な手法の実証分析を行う。また、新しいベンチマークデータセットを構築し、評価の向上と持続的な問題の特定を目指す。最終的に、編集技術の効果に関する洞察を提供し、適切な方法選択を支援する。コードとデータセットは公開されている。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-05-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1929">Physics of Language Models: Part 4.1, Architecture Design and the Magic of Canon Layers, Zeyuan Allen-Zhu+, ICML'24 Tutorial</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1919878625488449849?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QCanon層の発見著者による解説:https://x.com/zeyuanallenzhu/status/1918684257058197922?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-05-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1923">Physics of Language Models: Part 3.1, Knowledge Storage and Extraction, Zeyuan Allen-Zhu+, ICML'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）の知識抽出能力は、訓練データの多様性と強く相関しており、十分な強化がなければ知識は記憶されても抽出可能ではないことが示された。具体的には、エンティティ名の隠れ埋め込みに知識がエンコードされているか、他のトークン埋め込みに分散しているかを調査。LLMのプレトレーニングに関する重要な推奨事項として、補助モデルを用いたデータ再構成と指示微調整データの早期取り入れが提案された。</span>
<span class="snippet"><span>Comment</span>解説:

<br>

・1834</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Safety.html">#Safety</a>
<span class="issue_date">Issue Date: 2025-04-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1908">Safety Alignment Should Be Made More Than Just a Few Tokens Deep, Xiangyu Qi+, arXiv'24</a>
<span class="snippet"><span>Summary</span>現在の大規模言語モデル（LLMs）の安全性アラインメントは脆弱であり、単純な攻撃や善意のファインチューニングによって脱獄される可能性がある。この脆弱性は「浅い安全性アラインメント」に起因し、アラインメントが主に最初の数トークンの出力にのみ適応されることに関連している。本論文では、この問題のケーススタディを提示し、現在のアラインされたLLMsが直面する脆弱性を説明する。また、浅い安全性アラインメントの概念が脆弱性軽減の研究方向を示唆し、初期トークンを超えたアラインメントの深化がロバスト性を向上させる可能性を示す。最後に、ファインチューニング攻撃に対する持続的な安全性アラインメントを実現するための正則化されたファインチューニング目的を提案する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1917006979836612640?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QOpenReview:https://openreview.net/forum?id=6Mxhg9PtDESafety Alignment手法が最初の数トークンに依存しているからそうならないように学習しますというのは、興味深いテーマだし技術的にまだ困難な点もあっただろうし、インパクトも大きいし、とても良い研究だ…。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Decoding.html">#Decoding</a>
<span class="issue_date">Issue Date: 2025-04-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1890">Non-Determinism of "Deterministic" LLM Settings, Berk Atil+, arXiv'24</a>
<span class="snippet"><span>Summary</span>本研究では、5つの決定論的LLMにおける非決定性を8つのタスクで調査し、最大15%の精度変動と70%のパフォーマンスギャップを観察。全てのタスクで一貫した精度を提供できないことが明らかになり、非決定性が計算リソースの効率的使用に寄与している可能性が示唆された。出力の合意率を示す新たなメトリクスTARr@NとTARa@Nを導入し、研究結果を定量化。コードとデータは公開されている。</span>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/API.html">#API</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<span class="issue_date">Issue Date: 2025-04-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1874">Gorilla: Large Language Model Connected with Massive APIs, Shishir G. Patil+, NeurIPS'24</a>
<span class="snippet"><span>Summary</span>Gorillaは、API呼び出しの生成においてGPT-4を上回るLLaMAベースのモデルであり、文書検索システムと組み合わせることで、テスト時の文書変更に適応し、ユーザーの柔軟な更新を可能にします。幻覚の問題を軽減し、APIをより正確に使用する能力を示します。Gorillaの評価には新たに導入したデータセット「APIBench」を使用し、信頼性と適用性の向上を実現しています。</span>
<span class="snippet"><span>Comment</span>APIBench:https://huggingface.co/datasets/gorilla-llm/APIBenchOpenReview:https://openreview.net/forum?id=tBRNC6YemY</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/TMLR.html">#TMLR</a>
<span class="issue_date">Issue Date: 2025-04-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1868">Foundational Challenges in Assuring Alignment and Safety of Large   Language Models, Usman Anwar+, TMLR'24</a>
<span class="snippet"><span>Summary</span>本研究では、LLMsの整合性と安全性に関する18の基盤的課題を特定し、科学的理解、開発・展開方法、社会技術的課題の3つのカテゴリに整理。これに基づき、200以上の具体的な研究質問を提起。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=oVTkOs8Pka</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2025-04-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1854">Agent Workflow Memory, Zora Zhiruo Wang+, arXiv'24</a>
<span class="snippet"><span>Summary</span>エージェントワークフローメモリ（AWM）を導入し、エージェントが再利用可能なタスクワークフローを学習することで、複雑なウェブナビゲーションタスクを効率的に解決。Mind2WebとWebArenaのベンチマークで、成功率をそれぞれ24.6%および51.1%向上させ、必要なステップ数を削減。オンラインAWMは、タスクやドメインに対しても堅牢に一般化し、ベースラインを大幅に上回る性能を示した。</span>
<span class="snippet"><span>Comment</span>過去のワークフローをエージェントがprompt中で利用することができ、利用すればするほど賢くなるような仕組みの提案

<br>

<img width="873" alt="Image" src="https://github.com/user-attachments/assets/6160cfa5-9dbd-44c6-926c-a56eb698d78d"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2025-04-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1852">CoAct: A Global-Local Hierarchy for Autonomous Agent Collaboration, Xinming Hou+, arXiv'24</a>
<span class="snippet"><span>Summary</span>CoActフレームワークを提案し、2つのエージェント（グローバル計画エージェントとローカル実行エージェント）を用いて、LLMの複雑なタスクへの対応力を向上させる。実験では、WebArenaベンチマークにおいて優れた性能を示し、失敗時のプロセス再編成能力を確認。コードは公開中。</span>
<span class="snippet"><span>Comment</span>Planningエージェントと実行エージェントを活用するソフトウェアエージェント

<br>



<br>

<img width="632" alt="Image" src="https://github.com/user-attachments/assets/55db47b8-15f8-4a9c-b641-ce906994897f">

<br>



<br>

ReActより性能向上

<br>

・ 518 

<br>

<img width="325" alt="Image" src="https://github.com/user-attachments/assets/79ac984a-1aa4-4d27-8a3f-860ed2c3abf7"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<span class="issue_date">Issue Date: 2025-04-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1851">Training Software Engineering Agents and Verifiers with SWE-Gym, Jiayi Pan+, arXiv'24</a>
<span class="snippet"><span>Summary</span>SWE-Gymを提案し、2,438件の実世界のPythonタスクを含む環境を構築。言語モデルに基づくSWEエージェントを訓練し、SWE-Benchで最大19%の解決率向上を達成。微調整されたエージェントは新たな最先端の性能を示し、SWE-Gymやモデル、エージェントの軌跡を公開。</span>
<span class="snippet"><span>Comment</span>SWE-Benchとは完全に独立したより広範な技術スタックに関連するタスクに基づくSWEベンチマーク

<br>

・1848 SWE-Benchと比べて実行可能な環境と単体テストが提供されており、単なるベンチマークではなくエージェントを訓練できる環境が提供されている点が大きく異なるように感じる。

<br>

<img src="https://github.com/user-attachments/assets/8c96df84-d211-4035-8337-1ab624d30a4f" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/d25687d9-6f1a-44f6-8235-09be1ff4890f" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2025-04-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1849">WebArena: A Realistic Web Environment for Building Autonomous Agents, Shuyan Zhou+, ICLR'24</a>
<span class="snippet"><span>Summary</span>生成AIの進展により、自律エージェントが自然言語コマンドで日常タスクを管理する可能性が生まれたが、現行のエージェントは簡略化された環境でのテストに限られている。本研究では、ウェブ上でタスクを実行するエージェントのための現実的な環境を構築し、eコマースやソーシャルフォーラムなどのドメインを含む完全なウェブサイトを提供する。この環境を基に、タスクの正確性を評価するベンチマークを公開し、実験を通じてGPT-4ベースのエージェントの成功率が14.41%であり、人間の78.24%には及ばないことを示した。これにより、実生活のタスクにおけるエージェントのさらなる開発の必要性が強調される。</span>
<span class="snippet"><span>Comment</span>Webにおけるさまざまなrealisticなタスクを評価するためのベンチマーク

<br>

<img src="https://github.com/user-attachments/assets/8895fc29-e997-4cce-a43e-65b928dc1d78" alt="image" loading="lazy">実際のexample。スタート地点からピッツバーグのmuseumを巡る最短の経路を見つけるといった複雑なタスクが含まれる。

<br>

<img src="https://github.com/user-attachments/assets/5b7bebea-34c7-4c6f-bbe5-3928544e6c13" alt="image" loading="lazy">

<br>



<br>

人間とGPT4,GPT-3.5の比較結果

<br>

<img src="https://github.com/user-attachments/assets/390fee31-85d0-4d83-969a-57a7f1548ca8" alt="image" loading="lazy"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<span class="issue_date">Issue Date: 2025-04-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1847">Agentless: Demystifying LLM-based Software Engineering Agents, Chunqiu Steven Xia+, arXiv'24</a>
<span class="snippet"><span>Summary</span>最近のLLMの進展により、ソフトウェア開発タスクの自動化が進んでいるが、複雑なエージェントアプローチの必要性に疑問が生じている。これに対し、Agentlessというエージェントレスアプローチを提案し、シンプルな三段階プロセスで問題を解決。SWE-bench Liteベンチマークで最高のパフォーマンスと低コストを達成。研究は自律型ソフトウェア開発におけるシンプルで解釈可能な技術の可能性を示し、今後の研究の方向性を刺激することを目指している。</span>
<span class="snippet"><span>Comment</span>日本語解説:https://note.com/ainest/n/nac1c795e3825LLMによる計画の立案、環境からのフィードバックによる意思決定などの複雑なワークフローではなく、Localization（階層的に問題のある箇所を同定する）とRepair（LLMで複数のパッチ候補を生成する）、PatchValidation(再現テストと回帰テストの両方を通じて結果が良かったパッチを選ぶ）のシンプルなプロセスを通じてIssueを解決する。

<br>

<img src="https://github.com/user-attachments/assets/6d042dfe-9780-4410-9077-b265af5456d1" alt="image" loading="lazy">

<br>



<br>

これにより、低コストで高い性能を達成している、といった内容な模様。

<br>

<img src="https://github.com/user-attachments/assets/3934126f-3a4d-406c-8860-c3ed35a351c4" alt="image" loading="lazy"></span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/UserModeling.html">#UserModeling</a>
<a class="button" href="articles/CTRPrediction.html">#CTRPrediction</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/WWW.html">#WWW</a>
<span class="issue_date">Issue Date: 2025-03-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1840">ReLLa: Retrieval-enhanced Large Language Models for Lifelong Sequential   Behavior Comprehension in Recommendation, Jianghao Lin+, WWW'24</a>
<span class="snippet"><span>Summary</span>本論文では、ゼロショットおよび少ショットの推薦タスクにおいて、大規模言語モデル（LLMs）を強化する新しいフレームワーク「ReLLa」を提案。LLMsが長いユーザー行動シーケンスから情報を抽出できない問題に対処し、セマンティックユーザー行動検索（SUBR）を用いてデータ品質を向上させる。少ショット設定では、検索強化指示チューニング（ReiT）を設計し、混合トレーニングデータセットを使用。実験により、少ショットReLLaが従来のCTRモデルを上回る性能を示した。</span>
<span class="snippet"><span>Comment</span>・1839

<br>



<br>

のベースラインLLMでCTR予測する際の性能を向上した研究。

<br>



<br>

そもそもLLMでCTR予測をする際は、ユーザのデモグラ情報とアクティビティログなどのユーザプロファイルと、ターゲットアイテムの情報でpromptingし、yes/noを出力させる。yes/noトークンのスコアに対して2次元のソフトマックスを適用して[0, 1]のスコアを得ることで、CTR予測をする。

<br>

<img src="https://github.com/user-attachments/assets/75025947-f3bb-49d0-a8f1-e05c429183a4" alt="image" loading="lazy">

<br>



<br>

この研究ではコンテキストにユーザのログを入れても性能がスケールしない問題に対処するために

<br>

<img src="https://github.com/user-attachments/assets/69c27a84-0456-4ddf-aded-515608e27065" alt="image" loading="lazy">

<br>



<br>

直近のアクティビティログではなく、ターゲットアイテムと意味的に類似したアイテムに関するログをコンテキストに入れ（SUBR）、zero shotのinferenceに活用する。

<br>

<img src="https://github.com/user-attachments/assets/a5a2a300-ddca-42cc-97d7-251487ccfa3a" alt="image" loading="lazy">

<br>



<br>

few-shot recommendation（少量のクリックスルーログを用いてLLMをSFTすることでCTR予測する手法）においては、上述の意味的に類似したアイテムをdata augmentationに利用し（i.e, promptに埋め込むアクティビティログの量を増やして）学習する。

<br>

<img src="https://github.com/user-attachments/assets/b98af740-0628-4e98-a80f-30ff105621e1" alt="image" loading="lazy">

<br>



<br>

zeroshotにおいて、SUBRで性能改善。fewshot recommendationにといて、10%未満のデータで既存の全データを用いる手法を上回る。また、下のグラフを見るとpromptに利用するアクティビティログの量が増えるほど性能が向上するようになった。

<br>

<img src="https://github.com/user-attachments/assets/1297153e-bd6c-4548-a7e0-798eadee80e9" alt="image" loading="lazy">

<br>



<br>

ただし、latencyは100倍以上なのでユースケースが限定される。

<br>

<img src="https://github.com/user-attachments/assets/89555964-f5c4-4735-bc0d-9a5a1b7f0278" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SSM%20(StateSpaceModel).html">#SSM (StateSpaceModel)</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2025-03-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1831">Transformers are SSMs: Generalized Models and Efficient Algorithms   Through Structured State Space Duality, Tri Dao+, ICML'24</a>
<span class="snippet"><span>Summary</span>TransformersとMambaのような状態空間モデル（SSMs）の関連性を示し、SSMsと注意の変種との理論的接続を構築。新たに設計したMamba-2は、速度を2〜8倍向上させながら、Transformersと競争力を維持。</span>
<span class="snippet"><span>Comment</span>Mamba2の詳細を知りたい場合に読む</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Pruning.html">#Pruning</a>
<a class="button" href="articles/Distillation.html">#Distillation</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<span class="issue_date">Issue Date: 2025-03-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1804">Compact Language Models via Pruning and Knowledge Distillation, Saurav Muralidharan+, NeurIPS'24</a>
<span class="snippet"><span>Summary</span>本論文では、既存の大規模言語モデル（LLMs）をプルーニングし、少量のトレーニングデータで再トレーニングする手法を提案。深さ、幅、注意、MLPプルーニングを知識蒸留と組み合わせた圧縮ベストプラクティスを開発し、Nemotron-4ファミリーのLLMを2-4倍圧縮。これにより、トレーニングに必要なトークン数を最大40倍削減し、計算コストを1.8倍削減。Minitronモデルは、ゼロからトレーニングした場合と比較してMMLUスコアが最大16%改善され、他のモデルと同等の性能を示す。モデルの重みはオープンソース化され、補足資料も提供。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=9U0nLnNMJ7&referrer=%5Bthe%20profile%20of%20Pavlo%20Molchanov%5D(%2Fprofile%3Fid%3D~Pavlo_Molchanov1)<img src="https://github.com/user-attachments/assets/76ab1107-bf94-4cf1-9ad1-e9f494b917e7" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/d1bf8a84-5365-4d35-aae0-146b1860ed9d" alt="image" loading="lazy">

<br>



<br>

（あとでメモを追記）</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2025-03-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1802">Sparse Autoencoders Find Highly Interpretable Features in Language   Models, Hoagy Cunningham+, ICLR'24</a>
<span class="snippet"><span>Summary</span>神経ネットワークの多義性を解消するために、スパースオートエンコーダを用いて内部活性化の方向を特定。これにより、解釈可能で単義的な特徴を学習し、間接目的語の同定タスクにおける因果的特徴をより詳細に特定。スケーラブルで教師なしのアプローチが重ね合わせの問題を解決できることを示唆し、モデルの透明性と操作性向上に寄与する可能性を示す。</span>
<span class="snippet"><span>Comment</span>日本語解説:https://note.com/ainest/n/nbe58b36bb2dbOpenReview:https://openreview.net/forum?id=F76bwRSLeKSparseAutoEncoderはネットワークのあらゆるところに仕込める（と思われる）が、たとえばTransformer Blockのresidual connection部分のベクトルに対してFeature Dictionaryを学習すると、当該ブロックにおいてどのような特徴の組み合わせが表現されているかが（あくまでSparseAutoEncoderがreconstruction lossによって学習された結果を用いて）解釈できるようになる。

<br>

<img src="https://github.com/user-attachments/assets/f86f5f7b-f46d-48ab-94e3-cf7f298eb9d7" alt="image" loading="lazy">

<br>



<br>

SparseAutoEncoderは下記式で表され、下記loss functionで学習される。MがFeature Matrix（row-wiseに正規化されて後述のcに対するL1正則化に影響を与えないようにしている）に相当する。cに対してL1正則化をかけることで（Sparsity Loss）、c中の各要素が0に近づくようになり、結果としてcがSparseとなる（どうしても値を持たなければいけない重要な特徴量のみにフォーカスされるようになる）。

<br>

<img src="https://github.com/user-attachments/assets/7e400f25-8a63-4222-904c-4a7b94d50880" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/dd8c10b3-3bb5-46fb-b94a-d91f3602bbd1" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/AutomaticPromptEngineering.html">#AutomaticPromptEngineering</a>
<span class="issue_date">Issue Date: 2025-02-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1752">PromptWizard: Task-Aware Prompt Optimization Framework, Eshaan Agarwal+, arXiv'24</a>
<span class="snippet"><span>Summary</span>PromptWizardは、完全自動化された離散プロンプト最適化フレームワークであり、自己進化的かつ自己適応的なメカニズムを利用してプロンプトの質を向上させる。フィードバック駆動の批評を通じて、タスク特有のプロンプトを生成し、45のタスクで優れたパフォーマンスを実現。限られたデータや小規模なLLMでも効果を発揮し、コスト分析により効率性とスケーラビリティの利点が示された。</span>
<span class="snippet"><span>Comment</span>Github:https://github.com/microsoft/PromptWizard?tab=readme-ov-file

<br>

元ポスト:https://x.com/tom_doerr/status/1888178173684199785?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q初期に提案された

<br>

・1034

<br>



<br>

と比較すると大分性能が上がってきているように見える。

<br>

<img src="https://github.com/user-attachments/assets/5f7a329e-e83b-46da-9213-af8877201572" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/857b3526-4f56-4e31-8a69-a4193657b286" alt="image" loading="lazy">reasoning modelではfewshot promptingをすると性能が落ちるという知見があるので、reasoningモデル向けのAPE手法もそのうち出現するのだろう（既にありそう）。OpenReview: https://openreview.net/forum?id=VZC9aJoI6a

<br>

ICLR'25にrejectされている</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenSource.html">#OpenSource</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-02-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1745">Tulu 3: Pushing Frontiers in Open Language Model Post-Training, Nathan Lambert+, arXiv'24</a>
<span class="snippet"><span>Summary</span>Tulu 3は、オープンなポストトレーニングモデルのファミリーで、トレーニングデータやレシピを公開し、現代のポストトレーニング技術のガイドを提供します。Llama 3.1を基にし、他のクローズドモデルを上回る性能を達成。新しいトレーニング手法としてSFT、DPO、RLVRを採用し、マルチタスク評価スキームを導入。モデルウェイトやデモ、トレーニングコード、データセットなどを公開し、他のドメインへの適応も可能です。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/icoxfog417/status/1885460713264775659?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Distillation.html">#Distillation</a>
<span class="issue_date">Issue Date: 2025-02-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1742">A Survey on Knowledge Distillation of Large Language Models, Xiaohan Xu+, arXiv'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）における知識蒸留（KD）の重要性を調査し、小型モデルへの知識伝達やモデル圧縮、自己改善の役割を強調。KDメカニズムや認知能力の向上、データ拡張（DA）との相互作用を検討し、DAがLLM性能を向上させる方法を示す。研究者や実務者に向けたガイドを提供し、LLMのKDの倫理的適用を推奨。関連情報はGithubで入手可能。</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2025-01-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1731">Don't Do RAG: When Cache-Augmented Generation is All You Need for  Knowledge Tasks, Brian J Chan+, arXiv'24</a>
<span class="snippet"><span>Summary</span>キャッシュ拡張生成（CAG）は、RAGの課題を克服するために提案された手法で、LLMの拡張コンテキストに事前に関連リソースをロードし、検索なしでクエリに応答する。CAGは検索の遅延を排除し、エラーを最小限に抑えつつ、コンテキストの関連性を維持。性能評価では、CAGが従来のRAGを上回るか補完することが示され、特に制約のある知識ベースにおいて効率的な代替手段となることが示唆されている。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/omarsar0/status/1876721221083214200?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q外部知識として利用したいドキュメントがそこまで大きく無いなら、事前にLLMで全てのKey Valueを計算しておきKV Cacheとして利用可能にしておけば、生成時に検索をすることもなく、contextとして利用して生成できるじゃん、という研究</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<span class="issue_date">Issue Date: 2025-01-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1729">[Paper Note] Chain of Agents: Large language models collaborating on long-context tasks, Google Research, 2025.01, NeurIPS'24</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/googleai/status/1882554959272849696?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLLMがどこまでいってもcontext長の制約に直面する問題に対してLLM Agentを組み合わせて対処しました、的な話な模様ブログ中にアプローチを解説した動画があるのでわかりやすいIs the experimental code open source?Thank you for your comment. I tried to find an official open-source implementation provided by the authors, but I was not able to locate one. In fact, I also checked the personal webpage of the first author, but there was no link to any released code.

<br>



<br>

Is seems that an unofficial implementation is listed under the “Code” tab on the NeurIPS page. I hope this is helpful. Thank you.

<br>



<br>

NeurIPS link: https://nips.cc/virtual/2024/poster/95563

<br>

openreview: https://openreview.net/forum?id=LuCLf4BJsr</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<span class="issue_date">Issue Date: 2025-01-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1724">Spectrum: Targeted Training on Signal to Noise Ratio, Eric Hartford+, arXiv'24</a>
<span class="snippet"><span>Summary</span>「Spectrum」という手法を提案し、SNRに基づいてレイヤーモジュールを選択的にターゲットにすることで、LLMのトレーニングを加速。これによりGPUメモリ使用量を削減しつつ、フルファインチューニングに匹敵する性能を実現。実験により、既存手法QLoRAと比較してモデルの品質とVRAM効率の向上が確認された。</span>
<span class="snippet"><span>Comment</span>・1723

<br>



<br>

によるとLLMのうち最もinformativeなLayerを見つけ、選択的に学習することで、省リソースで、Full-Parameter tuningと同等の性能を発揮する手法らしい

<br>



<br>

</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2025-01-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1699">OlympiadBench: A Challenging Benchmark for Promoting AGI with   Olympiad-Level Bilingual Multimodal Scientific Problems, Chaoqun He+, ACL'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）やマルチモーダルモデル（LMMs）の能力を測定するために、オリンピアドレベルのバイリンガルマルチモーダル科学ベンチマーク「OlympiadBench」を提案。8,476の数学と物理の問題を含み、専門家レベルの注釈が付けられている。トップモデルのGPT-4Vは平均17.97%のスコアを達成したが、物理では10.74%にとどまり、ベンチマークの厳しさを示す。一般的な問題として幻覚や論理的誤謬が指摘され、今後のAGI研究に貴重なリソースとなることが期待される。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Bias.html">#Bias</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2025-01-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1670">ConSiDERS-The-Human Evaluation Framework: Rethinking Human Evaluation  for Generative Large Language Models, Aparna Elangovan+, arXiv'24</a>
<span class="snippet"><span>Summary</span>本ポジションペーパーでは、生成的な大規模言語モデル（LLMs）の人間評価は多分野にわたる取り組みであるべきと主張し、実験デザインの信頼性を確保するためにユーザーエクスペリエンスや心理学の洞察を活用する必要性を強調します。評価には使いやすさや認知バイアスを考慮し、強力なモデルの能力と弱点を区別するための効果的なテストセットが求められます。さらに、スケーラビリティも重要であり、6つの柱から成るConSiDERS-The-Human評価フレームワークを提案します。これらの柱は、一貫性、評価基準、差別化、ユーザーエクスペリエンス、責任、スケーラビリティです。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/EducationalDataMining.html">#EducationalDataMining</a>
<span class="issue_date">Issue Date: 2025-01-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1667">Engaging an LLM to Explain Worked Examples for Java Programming: Prompt Engineering and a Feasibility Study, Hassany+, EDM'24 Workshop, 2024.07</a>
<span class="snippet"><span>Summary</span>プログラミングクラスでのコード例の説明を効率化するために、LLMを用いた人間とAIの共同執筆アプローチを提案。講師が編集可能な初期コード説明を生成し、学生にとって意味のある内容を確保するためにプロンプトエンジニアリングを行い、その効果をユーザー研究で評価した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/peterpaws/status/1876047837441806604?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2025-01-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1665">DeepSeekMoE: Towards Ultimate Expert Specialization in Mixture-of-Experts Language Models, Damai+, ACL'24, 2024.08</a>
<span class="snippet"><span>Summary</span>DeepSeekMoEアーキテクチャは、専門家の専門性を高めるために、専門家を細分化し柔軟な組み合わせを可能にし、共有専門家を設けて冗長性を軽減する。2BパラメータのDeepSeekMoEは、GShardと同等の性能を達成し、同じパラメータ数の密なモデルに近づく。16Bパラメータにスケールアップした際も、計算量を約40%に抑えつつ、LLaMA2と同等の性能を示した。</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RLHF.html">#RLHF</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-01-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1655">DeepSeekMath: Pushing the Limits of Mathematical Reasoning in Open  Language Models, Zhihong Shao+, arXiv'24</a>
<span class="snippet"><span>Summary</span>DeepSeekMath 7Bは、120Bの数学関連トークンを用いて事前学習された言語モデルで、競技レベルのMATHベンチマークで51.7%のスコアを達成。自己一貫性は60.9%で、データ選択パイプラインとGroup Relative Policy Optimization (GRPO)の導入により数学的推論能力が向上。Gemini-UltraやGPT-4に迫る性能を示す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://www.linkedin.com/posts/philipp-schmid-a6a2bb196_the-rlhf-method-behind-the-best-open-models-activity-7280850174522843137-3V9v?utm_source=share&utm_medium=member_ios元々数学のreasoningに関する能力を改善するために提案されたが、現在はオンラインでTruthfulness, Helpfulness, Concisenessなどの改善に活用されているとのこと。PPOとGRPOの比較。value function model（状態の価値を予測するモデル）が不要なため省メモリ、かつ利用する計算リソースが小さいらしい。

<br>

あとサンプルをグループごとに分けて、グループ内でのKLダイバージェンスが最小化されるよう（つまり、各グループ内で方策が類似する）Policy Modelが更新される（つまりloss functionに直接組み込まれる）点が違うらしい。

<br>



<br>

PPOでは生成するトークンごとにreference modelとPolicy ModelとのKLダイバージェンスをとり、reference modelとの差が大きくならないよう、報酬にペナルティを入れるために使われることが多いらしい。

<br>

<img src="https://github.com/user-attachments/assets/e145ad52-e6c9-4481-b2ee-10a3987ea2e3" alt="image" loading="lazy">下記記事によると、PPOで最大化したいのはAdvantage（累積報酬と状態価値（累積報酬の期待値を計算するモデル）の差分;期待値よりも実際の累積報酬が良かったら良い感じだぜ的な数値）であり、それには状態価値を計算するモデルが必要である。そして、PPOにおける状態価値モデルを使わないで、LLMにテキスト生成させて最終的な報酬を平均すれば状態価値モデル無しでAdvantageが計算できるし嬉しくね？という気持ちで提案されたのが、本論文で提案されているGRPOとのこと。勉強になる。

<br>



<br>

DeepSeek-R1の論文読んだ？【勉強になるよ】

<br>

, asap: https://zenn.dev/asap/articles/34237ad87f8511</span>
<a class="button" href="articles/Controllable.html">#Controllable</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/PositionalEncoding.html">#PositionalEncoding</a>
<a class="button" href="articles/Length.html">#Length</a>
<span class="issue_date">Issue Date: 2025-01-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1646">Precise Length Control in Large Language Models, Bradley Butcher+, arXiv'24</a>
<span class="snippet"><span>Summary</span>本研究では、LLMの応答の長さを正確に制御するために、二次的な長さ差位置エンコーディング（LDPE）を用いたアプローチを提案。LDPEを組み込むことで、モデルは平均3トークン未満の誤差で望ましい長さで応答を終了できるようになる。また、柔軟な上限長さ制御を可能にするMax New Tokens++も導入。実験結果は、質問応答や文書要約において応答の質を維持しつつ正確な長さ制御が実現できることを示している。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dair_ai/status/1870821203780256178?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q・1647

<br>



<br>

などのEncoder-Decoderモデルで行われていたoutput lengthの制御をDecoder-onlyモデルでもやりました、という話に見える。</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2025-01-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1645">TheAgentCompany: Benchmarking LLM Agents on Consequential Real World  Tasks, Frank F. Xu+, arXiv'24</a>
<span class="snippet"><span>Summary</span>日常生活や仕事におけるAIエージェントの効果を測定するため、TheAgentCompanyというベンチマークを導入。AIエージェントは、ウェブブラウジングやコード実行などのタスクを自律的に行う能力を評価。テストの結果、最も競争力のあるエージェントはタスクの24%を自律的に完了できることが判明。簡単なタスクは自動化可能だが、難しい長期的なタスクは現行システムでは対応できないことが示された。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dair_ai/status/1870821189809217921?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qソフトウェアエンジニアリングの企業の設定で現実に起こりうるな　175種類のタスクを定義してAI Agentを評価できるベンチマークTheAgentCompanyを提案。

<br>



<br>

<img src="https://github.com/user-attachments/assets/ef7b51d3-b4af-4171-a692-48fb2c2552ef" alt="image" loading="lazy">

<br>



<br>

既存のベンチマークより、多様で、実際のソフトウェアエンジニアリング企業でで起こりうる幅広いタスクを持ち、タスクの遂行のために同僚に対して何らかのインタラクションが必要で、達成のために多くのステップが必要でかつ個々のステップ（サブタスク）を評価可能で、多様なタスクを遂行するために必要な様々なインタフェースをカバーし、self hostingして結果を完全に再現可能なベンチマークとなっている模様。

<br>

<img src="https://github.com/user-attachments/assets/e5fbd6da-75d7-49e1-8c66-dc7950d443e4" alt="image" loading="lazy">

<br>



<br>

https://x.com/gneubig/status/1869735196700062089?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

（画像は著者ツイートより引用）プロプライエタリなモデルとOpenWeightなモデルでAI Agentとしての能力を評価した結果、Claude-3.5-sonnetは約24%のタスクを解決可能であり、他モデルと比べて性能が明らかに良かった。また、Gemini-2.0-flashなコストパフォーマンスに優れている。OpenWeightなモデルの中ではLlama3.3-70Bのコストパフォーマンスが良かった。タスクとしては具体的に評価可能なタスクのみに焦点を当てており、Open Endなタスクでは評価していない点に注意とのこと。

<br>

https://x.com/gneubig/status/1869735209404682706?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

https://x.com/gneubig/status/1869735213976432764?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

<img src="https://github.com/user-attachments/assets/3bdcabef-70da-4f09-8366-efe29f7ab371" alt="image" loading="lazy">まだまだAI Agentが完全に'同僚'として機能することとは現時点ではなさそうだが、このベンチマークのスコアが今後どこまで上がっていくだろうか。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<span class="issue_date">Issue Date: 2025-01-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1644">A Survey of Mathematical Reasoning in the Era of Multimodal Large  Language Model: Benchmark, Method &amp; Challenges, Yibo Yan+, arXiv'24</a>
<span class="snippet"><span>Summary</span>数学的推論は多くの分野で重要であり、AGIの進展に伴い、LLMsを数学的推論タスクに統合することが求められている。本調査は、2021年以降の200以上の研究をレビューし、マルチモーダル設定におけるMath-LLMsの進展を分析。分野をベンチマーク、方法論、課題に分類し、マルチモーダル数学的推論のパイプラインやLLMsの役割を探る。さらに、AGI実現の障害となる5つの課題を特定し、今後の研究方向性を示す。</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/KnowledgeGraph.html">#KnowledgeGraph</a>
<span class="issue_date">Issue Date: 2025-01-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1643">Can LLMs Convert Graphs to Text-Attributed Graphs?, Zehong Wang+, arXiv'24</a>
<span class="snippet"><span>Summary</span>Topology-Aware Node description Synthesis（TANS）を提案し、GNNが異なる特徴空間を持つグラフに適用できるようにする。TANSはLLMsを用いて既存のグラフをテキスト属性グラフに変換し、ノードの特性にトポロジー情報を統合。テキストがないグラフでも手動設計を超える性能を示し、LLMsの可能性を実証。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/omarsar0/status/1868691391129272461?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<span class="issue_date">Issue Date: 2025-01-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1641">How Much Data is Enough Data? Fine-Tuning Large Language Models for  In-House Translation: Performance Evaluation Across Multiple Dataset Sizes, Inacio Vieira+, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMsのファインチューニングに翻訳メモリ（TMs）を活用し、特定の組織向けの翻訳精度と効率を向上させる研究。5つの翻訳方向で異なるサイズのデータセットを用いて実験し、トレーニングデータが増えるほど翻訳パフォーマンスが向上することを確認。特に、1kおよび2kの例ではパフォーマンスが低下するが、データセットのサイズが増加するにつれて改善が見られる。LLMsとTMsの統合により、企業特有のニーズに応じたカスタマイズ翻訳モデルの可能性を示唆。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gyakuse/status/1874357127248306200?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QQLoRAでLlama 8B InstructをMTのデータでSFTした場合のサンプル数に対する性能の変化を検証している。ただし、検証しているタスクはMT、QLoRAでSFTを実施しrankは64、学習時のプロンプトは非常にシンプルなものであるなど、幅広い設定で学習しているわけではないので、ここで得られた知見が幅広く適用可能なことは示されていないであろう点、には注意が必要だと思われる。

<br>



<br>

この設定では、SFTで利用するサンプル数が増えれば増えるほど性能が上がっているように見える。

<br>



<br>

<img src="https://github.com/user-attachments/assets/71309a00-85fd-491f-a89e-c9cb99f4da6c" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/ea1eba38-9488-43e5-a64b-f997bf65f57b" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/21b21628-d589-4214-8860-680e392a2556" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<span class="issue_date">Issue Date: 2025-01-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1640">LoRA Learns Less and Forgets Less, Dan Biderman+, TMLR'24</a>
<span class="snippet"><span>Summary</span>LoRAは大規模言語モデルの効率的なファインチューニング手法であり、プログラミングと数学のドメインでの性能をフルファインチューニングと比較。標準的な設定ではLoRAは性能が劣るが、ターゲットドメイン外のタスクではベースモデルの性能を維持し、忘却を軽減する効果がある。フルファインチューニングはLoRAよりも高いランクの摂動を学習し、性能差の一因と考えられる。最終的に、LoRAのファインチューニングに関するベストプラクティスを提案。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gyakuse/status/1874357127248306200?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qfull finetuningとLoRAの性質の違いを理解するのに有用</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<span class="issue_date">Issue Date: 2025-01-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1639">FineTuneBench: How well do commercial fine-tuning APIs infuse knowledge  into LLMs?, Eric Wu+, arXiv'24</a>
<span class="snippet"><span>Summary</span>商業的なLLM微調整APIの効果を評価するためのFineTuneBenchを提案。5つの最前線のLLMを分析し、新しい情報の学習と既存知識の更新における能力を評価した結果、全モデルで平均一般化精度は37%、医療ガイドラインの更新では19%と低いことが判明。特にGPT-4o miniが最も効果的で、Gemini 1.5シリーズは能力が限られていた。商業的微調整サービスの信頼性に課題があることを示唆。データセットはオープンソースで提供。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gyakuse/status/1874357127248306200?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<span class="issue_date">Issue Date: 2025-01-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1637">Generative AI for Synthetic Data Generation: Methods, Challenges and the  Future, Xu Guo+, arXiv'24</a>
<span class="snippet"><span>Summary</span>限られたデータのシナリオでLLMsを用いて合成データを生成する研究が増加しており、これは生成的AIの進展を示す。LLMsは実世界のデータと同等の性能を持ち、リソースが限られた課題に対する解決策となる。本論文では、タスク特化型のトレーニングデータ生成のための技術、評価方法、実用的応用、現在の制限、将来の研究の方向性について議論する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gyakuse/status/1874357127248306200?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<span class="issue_date">Issue Date: 2025-01-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1636">On LLMs-Driven Synthetic Data Generation, Curation, and Evaluation: A  Survey, Lin Long+, arXiv'24</a>
<span class="snippet"><span>Summary</span>深層学習におけるデータの量と質の問題に対し、LLMsが合成データ生成を通じて解決策を提供。しかし、現状の研究は統一されたフレームワークを欠き、表面的なものが多い。本論文では合成データ生成のワークフローを整理し、研究のギャップを明らかにし、今後の展望を示す。学術界と産業界のより体系的な探求を促進することを目指す。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gyakuse/status/1874357127248306200?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/SessionBased.html">#SessionBased</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2024-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1632">Preference Discerning with LLM-Enhanced Generative Retrieval, Fabian Paischer+, arXiv'24</a>
<span class="snippet"><span>Summary</span>逐次推薦システムのパーソナライズを向上させるために、「好みの識別」という新しいパラダイムを提案。大規模言語モデルを用いてユーザーの好みを生成し、包括的な評価ベンチマークを導入。新手法Menderは、既存手法を改善し、最先端の性能を達成。Menderは未観察の人間の好みにも効果的に対応し、よりパーソナライズされた推薦を実現する。コードとベンチマークはオープンソース化予定。</span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/SessionBased.html">#SessionBased</a>
<span class="issue_date">Issue Date: 2024-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1631">Unifying Generative and Dense Retrieval for Sequential Recommendation, Liu Yang+, arXiv'24</a>
<span class="snippet"><span>Summary</span>逐次密な検索モデルはユーザーとアイテムの内積計算を行うが、アイテム数の増加に伴いメモリ要件が増大する。一方、生成的検索はセマンティックIDを用いてアイテムインデックスを予測する新しいアプローチである。これら二つの手法の比較が不足しているため、LIGERというハイブリッドモデルを提案し、生成的検索と逐次密な検索の強みを統合。これにより、コールドスタートアイテム推薦を強化し、推薦システムの効率性と効果を向上させることを示した。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2024-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1630">Mulberry: Empowering MLLM with o1-like Reasoning and Reflection via  Collective Monte Carlo Tree Search, Huanjin Yao+, arXiv'24</a>
<span class="snippet"><span>Summary</span>本研究では、MLLMを用いて質問解決のための推論ステップを学習する新手法CoMCTSを提案。集団学習を活用し、複数モデルの知識で効果的な推論経路を探索。マルチモーダルデータセットMulberry-260kを構築し、モデルMulberryを訓練。実験により提案手法の優位性を確認。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Education.html">#Education</a>
<a class="button" href="articles/EducationalDataMining.html">#EducationalDataMining</a>
<span class="issue_date">Issue Date: 2024-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1629">LearnLM: Improving Gemini for Learning, LearnLM Team+, arXiv'24</a>
<span class="snippet"><span>Summary</span>生成AIシステムは従来の情報提示に偏っているため、教育的行動を注入する「教育的指示の遵守」を提案。これにより、モデルの振る舞いを柔軟に指定でき、教育データを追加することでGeminiモデルの学習を向上。LearnLMモデルは、さまざまな学習シナリオで専門家から高く評価され、GPT-4oやClaude 3.5に対しても優れた性能を示した。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/TheoryOfMind.html">#TheoryOfMind</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2024-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1628">Explore Theory of Mind: Program-guided adversarial data generation for  theory of mind reasoning, Melanie Sclar+, arXiv'24</a>
<span class="snippet"><span>Summary</span>ExploreToMは、心の理論を評価するための多様で挑戦的なデータを生成するフレームワークであり、LLMsの限界をテストする。最先端のLLMsは、ExploreToM生成データに対して低い精度を示し、堅牢な評価の必要性を強調。ファインチューニングにより従来のベンチマークで精度向上を実現し、モデルの低パフォーマンスの要因を明らかにする。</span>
<span class="snippet"><span>Comment</span>おもしろそう。あとで読む</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2024-12-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1627">A Survey on LLM Inference-Time Self-Improvement, Xiangjue Dong+, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLM推論における自己改善技術を三つの視点から検討。独立した自己改善はデコーディングやサンプリングに焦点、文脈に応じた自己改善は追加データを活用、モデル支援の自己改善はモデル間の協力を通じて行う。関連研究のレビューと課題、今後の研究への洞察を提供。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<span class="issue_date">Issue Date: 2024-12-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1626">From Matching to Generation: A Survey on Generative Information  Retrieval, Xiaoxi Li+, arXiv'24</a>
<span class="snippet"><span>Summary</span>情報検索（IR）システムは、検索エンジンや質問応答などで重要な役割を果たしている。従来のIR手法は類似性マッチングに基づいていたが、事前学習された言語モデルの進展により生成情報検索（GenIR）が注目されている。GenIRは生成文書検索（GR）と信頼性のある応答生成に分かれ、GRは生成モデルを用いて文書を直接生成し、応答生成はユーザーの要求に柔軟に応える。本論文はGenIRの最新研究をレビューし、モデルのトレーニングや応答生成の進展、評価や課題についても考察する。これにより、GenIR分野の研究者に有益な参考資料を提供し、さらなる発展を促すことを目指す。</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2024-12-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1624">RetroLLM: Empowering Large Language Models to Retrieve Fine-grained  Evidence within Generation, Xiaoxi Li+, arXiv'24</a>
<span class="snippet"><span>Summary</span>RetroLLMは、リトリーバルと生成を統合したフレームワークで、LLMsがコーパスから直接証拠を生成することを可能にします。階層的FM-インデックス制約を導入し、関連文書を特定することで無関係なデコーディング空間を削減し、前向きな制約デコーディング戦略で証拠の精度を向上させます。広範な実験により、ドメイン内外のタスクで優れた性能を示しました。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/rohanpaul_ai/status/1872714703090401721?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q従来のRAGとの違いと、提案手法の概要

<br>

<img src="https://github.com/user-attachments/assets/cd237a17-52f8-429f-9553-d35a449982ff" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/3a355c20-ccd2-49a8-bed7-f84ea84af14c" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<span class="issue_date">Issue Date: 2024-12-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1616">A Survey on LLM-as-a-Judge, Jiawei Gu+, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMを評価者として利用する「LLM-as-a-Judge」の信頼性向上に関する調査。信頼性を確保するための戦略や評価方法論を提案し、新しいベンチマークを用いてサポート。実用的な応用や将来の方向性についても議論し、研究者や実務者の参考資料となることを目指す。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2024-12-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1598">VLR-Bench: Multilingual Benchmark Dataset for Vision-Language Retrieval  Augmented Generation, Hyeonseok Lim+, arXiv'24</a>
<span class="snippet"><span>Summary</span>視覚言語モデル（VLM）を評価するための新しいベンチマークVLR-Benchを提案。これは5つの入力パッセージを用いて、特定のクエリに対する有用な情報の判断能力をテストする。32,000の自動生成された指示からなるデータセットVLR-IFを構築し、VLMのRAG能力を強化。Llama3ベースのモデルで性能を検証し、両データセットはオンラインで公開。</span>
<span class="snippet"><span>Comment</span>Multilingual VLMを用いたRAGのベンチマークデータセット</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<span class="issue_date">Issue Date: 2024-12-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1597">Marco-o1: Towards Open Reasoning Models for Open-Ended Solutions, Yu Zhao+, arXiv'24</a>
<span class="snippet"><span>Summary</span>Marco-o1は、LRMの研究において、数学や物理学だけでなく、RLやオープンエンドの解決策にも重点を置いている。特に、o1モデルが基準が不明瞭な領域に一般化できるかを探求し、Chain-of-ThoughtファインチューニングやMCTS、反射メカニズムを活用して複雑な問題解決に最適化されている。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/bilzrd/status/1868568258468774048?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLarge Reasoning Model （LRM）という用語は初めて見た。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2024-12-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1594">When Benchmarks are Targets: Revealing the Sensitivity of Large Language   Model Leaderboards, Norah Alzahrani+, ACL'24</a>
<span class="snippet"><span>Summary</span>LLMのリーダーボードは、ベンチマークランキングに基づいてモデル選択を支援するが、ランキングは微細な変更に敏感であり、最大8位変動することがある。3つのベンチマーク摂動のカテゴリにわたる実験を通じて、この現象の原因を特定し、ハイブリッドスコアリング方法の利点を含むベストプラクティスを提案。単純な評価に依存する危険性を強調し、より堅牢な評価スキームの必要性を示した。</span>
<span class="snippet"><span>Comment</span>・1591

<br>



<br>

に日本語でのサマリが記載されているので参照のこと。

<br>



<br>

リーダーボードのバイアスを軽減した結果、どのLLMが最大パフォーマンスとみなされるようになったのだろうか？</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<span class="issue_date">Issue Date: 2024-12-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1593">BatchEval: Towards Human-like Text Evaluation, Peiwen Yuan+, ACL'24</a>
<span class="snippet"><span>Summary</span>BatchEvalという新しい評価パラダイムを提案し、LLMを用いた自動テキスト評価の問題を解決。バッチ単位での反復評価により、プロンプト設計の敏感さやノイズ耐性の低さを軽減。実験により、BatchEvalは最先端手法に対して10.5%の改善を示し、APIコストを64%削減。</span>
<span class="snippet"><span>Comment</span>・1591

<br>



<br>

に日本語によるサマリが掲載されているので参照のこと。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<span class="issue_date">Issue Date: 2024-12-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1592">Striking Gold in Advertising: Standardization and Exploration of Ad Text   Generation, Masato Mita+, ACL'24</a>
<span class="snippet"><span>Summary</span>自動広告テキスト生成（ATG）のために、標準化されたベンチマークデータセットCAMERAを提案。これにより、マルチモーダル情報の活用と業界全体での評価が促進される。9つのベースラインを用いた実験で、現状と課題を明らかにし、LLMベースの評価者と人間の評価の一致を探求。</span>
<span class="snippet"><span>Comment</span>広告文生成タスク（Ad Text Generation）は個々のグループのプロプライエタリデータでしか評価されてこなかったことと、そもそもタスク設定が十分に規定されていないので、その辺を整備したという話らしい。

<br>

特に広告文生成のための初のオープンデータなCAMERAを構築している。

<br>



<br>

データセットを作るだけでなく、既存の手法、古典的なものからLLMまででどの程度の性能まで到達しているか、さらにはROUGEやGPT-4を用いたLLM-as-a-Judgeのような自動評価手法をメタ評価し、人手評価とオンライン評価のどの程度代替になるかも分析したとのことらしい。Table5にメタ評価の結果が記載されている。システムレベルのcorrelationを測定している。興味深いのが、BLEU-4, ROUGE-1, BERTScoreなどの古典的or埋め込みベースのNLG評価手法がFaithfulnessとFluencyにおいて、人間の専門家と高い相関を示しているのに対し、GPT-4による評価では人間による評価と全然相関が出ていない。

<br>



<br>

既存のLLM-as-a-Judge研究では専門家と同等の評価できます、みたいな話がよく見受けられるがこれらの報告と結果が異なっていておもしろい。著者らは、OpenAIのGPTはそもそも広告ドメインとテキストでそんなに訓練されていなさそうなので、ドメインのミスマッチが一つの要因としてあるのではないか、と考察している。

<br>



<br>

また、Attractivenessでは専門家による評価と弱い相関しか示していない点も興味深い。広告文がどの程度魅力的かはBLEU, ROUGE, BERTScoreあたりではなかなか難しそうなので、GPT4による評価がうまくいって欲しいところだが、全くうまくいっていない。この論文の結果だけを見ると、（Attractivenessに関しては）自動評価だけではまだまだ広告文の評価は厳しそうに見える。

<br>



<br>

<img src="https://github.com/user-attachments/assets/15804ddc-3131-4a3d-9071-a66473e0e987" alt="image" loading="lazy">GPT4によるAttractivenessの評価に利用したプロンプトが下記。MTBenchっぽく、ペアワイズの分類問題として解いていることがわかる。この辺はLLM-as-a-Judgeの研究では他にもスコアトークンを出力し尤度で重みづけるG-Evalをはじめ、さまざまな手法が提案されていると思うので、その辺の手法を利用したらどうなるかは興味がある。

<br>

あとはそもそも手法面の話以前に、promptのコンテキスト情報としてどのような情報がAttractivenessの評価に重要か？というのも明らかになると興味深い。この辺は、サイバーエージェントの専門家部隊が、どのようなことを思考してAttractivenessを評価しているのか？というのがヒントになりそうである。

<br>

<img src="https://github.com/user-attachments/assets/5c0d3989-d4c1-4d61-b592-b1140c4cf93d" alt="image" loading="lazy">

<br>

・1591

<br>



<br>

に著者によるサマリが記載されているので参照のこと。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<span class="issue_date">Issue Date: 2024-12-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1590">The broader spectrum of in-context learning, Andrew Kyle Lampinen+, arXiv'24</a>
<span class="snippet"><span>Summary</span>本研究では、言語モデルの少数ショット学習をメタ学習に基づく文脈内学習の一部として位置づけ、文脈が予測の損失を減少させるメカニズムを提案します。この視点は、言語モデルの文脈内能力を統一し、一般化の重要性を強調します。一般化は新しい学習だけでなく、異なる提示からの学びや適用能力にも関連し、過去の文献との関連性も議論されます。文脈内学習の研究は、広範な能力と一般化のタイプを考慮すべきと結論付けています。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=RHo3VVi0i5

<br>



<br>

OpenReviewによると、

<br>

論文は理解しやすく、meta learningについて広範にサーベイされている。しかし、論文が定義しているICLの拡張はICLを過度に一般化し過ぎており（具体的に何がICLで何がICLでないのか、といった規定ができない）、かつ論文中で提案されているコンセプトを裏付ける実験がなくspeculativeである、とのことでrejectされている。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-12-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1589">Phi-4 Technical Report, Marah Abdin+, arXiv'24</a>
<span class="snippet"><span>Summary</span>140億パラメータの言語モデル「phi-4」は、合成データを取り入れたトレーニングにより、STEMに特化したQA能力で教師モデルを大幅に上回る性能を示す。phi-3のアーキテクチャを最小限に変更しただけで、推論ベンチマークにおいても改善されたデータとトレーニング手法により強力なパフォーマンスを達成。</span>
<span class="snippet"><span>Comment</span>現状Azureでのみ利用可能かも。Huggingfaceにアップロードされても非商用ライセンスになるという噂もMITライセンス

<br>

HuggingFace:

<br>

https://huggingface.co/microsoft/phi-4</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/LatentReasoning.html">#LatentReasoning</a>
<span class="issue_date">Issue Date: 2024-12-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1586">Training Large Language Models to Reason in a Continuous Latent Space, Shibo Hao+, arXiv'24</a>
<span class="snippet"><span>Summary</span>新しい推論パラダイム「Coconut」を提案し、LLMの隠れ状態を連続的思考として利用。これにより、次の入力を連続空間でフィードバックし、複数の推論タスクでLLMを強化。Coconutは幅優先探索を可能にし、特定の論理推論タスクでCoTを上回る性能を示す。潜在的推論の可能性を探る重要な洞察を提供。</span>
<span class="snippet"><span>Comment</span>Chain of Continuous Thought...?通常のCoTはRationaleをトークン列で生成するが、Coconutは最終的なhidden state（まだ読んでないのでこれが具体的に何を指すか不明）をそのまま入力に追加することで、トークンに制限されずにCoTさせるということらしい。あとでしっかり読む

<br>

<img src="https://github.com/user-attachments/assets/b930f44b-96f4-47cd-aa1a-0b5fabde54a5" alt="image" loading="lazy">まだ読んでいないが、おそらく学習の際に工夫が必要なので既存モデルをこねくり回してできます系の話ではないかもOpenReview:https://openreview.net/forum?id=tG4SgayTtk

<br>



<br>

ICLR'25にrejectされている。

<br>

ざっと最初のレビューに書かれているWeaknessを読んだ感じ

<br>

・評価データが合成データしかなく、よりrealisticなデータで評価した方が良い

<br>

・CoTら非常に一般的に適用可能な技術なので、もっと広範なデータで評価すべき

<br>

・GSM8Kでは大幅にCOCONUTはCoTに性能が負けていて、ProsQAでのみにしかCoTに勝てていない

<br>

・特定のデータセットでの追加の学習が必要で、そこで身につけたreasoning能力が汎化可能か明らかでない

<br>



<br>

といった感じに見える</span>
<a class="button" href="articles/Multi.html">#Multi</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2024-12-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1578">Auto-RAG: Autonomous Retrieval-Augmented Generation for Large Language  Models, Tian Yu+, arXiv'24</a>
<span class="snippet"><span>Summary</span>Auto-RAGは、LLMの意思決定能力を活用した自律的な反復検索モデルで、リトリーバーとのマルチターン対話を通じて知識を取得します。推論に基づく意思決定を自律的に合成し、6つのベンチマークで優れた性能を示し、反復回数を質問の難易度に応じて調整可能です。また、プロセスを自然言語で表現し、解釈可能性とユーザー体験を向上させます。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/omarsar0/status/1863600141103501454?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QOpenReview:https://openreview.net/forum?id=jkVQ31GeIAOpenReview:https://openreview.net/forum?id=jkVQ31GeIA</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<span class="issue_date">Issue Date: 2024-12-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1575">LLMs Will Always Hallucinate, and We Need to Live With This, Sourav Banerjee+, arXiv'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLM）の幻覚は偶発的なエラーではなく、これらのモデルの基本的な構造から生じる避けられない特徴であると主張。アーキテクチャやデータセットの改善では幻覚を排除できないことを示し、各プロセス段階で幻覚が生成される確率が存在することを分析。新たに「構造的幻覚」という概念を導入し、幻覚の数学的確実性を確立することで、完全な軽減は不可能であると論じる。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Quantization.html">#Quantization</a>
<span class="issue_date">Issue Date: 2024-12-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1566">The Super Weight in Large Language Models, Mengxia Yu+, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMのパラメータの一部がモデルの品質に不均衡に重要であり、1つのパラメータの剪定でテキスト生成能力が大幅に低下することを発見。データフリーの方法で重要なスーパーパラメータを特定し、これにより四捨五入量子化の精度を向上させることができる。スーパーパラメータに関する研究を促進するために、オープンアクセスのLLMに対するインデックスを提供。</span>
<span class="snippet"><span>Comment</span>図にある通り、たった一つのニューラルネットワーク中の重みを0にするだけで、途端に意味のあるテキストが生成できなくなるような重みが存在するらしい。

<br>

<img src="https://github.com/user-attachments/assets/065e921b-c447-4c0d-b1de-a2f79bd090f8" alt="image" loading="lazy">

<br>



<br>



<br>

（図は論文より引用）ICLR 2025のOpenreview

<br>

https://openreview.net/forum?id=0Ag8FQ5Rr3</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2024-12-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1561">Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge  Conflicts for Large Language Models, Fei Wang+, arXiv'24</a>
<span class="snippet"><span>Summary</span>Astute RAGは、外部知識の不完全な取得による問題を解決する新しいアプローチで、LLMsの内部知識と外部知識を適応的に統合し、情報の信頼性に基づいて回答を決定します。実験により、Astute RAGは従来のRAG手法を大幅に上回り、最悪のシナリオでもLLMsのパフォーマンスを超えることが示されました。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<span class="issue_date">Issue Date: 2024-11-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1550">From Generation to Judgment: Opportunities and Challenges of  LLM-as-a-judge, Dawei Li+, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMを用いた判断と評価の新たなパラダイム「LLM-as-a-judge」に関する包括的な調査を行い、定義や分類法を提示。評価のためのベンチマークをまとめ、主要な課題と今後の研究方向を示す。関連リソースも提供。</span>
<span class="snippet"><span>Comment</span>LLM-as-a-Judgeに関するサーベイ

<br>

<img src="https://github.com/user-attachments/assets/88059cc4-123e-4a89-ac2d-4b3db83cd2df" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/10fea773-e52b-4e67-9137-dfc51846988b" alt="image" loading="lazy">・1214

<br>



<br>

も参照のこと</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2024-11-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1549">Does Prompt Formatting Have Any Impact on LLM Performance?, Jia He+, arXiv'24</a>
<span class="snippet"><span>Summary</span>プロンプト最適化はLLMの性能に重要であり、異なるプロンプトテンプレートがモデルの性能に与える影響を調査。実験では、GPT-3.5-turboがプロンプトテンプレートによってコード翻訳タスクで最大40%変動する一方、GPT-4はより堅牢であることが示された。これにより、固定プロンプトテンプレートの再考が必要であることが強調された。</span>
<span class="snippet"><span>Comment</span>（以下、個人の感想です）

<br>

本文のみ斜め読みして、Appendixは眺めただけなので的外れなことを言っていたらすみません。

<br>



<br>

まず、実務上下記知見は有用だと思いました:

<br>

・プロンプトのフォーマットによって性能に大きな差がある

<br>

・より大きいモデルの方がプロンプトフォーマットに対してロバスト

<br>



<br>

ただし、フォーマットによって性能差があるというのは経験的にある程度LLMを触っている人なら分かることだと思うので、驚きは少なかった。

<br>



<br>

個人的に気になる点は、学習データもモデルのアーキテクチャもパラメータ数も分からないGPT3.5, GPT4のみで実験をして「パラメータサイズが大きい方がロバスト」と結論づけている点と、もう少し深掘りして考察したらもっとおもしろいのにな、と感じる点です。

<br>



<br>

実務上は有益な知見だとして、では研究として見たときに「なぜそうなるのか?」というところを追求して欲しいなぁ、という感想を持ちました。

<br>

たとえば、「パラメータサイズが大きいモデルの方がフォーマットにロバスト」と論文中に書かれているように見えますが、

<br>

それは本当にパラメータサイズによるものなのか？学習データに含まれる各フォーマットの割合とか（これは事実はOpenAIの中の人しか分からないので、学習データの情報がある程度オープンになっているOpenLLMでも検証するとか）、評価するタスクとフォーマットの相性とか、色々と考察できる要素があるのではないかと思いました。

<br>

その上で、大部分のLLMで普遍的な知見を見出した方が研究としてより面白くなるのではないか、と感じました。

<br>



<br>

<img src="https://github.com/user-attachments/assets/d0a6c727-1253-4503-93f2-8daa4db2321b" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/b7166b2b-b848-43f5-a823-7ed491232234" alt="image" loading="lazy">参考: Data2Textにおける数値データのinput formatによる性能差を分析し考察している研究

<br>

・1267</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<span class="issue_date">Issue Date: 2024-11-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1542">Multimodal Autoregressive Pre-training of Large Vision Encoders, Enrico Fini+, arXiv'24</a>
<span class="snippet"><span>Summary</span>新しい手法AIMV2を用いて、大規模なビジョンエンコーダの事前学習を行う。これは画像とテキストを組み合わせたマルチモーダル設定に拡張され、シンプルな事前学習プロセスと優れた性能を特徴とする。AIMV2-3BエンコーダはImageNet-1kで89.5%の精度を達成し、マルチモーダル画像理解において最先端のコントラストモデルを上回る。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2024-11-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1540">Observational Scaling Laws and the Predictability of Language Model  Performance, Yangjun Ruan+, arXiv'24</a>
<span class="snippet"><span>Summary</span>言語モデルの性能を理解するために、約100の公開モデルからスケーリング法則を構築する新しい観察アプローチを提案。モデルファミリー間の能力変動を考慮し、性能が低次元の能力空間の関数であることを示す。これにより、複雑なスケーリング現象の予測可能性を示し、GPT-4のエージェント性能を非エージェント的ベンチマークから予測できることを明らかにし、Chain-of-ThoughtやSelf-Consistencyの影響を予測する方法を示す。</span>
<span class="snippet"><span>Comment</span>縦軸がdownstreamタスクの主成分（のうち最も大きい80%を説明する成分）の変化（≒LLMの性能）で、横軸がlog scaleの投入計算量。

<br>

Qwenも頑張っているが、投入データ量に対する性能（≒データの品質）では、先駆け的な研究であるPhiがやはり圧倒的?

<br>

<img src="https://github.com/user-attachments/assets/c38286df-37c1-4c72-832f-676832845c0e" alt="image" loading="lazy">・766

<br>



<br>

も参照のこと</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<span class="issue_date">Issue Date: 2024-11-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1539">On the Way to LLM Personalization: Learning to Remember User  Conversations, Lucie Charlotte Magister+, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMのパーソナライズを過去の会話の知識を注入することで実現するため、PLUMというデータ拡張パイプラインを提案。会話の時間的連続性とパラメータ効率を考慮し、ファインチューニングを行う。初めての試みでありながら、RAGなどのベースラインと競争力を持ち、81.5%の精度を達成。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2024-11-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1530">Likelihood as a Performance Gauge for Retrieval-Augmented Generation, Tianyu Liu+, arXiv'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデルを用いた情報検索強化生成は、文脈内の文書の順序に影響を受けやすい。研究では、質問の確率がモデルのパフォーマンスに与える影響を分析し、正確性との相関関係を明らかにした。質問の確率を指標として、プロンプトの選択と構築に関する2つの方法を提案し、その効果を実証。確率に基づく手法は効率的で、少ないモデルのパスで応答を生成できるため、プロンプト最適化の新たな方向性を示す。</span>
<span class="snippet"><span>Comment</span>トークンレベルの平均値をとった生成テキストの対数尤度と、RAGの回答性能に関する分析をした模様。

<br>

<img src="https://github.com/user-attachments/assets/ac03c0b6-b16c-4992-8446-2f56bad09ab2" alt="image" loading="lazy">

<br>



<br>

とりあえず、もし「LLMとしてGPTを（OpenAIのAPIを用いて）使いました！temperatureは0です！」みたいな実験設定だったら諸々怪しくなる気がしたのでそこが大丈夫なことを確認した（OpenLLM、かつdeterministicなデコーディング方法が望ましい）。おもしろそう。

<br>



<br>

<img src="https://github.com/user-attachments/assets/9ba2bdc7-f6e5-4b9c-aca4-3d461c78a046" alt="image" loading="lazy">参考: [RAGのハルシネーションを尤度で防ぐ, sasakuna, 2024.11.19](https://zenn.dev/knowledgesense/articles/7c47e1796e96c0)参考

<br>



<br>

生成されたテキストの尤度を用いて、どの程度正解らしいかを判断する、といった話は

<br>

・1223

<br>



<br>

のようなLLM-as-a-Judgeでも行われている。

<br>



<br>

G-Evalでは1--5のスコアのような離散的な値を生成する際に、これらを連続的なスコアに補正するために、尤度（トークンの生成確率）を用いている。

<br>

ただし、G-Evalの場合は実験でGPTを用いているため、モデルから直接尤度を取得できず、代わりにtemperature1とし、20回程度生成を行った結果からスコアトークンの生成確率を擬似的に計算している。

<br>



<br>

G-Evalの設定と比較すると（当時はつよつよなOpenLLMがなかったため苦肉の策だったと思われるが）、こちらの研究の実験設定の方が望ましいと思う。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<span class="issue_date">Issue Date: 2024-11-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1529">Multilingual Large Language Models: A Systematic Survey, Shaolin Zhu+, arXiv'24</a>
<span class="snippet"><span>Summary</span>本論文は、多言語大規模言語モデル（MLLMs）の最新研究を調査し、アーキテクチャや事前学習の目的、多言語能力の要素を論じる。データの質と多様性が性能向上に重要であることを強調し、MLLMの評価方法やクロスリンガル知識、安全性、解釈可能性について詳細な分類法を提示。さらに、MLLMの実世界での応用を多様な分野でレビューし、課題と機会を強調する。関連論文は指定のリンクで公開されている。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/user-attachments/assets/0b86445f-b974-459c-94f0-a80f5e2bbc9a" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/0d03af89-23b0-4b4b-972a-bbe4320d4f0c" alt="image" loading="lazy"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2024-11-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1524">Balancing Speed and Stability: The Trade-offs of FP8 vs. BF16 Training  in LLMs, Kazuki Fujii+, arXiv'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）は、その言語理解能力と適用可能性から注目を集めており、特にLlama 3シリーズは4050億パラメータを持つ。トレーニングの効率化が求められる中、NVIDIAのH100 GPUはFP8フォーマットを導入し、トレーニング時間を短縮する可能性がある。初期研究ではFP8が性能を損なわずに効率を向上させることが示唆されているが、トレーニングの安定性や下流タスクへの影響はまだ不明である。本研究は、LLMsのトレーニングにおけるBF16とFP8のトレードオフを探る。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/okoge_kaz/status/1857639065421754525?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QFP8で継続的事前学習をするとスループットは向上するが、lossのスパイクを生じたり、downstreamタスクの性能がBF16よりも低下したりする（日本語と英語の両方）との報告のようである。現状アブストと付録しか記載がないが、内容はこれから更新されるのだろうか。

<br>



<br>

<img src="https://github.com/user-attachments/assets/8d60d59b-de00-483a-bff0-04a4145715c1" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<span class="issue_date">Issue Date: 2024-11-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1523">Understanding LLMs: A Comprehensive Overview from Training to Inference, Yiheng Liu+, arXiv'24</a>
<span class="snippet"><span>Summary</span>ChatGPTの普及に伴い、LLMsのコスト効率の良いトレーニングとデプロイメントへの関心が高まっている。本論文では、LLMsのトレーニング技術と推論デプロイメント技術の進化をレビューし、データ前処理やモデル圧縮などのさまざまな側面を議論する。また、LLMsの利用方法と将来の発展についての洞察も提供する。</span>
<span class="snippet"><span>Comment</span>[Perplexity（参考;Hallucinationに注意）](https://www.perplexity.ai/search/yi-xia-nolun-wen-wodu-minei-ro-7vGwDK_AQX.HDO7j9H8iNA)単なるLLMの理論的な説明にとどまらず、実用的に必要な各種並列処理技術、Mixed Precision、Offloadingなどのテクニックもまとまっているのがとても良いと思う。LLM Frameworkのところに、メジャーなものが網羅されていないように感じる。たとえば、UnslothやLiger-KernelなどはTransformersの部分で言及されてても良いのでは、と感じる。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2024-11-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1522">The Geometry of Concepts: Sparse Autoencoder Feature Structure, Yuxiao Li+, arXiv'24</a>
<span class="snippet"><span>Summary</span>スパースオートエンコーダは、高次元ベクトルの辞書を生成し、概念の宇宙に三つの興味深い構造を発見した。1) 小規模構造では、平行四辺形や台形の「結晶」があり、単語の長さなどの干渉を除去することで質が改善される。2) 中規模構造では、数学とコードの特徴が「葉」を形成し、空間的局所性が定量化され、特徴が予想以上に集まることが示された。3) 大規模構造では、特徴点雲が各向同性でなく、固有値のべき法則を持ち、クラスタリングエントロピーが層に依存することが定量化された。</span>
<span class="snippet"><span>Comment</span>参考: https://ledge.ai/articles/llm_conceptual_structure_sae[Perplexity（参考;Hallucinationに注意）](https://www.perplexity.ai/search/yi-xia-nolun-wen-wodu-minei-ro-kR626A9_R8.6CU7IKvGyhQ)</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/RelevanceJudgment.html">#RelevanceJudgment</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2024-11-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1517">A Large-Scale Study of Relevance Assessments with Large Language Models:  An Initial Look, Shivani Upadhyay+, arXiv'24</a>
<span class="snippet"><span>Summary</span>本研究では、TREC 2024 RAG Trackにおける大規模言語モデル（LLM）を用いた関連性評価の結果を報告。UMBRELAツールを活用した自動生成評価と従来の手動評価の相関を分析し、77の実行セットにおいて高い相関を示した。LLMの支援は手動評価との相関を高めず、人間評価者の方が厳格であることが示唆された。この研究は、TRECスタイルの評価におけるLLMの使用を検証し、今後の研究の基盤を提供する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/lintool/status/1856876816197165188?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q[Perplexity（参考;Hallucinationに注意）](https://www.perplexity.ai/search/yi-xia-nolun-wen-wodu-ntenei-r-h3qlECirT3G9O2BGk765_g)

<br>



<br>

Perplexityの生成結果では、27個のシステムと記述されているが、これは実際はトピックで、各トピックごとに300件程度の0--3のRelevance Scoreが、人手評価、UMBRELA共に付与されている模様（Table1）。

<br>



<br>

<img src="https://github.com/user-attachments/assets/73bda88a-0f94-4562-8d04-dc0d93fc9287" alt="image" loading="lazy">

<br>



<br>

評価結果

<br>



<br>

・Fully Manual Assessment: 既存のNIST methodologyと同様に人手でRelevance Scoreを付与する方法

<br>

・Manual Aspessment with Filtering: LLMのnon-Relevantと判断したpassageを人手評価から除外する方法

<br>

・Manual Post-Editing of Automatic Assessment: LLMがnon-Relevantと判断したpassageを人手評価から除外するだけでなく、LLMが付与したスコアを評価者にも見せ、評価者が当該ラベルを修正するようなスコアリングプロセス

<br>

・Fully Automatic Assessment:UMBRELAによるRelevance Scoreをそのまま利用する方法

<br>



<br>

LLMはGPT4-oを用いている。

<br>



<br>

<img src="https://github.com/user-attachments/assets/ffc63d2c-d677-46b7-9909-95423ccf476d" alt="image" loading="lazy">

<br>



<br>

19チームの77個のRunがどのように実行されているか、それがTable1の統計量とどう関係しているかがまだちょっとよくわかっていない。UMBRELAでRelevance Scoreを生成する際に利用されたプロンプト。

<br>

<img src="https://github.com/user-attachments/assets/4350430b-fa37-4854-8cb4-114b2f0abf84" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2024-11-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1516">Language Models are Hidden Reasoners: Unlocking Latent Reasoning  Capabilities via Self-Rewarding, Haolin Chen+, arXiv'24</a>
<span class="snippet"><span>Summary</span>LaTRO（LaTent Reasoning Optimization）を提案し、LLMの推論能力を向上させる新しいフレームワークを構築。推論を潜在分布からのサンプリングとして定式化し、外部フィードバックなしで推論プロセスと質を同時に改善。GSM8KおよびARC-Challengeデータセットで実験し、平均12.5%の精度向上を達成。事前学習されたLLMの潜在的な推論能力を引き出すことが可能であることを示唆。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/haolinchen11/status/1856150958772040165?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QOpenReview:https://openreview.net/forum?id=4Po8d9GAfQ&referrer=%5Bthe%20profile%20of%20Ricky%20Ho%5D(%2Fprofile%3Fid%3D~Ricky_Ho2)</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<span class="issue_date">Issue Date: 2024-11-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1509">A Theoretical Understanding of Chain-of-Thought: Coherent Reasoning and  Error-Aware Demonstration, Yingqian Cui+, arXiv'24</a>
<span class="snippet"><span>Summary</span>Few-shot Chain-of-Thought (CoT) プロンプティングはLLMsの推論能力を向上させるが、従来の研究は推論プロセスを分離された文脈内学習に依存している。本研究では、初期ステップからの一貫した推論（Coherent CoT）を統合することで、トランスフォーマーのエラー修正能力と予測精度を向上させることを理論的に示す。実験により、正しい推論経路と誤った推論経路を組み込むことでCoTを改善する提案の有効性を検証する。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_philschmid/status/1855926845855699311?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

おもしろそうな研究</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Subword.html">#Subword</a>
<a class="button" href="articles/Tokenizer.html">#Tokenizer</a>
<span class="issue_date">Issue Date: 2024-11-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1507">LBPE: Long-token-first Tokenization to Improve Large Language Models, Haoran Lian+, arXiv'24</a>
<span class="snippet"><span>Summary</span>LBPEは、長いトークンを優先する新しいエンコーディング手法で、トークン化データセットにおける学習の不均衡を軽減します。実験により、LBPEは従来のBPEを一貫して上回る性能を示しました。</span>
<span class="snippet"><span>Comment</span>BPEとは異なりトークンの長さを優先してマージを実施することで、最終的なトークンを決定する手法で、

<br>

<img src="https://github.com/user-attachments/assets/99b91472-88d8-4792-bf04-acc67956e4f5" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/99103316-bd1c-448d-b52a-5db815298e7e" alt="image" loading="lazy">

<br>



<br>

BPEよりも高い性能を獲得し、

<br>

<img src="https://github.com/user-attachments/assets/c7dccf00-b9c2-4739-82f3-4f8eeacd4fc7" alt="image" loading="lazy">

<br>



<br>

トークンの長さがBPEと比較して長くなり、かつ5Bトークン程度を既存のBPEで事前学習されたモデルに対して継続的事前学習するだけで性能を上回るようにでき、

<br>

<img src="https://github.com/user-attachments/assets/10f4ff2e-1d49-4c8a-87ec-67466bdce2f0" alt="image" loading="lazy">

<br>



<br>

同じVocabサイズでBPEよりも高い性能を獲得できる手法

<br>

<img src="https://github.com/user-attachments/assets/5e19fc11-10f6-467a-ae06-8fb62b5f0a65" alt="image" loading="lazy">

<br>



<br>

らしい</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/ScientificDiscovery.html">#ScientificDiscovery</a>
<a class="button" href="articles/Investigation.html">#Investigation</a>
<span class="issue_date">Issue Date: 2024-11-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1506">LLMs as Research Tools: A Large Scale Survey of Researchers' Usage and  Perceptions, Zhehui Liao+, arXiv'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）の利用に関する816人の研究者を対象とした調査を実施。81%が研究ワークフローにLLMsを組み込んでおり、特に非白人や若手研究者が高い使用率を示す一方で、女性やシニア研究者は倫理的懸念を抱いていることが明らかに。研究の公平性向上の可能性が示唆される。</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<span class="issue_date">Issue Date: 2024-11-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1504">DELIFT: Data Efficient Language model Instruction Fine Tuning, Ishika Agarwal+, arXiv'24</a>
<span class="snippet"><span>Summary</span>DELIFTという新しいアルゴリズムを提案し、ファインチューニングの各ステージでデータ選択を最適化。ペアワイズユーティリティメトリックを用いてデータの有益性を定量化し、最大70%のデータ削減を実現。計算コストを大幅に節約し、既存の方法を上回る効率性と効果を示す。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2024-11-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1503">GUI Agents with Foundation Models: A Comprehensive Survey, Shuai Wang+, arXiv'24</a>
<span class="snippet"><span>Summary</span>(M)LLMを活用したGUIエージェントの研究を統合し、データセット、フレームワーク、アプリケーションの革新を強調。重要なコンポーネントをまとめた統一フレームワークを提案し、商業アプリケーションを探求。課題を特定し、今後の研究方向を示唆。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/user-attachments/assets/999adca8-f0d7-483c-ae5a-b6f78fe9da4b" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/b69dc991-3e15-4965-a183-cc7909ad9eba" alt="image" loading="lazy">Referenceやページ数はサーベイにしては少なめに見える。</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<span class="issue_date">Issue Date: 2024-11-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1501">Scaling LLM Test-Time Compute Optimally can be More Effective than  Scaling Model Parameters, Charlie Snell+, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMの推論時の計算をスケーリングすることで、挑戦的なプロンプトに対するパフォーマンスを改善する方法を研究。特に、密なプロセスベースの検証者報酬モデルとプロンプトに応じた応答の適応的更新を分析。プロンプトの難易度によって効果が変化し、計算最適戦略を適用することで効率を4倍以上向上。さらに、テスト時計算を用いることで小さなモデルが大きなモデルを上回ることが示された。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/user-attachments/assets/0562a65e-b2f1-4ff4-b806-107313fc255e" alt="image" loading="lazy">[Perplexity（参考;Hallucinationに注意）](https://www.perplexity.ai/search/yi-xia-noyan-jiu-wodu-mi-nei-r-1e1euXgLTH.G0Wlp.V2iqA)</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2024-11-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1497">HyQE: Ranking Contexts with Hypothetical Query Embeddings, Weichao Zhou+, arXiv'24</a>
<span class="snippet"><span>Summary</span>リトリーバル拡張システムにおいて、LLMのファインチューニングを必要とせず、埋め込みの類似性とLLMの能力を組み合わせたスケーラブルなランキングフレームワークを提案。ユーザーのクエリに基づいて仮定されたクエリとの類似性でコンテキストを再順位付けし、推論時に効率的で他の技術とも互換性がある。実験により、提案手法がランキング性能を向上させることを示した。</span>
<span class="snippet"><span>Comment</span>・1498 も参照のこと。

<br>



<br>



<br>



<br>

下記に試しにHyQEとHyDEの比較の記事を作成したのでご参考までに（記事の内容に私は手を加えていないのでHallucinationに注意）。ざっくりいうとHyDEはpseudo documentsを使うが、HyQEはpseudo queryを扱う。

<br>



<br>



<br>



<br>

[参考: Perplexity Pagesで作成したHyDEとの簡単な比較の要約](https://www.perplexity.ai/page/hyqelun-wen-nofen-xi-toyao-yue-aqZZj8mDQg6NL1iKml7.eQ)<img src="https://github.com/user-attachments/assets/f757781c-036c-440d-b1b8-c5f255039479" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<span class="issue_date">Issue Date: 2024-11-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1496">Personalization of Large Language Models: A Survey, Zhehao Zhang+, arXiv'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）のパーソナライズに関する研究のギャップを埋めるため、パーソナライズされたLLMsの分類法を提案。パーソナライズの概念を統合し、新たな側面や要件を定義。粒度、技術、データセット、評価方法に基づく体系的な分類を行い、文献を統一。未解決の課題を強調し、研究者と実務者への明確なガイドを提供することを目指す。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/NumericReasoning.html">#NumericReasoning</a>
<span class="issue_date">Issue Date: 2024-11-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1495">Number Cookbook: Number Understanding of Language Models and How to  Improve It, Haotong Yang+, arXiv'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）の数値理解および処理能力（NUPA）を調査し、41の数値タスクを含むベンチマークを導入。多くのタスクでLLMsが失敗することを確認し、NUPA向上のための技術を用いて小規模モデルを訓練。ファインチューニングによりNUPAが改善されるが、すべてのタスクには効果がないことが判明。思考の連鎖技術の影響も探求。研究はLLMsのNUPA改善に向けた初歩的なステップを示す。</span>
<span class="snippet"><span>Comment</span>んー、abstしか読んでいないけれども、9.11 &gt; 9.9 については、このような数字に慣れ親しんでいるエンジニアなどに咄嗟に質問したら、ミスして答えちゃう人もいるのでは？という気がする（エンジニアは脳内で9.11 &gt; 9.9を示すバージョン管理に触れる機会が多く、こちらの尤度が高い）。

<br>



<br>

LLMがこのようなミス（てかそもそもミスではなく、回答するためのcontextが足りてないので正解が定義できないだけ、だと思うが、、）をするのは、単に学習データにそういった9.11 &gt; 9.9として扱うような文脈や構造のテキストが多く存在しており、これらテキスト列の尤度が高くなってこのような現象が起きているだけなのでは、という気がしている。

<br>



<br>

instructionで注意を促したり適切に問題を定義しなければ、そりゃこういう結果になって当然じゃない?という気がしている。

<br>



<br>

（ここまで「気がしている」を3連発してしまった…😅）

<br>



<br>

また、本研究で扱っているタスクのexampleは下記のようなものだが、これらをLLMに、なんのツールも利用させずautoregressiveな生成のみで解かせるというのは、人間でいうところの暗算に相当するのでは？と個人的には思う。

<br>

何が言いたいのかというと、人間でも暗算でこれをやらせたら解けない人がかなりいると思う（というか私自身単純な加算でも桁数増えたら暗算など無理）。

<br>

一方で暗算ではできないけど、電卓やメモ書き、計算機を使っていいですよ、ということにしたら多くの人がこれらタスクは解けるようになると思うので、LLMでも同様のことが起きると思う。

<br>



<br>

LLMの数値演算能力は人間の暗算のように限界があることを認知し、金融分野などの正確な演算や数値の取り扱うようなタスクをさせたかったら、適切なツールを使わせましょうね、という話なのかなあと思う。

<br>



<br>

<img src="https://github.com/user-attachments/assets/0aa690d2-3835-4d32-b5d4-596b83a69674" alt="image" loading="lazy">元ポスト: https://x.com/omarsar0/status/1854528742095458337?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QICLR25のOpenReview。こちらを読むと興味深い。

<br>

https://openreview.net/forum?id=BWS5gVjgeY

<br>



<br>

幅広い数値演算のタスクを評価できるデータセット構築、トークナイザーとの関連性を明らかにした点、分析だけではなくLLMの数値演算能力を改善した点は評価されているように見える。

<br>



<br>

一方で、全体的に、先行研究との比較やdiscussionが不足しており、研究で得られた知見がどの程度新規性があるのか?といった点や、説明が不十分でjustificationが足りない、といった話が目立つように見える。

<br>

特に、そもそもLoRAやCoTの元論文や、Numerical Reasoningにフォーカスした先行研究がほぼ引用されていないらしい点が見受けられるようである。さすがにその辺は引用して研究のcontributionをクリアにした方がいいよね、と思うなどした。&gt;I am unconvinced that numeracy in LLMs is a problem in need of a solution. First, surely there is a citable source for LLM inadequacy for numeracy. Second, even if they were terrible at numeracy, the onus is on the authors to convince the reader that this a problem worth caring about, for at least two obvious reasons: 1) all of these tasks are already trivially done by a calculator or a python program, and 2) commercially available LLMs can probably do alright at numerical tasks indirectly via code-generation and execution. As it stands, it reads as if the authors are insisting that this is a problem deserving of attention --・I'm sure it could be, but this argument can be better made.

<br>



<br>

上記レビュワーコメントと私も同じことを感じる。なぜLLMそのものに数値演算の能力がないことが問題なのか?という説明があった方が良いのではないかと思う。

<br>



<br>

これは私の中では、論文のイントロで言及されているようなシンプルなタスクではなく、

<br>

・inputするcontextに大量の数値を入力しなければならず、

<br>

・かつcontext中の数値を厳密に解釈しなければならず、

<br>

・かつ情報を解釈するために計算すべき数式がcontextで与えられた数値によって変化するようなタスク（たとえばテキスト生成で言及すべき内容がgivenな数値情報によって変わるようなもの。最大値に言及するのか、平均値を言及するのか、数値と紐づけられた特定のエンティティに言及しなければならないのか、など）

<br>



<br>

（e.g. 上記を満たすタスクはたとえば、金融関係のdata-to-textなど）では、LLMが数値を解釈できないと困ると思う。そういった説明が入った方が良いと思うなあ、感。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<span class="issue_date">Issue Date: 2024-11-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1492">LoRA vs Full Fine-tuning: An Illusion of Equivalence, Reece Shuttleworth+, arXiv'24</a>
<span class="snippet"><span>Summary</span>ファインチューニング手法の違いが事前学習済みモデルに与える影響を、重み行列のスペクトル特性を通じて分析。LoRAと完全なファインチューニングは異なる構造の重み行列を生成し、LoRAモデルは新たな高ランクの特異ベクトル（侵入次元）を持つことが判明。侵入次元は一般化能力を低下させるが、同等の性能を達成することがある。これにより、異なるファインチューニング手法がパラメータ空間の異なる部分にアクセスしていることが示唆される。</span>
<span class="snippet"><span>Comment</span>元ポスト: https://x.com/aratako_lm/status/1854838012909166973?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q1423 や 1475 、双方の知見も交えて、LoRAの挙動を考察する必要がある気がする。それぞれ異なるデータセットやモデルで、LoRAとFFTを比較している。時間がないが後でやりたい。

<br>



<br>

あと、昨今はそもそも実験設定における変数が多すぎて、とりうる実験設定が多すぎるため、個々の論文の知見を鵜呑みにして一般化するのはやめた方が良い気がしている。実験設定の違い

<br>

モデルのアーキテクチャ

<br>

・本研究: RoBERTa-base（transformer-encoder）

<br>

・1423: transformer-decoder

<br>

・1475: transformer-decoder（LLaMA）

<br>



<br>

パラメータサイズ

<br>

・本研究: 

<br>

・1423: 1B, 2B, 4B, 8B, 16B

<br>

・1475: 7B

<br>



<br>

時間がある時に続きをかきたい

<br>



<br>

Finetuningデータセットのタスク数

<br>



<br>

1タスクあたりのデータ量

<br>



<br>

trainableなパラメータ数</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SmallModel.html">#SmallModel</a>
<span class="issue_date">Issue Date: 2024-11-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1490">A Comprehensive Survey of Small Language Models in the Era of Large  Language Models: Techniques, Enhancements, Applications, Collaboration with  LLMs, and Trustworthiness, Fali Wang+, arXiv'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLM）は多様なタスクで能力を示すが、パラメータサイズや計算要求から制限を受け、プライバシーやリアルタイムアプリケーションに課題がある。これに対し、小型言語モデル（SLM）は低遅延、コスト効率、簡単なカスタマイズが可能で、特に専門的なドメインにおいて有用である。SLMの需要が高まる中、定義や応用に関する包括的な調査が不足しているため、SLMを専門的なタスクに適したモデルとして定義し、強化するためのフレームワークを提案する。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/user-attachments/assets/9faf2732-233d-468e-ac4c-98b18f2f2bcf" alt="image" loading="lazy"><img src="https://github.com/user-attachments/assets/889ebda5-7cf4-4f62-ae48-e3fdd8f91c15" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2024-11-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1484">Beyond Accuracy: Evaluating the Reasoning Behavior of Large Language  Models -- A Survey, Philipp Mondorf+, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMsの推論能力に関する研究をレビューし、タスク精度を超えた深い洞察を提供。モデルは表面的なパターンに依存し、洗練された推論能力が不足していることを示唆。人間との推論の違いを明確にするためのさらなる研究が必要であることを指摘。</span>
<span class="snippet"><span>Comment</span>論文紹介（sei_shinagawa）:https://www.docswell.com/s/sei_shinagawa/KL1QXL-beyond-accuracy-evaluating-the-behaivior-of-llm-survey<img src="https://github.com/user-attachments/assets/a0369ac2-8dbc-4a7a-baf5-df59850a3b55" alt="image" loading="lazy"></span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/OpenSource.html">#OpenSource</a>
<span class="issue_date">Issue Date: 2024-11-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1483">Hunyuan-Large: An Open-Source MoE Model with 52 Billion Activated  Parameters by Tencent, Xingwu Sun+, arXiv'24</a>
<span class="snippet"><span>Summary</span>Hunyuan-Largeは、3890億パラメータを持つオープンソースのTransformerベースの専門家混合モデルで、最大256Kトークンを処理可能。言語理解や生成、論理推論などのベンチマークでLLama3.1-70Bを上回り、LLama3.1-405Bと同等の性能を示す。主な特徴には大規模な合成データ、混合専門家ルーティング、キー・バリューキャッシュ圧縮、専門家特有の学習率戦略が含まれ、今後のモデル開発に向けた洞察も提供。コードとモデルは公開されている。</span>
<span class="snippet"><span>Comment</span>合計パラメータ数はLlama-3.1-405Bと同等の389Bだが、MoEによって52BのActive ParameterでSoTAを達成したTencentのOpenSource LLM。大量のSynthetia Dataを利用している。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2024-11-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1476">Looking Inward: Language Models Can Learn About Themselves by  Introspection, Felix J Binder+, N_A, arXiv'24, 2024.11</a>
<span class="snippet"><span>Summary</span>内省は、LLMsがトレーニングデータに依存せずに内部状態から知識を獲得する能力を指す。本研究では、LLMsを微調整し、仮想シナリオにおける自身の行動を予測させることで内省を検証。実験の結果、内省可能なモデル（M1）は、異なるモデル（M2）よりも自身の行動を正確に予測できることが示された。特に、M1は行動を意図的に変更した後でも予測精度を維持したが、複雑なタスクでは内省を引き出すことができなかった。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/user-attachments/assets/2b19bc9c-342d-42a9-b603-ff9cfc694570" alt="image" loading="lazy">LLMが単に訓練データを模倣しているにすぎない的な主張に対するカウンターに使えるかも</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2024-10-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1472">KTO: Model Alignment as Prospect Theoretic Optimization, Kawin Ethayarajh+, N_A, ICML'24</a>
<span class="snippet"><span>Summary</span>プロスペクト理論に基づき、LLMの人間フィードバック調整におけるバイアスの影響を示す。新たに提案する「人間認識損失」（HALOs）を用いたアプローチKTOは、生成物の効用を最大化し、好みベースの方法と同等またはそれ以上の性能を発揮。研究は、最適な損失関数が特定の設定に依存することを示唆。</span>
<span class="snippet"><span>Comment</span>binaryフィードバックデータからLLMのアライメントをとるKahneman-Tversky Optimization (KTO)論文</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2024-10-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1468">Generative Reward Models, Dakota Mahan+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>RLHFとRLAIFを統合したハイブリッドアプローチを提案し、合成好みラベルの質を向上させるGenRMアルゴリズムを導入。実験により、GenRMは分布内外のタスクでBradley-Terryモデルと同等またはそれを上回る性能を示し、LLMを判断者として使用する場合のパフォーマンスも向上。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=MwU2SGLKpS関連研究

<br>

・708

<br>

・1212</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2024-10-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1464">Self-Taught Evaluators, Tianlu Wang+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>本研究では、人間の注釈なしで評価者を改善するアプローチを提案。合成トレーニングデータを用い、自己改善スキームによりLLMを評価者としてトレーニング。これにより、RewardBenchでのLLMのパフォーマンスを75.4から88.3に向上させ、GPT-4を超える結果を達成。</span>
<span class="snippet"><span>Comment</span>LLMのアラインメント等をSFTする際に、preferenceのラベル付きデータが必要になるが、このようなデータを作るのはコストがかかって大変なので自動生成して、より良いreward modelを作りたいよね、という話。

<br>

具体的には、LLMを用いて good responseと、instructionを変化させてbad sesponseを生成し、JudgeモデルM_tにpairwiseでどちらが良いかをjudgeさせることで学習データを作成。新たに作成されたデータを用いてJudgeモデルを再学習し、同様のプロセスを繰り返すことで、人手の介在なく強力なJudgeモデルが完成する。

<br>

<img src="https://github.com/user-attachments/assets/837c4567-6993-4e4c-81c8-650b7777c49b" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/10a4fb62-160d-4bcf-b3a2-a960a7c9bc46" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2024-10-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1463">Retrieval Augmented Generation （RAG） and Beyond: A Comprehensive Survey  on How to Make your LLMs use External Data More Wisely, Siyun Zhao+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）は外部データを活用することで実世界のタスクを遂行する能力を示すが、データ強化型LLMsの効果的な展開には多くの課題がある。これには、関連データの取得やユーザーの意図の解釈、複雑なタスクに対する推論能力の活用が含まれる。本研究では、RAGタスクを四つのクエリレベルに分類し、関連データセットや課題、技術を要約する。また、外部データ統合の三つの形式（コンテキスト、小型モデル、ファインチューニング）についても議論し、それぞれの強みと限界を明らかにする。これにより、データ要件とLLMアプリケーション構築のボトルネックを理解し、体系的な開発のためのガイドを提供することを目指す。</span>
<span class="snippet"><span>Comment</span>RAGのクエリを4種類に分類した各クエリごとの技術をまとめたSurvey

<br>

<img src="https://github.com/user-attachments/assets/b551725d-5f82-4914-8b8f-716ddb6a342b" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<span class="issue_date">Issue Date: 2024-10-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1460">LLMs Know More Than They Show: On the Intrinsic Representation of LLM  Hallucinations, Hadas Orgad+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMsは「幻覚」と呼ばれるエラーを生成するが、内部状態が真実性に関する情報をエンコードしていることが示されている。本研究では、真実性情報が特定のトークンに集中していることを発見し、これを利用することでエラー検出性能が向上することを示す。しかし、エラーディテクターはデータセット間で一般化に失敗し、真実性のエンコーディングは普遍的ではないことが明らかになる。また、内部表現を用いてエラーの種類を予測し、特化した緩和戦略の開発を促進する。さらに、内部エンコーディングと外部の振る舞いとの不一致が存在し、正しい答えをエンコードしていても誤った答えを生成することがある。これにより、LLMのエラー理解が深まり、今後の研究に寄与する。</span>
<span class="snippet"><span>Comment</span>特定のトークンがLLMのtrustfulnessに集中していることを実験的に示し、かつ内部でエンコードされたrepresentationは正しい答えのものとなっているのに、生成結果に誤りが生じるような不整合が生じることも示したらしい</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<span class="issue_date">Issue Date: 2024-10-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1459">Addition is All You Need for Energy-efficient Language Models, Hongyin Luo+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>本研究では、浮動小数点乗算を高精度で整数加算器によって近似するL-Mulアルゴリズムを提案。これにより、8ビット浮動小数点乗算に比べて計算リソースを大幅に削減しつつ、より高い精度を実現。L-Mulをテンソル処理ハードウェアに適用することで、エネルギーコストを95％（要素ごとの乗算）および80％（ドット積）削減可能。実験結果は理論的誤差推定と一致し、L-Mulは従来の浮動小数点乗算と同等またはそれ以上の精度を達成。トランスフォーマーモデル内の浮動小数点乗算をL-Mulに置き換えることで、ファインチューニングと推論において高い精度を維持できることを示した。</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2024-10-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1458">ToolGen: Unified Tool Retrieval and Calling via Generation, Renxi Wang+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>ToolGenは、外部ツールとの直接対話を可能にする新しいフレームワークで、各ツールをユニークなトークンとして表現し、LLMのパラメータに統合します。これにより、LLMはツール呼び出しや引数を自然言語生成の一部としてシームレスに生成でき、情報取得ステップなしで多くのツールにアクセス可能になります。実験結果は、ToolGenが自律的なタスク完了と情報取得で優れた性能を示し、より効率的で自律的なAIシステムの基盤を築くことを示しています。</span>
<span class="snippet"><span>Comment</span>昔からよくある特殊トークンを埋め込んで、特殊トークンを生成したらそれに応じた処理をする系の研究。今回はツールに対応するトークンを仕込む模様。斜め読みだが、3つのstepでFoundation Modelを訓練する。まずはツールのdescriptionからツールトークンを生成する。これにより、モデルにツールの情報を覚えさせる（memorization）。斜め読みなので読めていないが、ツールトークンをvocabに追加してるのでここは継続的事前学習をしているかもしれない。続いて、（おそらく）人手でアノテーションされたクエリ-必要なツールのペアデータから、クエリに対して必要なツールを生成するタスクを学習させる。最後に、（おそらく人手で作成された）クエリ-タスクを解くためのtrajectoryペアのデータで学習させる。

<br>

<img src="https://github.com/user-attachments/assets/eebe4260-2e4f-4be7-9b59-a0b84913e667" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/d03ed971-e5c9-49f3-8385-cfb00505907c" alt="image" loading="lazy">学習データのサンプル。Appendix中に記載されているものだが、本文のデータセット節とAppendixの双方に、データの作り方の詳細は記述されていなかった。どこかに書いてあるのだろうか。

<br>

<img src="https://github.com/user-attachments/assets/41975d34-dc9d-405d-aaca-062a3ee1a4b0" alt="image" loading="lazy"><img src="https://github.com/user-attachments/assets/41e80988-5770-420e-bc80-a4cc0a724994" alt="image" loading="lazy">最終的な性能

<br>

<img src="https://github.com/user-attachments/assets/a247cc99-10eb-4346-9f0d-b406a022c3b4" alt="image" loading="lazy">特殊トークンを追加のvocabとして登録し、そのトークンを生成できるようなデータで学習し、vocabに応じて何らかの操作を実行するという枠組み、その学習手法は色々なタスクで役立ちそう。</span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/KnowledgeGraph.html">#KnowledgeGraph</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/Annotation.html">#Annotation</a>
<span class="issue_date">Issue Date: 2024-10-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1449">COSMO: A large-scale e-commerce common sense knowledge generation and serving system at Amazon , Yu+, SIGMOD_PODS '24</a>
<span class="snippet"><span>Summary</span>COSMOは、eコマースプラットフォーム向けにユーザー中心の常識知識をマイニングするためのスケーラブルな知識グラフシステムです。大規模言語モデルから抽出した高品質な知識を用い、指示チューニングによってファインチューニングされたCOSMO-LMは、Amazonの主要カテゴリにわたって数百万の知識を生成します。実験により、COSMOが検索ナビゲーションなどで顕著な改善を達成することが示され、常識知識の活用の可能性が強調されています。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/user-attachments/assets/56fec49b-0917-444f-825b-3f050b7357cb" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/978a1b9c-bd59-4838-be8d-bc72e5dc1032" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/b1d88bd7-2507-4086-89bf-5330831b00ce" alt="image" loading="lazy">search navigationに導入しA/Bテストした結果、0.7%のproduct sales向上効果。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<span class="issue_date">Issue Date: 2024-09-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1434">What matters when building vision-language models?, Hugo Laurençon+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>視覚と言語のモデル（VLM）の設計における裏付けのない決定が性能向上の特定を妨げていると指摘。事前学習済みモデルやアーキテクチャ、データ、トレーニング手法に関する実験を行い、80億パラメータの基盤VLM「Idefics2」を開発。Idefics2はマルチモーダルベンチマークで最先端の性能を達成し、4倍のサイズのモデルと同等の性能を示す。モデルとデータセットを公開。</span>
<span class="snippet"><span>Comment</span>元ポストにOpenVLMの進展の歴史が載っている。構築されたデータセットも公開される模様。

<br>

<img src="https://github.com/user-attachments/assets/9675c2ad-650a-460b-9655-1c6347d07f58" alt="image" loading="lazy">

<br>

元ポスト:https://x.com/thom_wolf/status/1840372428855280045?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2024-09-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1429">Logic-of-Thought: Injecting Logic into Contexts for Full Reasoning in  Large Language Models, Tongxuan Liu+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>Logic-of-Thought（LoT）プロンプティングを提案し、命題論理を用いて入力から拡張された論理情報を生成。これにより、LLMsの論理推論能力を向上させ、既存のプロンプト手法と統合可能。実験により、LoTが5つの論理推論タスクで顕著な性能向上を示し、特にReClorで+4.35%、LogiQAで+5%、ProofWriterで+8%の改善を達成。</span>
<span class="snippet"><span>Comment</span>SNSで話題になっているようだがGPT-3.5-TurboとGPT-4でしか比較していない上に、いつの時点のモデルかも記述されていないので、unreliableに見える

<br>



<br>

<img src="https://github.com/user-attachments/assets/9ca6fc62-2691-40c8-a578-554c0083df8f" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<span class="issue_date">Issue Date: 2024-09-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1423">When Scaling Meets LLM Finetuning: The Effect of Data, Model and  Finetuning Method, Biao Zhang+, N_A, ICLR'24</a>
<span class="snippet"><span>Summary</span>LLMのファインチューニング手法のスケーリング特性を調査し、モデルサイズやデータサイズが性能に与える影響を実験。結果、ファインチューニングはパワーベースの共同スケーリング法則に従い、モデルのスケーリングが事前学習データのスケーリングよりも効果的であることが判明。最適な手法はタスクやデータに依存する。</span>
<span class="snippet"><span>Comment</span>&gt; When only few thousands of finetuning examples are available, PET should be considered first, either Prompt or LoRA. With sightly larger datasets, LoRA would be preferred due to its stability and slightly better finetuning data scalability. For million-scale datasets, FMT would be good.

<br>



<br>



<br>



<br>

&gt; While specializing on a downstream task, finetuning could still elicit

<br>



<br>

and improve the generalization for closely related tasks, although the overall zero-shot translation

<br>



<br>

quality is inferior. Note whether finetuning benefits generalization is method・and task-dependent.

<br>



<br>

Overall, Prompt and LoRA achieve relatively better results than FMT particularly when the base

<br>



<br>

LLM is large, mostly because LLM parameters are frozen and the learned knowledge get inherited.

<br>



<br>

This also suggests that when generalization capability is a big concern, PET should be considered.</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2024-09-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1412">Direct Preference Optimization: Your Language Model is Secretly a Reward  Model, Rafael Rafailov+, N_A, NeurIPS'24</a>
<span class="snippet"><span>Summary</span>大規模無監督言語モデル（LM）の制御性を向上させるために、報酬モデルの新しいパラメータ化を導入し、単純な分類損失でRLHF問題を解決する「直接的な好み最適化（DPO）」アルゴリズムを提案。DPOは安定性と性能を持ち、ファインチューニング中のサンプリングやハイパーパラメータ調整を不要にし、既存の方法と同等以上の性能を示す。特に、生成物の感情制御においてPPOベースのRLHFを上回り、応答の質を改善しつつ実装が簡素化される。</span>
<span class="snippet"><span>Comment</span>DPOを提案した研究

<br>



<br>

<img width="838" alt="image" src="https://github.com/user-attachments/assets/2f7edf2c-32fa-4c5c-bc39-fb85112d1837">

<br>



<br>

解説ポスト:

<br>

https://x.com/theturingpost/status/1940194999993585925?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/GenerativeAI.html">#GenerativeAI</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<span class="issue_date">Issue Date: 2024-09-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1411">Recommendation with Generative Models, Yashar Deldjoo+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>生成モデルは新しいデータを生成するAIモデルであり、GANやVAE、トランスフォーマーに基づくアーキテクチャが注目されている。特にレコメンダーシステムにおいては、Gen-RecSysが推薦の精度と多様性を向上させ、パーソナライズされたユーザー体験を提供する。本書では、深層生成モデルをID駆動モデル、LLM、マルチモーダルモデルの3つに分類し、それぞれの技術的進展を紹介。生成モデルの影響やリスクについても考察し、評価フレームワークの重要性を強調する。</span>
<span class="snippet"><span>Comment</span>生成モデルやGenerativeAIによるRecSysの教科書

<br>

<img src="https://github.com/user-attachments/assets/a76e5fd2-cd82-43f9-ac64-bb33c5fe1dc2" alt="image" loading="lazy"></span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2024-09-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1410">Report on the 1st Workshop on Large Language Model for Evaluation in  Information Retrieval （LLM4Eval 2024） at SIGIR 2024, Hossein A. Rahmani+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLM4Eval 2024ワークショップがSIGIR 2024で開催され、情報検索における評価のための大規模言語モデルに関する研究者が集まりました。新規性を重視し、受理論文のパネルディスカッションやポスターセッションを通じて多面的な議論が行われました。</span>
<span class="snippet"><span>Comment</span>LLMを用いたIRシステムの評価方法に関するワークショップのレポート。レポート中にAccepted Paperがリストアップされている。</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/RelevanceJudgment.html">#RelevanceJudgment</a>
<span class="issue_date">Issue Date: 2024-09-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1409">Don't Use LLMs to Make Relevance Judgments, Ian Soboroff, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>TRECスタイルの関連性判断は高コストで複雑であり、通常は訓練を受けた契約者チームが必要です。最近の大規模言語モデルの登場により、情報検索研究者はこれらのモデルの利用可能性を考え始めました。ACM SIGIR 2024カンファレンスでの「LLM4Eval」ワークショップでは、TRECの深層学習トラックの判断を再現するデータチャレンジが行われました。本論文はその基調講演をまとめたもので、TRECスタイルの評価においてLLMを使用しないことを提言しています。</span>
<span class="snippet"><span>Comment</span>興味深い！！後で読む！</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Safety.html">#Safety</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2024-09-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1408">Backtracking Improves Generation Safety, Yiming Zhang+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>テキスト生成における安全性の問題に対処するため、バックトラッキング手法を提案。特別な[RESET]トークンを用いて生成された不適切なテキストを「取り消し」、モデルの安全性を向上させる。バックトラッキングを導入したLlama-3-8Bは、ベースラインモデルに比べて4倍の安全性を示し、有用性の低下は見られなかった。</span>
<span class="snippet"><span>Comment</span>元ポスト: https://x.com/jaseweston/status/1838415378529112330?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<span class="issue_date">Issue Date: 2024-09-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1406">To CoT or not to CoT? Chain-of-thought helps mainly on math and symbolic  reasoning, Zayne Sprague+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>Chain-of-thought（CoT）プロンプティングはLLMsの推論能力を引き出す手法であり、100以上の論文を対象にしたメタ分析により、主に数学や論理タスクでのパフォーマンス向上が確認された。一方、他のタスクでは効果が限定的で、MMLUでは直接回答生成がCoTと同等の精度を示した。計画と実行を分離し、ツール強化LLMsと比較した結果、CoTの利点は記号的実行の改善に起因し、記号ソルバーには劣ることが分かった。CoTの選択的適用により、推論コストを節約しつつパフォーマンスを維持できる可能性が示唆され、LLMアプリケーション全体での中間計算の活用が求められている。</span>
<span class="snippet"><span>Comment</span>CoTを100個以上の先行研究でmeta-analysisし（i.e. CoTを追加した場合のgainとタスクのプロット）、20個超えるデータセットで著者らが実験した結果、mathはsymbolic reasoning（124のように、シンボルを認識し、何らかの操作をして回答をする問題）が必要なタスクで、CoTは大きなgainが得られることがわかった（他はほとんどgainがない）。

<br>

<img src="https://github.com/user-attachments/assets/a399306f-bda9-45c9-a756-2a83a9727e63" alt="image" loading="lazy"></span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/CrossLingual.html">#CrossLingual</a>
<span class="issue_date">Issue Date: 2024-09-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1400">PLUG: Leveraging Pivot Language in Cross-Lingual Instruction Tuning, Zhihan Zhang+, N_A, ACL'24</a>
<span class="snippet"><span>Summary</span>指示チューニングはLLMsの指示理解を向上させるが、低リソース言語では課題がある。これに対処するため、英語をピボット言語とするPLUGアプローチを提案。モデルはまず英語で指示を処理し、次にターゲット言語で応答を生成。4つの言語での評価により、指示に従う能力が平均29%向上した。さらに、他のピボット言語を用いた実験も行い、アプローチの多様性を確認。コードとデータは公開されている。</span>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

cross-lingualでinstruction tuningをする手法。target言語のInstructionが与えられたときに、Pivotとなる言語でInstructionとResponseを生成した後、targetとなる言語に翻訳するようなデータ（それぞれをseparatorを用いてconcatする）でInstruction Tuningすることでtarget言語での性能が向上

<br>



<br>



<br>



<br>

<img src="https://github.com/user-attachments/assets/1a409df0-b8bf-45fd-8fc1-316519723820" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

評価

<br>



<br>

ゼロショットのOpen-end GenerationタスクでInstruction Tuningされたモデルが評価されるが、既存のマルチリンガルの評価セットはサンプル数が小さく、機械翻訳ベースのものはノイジーという課題がある。このため、著者らは評価する4言語（low-resource language）のプロの翻訳家を雇用し、AlpacaEvalを翻訳し、4言語（Chinese, Korean, Italian, Spanish）のinstructionが存在するパラレルコーパス X-AlpacaEvalを作成し評価データとして用いる。

<br>



<br>



<br>

利用するFoundationモデルは以下の3種類で、

<br>



<br>

・LLaMA-2-13B (英語に特化したモデル)

<br>



<br>

・PolyLM-13B (マルチリンガルなモデル)

<br>



<br>

・PolyLM-Instruct-Instruct (PolyLM-13Bをinstruction tuningしたもの)

<br>



<br>



<br>

これらに対して学習データとしてGPT4-Alpaca 1401 instruction-tuning dataset (52kのインストラクションが存在) を利用する。GPT4-AlpacaをChatGPTによって4言語に翻訳し、各言語に対するinstruction tuning datasetを得た。

<br>



<br>



<br>



<br>

比較手法として以下の5種類と比較している。ここでターゲット言語は今回4種類で、それぞれターゲット言語ごとに独立にモデルを学習している。

<br>



<br>

・Pivot-only training: pivot言語（今回は英語）のみで学習した場合 

<br>



<br>

・Monolingual response training: pivot言語とtarget言語のデータを利用した場合

<br>



<br>

・Code Switching: Monolingual response trainingに加えて、pivot言語とtarget言語のinput/outputをそれぞれ入れ替えたデータセットを用いた場合（i.e. pivot言語 input-target言語 output, target言語 input-pivot言語 outputのペアを作成し学習データに利用している）

<br>



<br>

・Auxiliary translation tasks: Monolingual respones trainingに加えて、翻訳タスクを定義し学習データとして加えた場合。すなわち、input, outputそれぞれに対して、pivot言語からtarget言語への翻訳のサンプル ([P_trans;x^p], x^t）と（[P_trans;y^p], y^t）を加えて学習している。ここで、P_transは翻訳を指示するpromptで、;は文字列のconcatnation。x^p, y^p, x^t, y^tはそれぞれ、pivot言語のinput, output、target言語のinput, outputのサンプルを表す。

<br>



<br>

・PLUG（提案手法）: Pivot-only Trainingに加えて、target言語のinputから、pivot言語のinput/output -&gt; target言語のoutputをconcatしたテキスト(x^t, [x^p;y^p;y^t]) を学習データに加えた場合

<br>



<br>



<br>



<br>

評価する際は、MT-Bench 903 のように、GPT4を用いた、direct pair-wise comparisonを行っている。

<br>



<br>

direct pair-wise comparisonは、2つのサンプルを与えてLLMに何らかの判断やスコアリングをさせる方法であり、今回はどちらがinstructionにより従っているかに勝敗/引き分けをGPT4に判断させている。LLMによる生成はサンプルの順番にsensitiveなので、順番を逆にした場合でも実験をして、win-lose rateを求めている。1つのサンプルペアに対して、サンプルの順番を正順と逆順の2回評価させ、その双方の結果を用いて最終的なwin/lose/tieを決めている。端的に言うと、勝敗が2-0ならそのサンプルの勝ち、同様に1-1なら引き分け、0-2なら負け、ということである。

<br>



<br>

<img src="https://github.com/user-attachments/assets/726ea2dc-8f62-4320-8489-45cc20ed32ae" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SelfCorrection.html">#SelfCorrection</a>
<span class="issue_date">Issue Date: 2024-09-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1398">When Can LLMs Actually Correct Their Own Mistakes? A Critical Survey of  Self-Correction of LLMs, Ryo Kamoi+, N_A, TACL'24</a>
<span class="snippet"><span>Summary</span>自己修正はLLMsの応答を改善する手法であり、フィードバック源の利用が提案されているが、誤り修正のタイミングについては合意が得られていない。本研究では、自己修正に必要な条件を議論し、従来の研究の問題点を指摘。新たに分類した研究課題に基づき、自己修正が成功した例がないこと、信頼できる外部フィードバックが重要であること、大規模なファインチューニングが効果的であることを示した。</span>
<span class="snippet"><span>Comment</span>LLMのself-correctionに関するサーベイ<img src="https://github.com/user-attachments/assets/bea63e03-8b6f-4c3e-b8ff-d738c062149c" alt="image" loading="lazy"><img src="https://github.com/user-attachments/assets/5701c2b8-bab1-4da4-af89-fa116f8848d0" alt="image" loading="lazy"><img src="https://github.com/user-attachments/assets/c3095388-52a5-40d6-ad18-235fd6a831f9" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/SyntheticDataGeneration.html">#SyntheticDataGeneration</a>
<span class="issue_date">Issue Date: 2024-09-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1393">Source2Synth: Synthetic Data Generation and Curation Grounded in Real  Data Sources, Alisia Lupidi+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>新手法「Source2Synth」を提案し、LLMに新しいスキルを教える。人間の注釈に依存せず、実世界のソースに基づいた合成データを生成し、低品質な生成物を廃棄してデータセットの質を向上。マルチホップ質問応答と表形式の質問応答に適用し、WikiSQLで25.51%、HotPotQAで22.57%の性能向上を達成。</span>
<span class="snippet"><span>Comment</span>合成データ生成に関する研究。

<br>

ソースからQAを生成し、2つのsliceに分ける。片方をLLMのfinetuning（LLMSynth）に利用し、もう片方をfinetuningしたLLMで解答可能性に基づいてフィルタリング（curation）する。

<br>

最終的にフィルタリングして生成された高品質なデータでLLMをfinetuningする。

<br>



<br>

Curationされたデータでfinetuningしたモデルの性能は、Curationしていないただの合成データと比べて、MultiHopQA, TableQAベンチマークで高い性能を獲得している。

<br>



<br>

<img src="https://github.com/user-attachments/assets/4aabfa32-6461-447f-b11d-a0875603fd08" alt="image" loading="lazy">

<br>



<br>

画像は元ポストより引用

<br>



<br>

元ポスト: https://x.com/jaseweston/status/1834402693995024453?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QMultiHopQAの合成データ生成方法

<br>

<img src="https://github.com/user-attachments/assets/853935be-1515-4064-bd08-3c0fe6a948a5" alt="image" loading="lazy">

<br>



<br>

TableQAの合成データ生成方法

<br>

<img src="https://github.com/user-attachments/assets/8f85bdf7-2de0-451a-a013-55cf0bcc167c" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<span class="issue_date">Issue Date: 2024-09-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1392">Training Large Language Models for Reasoning through Reverse Curriculum  Reinforcement Learning, Zhiheng Xi+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>R$^3$は、結果の監視を用いて大規模言語モデルの推論プロセスを最適化する新手法。正しいデモンストレーションから学ぶことで、段階的なカリキュラムを確立し、エラーを特定可能にする。Llama2-7Bを用いた実験では、8つの推論タスクでRLのベースラインを平均4.1ポイント上回り、特にGSM8Kでは4.2ポイントの改善を示した。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2024-09-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1391">ReFT: Reasoning with Reinforced Fine-Tuning, Trung Quoc Luong+, N_A, ACL'24</a>
<span class="snippet"><span>Summary</span>強化ファインチューニング（ReFT）を提案し、LLMsの推論能力を向上。SFTでモデルをウォームアップ後、PPOアルゴリズムを用いてオンライン強化学習を行い、豊富な推論パスを自動サンプリング。GSM8K、MathQA、SVAMPデータセットでSFTを大幅に上回る性能を示し、追加のトレーニング質問に依存せず優れた一般化能力を発揮。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/user-attachments/assets/ab5ed92d-6a5c-48dc-a607-3f652b2c9b3f" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/e34e5a62-c055-4586-87ee-5ece7e0cbffb" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2024-09-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1386">From Decoding to Meta-Generation: Inference-time Algorithms for Large  Language Models, Sean Welleck+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>推論時の計算リソース拡大の利点に焦点を当て、トークンレベル生成、メタ生成、効率的生成の3つのアプローチを統一的に探求。トークンレベル生成はデコーディングアルゴリズムを用い、メタ生成はドメイン知識や外部情報を活用し、効率的生成はコスト削減と速度向上を目指す。従来の自然言語処理、現代のLLMs、機械学習の視点を統合した調査。</span>
<span class="snippet"><span>Comment</span>元ツイート: https://x.com/gneubig/status/1833522477605261799?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QCMUのチームによるinference timeの高速化に関するサーベイ</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ScientificDiscovery.html">#ScientificDiscovery</a>
<span class="issue_date">Issue Date: 2024-09-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1385">Can LLMs Generate Novel Research Ideas? A Large-Scale Human Study with  100+ NLP Researchers, Chenglei Si+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>本研究では、LLMとNLP専門家による研究アイデア生成の比較を行い、LLMが生成したアイデアの新規性が人間のアイデアより高いことを示しましたが、実現可能性はやや劣ると評価されました。また、LLMの自己評価や生成の多様性に関する問題を特定し、研究者がアイデアを実行するためのエンドツーエンドの研究デザインを提案しました。</span>
<span class="snippet"><span>Comment</span>LLMがアイデアを考えた方が、79人のresearcherにblind reviewさせて評価した結果、Noveltyスコアが有意に高くなった（ただし、feasibilityは人手で考えた場合の方が高い）という話らしい。

<br>



<br>

アイデア生成にどのようなモデル、promptingを利用したかはまだ読めていない。

<br>



<br>

<img src="https://github.com/user-attachments/assets/c7a1726c-5d7c-4275-9f67-d51e5767173b" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<span class="issue_date">Issue Date: 2024-09-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1381">A Survey on Human Preference Learning for Large Language Models, Ruili Jiang+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>人間の好み学習に基づくLLMsの進展をレビューし、好みフィードバックのソースや形式、モデリング技術、評価方法を整理。データソースに基づくフィードバックの分類や、異なるモデルの利点・欠点を比較し、LLMsの人間の意図との整合性に関する展望を議論。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SelfCorrection.html">#SelfCorrection</a>
<span class="issue_date">Issue Date: 2024-09-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1378">Automatically Correcting Large Language Models: Surveying the landscape  of diverse self-correction strategies, Liangming Pan+, N_A, TACL'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）の性能は高いが、幻覚や不誠実な推論などの問題が存在する。自己修正が有望な解決策であり、自動フィードバックを活用することで人間の介入を最小限に抑えた実用的なLLMソリューションが可能になる。本論文では、トレーニング、生成、事後修正の各段階における技術を分析し、主要な応用と今後の課題について議論する。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/user-attachments/assets/8049b03d-927b-49ee-98eb-7b690b92c229" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SelfCorrection.html">#SelfCorrection</a>
<span class="issue_date">Issue Date: 2024-09-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1377">Self-Reflection in LLM Agents: Effects on Problem-Solving Performance, Matthew Renze+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>本研究では、自己反省が大規模言語モデル（LLMs）の問題解決パフォーマンスに与える影響を調査。9つのLLMに選択肢問題を解かせ、誤答に対して自己反省型エージェントが改善策を提供し再回答を試みた結果、自己反省によりパフォーマンスが有意に向上した（$p &lt; 0.001$）。さまざまな自己反省のタイプを比較し、それぞれの寄与も明らかにした。全てのコードとデータはGitHubで公開。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2024-09-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1372">The Prompt Report: A Systematic Survey of Prompting Techniques, Sander Schulhoff+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>生成的人工知能（GenAI）システムのプロンプトに関する構造的理解を確立するため、プロンプト技術の分類法を提案し、33の語彙用語と58のテキスト専用プロンプト技術を提示。さらに、自然言語プレフィックスプロンプトに関する文献のメタ分析を実施。</span>
<span class="snippet"><span>Comment</span>Promptingに関するサーベイ初期の手法からかなり網羅的に記述されているように見える。

<br>



<br>

<img src="https://github.com/user-attachments/assets/a6e6fd6c-910c-4d5d-a98e-47cf51e254ab" alt="image" loading="lazy">また、誤用されていたり、色々な意味合いで使われてしまっている用語を、きちんと定義している。

<br>

たとえば、Few shot LearningとFew shot Promptingの違い、そもそもPromptingの定義、Examplarなど。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<span class="issue_date">Issue Date: 2024-09-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1371">Does Fine-Tuning LLMs on New Knowledge Encourage Hallucinations?, Zorik Gekhman+, N_A, EMNLP'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデルはファインチューニングを通じて新しい事実情報に遭遇するが、既存の知識を活用する能力に影響を与える。研究では、閉じた書籍のQAを用いて新しい知識を導入するファインチューニング例の割合を変化させた結果、モデルは新しい知識を学習するのに苦労し、幻覚する傾向が増加することが示された。これにより、ファインチューニングによる新しい知識の導入のリスクが明らかになり、モデルは事前学習を通じて知識を獲得し、ファインチューニングはその利用を効率化することが支持される。</span>
<span class="snippet"><span>Comment</span>pre-training時に獲得されていない情報を用いてLLMのalignmentを実施すると、知識がない状態で学習データを正しく予測できるように学習されてしまうため、事実に基づかない回答をする（つまりhallucination）ように学習されてしまう、といったことを調査している模様。

<br>



<br>



<br>



<br>

&gt;新しい知識を導入するファインチューニング例は、モデルの知識と一致する例よりもはるかに遅く学習されます。しかし、新しい知識を持つ例が最終的に学習されるにつれて、モデルの幻覚する傾向が線形に増加することも発見しました。

<br>



<br>

<img src="https://github.com/user-attachments/assets/9c7b3e2e-3ecb-4d71-a7fc-09fa7e57a613" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

早々にoverfittingしている。

<br>



<br>



<br>



<br>

&gt;大規模言語モデルは主に事前学習を通じて事実知識を取得し、ファインチューニングはそれをより効率的に使用することを教えるという見解を支持しています。

<br>



<br>



<br>



<br>

なるほど、興味深い。下記画像は 1370より引用

<br>



<br>

<img src="https://github.com/user-attachments/assets/e08d47cf-b550-4ced-a6bd-02d90d3684e9" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

本論文中では、full finetuningによる検証を実施しており、LoRAのようなAdapterを用いたテクニックで検証はされていない。LoRAではもともとのLLMのパラメータはfreezeされるため、異なる挙動となる可能性がある。特にLoRAが新しい知識を獲得可能なことが示されれば、LoRA AdapterをもともとのLLMに付け替えるだけで、異なる知識を持ったLLMを運用可能になるため、インパクトが大きいと考えられる。もともとこういった思想は LoRA Hubを提唱する研究などの頃からあった気がするが、AdapterによってHallucination/overfittingを防ぎながら、新たな知識を獲得できることを示した研究はあるのだろうか？

<br>



<br>

<img src="https://github.com/user-attachments/assets/a05a3662-baf9-4fcd-b15e-440f1c2c9f6e" alt="image" loading="lazy">

<br>



<br>

参考: https://x.com/hillbig/status/1792334744522485954?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLoRAの場合については

<br>



<br>

・1640

<br>

・1475

<br>



<br>

も参照のこと。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<span class="issue_date">Issue Date: 2024-08-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1362">What Do Language Models Learn in Context? The Structured Task Hypothesis, Jiaoda Li+, N_A, ACL'24</a>
<span class="snippet"><span>Summary</span>LLMsのコンテキスト内学習（ICL）能力を説明する3つの仮説について、一連の実験を通じて探究。最初の2つの仮説を無効にし、最後の仮説を支持する証拠を提供。LLMが事前学習中に学習したタスクを組み合わせることで、コンテキスト内で新しいタスクを学習できる可能性を示唆。</span>
<span class="snippet"><span>Comment</span>SNLP2024での解説スライド:

<br>

http://chasen.org/~daiti-m/paper/SNLP2024-Task-Emergence.pdfICLが何をやっているのか?について、これまでの仮説が正しくないことを実験的に示し、新しい仮説「ICLは事前学習で得られたタスクを組み合わせて新しいタスクを解いている」を提唱し、この仮説が正しいことを示唆する実験結果を得ている模様。

<br>

理論的に解明されたわけではなさそうなのでそこは留意した方が良さそう。あとでしっかり読む。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/GrammaticalErrorCorrection.html">#GrammaticalErrorCorrection</a>
<span class="issue_date">Issue Date: 2024-08-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1351">Prompting open-source and commercial language models for grammatical  error correction of English learner text, Christopher Davis+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMsの進歩により、流暢で文法的なテキスト生成が可能になり、不文法な入力文を与えることで文法エラー修正（GEC）が可能となった。本研究では、7つのオープンソースと3つの商用LLMsを4つのGECベンチマークで評価し、商用モデルが常に教師ありの英語GECモデルを上回るわけではないことを示した。また、オープンソースモデルが商用モデルを上回ることがあり、ゼロショットのプロンプティングがフューショットのプロンプティングと同じくらい競争力があることを示した。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/chemical_tree/status/1822860849935253882?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/ScientificDiscovery.html">#ScientificDiscovery</a>
<span class="issue_date">Issue Date: 2024-08-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1350">The AI Scientist: Towards Fully Automated Open-Ended Scientific  Discovery, Chris Lu+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>最先端の大規模言語モデルを使用して、完全自動の科学的発見を可能にする包括的なフレームワークが提案された。AI Scientistは新しい研究アイデアを生成し、コードを記述し、実験を実行し、結果を可視化し、完全な科学論文を執筆し、査読プロセスを実行することができる。このアプローチは、機械学習における科学的発見の新しい時代の始まりを示しており、AIエージェントの変革的な利点をAI自体の研究プロセス全体にもたらし、世界で最も難しい問題に無限の手頃な価格の創造性とイノベーションを解き放つことに近づいています。</span>
<a class="button" href="articles/Controllable.html">#Controllable</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/Length.html">#Length</a>
<span class="issue_date">Issue Date: 2024-07-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1341">Following Length Constraints in Instructions, Weizhe Yuan+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>アラインされた命令に従うモデルは、非アラインのモデルよりもユーザーの要求をよりよく満たすことができることが示されています。しかし、このようなモデルの評価には長さのバイアスがあり、訓練アルゴリズムは長い応答を学習することでこのバイアスを利用する傾向があることが示されています。本研究では、推論時に所望の長さ制約を含む命令で制御できるモデルの訓練方法を示します。このようなモデルは、長さ指示された評価において優れており、GPT4、Llama 3、Mixtralなどの標準的な命令に従うモデルを上回っています。</span>
<span class="snippet"><span>Comment</span>SoTA LLMがOutput長の制約に従わないことを示し、それを改善する学習手法LIFT-DPOを提案<img src="https://github.com/user-attachments/assets/1002ae4a-66b2-4125-8cbb-3a2a8484da56" alt="image" loading="lazy">

<br>



<br>

元ツイート: https://x.com/jaseweston/status/1805771223747481690?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2024-07-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1337">A Systematic Survey of Prompt Engineering in Large Language Models:  Techniques and Applications, Pranab Sahoo+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>プロンプトエンジニアリングは、LLMsやVLMsの能力を拡張するための重要な技術であり、モデルのパラメータを変更せずにタスク固有の指示であるプロンプトを活用してモデルの効果を向上させる。本研究は、プロンプトエンジニアリングの最近の進展について構造化された概要を提供し、各手法の強みと制限について掘り下げることで、この分野をよりよく理解し、将来の研究を促進することを目的としている。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/user-attachments/assets/9c41dcc4-6b88-47ae-9032-1daca6bfee65" alt="image" loading="lazy"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-04-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1293">Phi-3 Technical Report: A Highly Capable Language Model Locally on Your  Phone, Marah Abdin+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>phi-3-miniは38億パラメータの言語モデルであり、3.3兆トークンで訓練されています。Mixtral 8x7BやGPT-3.5などの大規模モデルに匹敵する総合的なパフォーマンスを持ちながら、スマートフォンにデプロイ可能なサイズです。このモデルは、厳密にフィルタリングされたWebデータと合成データで構成されており、堅牢性、安全性、およびチャット形式に適合しています。また、phi-3-smallとphi-3-mediumというより大規模なモデルも紹介されています。</span>
<span class="snippet"><span>Comment</span>1039 の次の次（Phi2.0についてはメモってなかった）。スマホにデプロイできるレベルのサイズで、GPT3.5Turbo程度の性能を実現したらしいLlama2と同じブロックを利用しているため、アーキテクチャはLlama2と共通。

<br>



<br>

</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Pruning.html">#Pruning</a>
<span class="issue_date">Issue Date: 2024-04-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1292">The Unreasonable Ineffectiveness of the Deeper Layers, Andrey Gromov+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>一般的なオープンウェイトの事前学習されたLLMのレイヤー剪定戦略を研究し、異なる質問応答ベンチマークでのパフォーマンスの低下を最小限に抑えることを示しました。レイヤーの最大半分を削除することで、最適なブロックを特定し、微調整して損傷を修復します。PEFT手法を使用し、実験を単一のA100 GPUで実行可能にします。これにより、計算リソースを削減し、推論のメモリとレイテンシを改善できることが示唆されます。また、LLMがレイヤーの削除に対して堅牢であることは、浅いレイヤーが知識を格納する上で重要な役割を果たしている可能性を示唆しています。</span>
<span class="snippet"><span>Comment</span>下記ツイートによると、学習済みLLMから、コサイン類似度で入出力間の類似度が高い層を除いてもタスクの精度が落ちず、特に深い層を2-4割削除しても精度が落ちないとのこと。

<br>



<br>

参考:https://x.com/hillbig/status/1773110076502368642?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

VRAMに載せるのが大変なので、このような枝刈り技術が有効だと分かるのはありがたい。LoRAや量子化も利用しているっぽい。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2024-04-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1284">Knowledge Conflicts for LLMs: A Survey, Rongwu Xu+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMsにおける知識の衝突に焦点を当て、文脈とパラメトリック知識の組み合わせによる複雑な課題を分析。文脈-メモリ、文脈間、メモリ内の衝突の3つのカテゴリーを探求し、実世界のアプリケーションにおける信頼性とパフォーマンスへの影響を検討。解決策を提案し、LLMsの堅牢性向上を目指す。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<span class="issue_date">Issue Date: 2024-04-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1283">Quiet-STaR: Language Models Can Teach Themselves to Think Before  Speaking, Eric Zelikman+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>STaR（Self-Taught Reasoner）では、少数の例から合理的な推論を学習し、質問応答に活用する方法が提案された。Quiet-STaRでは、LMが合理性を生成する方法を学習し、難しい質問に直接答える能力を向上させる。この手法は、GSM8KやCommonsenseQAなどのタスクにおいてゼロショットの改善を実現し、ファインチューニングが不要であることが示された。Quiet-STaRは、推論を学習するための一般的でスケーラブルな方法を提供する一歩となっている。</span>
<span class="snippet"><span>Comment</span>1390 o1の基礎技術と似ている可能性がある

<br>

先行研究: 1397参考:https://x.com/hillbig/status/1835449666588271046?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q[Perplexity（参考; Hallucinationに注意）](https://www.perplexity.ai/search/yi-xia-nolun-wen-wodu-nte-nei-9OsZ8nFkQsuW2KwQWQzWjw)<img src="https://github.com/user-attachments/assets/a1b41417-99d3-4f76-a2f5-4838fdf43982" alt="image" loading="lazy"></span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<span class="issue_date">Issue Date: 2024-04-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1275">Visualization-of-Thought Elicits Spatial Reasoning in Large Language  Models, Wenshan Wu+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMsの空間推論能力を向上させるために、Visualization-of-Thought（VoT）プロンプティングを提案。VoTは、LLMsの推論トレースを可視化し、空間推論タスクで使用することで、既存のMLLMsを上回る性能を示す。VoTは、空間推論を促進するために「メンタルイメージ」を生成する能力を持ち、MLLMsでの有効性を示唆する。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ContextWindow.html">#ContextWindow</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<span class="issue_date">Issue Date: 2024-04-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1274">Long-context LLMs Struggle with Long In-context Learning, Tianle Li+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMsは長いシーケンスを処理する能力に進展しているが、実世界のシナリオでの能力を評価するための専門的なベンチマークLongICLBenchが導入された。このベンチマークでは、LLMsは巨大なラベル空間を理解し、正しい予測を行うために入力全体を理解する必要がある。研究によると、長いコンテキストLLMsは長いコンテキストウィンドウを活用することで比較的良いパフォーマンスを示すが、最も困難なタスクでは苦労している。現在のLLMsは長くコンテキスト豊かなシーケンスを処理し理解する能力にギャップがあることを示唆しており、長いコンテキストの理解と推論は依然として難しい課題であることが示されている。</span>
<span class="snippet"><span>Comment</span>GPT4以外はコンテキストが20Kを超えると性能が劣化する傾向にあるとのこと。データセットを難易度別に収集し評価したところ、難易度の高いデータではそもそもコンテキストが長くなると全てのLLMがタスクを理解するできずほぼ0%の性能となった。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/fc51d83a-3013-4fcc-bf7a-5722eb01d0d8" alt="image" loading="lazy"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<span class="issue_date">Issue Date: 2024-04-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1273">Mixture-of-Depths: Dynamically allocating compute in transformer-based  language models, David Raposo+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>Transformerベースの言語モデルは、入力シーケンス全体に均等にFLOPsを分散させる代わりに、特定の位置にFLOPsを動的に割り当てることを学習できることを示す。モデルの深さにわたって割り当てを最適化するために、異なるレイヤーで計算を動的に割り当てる。この手法は、トークンの数を制限することで合計計算予算を強制し、トークンはtop-kルーティングメカニズムを使用して決定される。この方法により、FLOPsを均等に消費しつつ、計算の支出が予測可能であり、動的かつコンテキストに敏感である。このようにトレーニングされたモデルは、計算を動的に割り当てることを学習し、効率的に行うことができる。</span>
<span class="snippet"><span>Comment</span>参考: https://x.com/theseamouse/status/1775782800362242157?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<span class="issue_date">Issue Date: 2024-04-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1270">Dynamic Memory Compression: Retrofitting LLMs for Accelerated Inference, Piotr Nawrot+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>トランスフォーマーの生成効率を向上させるために、Dynamic Memory Compression（DMC）が提案された。DMCは、異なるヘッドとレイヤーで異なる圧縮率を適用する方法を学習し、事前学習済みLLMsに適用される。DMCは、元の下流パフォーマンスを最大4倍のキャッシュ圧縮で維持しつつ、スループットを向上させることができる。DMCは、GQAと組み合わせることでさらなる利益をもたらす可能性があり、長いコンテキストと大きなバッチを処理する際に有用である。</span>
<span class="snippet"><span>Comment</span>参考: https://x.com/hillbig/status/1776755029581676943?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q論文中のFigure1が非常にわかりやすい。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/d416547e-f9ca-4c6c-8ebb-7d164bef5283" alt="image" loading="lazy">

<br>



<br>

GQA 1271 と比較して、2~4倍キャッシュを圧縮しつつ、より高い性能を実現。70Bモデルの場合は、GQAで8倍キャッシュを圧縮した上で、DMCで追加で2倍圧縮をかけたところ、同等のパフォーマンスを実現している。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/7b131f07-5eab-4830-88cc-5f6fd0508958" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2024-04-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1269">RAFT: Adapting Language Model to Domain Specific RAG, Tianjun Zhang+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>大規模なテキストデータのLLMsを事前学習し、新しい知識を追加するためのRetrieval Augmented FineTuning（RAFT）を提案。RAFTは、質問に回答するのに役立つ関連文書から正しいシーケンスを引用し、chain-of-thoughtスタイルの応答を通じて推論能力を向上させる。RAFTはPubMed、HotpotQA、Gorillaデータセットでモデルのパフォーマンスを向上させ、事前学習済みLLMsをドメイン固有のRAGに向けて改善する。</span>
<span class="snippet"><span>Comment</span>Question, instruction, coxtext, cot style answerの4つを用いてSFTをする模様

<br>

画像は下記ツイートより引用

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/0763b048-8029-4712-9e79-e833bdb9b2c0" alt="image" loading="lazy">

<br>

https://x.com/cwolferesearch/status/1770912695765660139?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2024-04-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1268">RankPrompt: Step-by-Step Comparisons Make Language Models Better  Reasoners, Chi Hu+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMsは推論タスクで優れた性能を発揮しているが、論理エラーが起こりやすい。RankPromptという新しいプロンプティング方法を導入し、LLMsが自己ランク付けを行い推論パフォーマンスを向上させる。実験では、RankPromptがChatGPTやGPT-4の推論パフォーマンスを13%向上させ、AlpacaEvalデータセットで人間の判断と74%の一致率を示すことが示された。RankPromptは言語モデルから高品質なフィードバックを引き出す効果的な方法であることが示された。</span>
<span class="snippet"><span>Comment</span>LLMでランキングをするためのプロンプト手法。大量の候補をランキングするのは困難だと思われるが、リランキング手法としては利用できる可能性がある

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/7115515c-10a2-44ae-9e48-86258cc11aed" alt="image" loading="lazy"></span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ModelMerge.html">#ModelMerge</a>
<span class="issue_date">Issue Date: 2024-03-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1257">Evolutionary Optimization of Model Merging Recipes, Takuya Akiba+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>進化アルゴリズムを使用した新しいアプローチを提案し、強力な基盤モデルの自動生成を実現。LLMの開発において、人間の直感やドメイン知識に依存せず、多様なオープンソースモデルの効果的な組み合わせを自動的に発見する。このアプローチは、日本語のLLMと数学推論能力を持つモデルなど、異なるドメイン間の統合を容易にし、日本語VLMの性能向上にも貢献。オープンソースコミュニティへの貢献と自動モデル構成の新しいパラダイム導入により、基盤モデル開発における効率的なアプローチを模索。</span>
<span class="snippet"><span>Comment</span>複数のLLMを融合するモデルマージの話。日本語LLMと英語の数学LLNをマージさせることで日本語の数学性能を大幅に向上させたり、LLMとVLMを融合したりすることで、日本にしか存在しない概念の画像も、きちんと回答できるようになる。

<br>



<br>

著者スライドによると、従来のモデルマージにはbase modelが同一でないとうまくいかなかったり（重みの線型結合によるモデルマージ）、パラメータが増減したり（複数LLMのLayerを重みは弄らず再配置する）。また日本語LLMに対してモデルマージを実施しようとすると、マージ元のLLMが少なかったり、広範囲のモデルを扱うとマージがうまくいかない、といった課題があった。本研究ではこれら課題を解決できる。著者による資料（NLPコロキウム）:

<br>

https://speakerdeck.com/iwiwi/17-nlpkorokiumu</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/OpenSource.html">#OpenSource</a>
<span class="issue_date">Issue Date: 2024-03-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1250">OLMo: Accelerating the Science of Language Models, Dirk Groeneveld+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>LMsの商業的重要性が高まる中、最も強力なモデルは閉鎖されており、その詳細が非公開になっている。そのため、本技術レポートでは、本当にオープンな言語モデルであるOLMoの初回リリースと、言語モデリングの科学を構築し研究するためのフレームワークについて詳細に説明している。OLMoはモデルの重みだけでなく、トレーニングデータ、トレーニングおよび評価コードを含むフレームワーク全体を公開しており、オープンな研究コミュニティを強化し、新しいイノベーションを促進することを目指している。</span>
<span class="snippet"><span>Comment</span>Model Weightsを公開するだけでなく、training/evaluation codeとそのデータも公開する真にOpenな言語モデル（truly Open Language Model）。AllenAI</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2024-03-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1247">Chain-of-Thought Reasoning Without Prompting, Xuezhi Wang+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMsの推論能力を向上させるための新しいアプローチに焦点を当てた研究が行われている。この研究では、LLMsがプロンプトなしで効果的に推論できるかどうかを検証し、CoT推論パスをデコーディングプロセスを変更することで引き出す方法を提案している。提案手法は、従来の貪欲なデコーディングではなく、代替トークンを調査することでCoTパスを見つけることができることを示しており、様々な推論ベンチマークで有効性を示している。</span>
<span class="snippet"><span>Comment</span>以前にCoTを内部的に自動的に実施されるように事前学習段階で学習する、といった話があったと思うが、この研究はデコーディング方法を変更することで、promptingで明示的にinstructionを実施せずとも、CoTを実現するもの、ということだと思われる。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/afb3a31e-3d85-4b7e-affa-fccc00b7321e" alt="image" loading="lazy"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2024-03-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1245">LoRA+: Efficient Low Rank Adaptation of Large Models, Soufiane Hayou+, N_A, ICML'24</a>
<span class="snippet"><span>Summary</span>本研究では、Huら（2021）によって導入されたLow Rank Adaptation（LoRA）が、大埋め込み次元を持つモデルの適切な微調整を妨げることを指摘します。この問題は、LoRAのアダプターマトリックスAとBが同じ学習率で更新されることに起因します。我々は、AとBに同じ学習率を使用することが効率的な特徴学習を妨げることを示し、異なる学習率を設定することでこの問題を修正できることを示します。修正されたアルゴリズムをLoRA$+$と呼び、幅広い実験により、LoRA$+$は性能を向上させ、微調整速度を最大2倍高速化することが示されました。</span>
<span class="snippet"><span>Comment</span>LoRAで導入される低ランク行列AとBを異なる学習率で学習することで、LoRAと同じ計算コストで、2倍以上の高速化、かつ高いパフォーマンスを実現する手法

<br>



<br>

<img src="https://github.com/user-attachments/assets/cde925fa-bfe8-4385-ae55-d80f7bf034f5" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/c054c5a6-56a2-4aa5-b7f2-0ae87a808f58" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/f32a7aba-e4b1-4d28-920d-00f81e9b85e8" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Annotation.html">#Annotation</a>
<span class="issue_date">Issue Date: 2024-03-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1244">Large Language Models for Data Annotation: A Survey, Zhen Tan+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>GPT-4などの大規模言語モデル（LLMs）を使用したデータアノテーションの研究に焦点を当て、LLMによるアノテーション生成の評価や学習への応用について述べられています。LLMを使用したデータアノテーションの手法や課題について包括的に議論し、将来の研究の進展を促進することを目的としています。</span>
<span class="snippet"><span>Comment</span>Data AnnotationにLLMを活用する場合のサーベイ</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/TabularData.html">#TabularData</a>
<span class="issue_date">Issue Date: 2024-03-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1243">Large Language Models（LLMs） on Tabular Data: Prediction, Generation, and  Understanding -- A Survey, Xi Fang+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>最近の大規模言語モデリングの進展により、様々なタスクにおける応用が容易になっているが、包括的なレビューが不足している。この研究は、最近の進歩をまとめ、データセット、メトリクス、方法論を調査し、将来の研究方向に洞察を提供することを目的としている。また、関連するコードとデータセットの参照も提供される。</span>
<span class="snippet"><span>Comment</span>Tabular DataにおけるLLM関連のタスクや技術等のサーベイ</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<span class="issue_date">Issue Date: 2024-02-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1235">User-LLM: Efficient LLM Contextualization with User Embeddings, Lin Ning+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>LLMsを活用したUser-LLMフレームワークが提案された。ユーザーエンベッディングを使用してLLMsをコンテキストに位置付けし、ユーザーコンテキストに動的に適応することが可能になる。包括的な実験により、著しい性能向上が示され、Perceiverレイヤーの組み込みにより計算効率が向上している。</span>
<span class="snippet"><span>Comment</span>next item prediction, favorite genre or category predictimnreview generationなどで評価している</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2024-01-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1225">MM-LLMs: Recent Advances in MultiModal Large Language Models, Duzhen Zhang+, N_A, ACL'24 Findings</a>
<span class="snippet"><span>Summary</span>MM-LLMsは、コスト効果の高いトレーニング戦略を用いて拡張され、多様なMMタスクに対応する能力を持つことが示されている。本論文では、MM-LLMsのアーキテクチャ、トレーニング手法、ベンチマークのパフォーマンスなどについて調査し、その進歩に貢献することを目指している。</span>
<span class="snippet"><span>Comment</span>以下、論文を斜め読みしながら、ChatGPTを通じて疑問点を解消しつつ理解した内容なので、理解が不十分な点が含まれている可能性があるので注意。

<br>



<br>



<br>



<br>

まあざっくり言うと、マルチモーダルを理解できるLLMを作りたかったら、様々なモダリティをエンコーディングして得られる表現と、既存のLLMが内部的に処理可能な表現を対応づける Input Projectorという名の関数を学習すればいいだけだよ（モダリティのエンコーダ、LLMは事前学習されたものをそのままfreezeして使えば良い）。

<br>



<br>



<br>



<br>

マルチモーダルを生成できるLLMを作りたかったら、LLMがテキストを生成するだけでなく、様々なモダリティに対応する表現も追加で出力するようにして、その出力を各モダリティを生成できるモデルに入力できるように変換するOutput Projectortという名の関数を学習しようね、ということだと思われる。

<br>



<br>



<br>



<br>

概要

<br>



<br>

<img width="1093" alt="image" src="https://github.com/user-attachments/assets/c12f621b-95e6-4bff-827b-c4c5cf43b532">

<br>



<br>



<br>



<br>

ポイント

<br>



<br>

・Modality Encoder, LLM Backbone、およびModality Generatorは一般的にはパラメータをfreezeする

<br>



<br>

・optimizationの対象は「Input/Output Projector」

<br>



<br>



<br>



<br>

Modality Encoder

<br>



<br>

様々なモダリティI_Xを、特徴量F_Xに変換する。これはまあ、色々なモデルがある。

<br>



<br>

<img width="195" alt="image" src="https://github.com/user-attachments/assets/578c3bbc-0183-4d62-bf98-ee1b1bc1109c">

<br>



<br>



<br>



<br>

Input Projector

<br>



<br>

モダリティI_Xとそれに対応するテキストtのデータ {I_X, t}が与えられたとき、テキストtを埋め込み表現に変換んした結果得られる特徴量がF_Tである。Input Projectorは、F_XをLLMのinputとして利用する際に最適な特徴量P_Xに変換するθX_Tを学習することである。これは、LLM(P_X, F_T)によってテキストtがどれだけ生成できたか、を表現する損失関数を最小化することによって学習される。

<br>



<br>

<img width="451" alt="image" src="https://github.com/user-attachments/assets/a80f5453-b50f-48d5-8114-5f9f81544793">

<br>



<br>



<br>



<br>

LLM Backbone

<br>



<br>

LLMによってテキスト列tと、各モダリティに対応した表現であるS_Xを生成する。outputからt, S_Xをどのように区別するかはモデルの構造などにもよるが、たとえば異なるヘッドを用意して、t, S_Xを区別するといったことは可能であろうと思われる。

<br>



<br>

<img width="256" alt="image" src="https://github.com/user-attachments/assets/0be4e1c7-f92b-4259-a536-8ea135c1bcba">

<br>



<br>



<br>



<br>

Output Projector

<br>



<br>

S_XをModality Generatorが解釈可能な特徴量H_Xに変換する関数のことである。これは学習しなければならない。

<br>



<br>

H_XとModality Generatorのtextual encoderにtを入力した際に得られる表現τX(t)が近くなるようにOutput Projector θ_T_Xを学習する。これによって、S_XとModality Generatorがalignするようにする。

<br>



<br>

<img width="356" alt="image" src="https://github.com/user-attachments/assets/faa87be0-e738-4dc1-8e52-0787d6b973e8">

<br>



<br>



<br>



<br>

Modality Generator

<br>



<br>

各ModalityをH_Xから生成できるように下記のような損失学習する。要は、生成されたモダリティデータ（または表現）が実際のデータにどれだけ近いか、を表しているらしい。具体的には、サンプリングによって得られたノイズと、モデルが推定したノイズの値がどれだけ近いかを測る、みたいなことをしているらしい。

<br>



<br>

<img width="448" alt="image" src="https://github.com/user-attachments/assets/a18cfe29-27bf-42bf-8481-7e0afd838918">

<br>



<br>



<br>



<br>

Multi Modalを理解するモデルだけであれば、Input Projectorの損失のみが学習され、生成までするのであれば、Input/Output Projector, Modality Generatorそれぞれに示した損失関数を通じてパラメータが学習される。あと、P_XやらS_Xはいわゆるsoft-promptingみたいなものであると考えられる。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ProgressiveLearning.html">#ProgressiveLearning</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2024-01-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1219">LLaMA Pro: Progressive LLaMA with Block Expansion, Chengyue Wu+, N_A, ACL'24</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）の新しい事前学習後の手法を提案し、モデルの知識を効果的かつ効率的に向上させることを目指しました。具体的には、Transformerブロックの拡張を使用し、新しいコーパスのみを使用してモデルを調整しました。実験の結果、提案手法はさまざまなベンチマークで優れたパフォーマンスを発揮し、知的エージェントとして多様なタスクに対応できることが示されました。この研究は、自然言語とプログラミング言語を統合し、高度な言語エージェントの開発に貢献するものです。</span>
<span class="snippet"><span>Comment</span>追加の知識を導入したいときに使えるかも?事前学習したLLaMA Blockに対して、追加のLLaMA Blockをstackし、もともとのLLaMA Blockのパラメータをfreezeした上でドメインに特化したコーパスで事後学習することで、追加の知識を挿入する。LLaMA Blockを挿入するときは、Linear Layerのパラメータを0にすることで、RMSNormにおける勾配消失の問題を避けた上で、Identity Block（Blockを追加した時点では事前学習時と同様のOutputがされることが保証される）として機能させることができる。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/0ef6cc84-da38-4254-9bb3-ea4e2f9ebfab" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/a2bb221a-3ac3-4b81-9308-c114daf00401" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<span class="issue_date">Issue Date: 2024-01-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1217">A Comprehensive Survey of Hallucination Mitigation Techniques in Large  Language Models, S. M Towhidul Islam Tonmoy+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>要約：本論文では、大規模言語モデル（LLMs）における幻覚の問題について調査し、その軽減策について紹介しています。LLMsは強力な言語生成能力を持っていますが、根拠のない情報を生成する傾向があります。この問題を解決するために、Retrieval Augmented Generation、Knowledge Retrieval、CoNLI、CoVeなどの技術が開発されています。さらに、データセットの利用やフィードバックメカニズムなどのパラメータに基づいてこれらの方法を分類し、幻覚の問題に取り組むためのアプローチを提案しています。また、これらの技術に関連する課題や制約についても分析し、将来の研究に向けた基盤を提供しています。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/TabularData.html">#TabularData</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2024-01-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1216">Chain-of-Table: Evolving Tables in the Reasoning Chain for Table   Understanding, Zilong Wang+, N_A, ICLR'24</a>
<span class="snippet"><span>Summary</span>LLMsを使用したChain-of-Tableフレームワークは、テーブルデータを推論チェーン内で活用し、テーブルベースの推論タスクにおいて高い性能を発揮することが示された。このフレームワークは、テーブルの連続的な進化を表現し、中間結果の構造化情報を利用してより正確な予測を可能にする。さまざまなベンチマークで最先端のパフォーマンスを達成している。</span>
<span class="snippet"><span>Comment</span>Table, Question, Operation Historyから次のoperationとそのargsを生成し、テーブルを順次更新し、これをモデルが更新の必要が無いと判断するまで繰り返す。最終的に更新されたTableを用いてQuestionに回答する手法。Questionに回答するために、複雑なテーブルに対する操作が必要なタスクに対して有効だと思われる。

<br>

<img src="https://github.com/user-attachments/assets/f23bdacf-ffc0-4d37-b992-62fea094c9d2" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/90ec4404-7ed0-4698-8223-15134b195977" alt="image" loading="lazy"></span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/ModelMerge.html">#ModelMerge</a>
<span class="issue_date">Issue Date: 2024-01-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1213">Knowledge Fusion of Large Language Models, Fanqi Wan+, N_A, ICLR'24</a>
<span class="snippet"><span>Summary</span>本研究では、既存の事前訓練済みの大規模言語モデル（LLMs）を統合することで、1つの強力なモデルを作成する方法を提案しています。異なるアーキテクチャを持つ3つの人気のあるLLMsを使用して、ベンチマークとタスクのパフォーマンスを向上させることを実証しました。提案手法のコード、モデルの重み、およびデータはGitHubで公開されています。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2024-01-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1212">Self-Rewarding Language Models, Weizhe Yuan+, N_A, ICML'24</a>
<span class="snippet"><span>Summary</span>将来のモデルのトレーニングには超人的なフィードバックが必要であり、自己報酬を提供するSelf-Rewarding Language Modelsを研究している。LLM-as-a-Judgeプロンプトを使用して、言語モデル自体が自己報酬を提供し、高品質な報酬を得る能力を向上させることを示した。Llama 2 70Bを3回のイテレーションで微調整することで、既存のシステムを上回るモデルが得られることを示した。この研究は、改善可能なモデルの可能性を示している。</span>
<span class="snippet"><span>Comment</span>人間の介入無しで（人間がアノテーションしたpreference data無しで）LLMのAlignmentを改善していく手法。LLM-as-a-Judge Promptingを用いて、LLM自身にpolicy modelとreward modelの役割の両方をさせる。unlabeledなpromptに対してpolicy modelとしてresponceを生成させた後、生成したレスポンスをreward modelとしてランキング付けし、DPOのpreference pairとして利用する、という操作を繰り返す。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/32db0422-6fb1-4741-bdfa-45a5e83e76c4" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<span class="issue_date">Issue Date: 2024-01-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1208">The Impact of Reasoning Step Length on Large Language Models, Mingyu Jin+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>Chain of Thought（CoT）の推論ステップの長さとLLMsの推論能力の関係を調査した。推論ステップを延長すると、プロンプトに新しい情報を追加せずにLLMsの推論能力が向上することがわかった。逆に、キーとなる情報を保持しながら推論ステップを短縮すると、推論能力が低下する。また、誤った根拠でも推論の必要な長さを保つ限り、好ましい結果が得られることも示された。さらに、タスクによって推論ステップの増加の利点が異なることも観察された。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-01-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1204">Mixtral of Experts, Albert Q. Jiang+, N_A, arXiv'24</a>
<span class="snippet"><span>Summary</span>Mixtralは、Sparse Mixture of Experts（SMoE）言語モデルであり、各レイヤーが8つのフィードフォワードブロックで構成されています。Mixtralは、トークンごとに2つのエキスパートを選択し、それらの出力を組み合わせます。Mixtralは、Llama 2 70BとGPT-3.5を上回る性能を持ち、数学、コード生成、多言語のベンチマークで特に優れています。また、Mixtral 8x7B Instructという指示に従うモデルも提供されており、人間のベンチマークを凌駕しています。</span>
<span class="snippet"><span>Comment</span>Mixture of experts Layer: inputを受け取ったrouterが、8つのexpertsのうち2つを選択し順伝搬。2つのexpertsのoutputを加重平均することで最終的なoutputとする。

<br>

<img src="https://github.com/user-attachments/assets/52ca3ed3-714f-4bc2-af76-c6884fc37927" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/COLM.html">#COLM</a>
<span class="issue_date">Issue Date: 2023-11-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1155">GPQA: A Graduate-Level Google-Proof Q&amp;A Benchmark, David Rein+, N_A, COLM'24</a>
<span class="snippet"><span>Summary</span>私たちは、高品質で非常に困難な多肢選択問題からなるGPQAデータセットを提案します。このデータセットは、専門家でも高い正答率を達成できず、最先端のAIシステムでも困難であることが示されています。将来のAIシステムの開発において、スケーラブルな監督方法を開発する必要があります。これにより、スキルを持つ監督者がAIシステムから信頼性のある情報を得ることができるようになります。GPQAデータセットは、スケーラブルな監督実験を可能にし、人間の専門家がAIシステムから真実の情報を確実に得る方法を考案するのに役立つことが期待されています。</span>
<span class="snippet"><span>Comment</span>該当領域のPh.D所有者でも74%、高いスキルを持つ非専門家（Googleへアクセスして良い環境）で34%しか正答できないQAデータセット。

<br>

元ツイート: https://x.com/idavidrein/status/1727033002234909060?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QOpenReview:https://openreview.net/forum?id=Ti67584b98</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2023-10-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1110">Re-Reading Improves Reasoning in Language Models, Xiaohan Xu+, N_A, EMNLP'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）において、推論は重要で困難な問題です。従来のアプローチでは、プロンプティング戦略を開発することに焦点が当てられてきましたが、双方向の相互作用や質問の重要性には注意が払われていませんでした。この問題に対処するため、質問の再読という新しいプロンプティング戦略を提案します。再読は、質問情報を再訪することで、LLMsの推論能力を向上させることができます。実験結果は、この手法の効果と汎用性を示しており、LLMsの領域でのその有用性を強調しています。</span>
<span class="snippet"><span>Comment</span>問題文を2,3回promptで繰り返すだけで、数学のベンチマークとCommonsenseのベンチマークの性能が向上したという非常に簡単なPrompting。self-consistencyなどの他のPromptingとの併用も可能。

<br>

なぜ性能が向上するかというと、

<br>

1. LLMはAuporegressiveなモデルであり、bidirectionalなモデルではない。このため、forwardパスのみでは読解力に限界がある。（たとえば人間はしばしばテキストを読み返したりする）。そこで、一度目の読解で概要を理解し、二度目の読解でsalience partを読み込むといったような挙動を実現することで、より問題文に対するComprehensionが向上する。

<br>

2. LLMはしばしばpromptの重要な箇所の読解を欠落させてしまう。たとえば、793 では、promptのmiddle partを軽視する傾向があることが示されている。このような現象も軽減できると考えられる。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/e575e0aa-b76c-444e-b9b0-e984d6fc73cf" alt="image" loading="lazy">

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/1b2344fb-bfb4-467b-9dbb-05e4eff23d06" alt="image" loading="lazy">

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/fcaa2337-cfce-4e0c-b068-a7de2c0eff78" alt="image" loading="lazy">

<br>

問題文の繰り返しは、3回までは性能が向上する。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/e333e807-24d4-4a64-b768-cbd6dfbceecd" alt="image" loading="lazy">このpromptingは複雑な問題であればあるほど効果があると推察される。</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2023-10-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1105">Self-RAG: Learning to Retrieve, Generate, and Critique through   Self-Reflection, Akari Asai+, N_A, ICLR'24</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）は、事実に基づかない回答を生成することがあります。そこで、自己反省的な検索増強生成（Self-RAG）という新しいフレームワークを提案します。このフレームワークは、検索と自己反省を通じてLLMの品質と事実性を向上させます。実験結果は、Self-RAGが最先端のLLMsおよび検索増強モデルを大幅に上回ることを示しています。</span>
<span class="snippet"><span>Comment</span>RAGをする際の言語モデルの回答の質とfactual consistencyを改善せるためのフレームワーク。

<br>

reflection tokenと呼ばれる特殊トークンを導入し、言語モデルが生成の過程で必要に応じて情報をretrieveし、自身で生成内容を批評するように学習する。単語ごとに生成するのではなく、セグメント単位で生成する候補を生成し、批評内容に基づいて実際に生成するセグメントを選択する。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/282eb6fd-d2bd-4804-a0bc-652158e2f857" alt="image" loading="lazy">

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/cf690500-7002-454d-bc7c-0664d152a664" alt="image" loading="lazy">OpenReview:https://openreview.net/forum?id=hSyW5go0v8</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-10-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1072">Think before you speak: Training Language Models With Pause Tokens, Sachin Goyal+, N_A, ICLR'24</a>
<span class="snippet"><span>Summary</span>言語モデルのトレーニングと推論において、遅延を導入することでモデルの性能を向上させる手法を提案しました。具体的には、入力に特定のトークンを追加し、そのトークンが現れるまでモデルの出力を遅らせることで、追加の計算を行うことができます。実験結果では、この手法が推論タスクにおいて有益であり、特にQAタスクでの性能向上が見られました。今後は、この遅延予測の手法をさらに研究していく必要があります。</span>
<span class="snippet"><span>Comment</span>この研究は興味深いが、事前学習時に入れないと効果が出にくいというのは直感的にわかるので、実用的には活用しづらい。

<br>

また、promptでこの研究をimitateする方法については、ZeroShot CoTにおいて、思考プロセスを明示的に指定するようなpromptingと同様のことを行っており、これは実際に効果があると思う。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/NAACL.html">#NAACL</a>
<span class="issue_date">Issue Date: 2023-10-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1060">Effective Long-Context Scaling of Foundation Models, Wenhan Xiong+, N_A, NAACL'24</a>
<span class="snippet"><span>Summary</span>私たちは、長いコンテキストをサポートする一連のLLMsを提案します。これらのモデルは、長いテキストを含むデータセットでトレーニングされ、言語モデリングや他のタスクで評価されます。提案手法は、通常のタスクと長いコンテキストのタスクの両方で改善をもたらします。また、70Bバリアントはgpt-3.5-turbo-16kを上回るパフォーマンスを実現します。さらに、私たちはLlamaの位置エンコーディングや事前学習プロセスの設計選択の影響についても分析しました。結果から、長いコンテキストの継続的な事前学習が効果的であることが示されました。</span>
<span class="snippet"><span>Comment</span>以下elvis氏のツイートの意訳

<br>



<br>

Metaが32kのcontext windowをサポートする70BのLLaMa2のvariant提案し、gpt-3.5-turboをlong contextが必要なタスクでoutperform。

<br>

short contextのLLaMa2を継続的に訓練して実現。これには人手で作成したinstruction tuning datasetを必要とせず、コスト効率の高いinstruction tuningによって実現される。

<br>

これは、事前学習データセットに長いテキストが豊富に含まれることが優れたパフォーマンスの鍵ではなく、ロングコンテキストの継続的な事前学習がより効率的であることを示唆している。

<br>

元ツイート: https://x.com/omarsar0/status/1707780482178400261?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q位置エンコーディングにはlong contxet用にRoPEのrotation angleを小さくしたものを利用。

<br>

また、単に長いコンテキストのデータを追加するだけでなく、データセット内における長いコンテキストのデータの比率を調整することで、より高い性能が発揮できることを示している。これをData Mixと呼ぶ。

<br>

また、instruction tuningのデータには、LLaMa2ChatのRLHFデータをベースに、LLaMa2Chat自身にself-instructを活用して、長いコンテキストを生成させ拡張したものを利用した。

<br>

具体的には、コーパス内のlong documentを用いたQAフォーマットのタスクに着目し、文書内のランダムなチャンクからQAを生成させた。その後、self-critiqueによって、LLaMa2Chat自身に、生成されたQAペアのverificationも実施させた。</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2023-09-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1044">[Paper Note] Chain-of-Verification Reduces Hallucination in Large Language Models, Shehzaad Dhuliawala+, N_A, ACL'24</a>
<span class="snippet"><span>Summary</span>私たちは、言語モデルが根拠のない情報を生成する問題に取り組んでいます。Chain-of-Verification（CoVe）メソッドを開発し、モデルが回答を作成し、検証し、最終的な回答を生成するプロセスを経ることで、幻想を減少させることができることを実験で示しました。</span>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

ユーザの質問から、Verificationのための質問をplanningし、質問に対して独立に回答を得たうえでオリジナルの質問に対するaggreementを確認し、最終的に生成を実施するPrompting手法

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/18763903-2d70-4180-9384-2da55bedad2e" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

評価

<br>



<br>

dataset

<br>



<br>

・Wikidata

<br>



<br>

    ・Wikipedia APIから自動生成した「“Who are some [Profession]s who were born in [City]?”」に対するQA pairs

<br>



<br>

    ・Goldはknowledge baseから取得

<br>



<br>

    ・全56 test questions

<br>



<br>

    ・Gold Entityが大体600程度ありLLMは一部しか回答しないので、precisionで評価

<br>



<br>

・Wiki category list

<br>



<br>

    ・QUEST datasetを利用 701 

<br>



<br>

    ・回答にlogical operationが不要なものに限定して頭に"Name some"をつけて質問を生成

<br>



<br>

        ・"Name some Mexican animated horror films" or "Name some Endemic orchids of Vietnam"

<br>



<br>

    ・8個の回答を持つ55 test questionsを作成

<br>



<br>

・MultiSpanQA

<br>



<br>

    ・Reading Comprehensionに関するBenchmark dataset

<br>



<br>

    ・複数の独立した回答（回答は連続しないスパンから回答が抽出される）から構成される質問で構成

<br>



<br>

        ・特に、今回はclosed-book setting で実施

<br>



<br>

        ・すなわち、与えられた質問のみから回答しなければならず、知っている知識が問われる問題

<br>



<br>

    ・418のtest questsionsで、各回答に含まれる複数アイテムのspanが3 token未満となるようにした

<br>



<br>

    ・QA例:

<br>



<br>

        ・Q: Who invented the first printing press and in what year?

<br>



<br>

        ・A: Johannes Gutenberg, 1450.

<br>



<br>

評価結果

<br>



<br>

提案手法には、verificationの各ステップでLLMに独立したpromptingをするかなどでjoint, 2-step, Factored, Factor+Revisedの4種類のバリエーションがあることに留意。

<br>



<br>

・joint: 全てのステップを一つのpromptで実施

<br>



<br>

・2-stepは2つのpromptに分けて実施

<br>



<br>

・Factoredは各ステップを全て異なるpromptingで実施

<br>



<br>

・Factor+Revisedは異なるpromptで追加のQAに対するcross-checkをかける手法

<br>



<br>

結果を見ると、CoVEでhallucinationが軽減され、特にjointよりも2-step, factoredの方が高い性能を示すことがわかる。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/05ff1e6c-75e7-428a-996f-61e844866391" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/d72aa05e-daab-4092-a6f5-9e80cdab7486" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2023-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/924">SelfCheck: Using LLMs to Zero-Shot Check Their Own Step-by-Step   Reasoning, Ning Miao+, N_A, ICLR'24</a>
<span class="snippet"><span>Summary</span>最新の大規模言語モデル（LLMs）は、推論問題を解決するために有望な手法ですが、複雑な問題にはまだ苦戦しています。本研究では、LLMsが自身のエラーを認識する能力を持っているかどうかを探求し、ゼロショットの検証スキームを提案します。この検証スキームを使用して、異なる回答に対して重み付け投票を行い、質問応答のパフォーマンスを向上させることができることを実験で確認しました。</span>
<span class="snippet"><span>Comment</span>これはおもしろそう。後で読むOpenReview:https://openreview.net/forum?id=pTHfApDakA</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<a class="button" href="articles/COLM.html">#COLM</a>
<span class="issue_date">Issue Date: 2023-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/917">LoraHub: Efficient Cross-Task Generalization via Dynamic LoRA   Composition, Chengsong Huang+, N_A, COLM'24</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）を新しいタスクに適応させるための低ランク適応（LoRA）を検討し、LoraHubというフレームワークを提案します。LoraHubを使用すると、少数の例から複数のLoRAモジュールを組み合わせて柔軟に適応性のあるパフォーマンスを実現できます。また、追加のモデルパラメータや勾配は必要ありません。実験結果から、LoraHubが少数の例でのインコンテキスト学習のパフォーマンスを効果的に模倣できることが示されています。さらに、LoRAコミュニティの育成と共有リソースの提供にも貢献しています。</span>
<span class="snippet"><span>Comment</span>学習されたLoRAのパラメータをモジュールとして捉え、新たなタスクのinputが与えられた時に、LoRA Hub上の適切なモジュールをLLMに組み合わせることで、ICL無しで汎化を実現するというアイデア。few shotのexampleを人間が設計する必要なく、同等の性能を達成。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/9d769042-5a29-4c22-8ab4-e90195f71184" alt="image" loading="lazy">複数のLoRAモジュールは組み合わられるか？element wiseの線型結合で今回はやっているが、その疑問にこたえたのがcontributionOpenReview:https://openreview.net/forum?id=TrloAXEJ2B</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/872">SciBench: Evaluating College-Level Scientific Problem-Solving Abilities   of Large Language Models, Xiaoxuan Wang+, N_A, ICML'24</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）の進歩により、数学のベンチマークでの性能向上が示されているが、これらのベンチマークは限定的な範囲の問題に限定されていることが指摘される。そこで、複雑な科学的問題解決に必要な推論能力を検証するための包括的なベンチマークスイートSciBenchを提案する。SciBenchには、大学レベルの科学的問題を含むオープンセットと、学部レベルの試験問題を含むクローズドセットの2つのデータセットが含まれている。さらに、2つの代表的なLLMを用いた詳細なベンチマーク研究を行い、現在のLLMのパフォーマンスが不十分であることを示した。また、ユーザースタディを通じて、LLMが犯すエラーを10の問題解決能力に分類し、特定のプロンプティング戦略が他の戦略よりも優れているわけではないことを明らかにした。SciBenchは、LLMの推論能力の向上を促進し、科学研究と発見に貢献することを目指している。</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/LearningToRank.html">#LearningToRank</a>
<a class="button" href="articles/PairWise.html">#PairWise</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/NAACL.html">#NAACL</a>
<span class="issue_date">Issue Date: 2023-07-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/799">Large Language Models are Effective Text Rankers with Pairwise Ranking   Prompting, Zhen Qin+, N_A, NAACL'24</a>
<span class="snippet"><span>Summary</span>LLMsを使用してドキュメントをランキングする際に、Pairwise Ranking Prompting（PRP）という新しい技術を提案する。PRPは、LLMsへの負荷を軽減し、最先端のランキングパフォーマンスを達成することができる。具体的には、20Bパラメータを持つFlan-UL2モデルに基づくPRPは、商用のGPT-4に基づく従来の手法を上回る結果を示した。さらに、PRPのバリアントを提案し、効率を改善することができることを示した。PRPは生成とスコアリングのLLM APIの両方をサポートし、入力の順序に対して無感度であることも示された。</span>
<span class="snippet"><span>Comment</span>open source LLMにおいてスタンダードなランキングタスクのベンチマークでSoTAを達成できるようなprompting技術を提案従来のランキングのためのpromptingはpoint-wiseとlist wiseしかなかったが、前者は複数のスコアを比較するためにスコアのcalibrationが必要だったり、OpenAIなどのAPIはlog probabilityを提供しないため、ランキングのためのソートができないという欠点があった。後者はinputのorderingに非常にsensitiveであるが、listのすべての組み合わせについてorderingを試すのはexpensiveなので厳しいというものであった。このため（古典的なlearning to rankでもおなじみや）pairwiseでサンプルを比較するランキング手法PRPを提案している。

<br>



<br>

PRPはペアワイズなのでorderを入れ替えて評価をするのは容易である。また、generation modeとscoring mode（outputしたラベルのlog probabilityを利用する; OpenLLMを使うのでlog probabilityを計算できる）の2種類を採用できる。ソートの方法についても、すべてのペアの勝敗からから単一のスコアを計算する方法（AllPair), HeapSortを利用する方法、LLMからのoutputを得る度にon the flyでリストの順番を正しくするSliding Windowの3種類を提案して比較している。

<br>

<img src="https://github.com/user-attachments/assets/7ad366c6-2afd-404b-9e7d-6051030983c6" alt="image" loading="lazy">

<br>



<br>

下表はscoring modeでの性能の比較で、GPT4に当時は性能が及んでいなかった20BのOpenLLMで近しい性能を達成している。

<br>

<img src="https://github.com/user-attachments/assets/7455b844-107f-4e88-85b8-3b5fc2866cc8" alt="image" loading="lazy">

<br>



<br>

また、PRPがinputのorderに対してロバストなことも示されている。

<br>

<img src="https://github.com/user-attachments/assets/5244fb56-a9bf-46c9-89ca-f2766f7ba4a0" alt="image" loading="lazy"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<a class="button" href="articles/TACL.html">#TACL</a>
<span class="issue_date">Issue Date: 2023-07-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/793">Lost in the Middle: How Language Models Use Long Contexts, Nelson F. Liu+, N_A, TACL'24</a>
<span class="snippet"><span>Summary</span>最近の言語モデルは、長い文脈を入力として受け取ることができますが、その長い文脈をどれだけうまく利用しているかについてはまだよくわかっていません。この研究では、マルチドキュメントの質問応答とキー・バリューの検索という2つのタスクにおいて、言語モデルのパフォーマンスを分析しました。その結果、関連情報が入力文脈の始まりや終わりにある場合、パフォーマンスが最も高くなることがわかりましたが、長い文脈の中で関連情報にアクセスする必要がある場合、パフォーマンスが著しく低下します。さらに、入力文脈が長くなるにつれて、明示的に長い文脈を扱うモデルでもパフォーマンスが大幅に低下します。この分析は、言語モデルが入力文脈をどのように利用しているかをより良く理解するためのものであり、将来の長い文脈モデルのための新しい評価プロトコルを提供します。</span>
<span class="snippet"><span>Comment</span>元ツイート

<br>

https://twitter.com/drjimfan/status/1678460065811136512?s=46&t=5BO_qSlNBSEGSugyUlP5Hw

<br>



<br>

非常に重要な知見がまとめられている1. モデルはコンテキストのはじめと最後の情報をうまく活用でき、真ん中の情報をうまく活用できない

<br>

2. 長いコンテキストのモデルを使っても、コンテキストをより短いコンテキストのモデルよりもうまく考慮できるわけではない

<br>

3. モデルのパフォーマンスは、コンテキストが長くなればなるほど悪化する</span>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<span class="issue_date">Issue Date: 2023-04-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/561">Harnessing the Power of LLMs in Practice: A Survey on ChatGPT and Beyond, Yang+, Amazon, TKDD'24</a>
<span class="snippet"><span>Summary</span>本記事は、自然言語処理（NLP）タスクにおける大規模言語モデル（LLMs）の実践的なガイドを提供し、モデルやデータ、タスクに関する洞察を示します。LLMsの概要、データの影響、知識集約型タスクや生成タスクにおける使用ケースと非使用ケースを詳述し、実用的な応用と限界を探ります。また、虚偽のバイアスや展開時の考慮事項についても言及し、研究者や実務者に役立つベストプラクティスを提供します。関連リソースは定期的に更新され、オンラインでアクセス可能です。</span>
<span class="snippet"><span>Comment</span>LLMに関するチュートリアル

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/235145819-842cdef3-485c-4553-b234-46d4896a5ed7.png" alt="image" loading="lazy">

<br>



<br>

encoder-onlyとまとめられているものの中には、デコーダーがあるものがあり（autoregressive decoderではない）、

<br>

encoder-decoderは正しい意味としてはencoder with autoregressive decoderであり、

<br>

decoder-onlyは正しい意味としてはautoregressive encoder-decoder

<br>

とのこと。

<br>

https://twitter.com/ylecun/status/1651762787373428736?s=46&t=-zElejt4asTKBGLr-c3bKw</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2023-04-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/554">Active prompting with chain-of-thought for large language models, Diao+, The Hong Kong University of Science and Technology, ACL'24</a>
<span class="snippet"><span>Comment</span>しっかりと読めていないが、CoT-answerが存在しないtrainingデータが存在したときに、nサンプルにCoTとAnswerを与えるだけでFew-shotの予測をtestデータに対してできるようにしたい、というのがモチベーションっぽい

<br>



<br>

そのために、questionに対して、training dataに対してFew-Shot CoTで予測をさせた場合やZero-Shot CoTによって予測をさせた場合などでanswerを取得し、answerのばらつき度合いなどから不確実性を測定する。

<br>



<br>

そして、不確実性が高いCoT-Answerペアを取得し、人間が手作業でCoTと回答のペアを与え、その人間が作成したものを用いてTestデータに対してFewShotしましょう、ということだと思われる。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234747555-4b7bd0d5-f099-4288-a470-32206533e652.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/SpeechProcessing.html">#SpeechProcessing</a>
<a class="button" href="articles/AAAI.html">#AAAI</a>
<span class="issue_date">Issue Date: 2023-04-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/547">AudioGPT: Understanding and Generating Speech, Music, Sound, and Talking Head, AAAI'24</a>
<span class="snippet"><span>Summary</span>AudioGPTは、複雑な音声情報を処理し、音声対話をサポートするマルチモーダルAIシステムである。基盤モデルとASR、TTSインターフェースを組み合わせ、音声、音楽、トーキングヘッドの理解と生成を行う。実験により、AudioGPTが多様なオーディオコンテンツの創造を容易にする能力を示した。</span>
<span class="snippet"><span>Comment</span>text, audio, imageといったマルチモーダルなpromptから、audioに関する様々なタスクを実現できるシステムマルチモーダルデータをjointで学習したというわけではなく、色々なモデルの組み合わせてタスクを実現しているっぽい

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234739859-f833706a-6040-484a-b015-553a719484d7.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<span class="issue_date">Issue Date: 2023-04-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/542">Scaling Instruction-Finetuned Language Models, Chung+, Google, JMLR'24</a>
<span class="snippet"><span>Summary</span>指示ファインチューニングは、タスク数、モデルサイズ、チェーン・オブ・ソートデータを活用し、言語モデルの性能を向上させる手法である。Flan-PaLM 540Bは1.8Kタスクでファインチューニングされ、PaLM 540Bを上回る+9.4%の改善を達成し、MMLUで75.2%の性能を示した。Flan-T5も強力な少数ショット性能を発揮し、指示ファインチューニングは事前学習モデルの性能向上に寄与する。</span>
<span class="snippet"><span>Comment</span>T5をinstruction tuningしたFlanT5の研究</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/DataGeneration.html">#DataGeneration</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2023-04-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/533">WizardLM: Empowering Large Language Models to Follow Complex Instructions, Xu+, Microsoft_Peking University, ICLR'24</a>
<span class="snippet"><span>Summary</span>本論文では、LLMを用いて複雑な指示データを自動生成する手法Evol-Instructを提案。初期の指示セットを段階的に書き換え、生成したデータでLLaMAをファインチューニングし、WizardLMモデルを構築。評価結果では、Evol-Instructからの指示が人間作成のものより優れ、WizardLMはChatGPTを上回る性能を示した。AI進化による指示生成がLLM強化の有望なアプローチであることを示唆。</span>
<span class="snippet"><span>Comment</span>instruction trainingは大きな成功を収めているが、人間がそれらのデータを作成するのはコストがかかる。また、そもそも複雑なinstructionを人間が作成するのは苦労する。そこで、LLMに自動的に作成させる手法を提案している（これはself instructと一緒）。データを生成する際は、seed setから始め、step by stepでinstructionをrewriteし、より複雑なinstructionとなるようにしていく。

<br>

これらの多段的な複雑度を持つinstructionをLLaMaベースのモデルに食わせてfinetuningした（これをWizardLMと呼ぶ）。人手評価の結果、WizardLMがChatGPTよりも好ましいレスポンスをすることを示した。特に、WizaraLMはコード生成や、数値計算といった難しいタスクで改善を示しており、複雑なinstructionを学習に利用することの重要性を示唆している。EvolInstructを提案。"1+1=?"といったシンプルなinstructionからスタートし、これをLLMを利用して段階的にcomplexにしていく。complexにする方法は2通り：

<br>



<br>

・In-Depth Evolving: instructionを5種類のoperationで深掘りする（blue direction line）

<br>



<br>

  ・add constraints

<br>



<br>

  ・deepening

<br>



<br>

  ・concretizing

<br>



<br>

  ・increase reasoning steps

<br>



<br>

  ・complicate input

<br>



<br>

・In-breadth Evolving: givenなinstructionから新しいinstructionを生成する

<br>



<br>



<br>



<br>

上記のEvolvingは特定のpromptを与えることで実行される。

<br>



<br>

また、LLMはEvolvingに失敗することがあるので、Elimination Evolvingと呼ばれるフィルタを利用してスクリーニングした。

<br>



<br>

フィルタリングでは4種類の失敗するsituationを想定し、1つではLLMを利用。2枚目画像のようなinstructionでフィルタリング。

<br>



<br>

1. instructionの情報量が増えていない場合。

<br>



<br>

2. instructionがLLMによって応答困難な場合（短すぎる場合やsorryと言っている場合）

<br>



<br>

3. puctuationやstop wordsによってのみ構成されている場合 

<br>



<br>

4.明らかにpromptの中から単語をコピーしただけのinstruction（given prompt, rewritten prompt, Rewritten Promptなど）

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234436445-e84ff44e-7b0b-4217-a735-7444b04bd760.png" alt="image" loading="lazy">

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234437210-6cb6d75f-509a-4f2e-a767-dba8861d8a69.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2025-08-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2400">[Paper Note] Physics of Language Models: Part 1, Learning Hierarchical Language  Structures, Zeyuan Allen-Zhu+, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、Transformerベースの言語モデルが文脈自由文法（CFG）による再帰的な言語構造推論をどのように行うかを調査。合成CFGを用いて長文を生成し、GPTのようなモデルがCFGの階層を正確に学習・推論できることを示す。モデルの隠れ状態がCFGの構造を捉え、注意パターンが動的プログラミングに類似していることが明らかに。また、絶対位置埋め込みの劣位や均一な注意の効果、エンコーダ専用モデルの限界、構造的ノイズによる堅牢性向上についても考察。</span>
<span class="snippet"><span>Comment</span>解説:

<br>

・1834</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<span class="issue_date">Issue Date: 2025-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2275">[Paper Note] Large Language Models Can Self-Improve, Jiaxin Huang+, EMNLP'23</a>
<span class="snippet"><span>Summary</span>LLMはラベルのないデータセットで自己改善可能であることを示し、Chain-of-Thoughtプロンプティングと自己一貫性を利用して高信頼度の回答を生成。これにより、540BパラメータのLLMの推論能力を向上させ、最先端のパフォーマンスを達成。ファインチューニングが自己改善に重要であることも確認。</span>
<span class="snippet"><span>Comment</span>openreview: https://openreview.net/forum?id=uuUQraD4XX&noteId=PWDEpZtn6P<img width="851" height="476" alt="Image" src="https://github.com/user-attachments/assets/39d3bf0f-09fa-4257-8239-573c491df4fb"></span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<a class="button" href="articles/ICCV.html">#ICCV</a>
<span class="issue_date">Issue Date: 2025-06-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2111">[Paper Note] Sigmoid Loss for Language Image Pre-Training, Xiaohua Zhai+, ICCV'23</a>
<span class="snippet"><span>Summary</span>シンプルなペアワイズシグモイド損失（SigLIP）を提案し、画像-テキストペアに基づく言語-画像事前学習を改善。シグモイド損失はバッチサイズの拡大を可能にし、小さなバッチサイズでも性能向上を実現。SigLiTモデルは84.5%のImageNetゼロショット精度を達成。バッチサイズの影響を研究し、32kが合理的なサイズであることを確認。モデルは公開され、さらなる研究の促進を期待。</span>
<span class="snippet"><span>Comment</span>SigLIP論文</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Inference.html">#Inference</a>
<span class="issue_date">Issue Date: 2025-06-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2028">[Paper Note] SARATHI: Efficient LLM Inference by Piggybacking Decodes with Chunked  Prefills, Amey Agrawal+, arXiv'23</a>
<span class="snippet"><span>Summary</span>SARATHIは、LLMの推論効率を向上させる手法で、プレフィルリクエストをチャンクに分割し、デコードマキシマルバッチを構築することで計算利用率を最大化します。これにより、デコードスループットを最大10倍向上させ、エンドツーエンドスループットも改善。特に、A6000 GPU上のLLaMA-13Bモデルで顕著な性能向上を示し、パイプラインバブルを大幅に削減しました。</span>
<span class="snippet"><span>Comment</span>vLLMでも採用されている `Chunked Prefills` と `Decode-Maximal Batching` を提案している。

<br>

![Image](https://github.com/user-attachments/assets/4db0f73d-bdf4-4c2b-a765-2c9b242904f1)</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/Parallelism.html">#Parallelism</a>
<span class="issue_date">Issue Date: 2025-05-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1970">Sequence Parallelism: Long Sequence Training from System Perspective, Li+, ACL'23</a>
<span class="snippet"><span>Comment</span>入力系列をチャンクに分割して、デバイスごとに担当するチャンクを決めることで原理上無限の長さの系列を扱えるようにした並列化手法。系列をデバイス間で横断する場合attention scoreをどのように計算するかが課題になるが、そのためにRing Self attentionと呼ばれるアルゴリズムを提案している模様。また、MLPブロックとMulti Head Attentonブロックの計算も、BatchSize  Sequence Lengthの大きさが、それぞれ32Hidden Size, 16Attention Head size  of Attention Headよりも大きくなった場合に、Tensor Parallelismよりもメモリ効率が良くなるらしい。

<br>

<img src="https://github.com/user-attachments/assets/f3ba9010-da3a-4c3a-8515-d3715466ff59" alt="image" loading="lazy">Data Parallel, Pipeline Parallel, Tensor Parallel、全てに互換性があるとのこと（併用可能）そのほかの並列化の解説については

<br>

・1184

<br>



<br>

を参照のこと。</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/ITI%20(Inference%20Time%20Intervention).html">#ITI (Inference Time Intervention)</a>
<a class="button" href="articles/Probing.html">#Probing</a>
<a class="button" href="articles/Trustfulness.html">#Trustfulness</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-05-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1941">Inference-Time Intervention: Eliciting Truthful Answers from a Language   Model, Kenneth Li+, NeurIPS'23</a>
<span class="snippet"><span>Summary</span>Inference-Time Intervention (ITI)を提案し、LLMsの真実性を向上させる技術を紹介。ITIは推論中にモデルの活性化を調整し、LLaMAモデルの性能をTruthfulQAベンチマークで大幅に改善。Alpacaモデルでは真実性が32.5%から65.1%に向上。真実性と有用性のトレードオフを特定し、介入の強度を調整する方法を示す。ITIは低コストでデータ効率が高く、数百の例で真実の方向性を特定可能。LLMsが虚偽を生成しつつも真実の内部表現を持つ可能性を示唆。</span>
<span class="snippet"><span>Comment</span>Inference Time Interventionを提案した研究。Attention Headに対して線形プロービング[^1]を実施し、真実性に関連するであろうHeadをtopKで特定できるようにし、headの出力に対し真実性を高める方向性のベクトルvを推論時に加算することで（＝intervention）、モデルの真実性を高める。vは線形プロービングによって学習された重みを使う手法と、正答と誤答の活性化の平均ベクトルを計算しその差分をvとする方法の二種類がある。後者の方が性能が良い。topKを求める際には、線形プロービングをしたモデルのvalidation setでの性能から決める。Kとαはハイパーパラメータである。

<br>



<br>

[^1]: headのrepresentationを入力として受け取り、線形モデルを学習し、線形モデルの2値分類性能を見ることでheadがどの程度、プロービングの学習に使ったデータに関する情報を保持しているかを測定する手法

<br>



<br>

日本語解説スライド:https://www.docswell.com/s/DeepLearning2023/Z38P8D-2024-06-20-131813p1これは相当汎用的に使えそうな話だから役に立ちそう</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-04-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1881">PaLI-3 Vision Language Models: Smaller, Faster, Stronger, Xi Chen+, arXiv'23</a>
<span class="snippet"><span>Summary</span>PaLI-3は、従来のモデルに比べて10倍小型で高速な視覚言語モデル（VLM）であり、特にローカリゼーションや視覚的テキスト理解において優れた性能を示す。SigLIPベースのPaLIは、20億パラメータにスケールアップされ、多言語クロスモーダル検索で新たな最先端を達成。50億パラメータのPaLI-3は、VLMの研究を再燃させることを期待されている。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=JpyWPfzu0b

<br>



<br>

実験的に素晴らしい性能が実現されていることは認められつつも

<br>

・比較対象がSigLIPのみでより広範な比較実験と分析が必要なこと

<br>

・BackboneモデルをContrastive Learningすること自体の有用性は既に知られており、新規性に乏しいこと

<br>



<br>

としてICLR'24にRejectされている</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/PositionalEncoding.html">#PositionalEncoding</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-04-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1865">The Impact of Positional Encoding on Length Generalization in   Transformers, Amirhossein Kazemnejad+, NeurIPS'23</a>
<span class="snippet"><span>Summary</span>長さ一般化はTransformerベースの言語モデルにおける重要な課題であり、位置エンコーディング（PE）がその性能に影響を与える。5つの異なるPE手法（APE、T5の相対PE、ALiBi、Rotary、NoPE）を比較した結果、ALiBiやRotaryなどの一般的な手法は長さ一般化に適しておらず、NoPEが他の手法を上回ることが明らかになった。NoPEは追加の計算を必要とせず、絶対PEと相対PEの両方を表現可能である。さらに、スクラッチパッドの形式がモデルの性能に影響を与えることも示された。この研究は、明示的な位置埋め込みが長いシーケンスへの一般化に必須でないことを示唆している。</span>
<span class="snippet"><span>Comment</span>・1863

<br>



<br>

において、Llama4 Scoutが10Mコンテキストウィンドウを実現できる理由の一つとのこと。

<br>



<br>

元ポスト:https://x.com/drjimfan/status/1908615861650547081?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

Llama4のブログポストにもその旨記述されている:

<br>

&gt;A key innovation in the Llama 4 architecture is the use of interleaved attention layers without positional embeddings. Additionally, we employ inference time temperature scaling of attention to enhance length generalization.

<br>



<br>

[The Llama 4 herd: The beginning of a new era of natively multimodal AI innovation](https://ai.meta.com/blog/llama-4-multimodal-intelligence/?utm_source=twitter&utm_medium=organic_social&utm_content=image&utm_campaign=llama4)斜め読みだが、length generalizationを評価する上でdownstream taskに焦点を当て、3つの代表的なカテゴリに相当するタスクで評価したところ、この観点においてはT5のrelative positinal encodingとNoPE（位置エンコードディング無し）のパフォーマンスが良く、

<br>



<br>

<img src="https://github.com/user-attachments/assets/dddadfff-ab28-4073-96c3-831eb16845a0" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/c6ec8e0e-7abb-4330-be23-2261486a477c" alt="image" loading="lazy">

<br>



<br>

NoPEは絶対位置エンコーディングと相対位置エンコーディングを理論上実現可能であり[^1]

<br>

<img src="https://github.com/user-attachments/assets/bbcf797a-d394-42d4-b017-08d7dba4261c" alt="image" loading="lazy">

<br>



<br>

実際に学習された異なる2つのモデルに対して同じトークンをそれぞれinputし、同じ深さのLayerの全てのattention distributionの組み合わせからJensen Shannon Divergenceで距離を算出し、最も小さいものを2モデル間の当該layerの距離として可視化すると下記のようになり、NoPEとT5のrelative positional encodingが最も類似していることから、NoPEが学習を通じて（実用上は）相対位置エンコーディングのようなものを学習することが分かった。

<br>

<img src="https://github.com/user-attachments/assets/9619c7e5-0612-45de-8717-1634bee509b7" alt="image" loading="lazy">

<br>



<br>

[^1]:深さ1のLayerのHidden State H^1から絶対位置の復元が可能であり（つまり、当該レイヤーのHが絶対位置に関する情報を保持している）、この前提のもと、後続のLayerがこの情報を上書きしないと仮定した場合に、相対位置エンコーディングを実現できる。また、CoT/Scratchpadはlong sequenceに対する汎化性能を向上させることがsmall scaleではあるが先行研究で示されており、Positional Encodingを変化させた時にCoT/Scratchpadの性能にどのような影響を与えるかを調査。

<br>



<br>

具体的には、CoT/Scratchpadのフォーマットがどのようなものが有効かも明らかではないので、5種類のコンポーネントの組み合わせでフォーマットを構成し、mathematical reasoningタスクで以下のような設定で訓練し

<br>



<br>

・さまざまなコンポーネントの組み合わせで異なるフォーマットを作成し、

<br>

・全ての位置エンコーディングあり/なしモデルを訓練

<br>



<br>

これらを比較した。この結果、CoT/Scratchpadはフォーマットに関係なく、特定のタスクでのみ有効（有効かどうかはタスク依存）であることが分かった。このことから、CoT/Scratcpad（つまり、モデルのinputとoutputの仕方）単体で、long contextに対する汎化性能を向上させることができないので、Positional Encoding（≒モデルのアーキテクチャ）によるlong contextに対する汎化性能の向上が非常に重要であることが浮き彫りになった。

<br>

<img src="https://github.com/user-attachments/assets/e23c4fbf-84de-4344-a01e-1e7e9e66fa7e" alt="image" loading="lazy">

<br>



<br>

また、CoT/Scratchpadが有効だったAdditionに対して各Positional Embeddingモデルを学習し、生成されたトークンのattentionがどの位置のトークンを指しているかを相対距離で可視化したところ（0が当該トークン、つまり現在のScratchpadに着目しており、1が遠いトークン、つまりinputに着目していることを表すように正規化）、NoPEとRelative Positional Encodingがshort/long rangeにそれぞれフォーカスするようなbinomialな分布なのに対し、他のPositional Encodingではよりuniformな分布であることが分かった。このタスクにおいてはNoPEとRelative POの性能が高かったため、binomialな分布の方がより最適であろうことが示唆された。

<br>

<img src="https://github.com/user-attachments/assets/833e6a81-8611-4e79-9d2e-473f7ebee2d0" alt="image" loading="lazy">

<br>

</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<span class="issue_date">Issue Date: 2025-04-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1848">SWE-bench: Can Language Models Resolve Real-World GitHub Issues?, Carlos E. Jimenez+, arXiv'23</a>
<span class="snippet"><span>Summary</span>SWE-benchは、12の人気Pythonリポジトリから得られた2,294のソフトウェアエンジニアリング問題を評価するフレームワークで、言語モデルがコードベースを編集して問題を解決する能力を測定します。評価の結果、最先端の商用モデルや微調整されたモデルSWE-Llamaも最も単純な問題しか解決できず、Claude 2はわずか1.96%の問題を解決するにとどまりました。SWE-benchは、より実用的で知的な言語モデルへの進展を示しています。</span>
<span class="snippet"><span>Comment</span>ソフトウェアエージェントの最もpopularなベンチマーク

<br>



<br>

<img width="693" alt="Image" src="https://github.com/user-attachments/assets/ac905221-d3b1-4d16-b447-3bdd4d5e97bb">

<br>



<br>

主にpythonライブラリに関するリポジトリに基づいて構築されている。

<br>

<img width="731" alt="Image" src="https://github.com/user-attachments/assets/14d26dd1-6b4a-4337-a652-4e48e36d633b">SWE-Bench, SWE-Bench Lite, SWE-Bench Verifiedの3種類がありソフトウェアエージェントではSWE-Bench Verifiedを利用して評価することが多いらしい。Verifiedでは、issueの記述に曖昧性がなく、適切なunittestのスコープが適切なもののみが採用されているとのこと（i.e., 人間の専門家によって問題がないと判断されたもの）。

<br>

https://www.swebench.com/</span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Contents-based.html">#Contents-based</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<a class="button" href="articles/Zero/FewShotLearning.html">#Zero/FewShotLearning</a>
<a class="button" href="articles/RecSys.html">#RecSys</a>
<span class="issue_date">Issue Date: 2025-03-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1841">TALLRec: An Effective and Efficient Tuning Framework to Align Large   Language Model with Recommendation, Keqin Bao+, RecSys'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）を推薦システムに活用するため、推薦データで調整するフレームワークTALLRecを提案。限られたデータセットでもLLMsの推薦能力を向上させ、効率的に実行可能。ファインチューニングされたLLMはクロスドメイン一般化を示す。</span>
<span class="snippet"><span>Comment</span>下記のようなユーザのプロファイルとターゲットアイテムと、binaryの明示的なrelevance feedbackデータを用いてLoRA、かつFewshot Learningの設定でSFTすることでbinaryのlike/dislikeの予測性能を向上。PromptingだけでなくSFTを実施した初めての研究だと思われる。

<br>

<img src="https://github.com/user-attachments/assets/08ea2d35-1dd1-4670-810b-a57722173460" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/acf565f8-9541-4fe1-95e8-10cff397fa7a" alt="image" loading="lazy">

<br>



<br>

既存ベースラインと比較して大幅にAUCが向上

<br>

<img src="https://github.com/user-attachments/assets/141a0c43-0504-4da3-84d9-c4dac119b590" alt="image" loading="lazy"></span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-03-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1829">Scaling Data-Constrained Language Models, Niklas Muennighoff+, NeurIPS'23</a>
<span class="snippet"><span>Summary</span>言語モデルのスケーリングにおいて、データ制約下でのトレーニングを調査。9000億トークンと90億パラメータのモデルを用いた実験で、繰り返しデータを使用しても損失に大きな変化は見られず、繰り返しの価値が減少することを確認。計算最適性のスケーリング法則を提案し、データ不足を軽減するアプローチも実験。得られたモデルとデータセットは公開。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=j5BuTrEj35チンチラ則のようなScaling Lawsはパラメータとデータ量の両方をスケールさせた場合の前提に立っており、かつデータは全てuniqueである前提だったが、データの枯渇が懸念される昨今の状況に合わせて、データ量が制限された状況で、同じデータを繰り返し利用する（＝複数エポック学習する）ことが一般的になってきた。このため、データのrepetitionに関して性能を事前学習による性能の違いを調査して、repetitionとパラメータ数に関するスケーリング則を提案（$3.1)しているようである。

<br>



<br>

Takeawayとしては、データが制限された環境下では、repetitionは上限4回までが効果的（コスパが良い）であり（左図）、小さいモデルを複数エポック訓練する方が固定されたBudgetの中で低いlossを達成できる右図）。

<br>

<img src="https://github.com/user-attachments/assets/4e62cd1b-fe83-4d6e-a40d-df992c85def3" alt="image" loading="lazy">

<br>



<br>

学習データの半分をコードにしても性能の劣化はなく、様々なタスクの性能が向上しパフォーマンスの分散も小さくなる、といったことが挙げられるようだ。

<br>

<img src="https://github.com/user-attachments/assets/d404156f-7416-4f22-aa7e-d342065435ee" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2025-01-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1668">Navigate through Enigmatic Labyrinth A Survey of Chain of Thought  Reasoning: Advances, Frontiers and Future, Zheng Chu+, arXiv'23</a>
<span class="snippet"><span>Summary</span>推論はAIにおいて重要な認知プロセスであり、チェーン・オブ・ソートがLLMの推論能力を向上させることが注目されている。本論文では関連研究を体系的に調査し、手法を分類して新たな視点を提供。課題や今後の方向性についても議論し、初心者向けの導入を目指す。リソースは公開されている。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<span class="issue_date">Issue Date: 2025-01-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1657">Program of Thoughts Prompting: Disentangling Computation from Reasoning   for Numerical Reasoning Tasks, Wenhu Chen+, TMLR'23</a>
<span class="snippet"><span>Summary</span>段階的な推論を用いた数値推論タスクにおいて、Chain-of-thoughts prompting（CoT）の進展があり、推論をプログラムとして表現する「Program of Thoughts」（PoT）を提案。PoTは外部コンピュータで計算を行い、5つの数学問題データセットと3つの金融QAデータセットで評価した結果、少数ショットおよびゼロショット設定でCoTに対して約12％の性能向上を示した。自己一貫性デコーディングとの組み合わせにより、数学問題データセットで最先端の性能を達成。データとコードはGitHubで公開。</span>
<span class="snippet"><span>Comment</span>1. LLMsは算術演算を実施する際にエラーを起こしやすく、特に大きな数に対する演算を実施する際に顕著

<br>

2. LLMsは複雑な数式（e.g. 多項式, 微分方程式）を解くことができない

<br>

3. LLMsはiterationを表現するのが非常に非効率

<br>



<br>

の3点を解決するために、外部のインタプリタに演算処理を委譲するPoTを提案。PoTでは、言語モデルにreasoning stepsをpython programで出力させ、演算部分をPython Interpreterに実施させる。

<br>



<br>

<img src="https://github.com/user-attachments/assets/ccaeee09-ca6f-45ec-aef4-c65960d52692" alt="image" loading="lazy">テキスト、テーブル、対話などの多様なinputをサポートする5つのMath Word Problem （MWP）, 3つのFinancial Datasetで評価した結果、zero-shot, few-shotの両方の設定において、PoTはCoTをoutpeformし、また、Self-Consistencyと組み合わせた場合も、PoTはCoTをoutperformした。

<br>

<img src="https://github.com/user-attachments/assets/6b380fab-ab60-4f21-bce1-532167c8c8f2" alt="image" loading="lazy"></span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-01-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1656">Recursion of Thought: A Divide-and-Conquer Approach to Multi-Context  Reasoning with Language Models, Soochan Lee+, arXiv'23</a>
<span class="snippet"><span>Summary</span>Recursion of Thought（RoT）という新しい推論フレームワークを提案し、言語モデル（LM）が問題を複数のコンテキストに分割することで推論能力を向上させる。RoTは特別なトークンを導入し、コンテキスト関連の操作をトリガーする。実験により、RoTがLMの推論能力を劇的に向上させ、数十万トークンの問題を解決できることが示された。</span>
<span class="snippet"><span>Comment</span>divide-and-conquerで複雑な問題に回答するCoT手法。生成過程でsubquestionが生じた際にモデルに特殊トークン（GO）を出力させ、subquestionの回答部分に特殊トークン（THINK）を出力させるようにSupervisedに学習させる。最終的にTHINKトークン部分は、subquestionを別途モデルによって解いた回答でreplaceして、最終的な回答を得る。

<br>

subquestionの中でさらにsubquestionが生じることもあるため、再帰的に処理される。

<br>

<img src="https://github.com/user-attachments/assets/6a5a5155-b3dd-4a6a-a9f5-0975dddcedb7" alt="image" loading="lazy">四則演算と4種類のアルゴリズムに基づくタスクで評価。アルゴリズムに基づくタスクは、2つの数のlongest common subsequenceを見つけて、そのsubsequenceとlengthを出力するタスク（LCS）、0-1 knapsack問題、行列の乗算、数値のソートを利用。x軸が各タスクの問題ごとの問題の難易度を表しており、難易度が上がるほど提案手法によるgainが大きくなっているように見える。

<br>



<br>

Without Thoughtでは直接回答を出力させ、CoTではground truthとなるrationaleを1つのcontextに与えて回答を生成している。RoTではsubquestionごとに回答を別途得るため、より長いcontextを活用して最終的な回答を得る点が異なると主張している。

<br>



<br>

<img src="https://github.com/user-attachments/assets/8e713c76-5f79-40c7-87b0-d69f6fac3ee3" alt="image" loading="lazy">

<br>

感想としては、ベースラインが弱すぎると感じる。詳細が書かれていないが、おそらくRoTはSFTによって各タスクに特化した学習をしていると考えられる（タスクごとの特殊トークンが存在するため）。ベースラインとしてRoT無しでSFTしたモデルあった方が良いのではないか？と感じる。

<br>



<br>

また、学習データにおけるsubquestionとsubquestionに対するground truthのデータ作成方法は書かれているが、そもそも元データとして何を利用したかや、その統計量も書かれていないように見える。あと、そもそも機械的に学習データを作成できない場合どうすれば良いのか？という疑問は残る。読んでいた時にAuto-CoTとの違いがよくわからなかったが、Related Workの部分にはAuto-CoTは動的、かつ多様なデモンストレーションの生成にフォーカスしているが、AutoReasonはquestionを分解し、few-shotの promptingでより詳細なrationaleを生成することにフォーカスしている点が異なるという主張のようである。

<br>



<br>

・556Auto-CoTとの差別化は上記で理解できるが、G-Evalが実施しているAuto-CoTとの差別化はどうするのか？という風にふと思った。論文中でもG-Evalは引用されていない。

<br>



<br>

素朴にはAutoReasonはSFTをして学習をしています、さらにRecursiveにquestionをsubquestionを分解し、分解したsubquestionごとに回答を得て、subquestionの回答結果を活用して最終的に複雑なタスクの回答を出力する手法なので、G-Evalが実施している同一context内でrationaleをzeroshotで生成する手法よりも、より複雑な問題に回答できる可能性が高いです、という主張にはなりそうではある。

<br>



<br>

・1223ICLR 2023 OpenReview:https://openreview.net/forum?id=PTUcygUoxuc

<br>



<br>

・提案手法は一般的に利用可能と主張しているが、一般的に利用するためには人手でsubquestionの学習データを作成する必要があるため十分に一般的ではない

<br>

・限られたcontext長に対処するために再帰を利用するというアイデアは新しいものではなく、数学の定理の証明など他の設定で利用されている

<br>



<br>

という理由でrejectされている。</span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/SequentialRecommendation.html">#SequentialRecommendation</a>
<span class="issue_date">Issue Date: 2024-12-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1625">Recommender Systems with Generative Retrieval, Shashank Rajput+, arXiv'23</a>
<span class="snippet"><span>Summary</span>新しい生成的検索アプローチを提案し、アイテムのセマンティックIDを自己回帰的にデコード。Transformerベースのモデルが次のアイテムのセマンティックIDを予測し、レコメンデーションタスクにおいて初のセマンティックIDベースの生成モデルとなる。提案手法は最先端モデルを大幅に上回り、過去の対話履歴がないアイテムに対する検索性能も向上。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Quantization.html">#Quantization</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2024-12-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1570">SmoothQuant: Accurate and Efficient Post-Training Quantization for Large   Language Models, Guangxuan Xiao+, ICML'23</a>
<span class="snippet"><span>Summary</span>SmoothQuantは、トレーニング不要で8ビットの重みと活性化の量子化を実現するポストトレーニング量子化ソリューションです。活性化の外れ値を滑らかにすることで、量子化の難易度を軽減し、精度を保持しつつ最大1.56倍の速度向上と2倍のメモリ削減を達成しました。これにより、530BのLLMを単一ノードで運用可能にし、LLMsの民主化を促進します。コードは公開されています。</span>
<span class="snippet"><span>Comment</span>おそらく量子化手法の現時点のSoTA</span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<span class="issue_date">Issue Date: 2024-12-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1568">Recommender Systems in the Era of Large Language Models （LLMs）, Zihuai Zhao+, arXiv'23</a>
<span class="snippet"><span>Summary</span>レコメンダーシステムは、ユーザーの好みに基づいた提案を提供する重要な要素であり、DNNの限界を克服するためにLLMsの活用が進んでいる。本論文では、LLMを用いたレコメンダーシステムの事前学習、ファインチューニング、プロンプティングに関する包括的なレビューを行い、ユーザーとアイテムの表現学習手法や最近の技術を紹介し、今後の研究方向性について議論する。</span>
<span class="snippet"><span>Comment</span>

<br>

中身を全然読んでいる時間はないので、図には重要な情報が詰まっていると信じ、図を読み解いていく。時間がある時に中身も読みたい。。。

<br>



<br>

LLM-basedなRecSysでは、NLPにおけるLLMの使い方（元々はT5で提案）と同様に、様々なレコメンド関係タスクを、テキスト生成タスクに落とし込み学習することができる。

<br>

<img src="https://github.com/user-attachments/assets/78faeea5-8e1f-49d5-93a8-9ea97d5a3170" alt="image" loading="lazy">

<br>

RecSysのLiteratureとしては、最初はコンテンツベースと協調フィルタリングから始まり、（グラフベースドな推薦, Matrix Factorization, Factorization Machinesなどが間にあって）、その後MLP, RNN, CNN, AutoEncoderなどの様々なDeep Neural Network（DNN）を活用した手法や、BERT4RecなどのProbabilistic Language Models（PLM）を用いた手法にシフトしていき、現在LLM-basedなRecSysの時代に到達した、との流れである。

<br>

<img src="https://github.com/user-attachments/assets/6c319f48-3c2f-4c0d-97d6-693fb8ba85cf" alt="image" loading="lazy">

<br>



<br>

LLM-basedな手法では、pretrainingの段階からEncoder-basedなモデルの場合はMLM、Decoder-basedな手法ではNext Token Predictionによってデータセットで事前学習する方法もあれば、フルパラメータチューニングやPEFT（LoRAなど）によるSFTによるアプローチもあるようである。

<br>



<br>

推薦タスクは、推薦するアイテムIDを生成するようなタスクの場合は、異なるアイテムID空間に基づくデータセットの間では転移ができないので、SFTをしないとなかなかうまくいかないと気がしている。また、その場合はアイテムIDの推薦以外のタスクも同時に実施したい場合は、事前学習済みのパラメータが固定されるPEFT手法の方が安全策になるかなぁ、という気がしている（破壊的忘却が怖いので）。特はたとえば、アイテムIDを生成するだけでなく、その推薦理由を生成できるのはとても良いことだなあと感じる（良い時代、感）。

<br>

<img src="https://github.com/user-attachments/assets/19474960-ac0d-4a61-915e-15a910504a3f" alt="image" loading="lazy">

<br>



<br>

また、PromptingによるRecSysの流れも図解されているが、In-Context Learningのほかに、Prompt Tuning（softとhardの両方）、Instruction Tuningも同じ図に含まれている。個人的にはPrompt TuningはPEFTの一種であり、Instruction TuningはSFTの一種なので、一つ上の図に含意される話なのでは?という気がするが、論文中ではどのような立て付けで記述されているのだろうか。

<br>

どちらかというと、Promptingの話であれば、zero-few-many shotや、各種CoTの話を含めるのが自然な気がするのだが。

<br>

<img src="https://github.com/user-attachments/assets/a1db1dba-ba13-44b0-ad9c-017ca9164ed2" alt="image" loading="lazy">

<br>



<br>

下図はPromptingによる手法を表にまとめたもの。Finetuningベースの手法が別表にまとめられていたが、研究の数としてはこちらの方が多そうに見える。が、性能的にはどの程度が達成されるのだろうか。直感的には、アイテムを推薦するようなタスクでは、Promptingでは性能が出にくいような印象がある。なぜなら、事前学習済みのLLMはアイテムIDのトークン列とアイテムの特徴に関する知識がないので。これをFinetuningしないのであればICLで賄うことになると思うのだが、果たしてどこまでできるだろうか…。興味がある。

<br>

<img src="https://github.com/user-attachments/assets/997e2bd9-68bd-4b72-92d4-72495a329dda" alt="image" loading="lazy">

<br>



<br>

（図は論文より引用）</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Diversity.html">#Diversity</a>
<span class="issue_date">Issue Date: 2024-12-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1567">Increasing Diversity While Maintaining Accuracy: Text Data Generation with Large Language Models and Human Interventions, John Chung+, ACL'23, 2023.07</a>
<span class="snippet"><span>Summary</span>本研究では、LLMを用いたテキストデータ生成における多様性と精度を向上させるための人間とAIのパートナーシップを探求。ロジット抑制と温度サンプリングの2つのアプローチで多様性を高める一方、ラベル置換（LR）と範囲外フィルタリング（OOSF）による人間の介入を検討。LRはモデルの精度を14.4%向上させ、一部のモデルは少数ショット分類を上回る性能を示したが、OOSFは効果がなかった。今後の研究の必要性が示唆される。</span>
<span class="snippet"><span>Comment</span>生成テキストの質を維持しつつ、多様性を高める取り組み。多様性を高める取り組みとしては3種類の方法が試されており、

<br>



<br>

・Logit Suppression: 生成されたテキストの単語生成頻度をロギングし、頻出する単語にpenaltyをかける方法

<br>



<br>

・High Temperature: temperatureを[0.3, 0.7, 0.9, 1.3]にそれぞれ設定して単語をサンプリングする方法

<br>



<br>

・Seeding Example: 生成されたテキストを、seedとしてpromptに埋め込んで生成させる方法

<br>



<br>



<br>



<br>

で実験されている。</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2024-12-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1560">Improving the Domain Adaptation of Retrieval Augmented Generation （RAG） Models for Open Domain Question Answering, Siriwardhana+, TACL'23, 2023.01</a>
<span class="snippet"><span>Summary</span>RAG-end2endは、ODQAにおけるドメイン適応のためにRAGのリトリーバーとジェネレーターを共同訓練する新しいアプローチを提案。外部知識ベースを更新し、補助的な訓練信号を導入することで、ドメイン特化型知識を強化。COVID-19、ニュース、会話のデータセットで評価し、元のRAGモデルよりも性能が向上。研究はオープンソースとして公開。</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2024-11-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1546">Sparse Upcycling: Training Mixture-of-Experts from Dense Checkpoints, Aran Komatsuzaki+, ICLR'23</a>
<span class="snippet"><span>Summary</span>スパース活性化モデルは、計算コストを抑えつつ密なモデルの代替として注目されているが、依然として多くのデータを必要とし、ゼロからのトレーニングは高コストである。本研究では、密なチェックポイントからスパース活性化Mixture-of-Expertsモデルを初期化する「スパースアップサイクリング」を提案。これにより、初期の密な事前トレーニングのコストを約50%再利用し、SuperGLUEやImageNetで密なモデルを大幅に上回る性能を示した。また、アップサイクリングされたモデルは、ゼロからトレーニングされたスパースモデルよりも優れた結果を得た。</span>
<span class="snippet"><span>Comment</span>斜め読みしかできていないが、Mixture-of-Expertsを用いたモデルをSFT/Pretrainingする際に、既存のcheckpointの重みを活用することでより効率的かつ性能向上する方法を提案。MoE LayerのMLPを全て既存のcheckpointにおけるMLPの重みをコピーして初期化する。Routerはスクラッチから学習する。

<br>

<img src="https://github.com/user-attachments/assets/d51a0746-d2cc-4343-a462-20034ef373d9" alt="image" loading="lazy">

<br>



<br>

継続事前学習においては、同じ学習時間の中でDense Layerを用いるベースラインと比較してでより高い性能を獲得。

<br>

<img src="https://github.com/user-attachments/assets/d7a67c99-15d7-4803-82e4-63187bb3d4ec" alt="image" loading="lazy">

<br>

Figure2で継続事前学習したモデルに対して、フルパラメータのFinetuningをした場合でもUpcyclingは効果がある（Figure3）。

<br>



<br>

特にPretrainingではUpcyclingを用いたモデルの性能に、通常のMoEをスクラッチから学習したモデルが追いつくのに時間がかかるとのこと。特に図右側の言語タスクでは、120%の学習時間が追いつくために必要だった。

<br>

<img src="https://github.com/user-attachments/assets/f0ca37ac-65a7-43ff-afef-ffc309b17040" alt="image" loading="lazy">

<br>



<br>

Sparse Upcycingと、Dense tilingによる手法（warm start; 元のモデルに既存の層を複製して新しい層を追加する方法）、元のモデルをそれぞれ継続事前学習すると、最も高い性能を獲得している。

<br>

<img src="https://github.com/user-attachments/assets/b357a08a-d202-47d3-977f-f02b192723d1" alt="image" loading="lazy">

<br>



<br>

（すごい斜め読みなのでちょっも自信なし、、、）</span>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2024-11-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1534">Prompting Large Language Model for Machine Translation: A Case Study, Biao Zhang+, arXiv'23</a>
<span class="snippet"><span>Summary</span>機械翻訳におけるプロンプティングの研究を体系的に行い、プロンプトテンプレートやデモ例の選択に影響を与える要因を検討。GLM-130Bを用いた実験により、プロンプト例の数と質が翻訳に重要であること、意味的類似性などの特徴がパフォーマンスと相関するが強くないこと、単言語データからの擬似平行プロンプト例が翻訳を改善する可能性があること、他の設定からの知識転送がパフォーマンス向上に寄与することを示した。プロンプティングの課題についても議論。</span>
<span class="snippet"><span>Comment</span>zero-shotでMTを行うときに、改行の有無や、少しのpromptingの違いでCOMETスコアが大幅に変わることを示している。

<br>



<br>

モデルはGLM-130BをINT4で量子化したモデルで実験している。

<br>



<br>

興味深いが、この知見を一般化して全てのLLMに適用できるか？と言われると、そうはならない気がする。他のモデルで検証したら傾向はおそらく変わるであろう（という意味でおそらく論文のタイトルにもCase Studyと記述されているのかなあ）。

<br>



<br>



<br>



<br>

<img src="https://github.com/user-attachments/assets/1302dbb2-40e2-40c2-9a71-cae01528b5e6" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2024-11-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1498">Precise Zero-Shot Dense Retrieval without Relevance Labels, Luyu Gao+, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、ゼロショット密な検索システムの構築において、仮想文書埋め込み（HyDE）を提案。クエリに基づき、指示に従う言語モデルが仮想文書を生成し、教師なしで学習されたエンコーダがこれを埋め込みベクトルに変換。実際のコーパスに基づく類似文書を取得することで、誤った詳細をフィルタリング。実験結果では、HyDEが最先端の密な検索器Contrieverを上回り、様々なタスクと言語で強力なパフォーマンスを示した。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Zero/FewShotPrompting.html">#Zero/FewShotPrompting</a>
<a class="button" href="articles/Self-SupervisedLearning.html">#Self-SupervisedLearning</a>
<span class="issue_date">Issue Date: 2024-10-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1448">SINC: Self-Supervised In-Context Learning for Vision-Language Tasks, Yi-Syuan Chen+, N_A, ICCV'23</a>
<span class="snippet"><span>Summary</span>自己教師あり文脈内学習（SINC）フレームワークを提案し、大規模言語モデルに依存せずに文脈内学習を実現。特別に調整されたデモンストレーションを用いたメタモデルが、視覚と言語のタスクで少数ショット設定において勾配ベースの手法を上回る性能を示す。SINCは文脈内学習の利点を探求し、重要な要素を明らかにする。</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2024-09-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1424">UL2: Unifying Language Learning Paradigms, Yi Tay+, N_A, ICLR'23</a>
<span class="snippet"><span>Summary</span>本論文では、事前学習モデルの普遍的なフレームワークを提案し、事前学習の目的とアーキテクチャを分離。Mixture-of-Denoisers（MoD）を導入し、複数の事前学習目的の効果を示す。20Bパラメータのモデルは、50のNLPタスクでSOTAを達成し、ゼロショットやワンショット学習でも優れた結果を示す。UL2 20Bモデルは、FLAN指示チューニングにより高いパフォーマンスを発揮し、関連するチェックポイントを公開。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=6ruVLB727MC[R] standard span corruption, [S] causal language modeling, [X] extreme span corruption の3種類のパラダイムを持つMoD (Mixture of Denoisers)を提案

<br>



<br>

<img width="1187" height="1203" alt="Image" src="https://github.com/user-attachments/assets/a07372c6-854c-4bd1-8f59-f8c4dbdc5d23"></span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<span class="issue_date">Issue Date: 2024-09-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1401">Instruction Tuning with GPT-4, Baolin Peng+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>GPT-4を用いて指示に従うデータを生成し、LLMのファインチューニングを行う初の試みを報告。生成された52Kの指示データは、従来のモデルよりも新しいタスクに対して優れたゼロショット性能を示した。GPT-4からのフィードバックと比較データも収集し、データとコードベースを公開。</span>
<span class="snippet"><span>Comment</span>現在はOpenAIの利用規約において、outputを利用してOpenAIと競合するモデルを構築することは禁止されているので、この点には注意が必要

<br>

https://openai.com/ja-JP/policies/terms-of-use/</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SelfCorrection.html">#SelfCorrection</a>
<span class="issue_date">Issue Date: 2024-09-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1382">Large Language Models Cannot Self-Correct Reasoning Yet, Jie Huang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>LLMsの自己修正能力を批判的に検討し、内在的自己修正の概念を中心に、外部フィードバックなしでの応答修正の難しさを示す。自己修正後にパフォーマンスが低下することもあり、今後の研究や応用に向けた提案を行う。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/SelfCorrection.html">#SelfCorrection</a>
<span class="issue_date">Issue Date: 2024-09-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1380">Reflection-Tuning: Data Recycling Improves LLM Instruction-Tuning, Ming Li+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>リフレクションチューニングという新手法を提案し、LLMsの自己改善を通じて低品質なトレーニングデータの問題に対処。オラクルLLMを用いてデータの質を向上させ、実験により再利用データで訓練されたLLMsが既存モデルを上回ることを示した。</span>
<span class="snippet"><span>Comment</span>Reflection-Tuningを提案している研究?</span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/ConversationalRecommenderSystems.html">#ConversationalRecommenderSystems</a>
<span class="issue_date">Issue Date: 2024-08-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1346">Leveraging Large Language Models in Conversational Recommender Systems, Luke Friedman+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>LLMsを使用した大規模な会話型推薦システム（CRS）の構築に関する論文の要約です。LLMsを活用したユーザーの好み理解、柔軟なダイアログ管理、説明可能な推薦の新しい実装を提案し、LLMsによって駆動される統合アーキテクチャの一部として説明します。また、LLMが解釈可能な自然言語のユーザープロファイルを利用してセッションレベルのコンテキストを調整する方法についても説明します。さらに、LLMベースのユーザーシミュレータを構築して合成会話を生成する技術を提案し、LaMDAをベースにしたYouTubeビデオの大規模CRSであるRecLLMを紹介します。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-05-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1309">Mistral 7B, Albert Q. Jiang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>Mistral 7B v0.1は、70億パラメータの言語モデルであり、高速な推論のためにGQAを活用し、SWAを組み合わせている。また、Mistral 7B -InstructはLlama 2 13B -Chatモデルを上回っており、Apache 2.0ライセンスの下で公開されています。</span>
<span class="snippet"><span>Comment</span>1237 1279 などのモデルも参照のこと

<br>



<br>



<br>



<br>

モデルのスケールが大きくなると、inferenceのlatencyが遅くなり、計算コストが大きくなりすぎて実用的でないので、小さいパラメータで素早いinference実現したいよね、というモチベーション。

<br>



<br>

そのために、SlidingWindowAttentionとGroupQueryAttention 1271 を活用している。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/154bc04b-5056-4b88-8b4d-deff169d4a10" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

より小さいパラメータ数でLlama2を様々なタスクでoutperformし

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/d2890d33-4895-4d09-aa22-5566a471f41f" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Instruction Tuningを実施したモデルは、13BモデルよりもChatbotArenaで高いElo Rateを獲得した。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/9f37a61e-0cf1-4712-a912-4f7e77094072" alt="image" loading="lazy">

<br>



<br>

コンテキスト長は8192</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Annotation.html">#Annotation</a>
<span class="issue_date">Issue Date: 2024-05-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1304">Benchmarking Large Language Models for News Summarization, Tianyi Zhang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>LLMsの成功の理由を理解するために、異なる事前学習方法、プロンプト、およびモデルスケールにわたる10つのLLMsに対する人間の評価を行った。その結果、モデルサイズではなく、指示の調整がLLMのゼロショット要約能力の鍵であることがわかった。また、LLMsの要約は人間の執筆した要約と同等と判断された。</span>
<span class="snippet"><span>Comment</span>・ニュース記事の高品質な要約を人間に作成してもらい、gpt-3.5を用いてLLM-basedな要約も生成

<br>



<br>

・annotatorにそれぞれの要約の品質をスコアリングさせたデータセットを作成</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<span class="issue_date">Issue Date: 2024-04-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1271">GQA: Training Generalized Multi-Query Transformer Models from Multi-Head  Checkpoints, Joshua Ainslie+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>Multi-query attention（MQA）は、単一のkey-value headのみを使用しており、デコーダーの推論を劇的に高速化しています。ただし、MQAは品質の低下を引き起こす可能性があり、さらには、より速い推論のためだけに別個のモデルをトレーニングすることが望ましくない場合もあります。既存のマルチヘッド言語モデルのチェックポイントを、オリジナルの事前トレーニング計量の5%を使用してMQAを持つモデルにアップトレーニングするためのレシピを提案し、さらに、複数のkey-value headを使用するマルチクエリアテンションの一般化であるグループ化クエリアテンション（GQA）を紹介します。アップトレーニングされたGQAが、MQAと同等の速度でマルチヘッドアテンションに匹敵する品質を達成することを示しています。</span>
<span class="snippet"><span>Comment</span>通常のMulti-Head AttentionがQKVが1対1対応なのに対し、Multi Query Attention (MQA) 1272  は全てのQに対してKVを共有する。一方、GQAはグループごとにKVを共有する点で異なる。MQAは大幅にInfeerence` speedが改善するが、精度が劣化する問題があった。この研究では通常のMulti-Head Attentionに対して、オリジナルの事前学習に対して追加の5%の計算量でGQAモデルを学習する手法を提案している。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/70ec2179-428c-47b8-af53-cb3cc0e4f022" alt="image" loading="lazy">

<br>



<br>

Main Result. Multi-Head Attentionに対して、inference timeが大幅に改善しているが、Multi-Query Attentionよりも高い性能を維持している。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/3687aeb4-90b8-403d-853b-740121dd5f98" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Explanation.html">#Explanation</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2024-01-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1224">INSTRUCTSCORE: Explainable Text Generation Evaluation with Finegrained   Feedback, Wenda Xu+, N_A, EMNLP'23</a>
<span class="snippet"><span>Summary</span>自動的な言語生成の品質評価には説明可能なメトリクスが必要であるが、既存のメトリクスはその判定を説明したり欠陥とスコアを関連付けることができない。そこで、InstructScoreという新しいメトリクスを提案し、人間の指示とGPT-4の知識を活用してテキストの評価と診断レポートを生成する。さまざまな生成タスクでInstructScoreを評価し、他のメトリクスを上回る性能を示した。驚くべきことに、InstructScoreは人間の評価データなしで最先端のメトリクスと同等の性能を達成する。</span>
<span class="snippet"><span>Comment</span>伝統的なNLGの性能指標の解釈性が低いことを主張する研究<img src="https://github.com/user-attachments/assets/4c4fe705-e0c5-41d1-b3c8-c084d85b77ba" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<span class="issue_date">Issue Date: 2024-01-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1223">G-Eval: NLG Evaluation using GPT-4 with Better Human Alignment, Yang Liu+, N_A, EMNLP'23</a>
<span class="snippet"><span>Summary</span>従来の参照ベースの評価指標では、自然言語生成システムの品質を正確に測定することが難しい。最近の研究では、大規模言語モデル（LLMs）を使用した参照ベースの評価指標が提案されているが、まだ人間との一致度が低い。本研究では、G-Evalという大規模言語モデルを使用した品質評価フレームワークを提案し、要約と対話生成のタスクで実験を行った。G-Evalは従来の手法を大幅に上回る結果を示し、LLMベースの評価器の潜在的な問題についても分析している。コードはGitHubで公開されている。</span>
<span class="snippet"><span>Comment</span>伝統的なNLGの性能指標が、人間の判断との相関が低いことを示した研究手法概要

<br>



<br>

・CoTを利用して、生成されたテキストの品質を評価する手法を提案している。

<br>



<br>

・タスクのIntroductionと、評価のCriteriaをプロンプトに仕込むだけで、自動的にLLMに評価ステップに関するCoTを生成させ、最終的にフォームを埋める形式でスコアをテキストとして生成させ評価を実施する。最終的に、各スコアの生成確率によるweighted-sumによって、最終スコアを決定する。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/a91c9234-6f41-4fb4-a94f-8a47a594dd9e" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Scoringの問題点

<br>



<br>

たとえば、1-5のdiscreteなスコアを直接LLMにoutputさせると、下記のような問題が生じる：

<br>



<br>

1. ある一つのスコアが支配的になってしまい、スコアの分散が無く、人間の評価との相関が低くなる

<br>



<br>

2. LLMは小数を出力するよう指示しても、大抵の場合整数を出力するため、多くのテキストの評価値が同一となり、生成されたテキストの細かな差異を評価に取り入れることができない。

<br>



<br>



<br>



<br>

上記を解決するため、下記のように、スコアトークンの生成確率の重みづけ和をとることで、最終的なスコアを算出している。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/a2a8d26c-0fb4-4f60-bd6e-600898785d7b" alt="image" loading="lazy">評価

<br>



<br>

・SummEval 984 データと、Topical-Chat, QAGSデータの3つのベンチマークで評価を実施した。タスクとしては、要約と対話のresponse generationのデータとなる。

<br>



<br>

・モデルはGPT-3.5 (text-davinci-003), GPT-4を利用した

<br>



<br>

・gpt3.5利用時は、temperatureは0に設定し、GPT-4はトークンの生成確率を返さないので、`n=20, temperature=1, top_p=1`とし、20回の生成結果からトークンの出現確率を算出した。

<br>



<br>



<br>



<br>

評価結果

<br>



<br>

G-EVALがbaselineをoutperformし、特にGPT4を利用した場合に性能が高い。GPTScoreを利用した場合に、モデルを何を使用したのかが書かれていない。Appendixに記述されているのだろうか。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/924b0acd-6236-49a0-a6bc-ae203c87f7ea" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/435fa260-a88d-4db2-b3a2-40d29a6617df" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/f9ca4e1f-903d-48fa-a40f-64fa8c799c43" alt="image" loading="lazy">

<br>



<br>

Analysis

<br>



<br>

G-EvalがLLMが生成したテキストを好んで高いスコアを付与してしまうか？

<br>



<br>

・人間に品質の高いニュース記事要約を書かせ、アノテータにGPTが生成した要約を比較させたデータ (1304) を用いて検証

<br>



<br>

・その結果、基本的にGPTが生成した要約に対して、G-EVAL4が高いスコアを付与する傾向にあることがわかった。

<br>



<br>

    ・原因1: 1304で指摘されている通り、人間が記述した要約とLLMが記述した要約を区別するタスクは、inter-annotator agreementは`0.07`であり、極端に低く、人間でも困難なタスクであるため。

<br>



<br>

    ・原因2: LLMは生成時と評価時に、共通したコンセプトをモデル内部で共有している可能性が高く、これがLLMが生成した要約を高く評価するバイアスをかけた

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/ec6a213d-15ea-4572-8716-ad9cbee6f19a" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

CoTの影響

<br>



<br>

・SummEvalデータにおいて、CoTの有無による性能の差を検証した結果、CoTを導入した場合により高いcorrelationを獲得した。特に、Fluencyへの影響が大きい。

<br>



<br>



<br>



<br>

Probability Normalizationによる影響

<br>



<br>

・probabilityによるnormalizationを導入したことで、kendall tauが減少した。この理由は、probabilityが導入されていない場合は多くの引き分けを生み出す。一方、kendall tauは、concordant / discordantペアの数によって決定されるが、引き分けの場合はどちらにもカウントされず、kendall tauの値を押し上げる効果がある。このため、これはモデルの真の性能を反映していない。

<br>



<br>

・一方、probabilityを導入すると、より細かいな連続的なスコアを獲得することができ、これはspearman-correlationの向上に反映されている。

<br>



<br>



<br>



<br>

モデルサイズによる影響

<br>



<br>

・基本的に大きいサイズの方が高いcorrelationを示す。特に、consistencyやrelevanceといった、複雑な評価タスクではその差が顕著である。

<br>



<br>

・一方モデルサイズが小さい方が性能が良い観点（engagingness, groundedness）なども存在した。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<span class="issue_date">Issue Date: 2023-12-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1194">Gemini: A Family of Highly Capable Multimodal Models, Gemini Team+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>この報告書では、マルチモーダルモデル「Gemini」のファミリーについて紹介します。Geminiは画像、音声、動画、テキストの理解に優れた能力を持ち、Ultra、Pro、Nanoのサイズがあります。Gemini Ultraは幅広いベンチマークで最先端の技術を提供し、MMLUでは人間の専門家のパフォーマンスを初めて達成しました。Geminiモデルはクロスモーダルな推論と言語理解の能力を持ち、さまざまなユースケースに適用できます。また、ユーザーへの責任ある展開についても議論しています。</span>
<span class="snippet"><span>Comment</span>1181 で発表されたGeminiの論文</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<span class="issue_date">Issue Date: 2023-12-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1181">Gemini, Google'23</a>
<span class="snippet"><span>Comment</span>多くのベンチマークでGPT4超えらしい

<br>



<br>

（追記1）

<br>

テクニカルレポートのp.44を見ると、ブログポスト中のGPT4のMMLUのスコアはGPT-4-0613のもののようなので、これが正しいとすると他のベンチマークのスコアも同モデルのものである可能性が高く、GPT-4-1163-preview（最新モデル）のスコアでは"ないかもしれない"点に注意。GPT4とどちらが実際に性能が良いか?については様子見した方が良さそう。

<br>



<br>

（追記2）

<br>

GSM8Kの結果も、GPT4に対してFair Comparisonではないかもしれない点に注意。Geminiは32個のCoTとSelf-Consistencyを利用しているが、GPT4では5-shotで単一のCoTのみであるため、prompting手法ではGeminiに有利な比較となっているように見える。ただしGPT4はGSM8Kの訓練データを事前学習時にMIXしている（SFT）ので、Geminiがこのようなことをしていないのであれば、この点ではGPT4が有利になっている“可能性”がある。

<br>



<br>

他にもFair Comparisonになっていないと推察されるものはTextモダリティでの評価の表の文言を見るとありそうなのでそこは念頭においた方が良さそうである。テクニカルレポート: https://storage.googleapis.com/deepmind-media/gemini/gemini_1_report.pdfGemini Summary

<br>

https://x.com/srush_nlp/status/1732427569352323401?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QMMLUでの同じprompting手法でのGPT-4-0613との比較。32個のCoTでのSelf-Consistencyで比較した場合、GPT-4-0613に負けているが、閾値を設けてconfidenceが閾値以上の場合はSelf-consistency, そうでない場合はgreedyに生成した結果を選択する、というUncertain-Routed CoT@32では、Geminiのパフォーマンスgainが大きくGPT-4-0613よりも高い性能を示している。

<br>

ブログポスト中のGPT4のスコアは5-shotのもの（reportedと書かれているのでOpenAIが公表している数値と推察）であり、Geminiの結果はUncertain-Routed CoT@32の結果であるため、Fair Comparisonになっていないかもしれない？点には注意。

<br>



<br>

レポート中ではSelf-consistencyという単語でこの部分は書かれていないが、実は少しやっていること違ってたりする…？

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/ab56b7e0-464a-4e29-84e7-7d1540ef2119" alt="image" loading="lazy"></span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<span class="issue_date">Issue Date: 2023-12-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1179">The Unlocking Spell on Base LLMs: Rethinking Alignment via In-Context  Learning, Bill Yuchen Lin+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>アラインメント調整は、大規模言語モデル（LLMs）のパフォーマンスを向上させるために使用されます。しかし、アラインメント調整の効果は「表面的」である可能性があります。この研究では、基本的なLLMとアラインメント調整されたバージョンのトークン分布のシフトを分析しました。結果は、アラインメント調整が主にスタイルトークンに影響を与えることを示しました。さらに、シンプルでチューニングフリーなアラインメント手法であるURIALを導入し、基本的なLLMのパフォーマンスを向上させることができることを示しました。これらの結果から、アラインメントのより深い分析と理論的な理解が重要であることが示唆されます。</span>
<span class="snippet"><span>Comment</span>モデルの知識はPre-training時に十分獲得されており、モデルのAlignmentをとることで生じるものは表面的な変化のみであるという仮説がある 700 。この仮説に関して分析をし、結果的にスタイリスティックな情報を生成する部分でAlignmentの有無で違いが生じることを明らかにし、そうであればわざわざパラメータチューニング（SFT, RLHF）しなくても、適切なサンプルを選択したIn-Context LearningでもAlignmentとれますよ、という趣旨の研究っぽい？

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/b8c62b33-dd72-43ea-8953-abb5c04cc504" alt="image" loading="lazy"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<span class="issue_date">Issue Date: 2023-12-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1177">Unnatural Error Correction: GPT-4 Can Almost Perfectly Handle Unnatural  Scrambled Text, Qi Cao+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）の内部動作についての新しい洞察を提供します。特に、GPT-4を調査し、LLMsの耐久性に関する実験結果を示します。実験では、文字レベルの順列に対するLLMsの耐性を調べるために、Scrambled Benchというスイートを使用しました。結果は、GPT-4がtypoglycemiaという現象に似た能力を持ち、非常に自然でないエラーを含む入力をほぼ完璧に処理できることを示しています。これは、LLMsの耐性が直感に反するものであり、他のLLMsや人間にとっても困難なタスクであることを示しています。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/df33c7a9-005e-4d7e-9d70-d8f0657869ed" alt="image" loading="lazy">OpenAIのモデルがブラックボックスである限り、コンタミネーションがあるのでは？という疑念は持ってしまう。

<br>



<br>

（部分的にしか読めていないが…）

<br>

RealtimeQAと呼ばれるweeklyで直近のニュースに対するQuestionを発表することで構築されるデータセットのうち、2023.03.17--2023.08.04のデータを収集し、ScrambledSentenaeRecovery（ScrRec）とScrambleQuestionAnswering（ScrQA）の評価データを生成している。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/362bcbca-b578-4f0e-ac4e-e65fd216aeac" alt="image" loading="lazy">

<br>



<br>

完全にランダムに単語の文字をscramble（RS）すると、FalconとLlama2では元のテキストをゼロショットでは再構築できないことが分かる。FewShotではFalconであれば少し解けるようになる。一方、OpenAIのモデル、特にGPT4, GPT3.5-turboではゼロショットでもにり再構築ができている。

<br>



<br>

ScrQAについては、ランダムにscrambleした場合でもMultipleChoiceQuestionなので（RPGと呼ばれるAccの相対的なgainを評価するメトリックを提案している）正解はできている。

<br>



<br>

最初の文字だけを残す場合（KF）最初と最後の文字を残す場合（KFL」については、残す文字が増えるほどどちらのタスクも性能が上がり、最初の文字だけがあればOpenSourceLLMでも（ゼロショットでも）かなり元のテキストの再構築ができるようになっている。また、QAも性能が向上している。完全にランダムに文字を入れ替えたら完全に無理ゲーなのでは、、、、と思ってしまうのだが、FalconでFewshotの場合は一部解けているようだ…。果たしてどういうことなのか…（大文字小文字が保持されたままなのがヒントになっている…？）Appendixに考察がありそうだがまだ読めていない。

<br>



<br>



<br>



<br>

（追記）

<br>



<br>

文全体でランダムに文字を入れ替えているのかと勘違いしていたが、実際には”ある単語の中だけでランダムに入れ替え”だった。これなら原理上はいけると思われる。</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-11-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1163">Exponentially Faster Language Modelling, Peter Belcak+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>UltraFastBERTは、推論時にわずか0.3%のニューロンしか使用せず、同等の性能を発揮することができる言語モデルです。UltraFastBERTは、高速フィードフォワードネットワーク（FFF）を使用して、効率的な実装を提供します。最適化されたベースラインの実装に比べて78倍の高速化を実現し、バッチ処理された推論に対しては40倍の高速化を実現します。トレーニングコード、ベンチマークのセットアップ、およびモデルの重みも公開されています。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/AutomaticPromptEngineering.html">#AutomaticPromptEngineering</a>
<span class="issue_date">Issue Date: 2023-11-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1161">NeuroPrompts: An Adaptive Framework to Optimize Prompts for  Text-to-Image Generation, Shachar Rosenman+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、テキストから画像への生成モデルの品質を向上させるための適応型フレームワークNeuroPromptsを提案します。このフレームワークは、事前学習された言語モデルを使用して制約付きテキストデコーディングを行い、人間のプロンプトエンジニアが生成するものに類似したプロンプトを生成します。これにより、高品質なテキストから画像への生成が可能となり、ユーザーはスタイルの特徴を制御できます。また、大規模な人間エンジニアリングされたプロンプトのデータセットを使用した実験により、当アプローチが自動的に品質の高いプロンプトを生成し、優れた画像品質を実現することを示しました。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<span class="issue_date">Issue Date: 2023-11-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1158">GAIA: a benchmark for General AI Assistants, Grégoire Mialon+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>GAIAは、General AI Assistantsのためのベンチマークであり、AI研究のマイルストーンとなる可能性がある。GAIAは、推論、マルチモダリティの処理、ウェブブラウジングなど、実世界の質問に対する基本的な能力を必要とする。人間の回答者は92％の正答率を達成し、GPT-4は15％の正答率を達成した。これは、最近の傾向とは異なる結果であり、専門的なスキルを必要とするタスクではLLMsが人間を上回っている。GAIAは、人間の平均的な堅牢性と同等の能力を持つシステムがAGIの到来に重要であると考えている。GAIAの手法を使用して、466の質問と回答を作成し、一部を公開してリーダーボードで利用可能にする。</span>
<span class="snippet"><span>Comment</span>Yann LeCun氏の紹介ツイート

<br>

https://x.com/ylecun/status/1727707519470977311?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

Meta-FAIR, Meta-GenAI, HuggingFace, AutoGPTによる研究。人間は92%正解できるが、GPT4でも15%しか正解できないQAベンチマーク。解くために推論やマルチモダリティの処理、ブラウジング、ツールに対する習熟などの基本的な能力を必要とする実世界のQAとのこと。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/0b13838b-0829-48b9-b281-3d09a5a3859f" alt="image" loading="lazy"></span>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<span class="issue_date">Issue Date: 2023-11-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1152">Igniting Language Intelligence: The Hitchhiker's Guide From  Chain-of-Thought Reasoning to Language Agents, Zhuosheng Zhang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）は、言語知能の分野で劇的な進歩を遂げており、複雑な推論タスクにおいて高いパフォーマンスを示しています。特に、chain-of-thought（CoT）推論技術を活用することで、中間ステップを形成し、解釈可能性や制御可能性を向上させることができます。この論文では、CoT技術の基本的なメカニズムやその効果について詳しく解説し、言語エージェントの開発における応用例を紹介しています。将来の研究の展望にも触れており、初心者から経験豊富な研究者まで幅広い読者に対応しています。関連論文のリポジトリも提供されています。</span>
<span class="snippet"><span>Comment</span>CoTに関するチュートリアル論文</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/ContextEngineering.html">#ContextEngineering</a>
<span class="issue_date">Issue Date: 2023-11-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1151">System 2 Attention （is something you might need too）, Jason Weston+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>Transformerベースの大規模言語モデル（LLMs）におけるソフトアテンションは、文脈から無関係な情報を取り込む傾向があり、次のトークン生成に悪影響を与える。そこで、System 2 Attention（S2A）を導入し、LLMsが自然言語で推論し、指示に従う能力を活用して、注目すべき情報を決定する。S2Aは関連する部分のみを含むように入力コンテキストを再生成し、再生成されたコンテキストに注目して最終的な応答を引き出す。実験では、S2Aは3つのタスクで標準のアテンションベースのLLMsよりも優れた性能を発揮し、事実性と客観性を高める。</span>
<span class="snippet"><span>Comment</span>おそらく重要論文How is System 2 Attention different from prompt engineering specialized in factual double checks? I'm very sorry for the extremely delayed response. It's been two years, so you may no longer have a chance to see this, but I'd still like to share my thoughts.

<br>



<br>

I believe that System 2 Attention is fundamentally different in concept from prompt engineering techniques such as factual double-checking. Unlike ad-hoc prompt engineering or approaches that enrich the context by adding new facts through prompting, System 2 Attention aims to improve the model’s reasoning ability itself by mitigating the influence of irrelevant tokens. It does so by selectively generating a new context composed only of relevant tokens, in a way that resembles human System 2 thinking—that is, more objective and deliberate reasoning.

<br>



<br>

From today’s perspective, two years later, I would say that this concept is more closely aligned with what we now refer to as Context Engineering. Thank you.</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<span class="issue_date">Issue Date: 2023-11-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1147">Implicit Chain of Thought Reasoning via Knowledge Distillation, Yuntian Deng+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、言語モデルの内部の隠れ状態を使用して暗黙的な推論を行う手法を提案します。明示的なチェーン・オブ・ソートの推論ステップを生成する代わりに、教師モデルから抽出した暗黙的な推論ステップを使用します。実験により、この手法が以前は解決できなかったタスクを解決できることが示されました。</span>
<span class="snippet"><span>Comment</span>これは非常に興味深い話</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-11-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1144">Contrastive Chain-of-Thought Prompting, Yew Ken Chia+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>言語モデルの推論を改善するために、対照的なchain of thoughtアプローチを提案する。このアプローチでは、有効な推論デモンストレーションと無効な推論デモンストレーションの両方を提供し、モデルが推論を進める際にミスを減らすようにガイドする。また、自動的な方法を導入して対照的なデモンストレーションを構築し、汎化性能を向上させる。実験結果から、対照的なchain of thoughtが一般的な改善手法として機能することが示された。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2023-11-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1140">Chain-of-Note: Enhancing Robustness in Retrieval-Augmented Language  Models, Wenhao Yu+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>検索補完言語モデル（RALM）は、外部の知識源を活用して大規模言語モデルの性能を向上させるが、信頼性の問題や知識の不足による誤った回答がある。そこで、Chain-of-Noting（CoN）という新しいアプローチを導入し、RALMの頑健性を向上させることを目指す。CoNは、順次の読み取りノートを生成し、関連性を評価して最終的な回答を形成する。ChatGPTを使用してCoNをトレーニングし、実験結果はCoNを装備したRALMが標準的なRALMを大幅に上回ることを示している。特に、ノイズの多いドキュメントにおいてEMスコアで平均+7.9の改善を達成し、知識範囲外のリアルタイムの質問に対する拒否率で+10.5の改善を達成している。</span>
<span class="snippet"><span>Comment</span>一番重要な情報がappendixに載っている

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/58dc0468-e3f5-4893-8173-fc891893519f" alt="image" loading="lazy">

<br>

CoNによって、ノイズがあった場合にゲインが大きい。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/556a20e1-f687-4f08-bd8a-6ba3cd197cd7" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<span class="issue_date">Issue Date: 2023-11-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1138">Fine-tuning Language Models for Factuality, Katherine Tian+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模な言語モデル（LLMs）を使用して、より事実に基づいた生成を実現するためのファインチューニングを行います。具体的には、外部の知識ベースや信頼スコアとの一貫性を測定し、選好最適化アルゴリズムを使用してモデルを調整します。実験結果では、事実エラー率の削減が観察されました。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-11-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1137">Instruction-Following Evaluation for Large Language Models, Jeffrey Zhou+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）の能力を評価するために、Instruction-Following Eval（IFEval）という評価ベンチマークが導入されました。IFEvalは、検証可能な指示に焦点を当てた直感的で再現性のある評価方法です。具体的には、25種類の検証可能な指示を特定し、それぞれの指示を含む約500のプロンプトを作成しました。この評価ベンチマークの結果は、GitHubで公開されています。</span>
<span class="snippet"><span>Comment</span>LLMがinstructionにどれだけ従うかを評価するために、検証可能なプロンプト（400字以上で書きなさいなど）を考案し評価する枠組みを提案。人間が評価すると時間とお金がかかり、LLMを利用した自動評価だと評価を実施するLLMのバイアスがかかるのだ、それら両方のlimitationを克服できるとのこと。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/0eb3fe10-536d-4674-aa3c-fd76f390f21d" alt="image" loading="lazy"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-11-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1135">Fast Chain-of-Thought: A Glance of Future from Parallel Decoding Leads  to Answers Faster, Hongxuan Zhang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>この研究では、FastCoTというフレームワークを提案します。FastCoTは、LLMを使用して並列デコーディングと自己回帰デコーディングを同時に行い、計算リソースを最大限に活用します。また、FastCoTは推論時間を約20%節約し、性能の低下がほとんどないことを実験で示しました。さらに、異なるサイズのコンテキストウィンドウに対しても頑健性を示すことができました。</span>
<span class="snippet"><span>Comment</span>論文中の図を見たが、全くわからなかった・・・。ちゃんと読まないとわからなそうである。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SmallModel.html">#SmallModel</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<span class="issue_date">Issue Date: 2023-11-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1132">Cappy: Outperforming and Boosting Large Multi-Task LMs with a Small   Scorer, Bowen Tan+, N_A, NeurIPS'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）はマルチタスキングに優れた性能を示していますが、パラメータ数が多く計算リソースを必要とし、効率的ではありません。そこで、小規模なスコアラーであるCappyを導入し、独立して機能するかLLMsの補助として使用することでパフォーマンスを向上させました。Cappyはファインチューニングやパラメータへのアクセスを必要とせず、さまざまなタスクで高い性能を発揮します。実験結果では、Cappyは独立したタスクや複雑なタスクで大きなLLMsを上回り、他のLLMsとの連携も可能です。</span>
<span class="snippet"><span>Comment</span>360MパラメータでさまざまなタスクでLLMに勝つっぽいのでおもしろそうだし実用性もありそう</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<span class="issue_date">Issue Date: 2023-11-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1131">MEGAVERSE: Benchmarking Large Language Models Across Languages,  Modalities, Models and Tasks, Sanchit Ahuja+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>LLMsの研究は急速に進展しており、英語以外の言語での評価が必要とされている。本研究では、新しいデータセットを追加したMEGAVERSEベンチマークを提案し、さまざまなLLMsを評価する。実験の結果、GPT4とPaLM2が優れたパフォーマンスを示したが、データの汚染などの問題があるため、さらなる取り組みが必要である。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/AutomaticPromptEngineering.html">#AutomaticPromptEngineering</a>
<span class="issue_date">Issue Date: 2023-11-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1128">Prompt Engineering a Prompt Engineer, Qinyuan Ye+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>プロンプトエンジニアリングは、LLMsのパフォーマンスを最適化するための重要なタスクであり、本研究ではメタプロンプトを構築して自動的なプロンプトエンジニアリングを行います。改善されたパフォーマンスにつながる推論テンプレートやコンテキストの明示などの要素を導入し、一般的な最適化概念をメタプロンプトに組み込みます。提案手法であるPE2は、さまざまなデータセットやタスクで強力なパフォーマンスを発揮し、以前の自動プロンプトエンジニアリング手法を上回ります。さらに、PE2は意味のあるプロンプト編集を行い、カウンターファクトの推論能力を示します。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<span class="issue_date">Issue Date: 2023-11-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1123">A Survey on Hallucination in Large Language Models: Principles,  Taxonomy, Challenges, and Open Questions, Lei Huang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>LLMsの出現はNLPにおける重要な進歩をもたらしているが、幻覚を生じることがあり、その信頼性に懸念がある。本調査では、LLMの幻覚に関する最近の進展について包括的に概説し、幻覚の要因や検出手法、軽減アプローチについて紹介する。また、現在の制約や将来の研究方向についても分析する。</span>
<span class="snippet"><span>Comment</span>Hallucinationを現象ごとに分類したSurveyとして 1048 もあるSurveyの内容。必要に応じて参照すべし。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/32d8d809-e197-4289-8000-12fee76a69cf" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<span class="issue_date">Issue Date: 2023-11-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1122">LightLM: A Lightweight Deep and Narrow Language Model for Generative  Recommendation, Kai Mei+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>この論文では、軽量なTransformerベースの言語モデルであるLightLMを提案し、生成型レコメンデーションタスクに特化したモデルを開発しています。LightLMは、モデルの容量を抑えつつも、レコメンデーションの精度と効率を向上させることに成功しています。また、ユーザーとアイテムのIDインデックス化方法として、Spectral Collaborative Indexing（SCI）とGraph Collaborative Indexing（GCI）を提案しています。さらに、アイテム生成時のhallucinationの問題に対処するために、制約付き生成プロセスを導入しています。実験結果は、LightLMが競合ベースラインを上回ることを示しています。</span>
<span class="snippet"><span>Comment</span>Generative Recommendationはあまり終えていないのだが、既存のGenerative Recommendationのモデルをより軽量にし、性能を向上させ、存在しないアイテムを生成するのを防止するような手法を提案しました、という話っぽい。

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/7a70bae0-20fd-495e-a563-5ac6ce5b6dfc" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Bayesian Personalized Ranking 28 ベースドなMatrix Factorizationよりは高い性能が出てるっぽい。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/40a39bfc-7a5b-442b-9231-1fbdbc99557a" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<span class="issue_date">Issue Date: 2023-11-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1121">Tell Your Model Where to Attend: Post-hoc Attention Steering for LLMs, Qingru Zhang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>PASTAは、大規模言語モデル（LLMs）において、ユーザーが指定した強調マークのあるテキストを読むことを可能にする手法です。PASTAは、注意の一部を特定し、再重み付けを適用してモデルの注意をユーザーが指定した部分に向けます。実験では、PASTAがLLMの性能を大幅に向上させることが示されています。</span>
<span class="snippet"><span>Comment</span>ユーザがprompt中で強調したいした部分がより考慮されるようにattention weightを調整することで、より応答性能が向上しましたという話っぽい。かなり重要な技術だと思われる。後でしっかり読む。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/a4d3714e-7279-495c-86f1-5ff4ed2cbeb8" alt="image" loading="lazy"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-11-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1120">Do LLMs exhibit human-like response biases? A case study in survey  design, Lindia Tjuatja+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>LLMsを使用して人間の代理としてタスクを実行する際に、LLMsが人間の応答バイアスをどの程度反映するかを調査する必要がある。この研究では、調査設計を使用して人間の応答バイアスを評価するデータセットとフレームワークを設計し、9つのモデルを評価した結果、一般的なLLMsが人間のような振る舞いを反映することに失敗していることが示された。これらの結果は、LLMsを人間の代わりに使用する際の潜在的な落とし穴を強調し、モデルの振る舞いの細かい特性の重要性を強調している。</span>
<span class="snippet"><span>Comment</span>LLMはPromptにsensitiveだが、人間も質問の仕方によって応答が変わるから、sensitiveなのは一緒では？ということを調査した研究。Neubig氏のツイートだと、instruction tuningやRLHFをしていないBase LLMの方が、より人間と類似した回答をするのだそう。

<br>



<br>

元ツイート: https://x.com/gneubig/status/1722294711355117666?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q人間のレスポンスのバイアス。左側は人間は「forbidden」よりも「not allowed」を好むという例、右側は「response order」のバイアスの例（選択肢の順番）。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/de129e78-5d52-41e3-a3bb-9aec20cf2b05" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

LLM側で評価したいバイアスごとに、QAのテキストを変更し、LLMに回答を生成され、social science studiesでのトレンドと比較することで、LLMにも人間と同様のバイアスがあるかを明らかにしている。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/3dc39afc-4e52-49a4-bf60-22ff94bf35c6" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

結果は以下の表であり、青いセルが人間と同様のバイアスを持つことを統計的に有意に示されたもの（のはず）。これをみると、全てのバイアスに対して人間と同様の傾向があったのはLlama2-70Bのみであり、instruction tuningや、RLHFをかけた場合（RLHFの方が影響が大きそう）人間のバイアスとは異なる挙動をするモデルが多くなることがわかる。また、モデルのパラメータサイズとバイアスの強さには相関関係は見受けられない。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/7d8eade0-ae3a-4d62-bb2d-160971542c39" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<span class="issue_date">Issue Date: 2023-11-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1117">Pretraining Data Mixtures Enable Narrow Model Selection Capabilities in  Transformer Models, Steve Yadlowsky+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、トランスフォーマーモデルの文脈学習（ICL）能力を調査しました。トランスフォーマーモデルは、事前学習データの範囲内で異なるタスクを特定し、学習する能力を持っています。しかし、事前学習データの範囲外のタスクや関数に対しては一般化が劣化することが示されました。また、高容量のシーケンスモデルのICL能力は、事前学習データの範囲に密接に関連していることが強調されました。</span>
<span class="snippet"><span>Comment</span>Transformerがpre-training時に利用された学習データ以外の分布に対しては汎化性能が落ちることを示したらしい。もしこれが正しいとすると、結局真に新しい分布というか関数というかタスクというか、をTransformerが創出する可能性は低いと言えるかもしれない。が、新しいものって大体は既存の概念の組み合わせだよね（スマホとか）、みたいなことを考えると、別にそれでも十分では？と思ってしまう。人間が本当に真の意味で新しい関数というかタスクというか分布を生み出せているかというと、実はそんなに多くないのでは？という予感もする。まあたとえば、量子力学を最初に考えました！とかそういうのは例外だと思うけど・・・、そのレベルのことってどんくらいあるんだろうね？</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2023-11-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1116">The Perils &amp; Promises of Fact-checking with Large Language Models, Dorian Quelle+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>自律型の事実チェックにおいて、大規模言語モデル（LLMs）を使用することが重要である。LLMsは真実と虚偽を見分ける役割を果たし、その出力を検証する能力がある。本研究では、LLMエージェントを使用して事実チェックを行い、推論を説明し、関連する情報源を引用する能力を評価した。結果は、文脈情報を備えたLLMsの能力の向上を示しているが、正確性には一貫性がないことに注意が必要である。今後の研究では、成功と失敗の要因をより深く理解する必要がある。</span>
<span class="snippet"><span>Comment</span>gpt3とgpt4でFactCheckして傾向を分析しました、という研究。promptにstatementとgoogleで補完したcontextを含め、出力フォーマットを指定することでFactCheckする。

<br>

promptingする際の言語や、statementの事実性の度合い（半分true, 全てfalse等）などで、性能が大きく変わる結果とのこと。

<br>

性能を見ると、まだまだ（このprompting方法では）人間の代わりが務まるほどの性能が出ていないことがわかる。また、trueな情報のFactCheckにcontextは効いていそうだが、falseの情報のFactCheckにContextがあまり効いてなさそうに見えるので、なんだかなあ、という感じである。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/1f310edd-58f3-4e45-ac40-e75337bff884" alt="image" loading="lazy">

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/e6901a32-af7a-472c-9790-d3784fa577ce" alt="image" loading="lazy">斜め読みしかしていないがこの研究、学術的な知見は少ないのかな、という印象。一つのケーススタディだよね、という感じがする。

<br>



<br>

まず、GPT3,4だけじゃなく、特徴の異なるOpenSourceのLLMを比較に含めてくれないと、前者は何で学習しているか分からないので、学術的に得られる知見はほぼないのではという気が。実務的には役に立つが。

<br>



<br>

その上で、Promptingをもっとさまざまな方法で検証した方が良いと思う。

<br>

たとえば、現在のpromptではラベルを先に出力させた後に理由を述べさせているが、それを逆にしたらどうなるか？（zero-shot CoT）や、4-Shotにしたらどうなるか、SelfConsistencyを利用したらどうなるかなど、promptingの仕方によって傾向が大きく変わると思う。

<br>



<br>

加えて、Retriever部分もいくつかのバリエーションで試してみても良いのかなと思う。特に、falseの情報を判断する際に役に立つ情報がcontextに含められているのかが気になる。

<br>

論文に書いてあるかもしれないが、ちょっとしっかり読む時間はないです！！</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/FoundationModel.html">#FoundationModel</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<span class="issue_date">Issue Date: 2023-10-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1104">Llemma: An Open Language Model For Mathematics, Zhangir Azerbayev+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>私たちは、数学のための大規模な言語モデルであるLlemmaを提案します。Llemmaは、Proof-Pile-2と呼ばれるデータセットを用いて事前学習され、MATHベンチマークで他のモデルを上回る性能を示しました。さらに、Llemmaは追加のfine-tuningなしでツールの使用や形式的な定理証明が可能です。アーティファクトも公開されています。</span>
<span class="snippet"><span>Comment</span>CodeLLaMAを200B tokenの数学テキスト（proof-pile-2データ;論文、数学を含むウェブテキスト、数学のコードが含まれるデータ）で継続的に事前学習することでfoundation modelを構築

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/87f9bbe1-3377-4e80-a7d4-904345ebb7d9" alt="image" loading="lazy">

<br>



<br>

約半分のパラメータ数で数学に関する性能でGoogleのMinervaと同等の性能を達成

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/5d209059-2275-415a-8b8d-f73f46712ba6" alt="image" loading="lazy">元ツイート: https://twitter.com/zhangir_azerbay/status/1714098823080063181まだ4-shotしてもAcc.50%くらいなのか。</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-10-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1102">Large Language Models are not Fair Evaluators, Peiyi Wang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>この論文では、大規模言語モデル（LLMs）を使用して、候補モデルの応答品質を評価する評価パラダイムにおける系統的なバイアスを明らかにします。さらに、バイアスを軽減するためのキャリブレーションフレームワークを提案し、実験によってその有効性を示します。また、コードとデータを公開して、今後の研究を支援します。</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/DataGeneration.html">#DataGeneration</a>
<span class="issue_date">Issue Date: 2023-10-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1099">Zephyr: Direct Distillation of LM Alignment, Lewis Tunstall+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>私たちは、小さな言語モデルを作成するために、教師モデルからの優先データを使用する手法を提案しています。この手法により、自然なプロンプトに対するモデルの応答が改善されます。提案手法を用いて学習されたZephyr-7Bモデルは、チャットベンチマークで最先端の性能を発揮し、人間の注釈を必要としません。詳細はGitHubで利用可能です。</span>
<span class="snippet"><span>Comment</span>7BパラメータでLlaMa70Bと同等の性能を達成したZephyrの論文。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/1348b3c1-f70a-49b6-97c9-4a27bf7805fa" alt="image" loading="lazy">

<br>



<br>

・dSFT:既存データからpromptをサンプリングし、user,assistantのmulti turnの対話をLLMでシミュレーションしてデータ生成しSFT

<br>

・AIF:既存データからpromstをサンプリングし、異なる4つのLLMのレスポンスをGPT4でランクづけしたデータの活用

<br>

・dDPO: 既存データからpromptをサンプリングし、ベストなレスポンスとランダムにサンプリングしたレスポンスの活用

<br>



<br>

人手を一切介していない。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/f2cd7b48-4036-49eb-bfb7-0ce3cc8a09b8" alt="image" loading="lazy">Blog: https://huggingface.co/blog/Isamu136/understanding-zephyr</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-10-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1098">Human Feedback is not Gold Standard, Tom Hosking+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>人間のフィードバックは、大規模言語モデルの性能評価に使用されているが、その好みのスコアがどの特性を捉えているのかは明確ではない。この研究では、人間のフィードバックの使用を分析し、重要なエラー基準を適切に捉えているかどうかを検証した。結果として、好みのスコアは広範なカバレッジを持っているが、事実性などの重要な側面が過小評価されていることがわかった。また、好みのスコアとエラーアノテーションは交絡因子の影響を受ける可能性があり、出力の断定性が事実性エラーの知覚率を歪めることも示された。さらに、人間のフィードバックを訓練目標として使用することが、モデルの出力の断定性を過度に増加させることも示された。今後の研究では、好みのスコアが望ましい目標と一致しているかどうかを慎重に考慮する必要がある。</span>
<span class="snippet"><span>Comment</span>参考: https://x.com/icoxfog417/status/1718151338520199180?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/3824b322-53fa-4360-a7d4-1b0f3bff3302" alt="image" loading="lazy"></span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/OCR.html">#OCR</a>
<span class="issue_date">Issue Date: 2023-10-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1093">Exploring OCR Capabilities of GPT-4V（ision） : A Quantitative and  In-depth Evaluation, Yongxin Shi+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>この論文では、GPT-4Vという大規模マルチモーダルモデルの光学文字認識（OCR）能力を評価します。さまざまなOCRタスクにおいてモデルのパフォーマンスを評価し、ラテン文字の認識と理解において優れた性能を示す一方、多言語や複雑なタスクには苦戦することがわかりました。これに基づいて、専門のOCRモデルの必要性やGPT-4Vを活用する戦略についても検討します。この研究は、将来のLMMを用いたOCRの研究に役立つものです。評価のパイプラインと結果は、GitHubで利用可能です。</span>
<span class="snippet"><span>Comment</span>GPT4-VをさまざまなOCRタスク「手書き、数式、テーブル構造認識等を含む）で性能検証した研究。

<br>

MLT19データセットを使った評価では、日本語の性能は非常に低く、英語とフランス語が性能高い。手書き文字認識では英語と中国語でのみ評価。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/c433b921-c527-441f-8925-00f4ac5fc6c3" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/InstructionGeneration.html">#InstructionGeneration</a>
<span class="issue_date">Issue Date: 2023-10-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1092">Auto-Instruct: Automatic Instruction Generation and Ranking for  Black-Box Language Models, Zhihan Zhang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）の性能を向上させるための新しい手法であるAuto-Instructを提案しています。この手法では、LLMsが生成する指示の品質を自動的に向上させるために、多様な候補の指示を生成し、スコアリングモデルでランク付けします。実験結果では、Auto-Instructが人間による指示や既存のLLM生成指示を上回ることが示されています。また、他のLLMsでも顕著な汎化性能を示すことも確認されています。</span>
<span class="snippet"><span>Comment</span>seed instructionとdemonstrationに基づいて、異なるスタイルのinstructionを自動生成し、自動生成したinstructionをとinferenceしたいexampleで条件づけてランキングし、良質なものを選択。選択したinstructionでinferenceを実施する。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/3b318cac-516d-4fc8-9097-ad695ab8223b" alt="image" loading="lazy">既存手法よりも高い性能を達成している。特にexampleごとにinstructionを選択する手法の中で最もgainが高い。これは、提案手法がinstructionの選択にtrained modelを利用しているためであると考えられる。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/8e2c8bad-54ec-49e8-b6e0-29bc18425e99" alt="image" loading="lazy"></span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<span class="issue_date">Issue Date: 2023-10-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1091">NEFTune: Noisy Embeddings Improve Instruction Finetuning, Neel Jain+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>私たちは、言語モデルのファインチューニングを改善するために、ノイズを加えた埋め込みベクトルを使用する手法を提案します。この手法は、AlpacaEvalやEvol-Instructなどのデータセットで強力なベースラインを上回る性能を示しました。また、RLHFでトレーニングされたモデルにも適用可能です。</span>
<span class="snippet"><span>Comment</span>Alpacaデータでの性能向上が著しい。かなり重要論文な予感。後で読む。HuggingFaceのTRLでサポートされている

<br>



<br>

https://huggingface.co/docs/trl/sft_trainer</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<span class="issue_date">Issue Date: 2023-10-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1090">In-Context Learning Creates Task Vectors, Roee Hendel+, N_A, EMNLP'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）におけるインコンテキスト学習（ICL）の基本的なメカニズムはまだ十分に理解されていない。本研究では、ICLによって学習される関数が非常に単純な構造を持つことを示し、ICLがトランスフォーマーLLMを使用して単一のタスクベクトルを生成し、それを使用して出力を生成するということを明らかにする。さまざまなモデルとタスクにわたる実験によって、この主張を支持している。</span>
<span class="snippet"><span>Comment</span>参考: https://x.com/hillbig/status/1717302086587875395?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QICLが実現可能なのは実はネットワーク内部で与えられたdemonstrationに対して勾配効果法を再現しているからです、という研究もあったと思うけど、このタスクベクトルとの関係性はどういうものなのだろうか。文脈に注意を与えなくてもICLと同じ性能が出るのは、文脈情報が不要なタスクを実施しているからであり、そうではないタスクだとこの知見が崩れるのだろうか。後で読む。</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-10-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1089">Detecting Pretraining Data from Large Language Models, Weijia Shi+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）を訓練するためのデータの検出問題を研究し、新しい検出方法であるMin-K% Probを提案します。Min-K% Probは、LLMの下で低い確率を持つアウトライアーワードを検出することに基づいています。実験の結果、Min-K% Probは従来の方法に比べて7.4%の改善を達成し、著作権のある書籍の検出や汚染された下流の例の検出など、実世界のシナリオにおいて効果的な解決策であることが示されました。</span>
<span class="snippet"><span>Comment</span>実験結果を見るにAUCは0.73-0.76程度であり、まだあまり高くない印象。また、テキストのlengthはそれぞれ32,64,128,256程度。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/1d7a5fe2-e0bc-4c6e-92b2-34457a17714a" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-10-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1088">Branch-Solve-Merge Improves Large Language Model Evaluation and  Generation, Swarnadeep Saha+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、多面的な言語生成および評価タスクにおいて、大規模言語モデルプログラム（BSM）を提案します。BSMは、ブランチ、ソルブ、マージの3つのモジュールから構成され、タスクを複数のサブタスクに分解し、独立して解決し、解決策を統合します。実験により、BSMが評価の正確性と一貫性を向上させ、パフォーマンスを向上させることが示されました。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<span class="issue_date">Issue Date: 2023-10-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1086">Personalized Soups: Personalized Large Language Model Alignment via  Post-hoc Parameter Merging, Joel Jang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>Reinforcement Learning from Human Feedback (RLHF) is not optimal for learning diverse individual perspectives, as it aligns general aggregated human preferences with large language models (LLMs). This study investigates the problem of Reinforcement Learning from Individual Human Feedback (RLPHF) and models the alignment with LLMs to multiple (sometimes conflicting) preferences as a Multi-Objective Reinforcement Learning (MORL) problem. It demonstrates that individual alignment can be achieved by decomposing preferences into multiple dimensions based on personalized declarations. The study shows that these dimensions can be efficiently trained independently and distributed, and effectively combined in post-processing through parameter merging. The code is available at https://github.com/joeljang/RLPHF.</span>
<span class="snippet"><span>Comment</span>どこまでのことが実現できるのかが気になる。</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-10-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1085">Eliminating Reasoning via Inferring with Planning: A New Framework to  Guide LLMs' Non-linear Thinking, Yongqi Tong+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）に非線形の思考を促すために、新しいプロンプティング方法であるInferential Exclusion Prompting（IEP）を提案する。IEPは、計画を立てて可能な解を推論し、逆推論を行うことで広い視点を得ることができる。IEPは他の手法と比較して複雑な人間の思考プロセスをシミュレートできることを実証し、LLMsのパフォーマンス向上にも貢献することを示した。さらに、Mental-Ability Reasoning Benchmark（MARB）を導入し、LLMsの論理と言語推論能力を評価するための新しいベンチマークを提案した。IEPとMARBはLLMsの研究において有望な方向性であり、今後の進展が期待される。</span>
<span class="snippet"><span>Comment</span>元論文は読んでいないのだが、CoTが線形的だという主張がよくわからない。

<br>

CoTはAutoregressiveな言語モデルに対して、コンテキストを自己生成したテキストで利用者の意図した方向性にバイアスをかけて補完させ、

<br>

利用者が意図した通りのアウトプットを最終的に得るためのテクニック、だと思っていて、

<br>

線形的だろうが非線形的だろうがどっちにしろCoTなのでは。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-10-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1078">Meta-CoT: Generalizable Chain-of-Thought Prompting in Mixed-task  Scenarios with Large Language Models, Anni Zou+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）を使用して、推論のためのチェーン・オブ・ソート（CoT）プロンプトを生成する方法を提案しています。従来のCoTの方法では、一般的なプロンプトや手作業デモンストレーションに依存していましたが、本研究では入力質問のタイプに基づいて自動的にプロンプトを生成するMeta-CoTを提案しています。Meta-CoTは、10のベンチマーク推論タスクで優れたパフォーマンスを示し、SVAMPでは最先端の結果を達成しました。また、分布外データセットでも安定性と汎用性が確認されました。</span>
<span class="snippet"><span>Comment</span>色々出てきたがなんかもう色々組み合わせれば最強なんじゃね?って気がしてきた。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/bb51c119-c1bc-4033-a7d4-f403d3c82d30" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/1c450a01-5cd6-4af3-af76-323e8c8d3769" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<span class="issue_date">Issue Date: 2023-10-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1077">Survey on Factuality in Large Language Models: Knowledge, Retrieval and  Domain-Specificity, Cunxiang Wang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>この研究では、大規模言語モデル（LLMs）の事実性の問題に取り組んでいます。LLMsの出力の信頼性と正確性は重要であり、事実に矛盾した情報を生成することがあるため、その問題を解決する方法を探求しています。具体的には、LLMsの事実的なエラーの影響や原因を分析し、事実性を評価する手法や改善策を提案しています。また、スタンドアロンのLLMsと外部データを利用する検索拡張型LLMsに焦点を当て、それぞれの課題と改善策について詳しく説明しています。この研究は、LLMsの事実的な信頼性を向上させるためのガイドとなることを目指しています。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/4d3ab4df-aaa0-460f-b16a-6114432336cd" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-10-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1076">Take a Step Back: Evoking Reasoning via Abstraction in Large Language  Models, Huaixiu Steven Zheng+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>Step-Back Promptingは、大規模言語モデル（LLMs）を使用して推論の手順をガイドするシンプルなプロンプティング技術です。この技術により、LLMsは具体的な詳細から高レベルの概念や基本原則を抽象化し、正しい推論経路をたどる能力を向上させることができます。実験により、Step-Back PromptingはSTEM、Knowledge QA、Multi-Hop Reasoningなどのタスクにおいて大幅な性能向上が観察されました。具体的には、MMLU Physics and Chemistryで7%、11%、TimeQAで27%、MuSiQueで7%の性能向上が確認されました。</span>
<span class="snippet"><span>Comment</span>また新しいのが出た<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/aac94123-7c39-4938-889f-feb5cff9317c" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/a793ff97-3d5c-4707-9ec6-3884b143182b" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2023-10-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1074">RECOMP: Improving Retrieval-Augmented LMs with Compression and Selective  Augmentation, Fangyuan Xu+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>ドキュメントの要約を生成することで、言語モデルの性能を向上させる手法を提案する。抽出型の圧縮器と抽象型の圧縮器を使用し、LMsの入力に要約を追加して訓練する。実験結果では、圧縮率が6％まで達成され、市販の要約モデルを上回る性能を示した。また、訓練された圧縮器は他のLMsにも転移可能であることが示された。</span>
<span class="snippet"><span>Comment</span>Retrieval Augmentationをする際に、元文書群を要約して圧縮することで、性能低下を抑えながら最大6%程度まで元文書群を圧縮できた、とのこと。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/2756ba98-d228-45e6-972d-ef239d4b990e" alt="image" loading="lazy">元ツイート: https://x.com/omarsar0/status/1711384213092479130?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QRetrieval Augmentationを導入する際のコスト削減に有用そう</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2023-10-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1070">Retrieval meets Long Context Large Language Models, Peng Xu+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>最先端の事前学習済みLLMsを使用して、リトリーバル拡張と長いコンテキストウィンドウの組み合わせについて研究しました。結果として、リトリーバル拡張LLMsは、ファインチューニングLLMsと比較しても高いパフォーマンスを示し、計算量も少ないことがわかりました。さらに、リトリーバルはLLMsのパフォーマンスを向上させることができることが示されました。リトリーバル拡張LLMsは、質問応答や要約などのタスクにおいて、他のモデルよりも優れた性能を発揮し、生成速度も速いです。この研究は、実践者にとってリトリーバル拡張と長いコンテキストウィンドウのLLMsの選択に関する洞察を提供します。</span>
<span class="snippet"><span>Comment</span>参考: https://x.com/hillbig/status/1711502993508671670?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q検索補強（Retrieval Augmentation）とは、言語モデルの知識を補完するために、関連する文書を外部の文書集合からとってきて、contextに含める技術のこと

<br>



<br>

https://tech.acesinc.co.jp/entry/2023/03/31/121001</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Conversation.html">#Conversation</a>
<span class="issue_date">Issue Date: 2023-10-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1069">RoleLLM: Benchmarking, Eliciting, and Enhancing Role-Playing Abilities  of Large Language Models, Zekun Moore Wang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）を使用して役割演技の能力を向上させるためのフレームワークであるRoleLLMを提案しています。RoleLLMは、役割プロファイルの構築、コンテキストベースの指示生成、役割プロンプトによる話し方の模倣、オープンソースモデルの微調整と役割のカスタマイズの4つのステージで構成されています。さらに、RoleBenchと呼ばれる役割演技のためのベンチマークデータセットを作成し、RoleLLaMAとRoleGLMというモデルを開発しました。これにより、役割演技の能力が大幅に向上し、GPT-4と同等の結果を達成しました。</span>
<span class="snippet"><span>Comment</span>Overview

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/4a4f8ad3-17d1-4a85-b553-6452371e2ccf" alt="image" loading="lazy">

<br>



<br>

RoleBench

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/a197648f-ee30-4e1d-9b3b-188c29671df4" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<span class="issue_date">Issue Date: 2023-10-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1068">Improved Baselines with Visual Instruction Tuning, Haotian Liu+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>LLaVAは、ビジョンと言語のクロスモーダルコネクタであり、データ効率が高く強力な性能を持つことが示されています。CLIP-ViT-L-336pxを使用し、学術タスク指向のVQAデータを追加することで、11のベンチマークで最先端のベースラインを確立しました。13Bのチェックポイントはわずか120万の公開データを使用し、1日で完全なトレーニングを終えます。コードとモデルは公開されます。</span>
<span class="snippet"><span>Comment</span>画像分析が可能なオープンソースLLMとのこと。Overview

<br>



<br>

画像生成をできるわけではなく、inputとして画像を扱えるのみ。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/8d0382b0-8c2b-438d-8de8-ee451f5e2649" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/AutoML.html">#AutoML</a>
<span class="issue_date">Issue Date: 2023-10-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1067">Benchmarking Large Language Models As AI Research Agents, Qian Huang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、AI研究エージェントを構築し、科学的な実験のタスクを実行するためのベンチマークとしてMLAgentBenchを提案する。エージェントはファイルの読み書きやコードの実行などのアクションを実行し、実験を実行し、結果を分析し、機械学習パイプラインのコードを変更することができる。GPT-4ベースの研究エージェントは多くのタスクで高性能なモデルを実現できるが、成功率は異なる。また、LLMベースの研究エージェントにはいくつかの課題がある。</span>
<span class="snippet"><span>Comment</span>GPT4がMLモデルをどれだけ自動的に構築できるかを調べた模様。また、ベンチマークデータを作成した模様。結果としては、既存の有名なデータセットでの成功率は90%程度であり、未知のタスク（新たなKaggle Challenge等）では30%程度とのこと。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<span class="issue_date">Issue Date: 2023-10-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1063">Large Language Model Alignment: A Survey, Tianhao Shen+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>近年、大規模言語モデル（LLMs）の進歩が注目されていますが、その潜在能力と同時に懸念もあります。本研究では、LLMsのアライメントに関する既存の研究と新たな提案を包括的に探求し、モデルの解釈可能性や敵対的攻撃への脆弱性などの問題も議論します。さらに、LLMsのアライメントを評価するためのベンチマークと評価手法を提案し、将来の研究の方向性を考察します。この調査は、研究者とAIアライメント研究コミュニティとの連携を促進することを目指しています。</span>
<span class="snippet"><span>Comment</span>LLMのalignmentに関するサーベイ。<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/09c10110-798f-4493-b431-41c2f2b017c1" alt="image" loading="lazy"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<a class="button" href="articles/ReversalCurse.html">#ReversalCurse</a>
<span class="issue_date">Issue Date: 2023-10-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1059">[Paper Note] The Reversal Curse: LLMs trained on "A is B" fail to learn "B is A", Lukas Berglund+, arXiv'23</a>
<span class="snippet"><span>Summary</span>自己回帰型大規模言語モデル（LLMs）は、「AはBである」という文から「BはAである」と逆の関係を自動的に一般化できない「逆転の呪い」を示す。例えば、モデルが「ワレンティナ・テレシコワは宇宙に行った最初の女性である」と訓練されても、「宇宙に行った最初の女性は誰か？」に正しく答えられない。実験では、架空の文を用いてGPT-3とLlama-1をファインチューニングし、逆転の呪いの存在を確認。ChatGPT（GPT-3.5およびGPT-4）でも、実在の有名人に関する質問で正答率に大きな差が見られた。</span>
<span class="snippet"><span>Comment</span>A is Bという文でLLMを訓練しても、B is Aという逆方向には汎化されないことを示した。

<br>



<br>

著者ツイート: https://x.com/owainevans_uk/status/1705285631520407821?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/25e20dcc-0313-4cd2-8768-afb0e4e48a68" alt="image" loading="lazy">

<br>

GPT3, LLaMaを A is Bでfinetuneし、B is Aという逆方向のfactを生成するように（質問をして）テストしたところ、0%付近のAcc.だった。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/d089eb94-6872-40b5-89a1-7532758e1d89" alt="image" loading="lazy">

<br>



<br>

また、Acc.が低いだけでなく、対数尤度もrandomなfactを生成した場合と、すべてのモデルサイズで差がないことがわかった。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/ba10fff4-cfdc-4e52-8217-c59247209211" alt="image" loading="lazy">

<br>



<br>

このことら、Reversal Curseはモデルサイズでは解決できないことがわかる。関連:

<br>

・1923</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-10-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1056">Large Language Models as Analogical Reasoners, Michihiro Yasunaga+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、言語モデルの推論プロセスを自動的にガイドするための新しいプロンプティング手法であるアナロジカルプロンプティングを提案しています。この手法は、関連する過去の経験を引用して新しい問題に取り組む認知プロセスに倣い、問題を解決する前に文脈内で関連する例示や知識を自己生成させるように言語モデルに促します。この手法は、例示のラベリングや検索の必要性を排除し、一般性と適応性を提供します。実験結果は、この手法がさまざまな推論タスクで他の手法を上回ることを示しています。</span>
<span class="snippet"><span>Comment</span>以下、著者ツイートのざっくり翻訳: https://x.com/michiyasunaga/status/1709582150025240854?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

人間は新しい問題に取り組む時、過去に解いた類義の問題を振り返り、その経験を活用する。これをLLM上で実践できないか?というのがアイデア。

<br>

Analogical Promptingでは、問題を解く前に、適切なexamplarを自動生成（problemとsolution）させ、コンテキストとして利用する。

<br>



<br>

これにより、examplarは自己生成されるため、既存のCoTで必要なexamplarのラベリングや検索が不要となることと、解こうとしている問題に合わせてexamplarを調整し、推論に対してガイダンスを提供することが可能となる。

<br>



<br>

実験の結果、数学、コード生成、BIG-Benchでzero-shot CoT、few-shot CoTを上回った。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/8aae5d9d-d8d8-4c86-b55f-0fcde5d5381c" alt="image" loading="lazy">

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/8544d7e2-bae3-4a1e-a867-ab655785c725" alt="image" loading="lazy">LLMが知っており、かつ得意な問題に対してならうまく働きそう。一方で、LLMが苦手な問題などは人手作成したexamplarでfew-shotした方が（ある程度）うまくいきそうな予感がする。うまくいきそうと言っても、そもそもLLMが苦手な問題なのでfew-shotした程度では焼石に水だとは思うが。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/NumericReasoning.html">#NumericReasoning</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<span class="issue_date">Issue Date: 2023-09-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1050">MAmmoTH: Building Math Generalist Models through Hybrid Instruction  Tuning, Xiang Yue+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>MAmmoTHは、数学の問題解決に特化した大規模言語モデルであり、厳密にキュレーションされた教育データセットで訓練されています。このモデルは、CoTとPoTのハイブリッドな根拠を提供し、さまざまな数学の分野を包括的にカバーしています。MAmmoTHは、既存のオープンソースモデルを大幅に上回り、特にMATHデータセットで高い精度を示しています。この研究は、多様な問題のカバレッジとハイブリッドな根拠の使用の重要性を強調しています。</span>
<span class="snippet"><span>Comment</span>9つのmath reasoningが必要なデータセットで13-29%のgainでSoTAを達成。

<br>

260kの根拠情報を含むMath Instructデータでチューニングされたモデル。

<br>



<br>

project page: https://tiger-ai-lab.github.io/MAmmoTH/</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<span class="issue_date">Issue Date: 2023-09-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1048">A Survey of Hallucination in Large Foundation Models, Vipula Rawte+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模ファウンデーションモデル（LFMs）におけるホールシネーションの問題に焦点を当て、その現象を分類し、評価基準を確立するとともに、既存の戦略を検討し、今後の研究の方向性についても議論しています。</span>
<span class="snippet"><span>Comment</span>Hallucinationを現象ごとに分類し、Hallucinationの程度の評価をする指標や、Hallucinationを軽減するための既存手法についてまとめられているらしい。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/ec507609-5b6d-42ed-92db-296856f93200" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/General.html">#General</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<span class="issue_date">Issue Date: 2023-09-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1047">RAIN: Your Language Models Can Align Themselves without Finetuning, Yuhui Li+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、追加のデータなしで凍結された大規模言語モデル（LLMs）を整列させる方法を探求しました。自己評価と巻き戻しメカニズムを統合することで、LLMsは自己ブースティングを通じて人間の好みと一致する応答を生成することができることを発見しました。RAINという新しい推論手法を導入し、追加のデータやパラメータの更新を必要とせずにAIの安全性を確保します。実験結果は、RAINの効果を示しており、LLaMA 30Bデータセットでは無害率を向上させ、Vicuna 33Bデータセットでは攻撃成功率を減少させることができました。</span>
<span class="snippet"><span>Comment</span>トークンのsetで構成されるtree上を探索し、出力が無害とself-evaluationされるまで、巻き戻しと前方生成を繰り返し、有害なトークンsetの重みを動的に減らすことでalignmentを実現する。モデルの追加のfinetuning等は不要。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/05bebc0a-325b-423d-ae36-4bc5698063fe" alt="image" loading="lazy">

<br>



<br>

self-evaluationでは下記のようなpromptを利用しているが、このpromptを変更することでこちら側の意図したとおりに出力のアライメントをとることができると思われる。非常に汎用性の高い手法のように見える。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/90070c63-e72d-4b49-bb03-a97dd5baa240" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/StructuredData.html">#StructuredData</a>
<span class="issue_date">Issue Date: 2023-09-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1046">Struc-Bench: Are Large Language Models Really Good at Generating Complex  Structured Data?, Xiangru Tang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）の能力を評価し、構造に注意したファインチューニング手法を提案します。さらに、Struc-Benchというデータセットを使用して、複雑な構造化データ生成のパフォーマンスを評価します。実験の結果、提案手法は他の評価されたLLMsよりも優れた性能を示しました。また、モデルの能力マップを提示し、LLMsの弱点と将来の研究の方向性を示唆しています。詳細はhttps://github.com/gersteinlab/Struc-Benchを参照してください。</span>
<span class="snippet"><span>Comment</span>Formatに関する情報を含むデータでInstruction TuningすることでFormatCoT（フォーマットに関する情報のCoT）を実現している模様。ざっくりしか論文を読んでいないが詳細な情報があまり書かれていない印象で、ちょっとなんともいえない。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/01a23836-b9fb-4d29-891f-d3b01e3e55d2" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Quantization.html">#Quantization</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2023-09-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1043">GPTQ: Accurate Post-Training Quantization for Generative Pre-trained   Transformers, Elias Frantar+, N_A, ICLR'23</a>
<span class="snippet"><span>Summary</span>本研究では、GPTモデルの推論における計算およびストレージコストの問題に取り組み、新しいワンショット重み量子化手法であるGPTQを提案します。GPTQは高い精度と効率性を持ち、1750億のパラメータを持つGPTモデルを4時間のGPU時間で量子化することができます。提案手法は従来の手法と比較して圧縮率を2倍以上向上させ、精度を保持することができます。さらに、提案手法は極端な量子化領域でも合理的な精度を提供します。実験結果では、提案手法を使用することでエンドツーエンドの推論速度が約3.25倍から4.5倍向上することが示されています。提案手法の実装はhttps://github.com/IST-DASLab/gptqで利用可能です。</span>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

・新たなpost-training量子化手法であるGPTQを提案

<br>



<br>

・数時間以内に数千億のパラメータを持つモデルでの実行が可能であり、パラメータごとに3～4ビットまで圧縮するが、精度の大きな損失を伴わない

<br>



<br>

    ・OPT-175BおよびBLOOM-176Bを、約4時間のGPU時間で、perplexityのわずかな増加で量子化することができた

<br>



<br>

・数千億のパラメータを持つ非常に高精度な言語モデルを3-4ビットに量子化可能なことを初めて示した

<br>



<br>

    ・先行研究のpost-training手法は、8ビット（Yao et al., 2022; Dettmers et al., 2022）。

<br>



<br>

    ・一方、以前のtraining-basedの手法は、1～2桁小さいモデルのみを対象としていた（Wu et al., 2022）。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/4ff107a9-7ccf-40f6-ad8c-fd910b1f0ac7" alt="image" loading="lazy">

<br>



<br>

Background

<br>



<br>

Layer-wise quantization

<br>



<br>

各linear layerがあるときに、full precisionのoutputを少量のデータセットをネットワークに流したときに、quantized weight W^barを用いてreconstructできるように、squared error lossを最小化する方法。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/9950fec1-966b-45c4-a82a-6bfd533042b3" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Optimal Brain quantization (OBQ)

<br>



<br>

OBQでは equation (1)をWの行に関するsummationとみなす。そして、それぞれの行 w をOBQは独立に扱い、ある一つの重みw_qをquantizeするときに、エラーがw_qのみに基づいていることを補償するために他のwの全てのquantizedされていない重みをupdateする。式で表すと下記のようになり、Fは残りのfull-precision weightの集合を表している。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/aab7784d-45f3-4f23-ac74-6cc4c2026486" alt="image" loading="lazy">

<br>



<br>

この二つの式を、全てのwの重みがquantizedされるまで繰り返し適用する。

<br>



<br>



<br>



<br>

つまり、ある一個の重みをquantizedしたことによる誤差を補うように、他のまだquantizedされていない重みをupdateすることで、次に別の重みをquantizedする際は、最初の重みがquantizedされたことを考慮した重みに対してquantizedすることになる。これを繰り返すことで、quantizedしたことによる誤差を考慮してw全体をアップデートできる、という気持ちだと思う。

<br>



<br>



<br>



<br>

この式は高速に計算することができ、medium sizeのモデル（25M parameters; ResNet-50 modelなど）とかであれば、single GPUで1時間でquantizeできる。しかしながら、OBQはO(d_row  d_col^3)であるため、（ここでd_rowはWの行数、d_colはwの列数）、billions of parametersに適用するには計算量が多すぎる。Algorithm

<br>



<br>

Step 1: Arbitrary Order Insight.

<br>



<br>

通常のOBQは、量子化誤差が最も少ない重みを常に選択して、greedyに重みを更新していく。しかし、パラメータ数が大きなモデルになると、重みを任意の順序で量子化したとしてもそれによる影響は小さいと考えられる。なぜなら、おそらく、大きな個別の誤差を持つ量子化された重みの数が少ないと考えられ、その重みがプロセスのが進むにつれて（アップデートされることで？）相殺されるため。

<br>



<br>



<br>



<br>

このため、提案手法は、すべての行の重みを同じ順序で量子化することを目指し、これが通常、最終的な二乗誤差が元の解と同じ結果となることを示す。が、このために2つの課題を乗り越えなければならない。

<br>



<br>



<br>



<br>

Step2. Lazy Batch-Updates

<br>



<br>

Fを更新するときは、各エントリに対してわずかなFLOPを使用して、巨大な行列のすべての要素を更新する必要があります。しかし、このような操作は、現代のGPUの大規模な計算能力を適切に活用することができず、非常に小さいメモリ帯域幅によってボトルネックとなる。

<br>



<br>



<br>



<br>

幸いにも、この問題は以下の観察によって解決できる：列iの最終的な四捨五入の決定は、この特定の列で行われた更新にのみ影響され、そのプロセスの時点で後の列への更新は関連がない。これにより、更新を「lazy batch」としてまとめることができ、はるかに効率的なGPUの利用が可能となる。（要は独立して計算できる部分は全部一気に計算してしまって、後で一気にアップデートしますということ）。たとえば、B = 128の列にアルゴリズムを適用し、更新をこれらの列と対応するB × Bブロックの H^-1 に格納する。

<br>



<br>

この戦略は理論的な計算量を削減しないものの、メモリスループットのボトルネックを改善する。これにより、非常に大きなモデルの場合には実際に1桁以上の高速化が提供される。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/fcb33c4d-3924-4abd-b149-936b9e350c76" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Step 3: Cholesky Reformulation

<br>



<br>

行列H_F^-1が不定になることがあり、これがアルゴリズムが残りの重みを誤った方向に更新する原因となり、該当する層に対して悪い量子化を実施してしまうことがある。この現象が発生する確率はモデルのサイズとともに増加することが実際に観察された。これを解決するために、コレスキー分解を活用して解決している（詳細はきちんと読んでいない）。実験で用いたCalibration data

<br>



<br>

GPTQのキャリブレーションデータ全体は、C4データセット(Raffel et al., 2020)からのランダムな2048トークンのセグメント128個で構成される。つまり、ランダムにクロールされたウェブサイトからの抜粋で、一般的なテキストデータを表している。GPTQがタスク固有のデータを一切見ていないため「ゼロショット」な設定でquantizationを実施している。

<br>



<br>



<br>



<br>

Language Generationでの評価

<br>



<br>

WikiText2に対するPerplexityで評価した結果、先行研究であるRTNを大幅にoutperformした。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/23e12194-d329-46f7-bb69-2cce290282c1" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-09-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1041">From Sparse to Dense: GPT-4 Summarization with Chain of Density  Prompting, Griffin Adams+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>要約は詳細でエンティティ中心的でありながら、理解しやすくすることが困難です。この課題を解決するために、私たちは「密度の連鎖」（CoD）プロンプトを使用して、GPT-4の要約を生成します。CoDによって生成された要約は抽象的であり、リードバイアスが少なく、人間に好まれます。また、情報量と読みやすさのトレードオフが存在することも示されました。CoD要約は無料で利用できます。</span>
<span class="snippet"><span>Comment</span>論文中のprompt例。InformativeなEntityのCoverageを増やすようにイテレーションを回し、各Entityに関する情報（前ステップで不足している情報は補足しながら）を具体的に記述するように要約を生成する。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/c24ab8c0-06fa-49ea-9df7-f248ec18ba45" alt="image" loading="lazy">

<br>



<br>

人間が好むEntityのDensityにはある程度の閾値がある模様（でもこれは人や用途によって閾値が違うようねとは思う）。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/d63c21e9-9179-4f8c-925f-ed435ecb1717" alt="image" loading="lazy">

<br>



<br>

人手評価とGPT4による5-scale の評価を実施している。定性的な考察としては、主題と直接的に関係ないEntityの詳細を述べるようになっても人間には好まれない（右例）ことが述べられている。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/900695ca-fbad-4d58-9388-2d2f86644e48" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/d3b3afe2-15fa-4b40-95cb-51aa0f27d6db" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<span class="issue_date">Issue Date: 2023-09-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1040">DoLa: Decoding by Contrasting Layers Improves Factuality in Large  Language Models, Yung-Sung Chuang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>我々は、事前学習済みの大規模言語モデル（LLMs）における幻覚を軽減するためのシンプルなデコーディング戦略を提案する。このアプローチは、ロジットの差異を対比することで次のトークンの分布を得るもので、事実知識をより明確に示し、誤った事実の生成を減らすことができる。このアプローチは、複数の選択課題やオープンエンドの生成課題において真実性を向上させることができることが示されている。</span>
<span class="snippet"><span>Comment</span>【以下、WIP状態の論文を読んでいるため今後内容が変化する可能性あり】

<br>



<br>

概要

<br>



<br>

Transformer Layerにおいて、factual informationが特定のレイヤーに局所化するという現象を観測しており、それを活用しよりFactual Consistencyのある生成をします、という研究

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/eb8dbecb-21cb-4abb-879c-5a8f39364e6a" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

あるテキストを生成するときの単語の生成確率の分布を可視化。final layer (N=32だと思われる)との間のJensen-shanon Divergence (JSD) で可視化している。が、図を見るとJSDの値域は[0, 1]のはずなのにこれを逸脱しているので一体どういう計算をしているのか。。。

<br>



<br>

図の説明としては論文中では2つのパターンがあると言及しており

<br>



<br>

1. 重要な固有表現や日付（Wole Soyinka, 1986など; Factual Knowledgeが必要なもの）は、higher layerでも高い値となっており、higher-layerにおいてpredictionの内容を変えている（重要な情報がここでinjectionされている）

<br>



<br>

2. 機能語や、questionからの単語のコピー（Nigerian, Nobel Prize など）のような "easy" なtokenは既にmiddle of layersで既にJSDの値が小さく、early layerの時点で出力することが既に決定されている

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/daed79c1-1391-43ad-a94e-a6748ec3529f" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

手法概要

<br>



<br>

ここからの考察としては、重要な事実に関する情報はfinal layerの方で分布が変化する傾向にあり、低layerの方ではそうではないぽいので、final layerと分布が似ているがFactual Informationがまだあまり顕著に生成確率が高くなっていないlayer（pre mature layer）との対比をとることで、生成されるべきFactual Informationがわかるのではないか、という前提の元提案手法が組まれている。手法としては、final layerとのJSDが最大となるようなlayerを一つ選択する、というものになっているが、果たしてこの選択方法で前述の気持ちが実現できているのか？という気は少しする。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/0c4973a0-baee-4de3-82fa-55aba12f9c73" alt="image" loading="lazy"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-09-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1039">Textbooks Are All You Need II: phi-1.5 technical report, Yuanzhi Li+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>私たちは、小さなTransformerベースの言語モデルであるTinyStoriesと、大規模な言語モデルであるphi-1の能力について調査しました。また、phi-1を使用して教科書の品質のデータを生成し、学習プロセスを改善する方法を提案しました。さらに、phi-1.5という新しいモデルを作成し、自然言語のタスクにおいて性能が向上し、複雑な推論タスクにおいて他のモデルを上回ることを示しました。phi-1.5は、良い特性と悪い特性を持っており、オープンソース化されています。</span>
<span class="snippet"><span>Comment</span>766 に続く論文</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Sycophancy.html">#Sycophancy</a>
<span class="issue_date">Issue Date: 2023-09-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1038">Simple synthetic data reduces sycophancy in large language models, Jerry Wei+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、機械学習モデルのおべっか行動を減らすための方法を提案しています。まず、言語モデルにおけるおべっか行動の普及度を調査し、その行動を減らすための合成データ介入を提案しています。具体的には、ユーザーの意見に対してモデルが頑健であることを促す合成データを使用し、モデルのファインチューニングを行います。これにより、おべっか行動を大幅に減らすことができます。提案手法の詳細は、https://github.com/google/sycophancy-intervention で確認できます。</span>
<span class="snippet"><span>Comment</span>LLMはユーザの好む回答をするように事前学習されるため、prompt中にユーザの意見が含まれていると、ユーザの意見に引っ張られ仮に不正解でもユーザの好む回答をしてしまう問題があることを示した。また、その対策として人工的にユーザの意見と、claimを独立させるように学習するためのデータセットを生成しFinetuningすることで防ぐことができることを示した。誤ったユーザの意見を挿入すると、正解できていた問題でも不正解になることを示した。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/43c03357-5c5c-4ceb-a089-0ad0a35eea1d" alt="image" loading="lazy">この傾向は、instruction tuningしている場合、モデルサイズが大きい場合により顕著であることを示した。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/6737eb30-7055-43d6-a1f4-d700be5963f2" alt="image" loading="lazy"><img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/54458bc0-ba89-4b10-b6c1-baa70384abb9" alt="image" loading="lazy"><img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/7690e3b4-00e7-468a-a36f-7130f65669dc" alt="image" loading="lazy"></span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/AutomaticPromptEngineering.html">#AutomaticPromptEngineering</a>
<span class="issue_date">Issue Date: 2023-09-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1037">Large Language Models as Optimizers, Chengrun Yang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、最適化タスクを自然言語で記述し、大規模言語モデル（LLMs）を使用して最適化を行う手法「Optimization by PROmpting（OPRO）」を提案しています。この手法では、LLMが以前の解とその値を含むプロンプトから新しい解を生成し、評価して次の最適化ステップのためのプロンプトに追加します。実験結果では、OPROによって最適化された最良のプロンプトが、人間が設計したプロンプトよりも優れていることが示されました。</span>
<span class="snippet"><span>Comment</span>`Take a deep breath and work on this problem step-by-step. `論文

<br>



<br>



<br>



<br>

概要

<br>



<br>

LLMを利用して最適化問題を解くためのフレームワークを提案したという話。論文中では、linear regressionや巡回セールスマン問題に適用している。また、応用例としてPrompt Engineeringに利用している。

<br>



<br>

これにより、Prompt Engineeringが最適か問題に落とし込まれ、自動的なprompt engineeringによって、`Let's think step by step.` よりも良いプロンプトが見つかりましたという話。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/2a469085-8a14-4eac-85ee-3918fe1becd5" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

手法概要

<br>



<br>

全体としての枠組み。meta-promptをinputとし、LLMがobjective functionに対するsolutionを生成する。生成されたsolutionとスコアがmeta-promptに代入され、次のoptimizationが走る。これを繰り返す。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/3e34ed47-5cbe-4cb0-b25a-8ee939e780e3" alt="image" loading="lazy">

<br>



<br>

Meta promptの例

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/a0dd261e-0dcd-487a-bfac-89db243e0b1c" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<span class="issue_date">Issue Date: 2023-09-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1035">Instruction Tuning for Large Language Models: A Survey, Shengyu Zhang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>この論文では、instruction tuning（IT）という技術について調査しています。ITは、大規模言語モデル（LLMs）をさらにトレーニングするための方法であり、ユーザーの指示に従うことを目的としています。本研究では、ITの方法論やデータセットの構築、トレーニング方法などについて調査し、指示の生成やデータセットのサイズなどがITの結果に与える影響を分析します。また、ITの潜在的な問題や批判、現在の不足点についても指摘し、今後の研究の方向性を提案します。</span>
<span class="snippet"><span>Comment</span>主要なモデルやデータセットの作り方など幅広くまとまっている<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/440b5214-71b9-4d22-9c0c-badd84a717ce" alt="image" loading="lazy"><img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/69cfdf51-e230-48b8-8f34-0286b3469c01" alt="image" loading="lazy"></span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/AutomaticPromptEngineering.html">#AutomaticPromptEngineering</a>
<span class="issue_date">Issue Date: 2023-09-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1034">Large Language Models Are Human-Level Prompt Engineers, Yongchao Zhou+, ICLR'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）は、自然言語の指示に基づいて一般的な用途のコンピュータとして優れた能力を持っています。しかし、モデルのパフォーマンスは、使用されるプロンプトの品質に大きく依存します。この研究では、自動プロンプトエンジニア（APE）を提案し、LLMによって生成された指示候補のプールから最適な指示を選択するために最適化します。実験結果は、APEが従来のLLMベースラインを上回り、19/24のタスクで人間の生成した指示と同等または優れたパフォーマンスを示しています。APEエンジニアリングされたプロンプトは、モデルの性能を向上させるだけでなく、フューショット学習のパフォーマンスも向上させることができます。詳細は、https://sites.google.com/view/automatic-prompt-engineerをご覧ください。</span>
<span class="snippet"><span>Comment</span>プロジェクトサイト: https://sites.google.com/view/automatic-prompt-engineer</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-09-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1030">Algorithm of Thoughts: Enhancing Exploration of Ideas in Large Language  Models, Bilgehan Sel+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）の推論能力を向上させるために、新しい戦略「Algorithm of Thoughts」を提案している。この戦略では、LLMsをアルゴリズム的な推論経路に導き、わずか1つまたは数個のクエリでアイデアの探索を拡大する。この手法は、以前の単一クエリ手法を上回り、マルチクエリ戦略と同等の性能を発揮する。また、LLMを指導するアルゴリズムを使用することで、アルゴリズム自体を上回るパフォーマンスが得られる可能性があり、LLMが最適化された検索に自己の直感を織り込む能力を持っていることを示唆している。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2023-09-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1028">A Survey on Large Language Model based Autonomous Agents, Lei Wang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>自律エージェントの研究は、以前は限られた知識を持つエージェントに焦点を当てていましたが、最近では大規模言語モデル（LLMs）を活用した研究が増えています。本論文では、LLMに基づく自律エージェントの研究を包括的に調査し、統一されたフレームワークを提案します。さらに、LLMに基づくAIエージェントの応用や評価戦略についてもまとめています。将来の方向性や課題についても議論し、関連する参考文献のリポジトリも提供しています。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/c921a960-02f7-44e6-8c24-bb578f599bbe" alt="image" loading="lazy">

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/73c4662b-ca74-41cc-8be5-c76c4aad36c8" alt="image" loading="lazy">良いサーベイ</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/DataAugmentation.html">#DataAugmentation</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/DataGeneration.html">#DataGeneration</a>
<span class="issue_date">Issue Date: 2023-08-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1024">Prompt2Model: Generating Deployable Models from Natural Language   Instructions, Vijay Viswanathan+, N_A, EMNLP'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）を使用して、プロンプトを自然言語でタスクを説明し、特定のモデルを訓練する手法であるPrompt2Modelを提案しています。Prompt2Modelは、既存のデータセットと事前学習済みモデルの検索、LLMsを使用したデータセットの生成、および教師あり微調整のプロセスを通じて行われます。実験結果では、Prompt2Modelが強力なLLMを上回る性能を示し、モデルの信頼性の評価も可能であることが示されています。Prompt2Modelはオープンソースで利用可能です。</span>
<span class="snippet"><span>Comment</span>Dataset Generatorによって、アノテーションが存在しないデータについても擬似ラベル付きデータを生成することができ、かつそれを既存のラベル付きデータと組み合わせることによってさらに性能が向上することが報告されている。これができるのはとても素晴らしい。Dataset Generatorについては、データを作成する際に低コストで、高品質で、多様なデータとするためにいくつかの工夫を実施している。

<br>

1. ユーザが与えたデモンストレーションだけでなく、システムが生成したexampleもサンプリングして活用することで、生成されるexampleの多様性を向上させる。実際、これをやらない場合は120/200がduplicate exampleであったが、これが25/200まで減少した。

<br>

2. 生成したサンプルの数に比例して、temperatureを徐々に高くしていく。これにより、サンプルの質を担保しつつ、多様性を徐々に増加させることができる。Temperature Annealingと呼ぶ。

<br>

3. self-consistencyを用いて、擬似ラベルの質を高める。もしmajority votingが互角の場合は、回答が短いものを採用した（これはヒューリスティックに基づいている）

<br>

4. zeno buildを用いてAPIへのリクエストを並列化することで高速に実験を実施

<br>



<br>

非常に参考になる。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Bias.html">#Bias</a>
<span class="issue_date">Issue Date: 2023-08-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1023">Large Language Models Sensitivity to The Order of Options in  Multiple-Choice Questions, Pouya Pezeshkpour+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）の頑健性に焦点を当てています。LLMsは多肢選択問題において順序に敏感であり、オプションの配置によって性能に大きな差が生じることを示しました。さらに、オプションの配置に対するバイアスを増幅または軽減する方法を特定し、LLMsの予測を改善するアプローチを提案しました。実験により、最大8パーセントポイントの改善が実現されました。</span>
<span class="snippet"><span>Comment</span>これはそうだろうなと思っていたけど、ここまで性能に差が出るとは思わなかった。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/fb13c25c-4d76-4c8c-b08a-6491c43f34b9" alt="image" loading="lazy">これがもしLLMのバイアスによるもの（2番目の選択肢に正解が多い）の場合、

<br>

ランダムにソートしたり、平均取ったりしても、そもそもの正解に常にバイアスがかかっているので、

<br>

結局バイアスがかかった結果しか出ないのでは、と思ってしまう。

<br>

そうなると、有効なのはone vs. restみたいに、全部該当選択肢に対してyes/noで答えさせてそれを集約させる、みたいなアプローチの方が良いかもしれない。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-08-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1020">AgentBench: Evaluating LLMs as Agents, Xiao Liu+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）をエージェントとして評価するための多次元の進化するベンチマーク「AgentBench」を提案しています。AgentBenchは、8つの異なる環境でマルチターンのオープンエンドの生成設定を提供し、LLMの推論と意思決定能力を評価します。25のLLMsに対するテストでは、商用LLMsは強力な能力を示していますが、オープンソースの競合他社との性能には差があります。AgentBenchのデータセット、環境、および評価パッケージは、GitHubで公開されています。</span>
<span class="snippet"><span>Comment</span>エージェントとしてのLLMの推論能力と意思決定能力を評価するためのベンチマークを提案。

<br>

トップの商用LLMとOpenSource LLMの間に大きな性能差があることを示した。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-08-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1015">Large Language Model Guided Tree-of-Thought, Jieyi Long, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>この論文では、Tree-of-Thought（ToT）フレームワークを紹介し、自己回帰型の大規模言語モデル（LLM）の問題解決能力を向上させる新しいアプローチを提案しています。ToTは、人間の思考方法に触発された技術であり、複雑な推論タスクを解決するためにツリー状の思考プロセスを使用します。提案手法は、LLMにプロンプターエージェント、チェッカーモジュール、メモリモジュール、およびToTコントローラーなどの追加モジュールを組み込むことで実現されます。実験結果は、ToTフレームワークがSudokuパズルの解決成功率を大幅に向上させることを示しています。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-08-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1013">Decomposition Enhances Reasoning via Self-Evaluation Guided Decoding, Yuxi Xie+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>私たちは、大規模言語モデル（LLMs）を使用して、推論の品質と多様性を向上させるための効果的なプロンプティングアプローチを提案しました。自己評価によるガイド付き確率的ビームサーチを使用して、GSM8K、AQuA、およびStrategyQAのベンチマークで高い精度を達成しました。また、論理の失敗を特定し、一貫性と堅牢性を向上させることもできました。詳細なコードはGitHubで公開されています。</span>
<span class="snippet"><span>Comment</span><img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/8bd4a19e-e7e6-444f-9394-36e261e5219a" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-08-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1012">Graph of Thoughts: Solving Elaborate Problems with Large Language Models, Maciej Besta+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>私たちは、Graph of Thoughts（GoT）というフレームワークを紹介しました。これは、大規模言語モデル（LLMs）のプロンプティング能力を進化させるもので、任意のグラフとしてモデル化できることが特徴です。GoTは、思考の組み合わせやネットワーク全体の本質の抽出、思考の強化などを可能にします。さまざまなタスクで最先端の手法に比べて利点を提供し、LLMの推論を人間の思考に近づけることができます。</span>
<span class="snippet"><span>Comment</span>Chain of Thought 551 

<br>



<br>

=&gt; Self-consistency 558 

<br>



<br>

=&gt; Thought Decomposition 1013 

<br>



<br>

=&gt; Tree of Thoughts 684 Tree of Thought 1015 

<br>



<br>

=&gt; Graph of Thought</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-08-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1010">Consciousness in Artificial Intelligence: Insights from the Science of  Consciousness, Patrick Butlin+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>AIの意識についての厳密なアプローチを提案し、既存のAIシステムを神経科学的な意識理論に基づいて評価する。意識の指標的特性を導き出し、最近のAIシステムを評価することで、現在のAIシステムは意識的ではないが、意識的なAIシステムを構築するための障壁は存在しないことを示唆する。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<span class="issue_date">Issue Date: 2023-08-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1008">Self-Alignment with Instruction Backtranslation, Xian Li+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>私たちは、高品質な指示に従う言語モデルを構築するためのスケーラブルな手法を提案します。この手法では、少量のシードデータとウェブコーパスを使用して言語モデルをファインチューニングし、指示のプロンプトを生成してトレーニング例を構築します。そして、高品質な例を選択してモデルを強化します。この手法を使用すると、他のモデルよりも優れた性能を発揮し、自己整列の効果を実証できます。</span>
<span class="snippet"><span>Comment</span>人間が書いたテキストを対応するinstructionに自動的にラベル付けする手法を提案。

<br>

これにより高品質なinstruction following LLMの構築が可能手法概要

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/837e17cc-6df1-4ba5-ba61-9c4f72dede93" alt="image" loading="lazy">結果的に得られるデータは、訓練において非常にインパクトがあり高品質なものとなる。

<br>

実際に、他の同サイズのinstruct tuningデータセットを上回る。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/ef478922-8495-4a5f-9bc6-3d5bed7195a8" alt="image" loading="lazy">Humpackは他のstrong modelからdistillされていないモデルの中で最高性能を達成。これは、スケールアップしたり、より強いベースモデルを使うなどさらなる性能向上ができる余地が残されている。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/cd7ff8b5-62a4-46fe-a902-cbe8e9ffec4a" alt="image" loading="lazy">参考: https://x.com/hillbig/status/1694103441432580377?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

指示を予測するモデルは、今回はLLaMAをfinetuningしたモデルを用いており、予測と呼称しているが指示はgenerationされる。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/PersonalizedGeneration.html">#PersonalizedGeneration</a>
<span class="issue_date">Issue Date: 2023-08-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1005">Teach LLMs to Personalize -- An Approach inspired by Writing Education, Cheng Li+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>個別化されたテキスト生成において、大規模言語モデル（LLMs）を使用した一般的なアプローチを提案する。教育の執筆をベースに、多段階かつマルチタスクのフレームワークを開発し、検索、ランキング、要約、統合、生成のステージで構成される個別化されたテキスト生成へのアプローチを採用する。さらに、マルチタスク設定を導入してモデルの生成能力を向上させる。3つの公開データセットでの評価結果は、他のベースラインに比べて大幅な改善を示している。</span>
<span class="snippet"><span>Comment</span>研究の目的としては、ユーザが現在執筆しているdocumentのwriting支援</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/MultitaskLearning.html">#MultitaskLearning</a>
<a class="button" href="articles/Zero/FewShotPrompting.html">#Zero/FewShotPrompting</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/CrossLingual.html">#CrossLingual</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/Generalization.html">#Generalization</a>
<span class="issue_date">Issue Date: 2023-08-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/999">Crosslingual Generalization through Multitask Finetuning, Niklas Muennighoff+, N_A, ACL'23</a>
<span class="snippet"><span>Summary</span>マルチタスクプロンプトフィネチューニング（MTF）は、大規模な言語モデルが新しいタスクに汎化するのに役立つことが示されています。この研究では、マルチリンガルBLOOMとmT5モデルを使用してMTFを実施し、英語のプロンプトを使用して英語および非英語のタスクにフィネチューニングすることで、タスクの汎化が可能であることを示しました。さらに、機械翻訳されたプロンプトを使用してマルチリンガルなタスクにフィネチューニングすることも調査し、モデルのゼロショットの汎化能力を示しました。また、46言語の教師ありデータセットのコンポジットであるxP3も紹介されています。</span>
<span class="snippet"><span>Comment</span>英語タスクを英語でpromptingしてLLMをFinetuningすると、他の言語（ただし、事前学習で利用したコーパスに出現する言語に限る）で汎化し性能が向上することを示した模様。

<br>

![Image](https://github.com/user-attachments/assets/44e9cf6e-e80f-4092-af46-ad74c30fe59c)</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-08-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/931">Metacognitive Prompting Improves Understanding in Large Language Models, Yuqing Wang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、LLMsにメタ認知プロンプト（MP）を導入し、人間の内省的な推論プロセスを模倣することで、理解能力を向上させることを目指しています。実験結果は、MPを備えたPaLMが他のモデルに比べて優れたパフォーマンスを示しており、MPが既存のプロンプト手法を上回ることを示しています。この研究は、LLMsの理解能力向上の可能性を示し、人間の内省的な推論を模倣することの利点を強調しています。</span>
<span class="snippet"><span>Comment</span>CoTより一貫して性能が高いので次のデファクトになる可能性あり

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/8ca3a369-925b-44be-9d63-e3150137ff6b" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/d3b980e0-4402-4a32-96ee-684da7f3a487" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<span class="issue_date">Issue Date: 2023-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/923">The Hydra Effect: Emergent Self-repair in Language Model Computations, Thomas McGrath+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>私たちは、言語モデルの内部構造を調査し、言語モデルの計算における特定の効果を示しました。具体的には、1つの層の削除が他の層によって補完される「Hydra効果」と、遅いMLP層が最大尤度トークンを制御する役割を持つことを示しました。また、ドロップアウトを使用しない言語モデルでも同様の効果が見られることを示しました。これらの効果を事実の回想の文脈で分析し、言語モデルの回路レベルの属性付与について考察しました。</span>
<span class="snippet"><span>Comment</span>LLMからattention layerを一つ取り除くと、後続の層が取り除かれたlayerの機能を引き継ぐような働きをすることがわかった。これはLLMの自己修復機能のようなものであり、HydraEffectと命名された。</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/922">MetaGPT: Meta Programming for Multi-Agent Collaborative Framework, Sirui Hong+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）を使用したマルチエージェントの自動タスク解決における進歩について調査しました。既存の研究では単純なタスクに焦点を当てており、複雑なタスクにおける探索や調査が不足していることがわかりました。そこで、MetaGPTという革新的なフレームワークを提案しました。MetaGPTは、人間のワークフローをLLMに組み込むことで、マルチエージェントの協力を効果的に支援します。実験結果から、MetaGPTが既存のシステムに比べてより高い結束性を持つ解決策を生成することが示されました。これは、マルチエージェントに人間のドメイン知識を組み込むことの潜在能力を示し、新しいアプローチの可能性を開拓するものです。</span>
<span class="snippet"><span>Comment</span>要はBabyTalk, AutoGPTの進化系で、人間のワークフローを模倣するようにデザインしたら良くなりました、という話と思われる

<br>



<br>

ソフトウェアエンジニア、アーキテクト、プロダクトオーナー、プロジェクトマネージャーなどのロールを明示的に与えて、ゴールを目指す。もはやLLM内部でソフトウェア企業を模倣しているのと同様である。</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/921">Skeleton-of-Thought: Large Language Models Can Do Parallel Decoding, Xuefei Ning+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>この研究では、大規模言語モデル（LLMs）の生成遅延を減らすために、思考の骨組み（SoT）という手法を提案しています。SoTは、回答の骨組みをまず生成し、その後に内容を並列で処理することで高速化を実現します。また、回答品質の向上も期待されます。SoTはデータ中心の最適化の初めの試みであり、LLMsの人間らしい思考を可能にする可能性があります。</span>
<span class="snippet"><span>Comment</span>最初に回答の枠組みだけ生成して、それぞれの内容を並列で出力させることでデコーディングを高速化しましょう、という話。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/fb25d8ba-dff7-4f6f-be25-0973488f6e8a" alt="image" loading="lazy"></span>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/920">ToolLLM: Facilitating Large Language Models to Master 16000+ Real-world  APIs, Yujia Qin+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>オープンソースの大規模言語モデル（LLMs）を使用して、外部ツール（API）の高度なタスクの実行を容易にするためのToolLLMというフレームワークを紹介します。ToolBenchというデータセットを使用して、ツールの使用方法を調整し、DFSDTという決定木を使用して効率的な検索を行います。ToolEvalという自動評価ツールを使用して、ToolLLaMAが高いパフォーマンスを発揮することを示します。さらに、ニューラルAPIリトリーバーを使用して、適切なAPIを推奨します。</span>
<span class="snippet"><span>Comment</span>16000のreal worldのAPIとインタラクションし、データの準備、訓練、評価などを一貫してできるようにしたフレームワーク。LLaMAを使った場合、ツール利用に関してturbo-16kと同等の性能に達したと主張。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/a9c394b5-6148-4bab-acaa-4934ead5c1a7" alt="image" loading="lazy"></span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<span class="issue_date">Issue Date: 2023-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/919">Open Problems and Fundamental Limitations of Reinforcement Learning from  Human Feedback, Stephen Casper+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>人間のフィードバックからの強化学習（RLHF）は、AIシステムを人間の目標に合わせてトレーニングするための技術であり、最先端の大規模言語モデル（LLMs）を微調整するために使用されている。しかし、RLHFの欠点を体系化するための公開された研究は少ない。本論文では、RLHFのオープンな問題と制約を調査し、実践における理解、改善、補完技術を概説し、RLHFシステムの社会的な監視を向上させるための監査と開示の基準を提案する。この研究は、RLHFの制約を強調し、安全なAIシステムの開発に多面的なアプローチの重要性を強調している。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<span class="issue_date">Issue Date: 2023-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/918">Aligning Large Language Models with Human: A Survey, Yufei Wang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）は、自然言語処理のタスクにおいて重要な役割を果たしていますが、その性能には制約があります。この調査では、LLMsの性能を向上させるためのアラインメント技術について包括的な概要を提供します。具体的には、データ収集方法、トレーニング手法、モデル評価方法について説明します。さらに、将来の研究の方向性についてもまとめられています。この調査は、LLMsの性能向上に関心のある人々にとって貴重な情報源となるでしょう。</span>
<span class="snippet"><span>Comment</span>LLMのAlignment手法に関するSurvey

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/6c5288c8-7f5b-4526-ba6f-25c2b9b3fc55" alt="image" loading="lazy"></span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/916">L-Eval: Instituting Standardized Evaluation for Long Context Language  Models, Chenxin An+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>長い文脈の言語モデル（LCLM）の評価を標準化するために、L-Evalという評価スイートを提案しました。L-Evalには411の長いドキュメントと2,000以上の人間によるクエリ-レスポンスのペアが含まれており、多様な評価方法と指示スタイルを採用しています。オープンソースのモデルは商用モデルに比べて遅れていますが、通常のバージョンと比較しても印象的なパフォーマンスを示しています。LCLMの生成結果は公開されています。</span>
<span class="snippet"><span>Comment</span>long contextに対するLLMの評価セット。411のlong documentに対する2kのquery-response pairのデータが存在。法律、fainance, school lectures, 長文対話、小説、ミーティングなどのドメインから成る。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-08-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/913">Do Multilingual Language Models Think Better in English?, Julen Etxaniz+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>self-translateは、マルチリンガル言語モデルの少数ショット翻訳能力を活用する新しいアプローチであり、外部の翻訳システムの必要性を克服する。実験結果は、self-translateが直接推論を上回る性能を示し、非英語の言語でプロンプトされた場合にも有効であることを示している。コードはhttps://github.com/juletx/self-translateで利用可能。</span>
<span class="snippet"><span>Comment</span>参考: https://twitter.com/imai_eruel/status/1687735268311511040?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/65a44946-c82b-4895-9ce9-c48792e09b3e" alt="image" loading="lazy"><img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/86ff0cbb-7fac-4ba2-bf11-652b80db0fe5" alt="image" loading="lazy"></span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<span class="issue_date">Issue Date: 2023-08-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/911">LLM-Rec: Personalized Recommendation via Prompting Large Language Models, Hanjia Lyu+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>LLMsを用いたパーソナライズされたコンテンツ推薦のためのプロンプティング戦略を調査し、LLM-Recというアプローチを提案した。実験の結果、プロンプティング戦略によって生成されたLLMによる拡張入力テキストと元のコンテンツの説明を組み合わせることで、推薦の性能が向上することが示された。これは、多様なプロンプトと入力拡張技術がパーソナライズされたコンテンツ推薦の能力を向上させる上で重要であることを示している。</span>
<span class="snippet"><span>Comment</span>LLMのpromptingの方法を変更しcontent descriptionだけでなく、様々なコンテキストの追加（e.g. このdescriptionを推薦するならどういう人におすすめ？、アイテム間の共通項を見つける）、内容の拡張等を行いコンテントを拡張して活用するという話っぽい。WIP</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-07-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/905">FrugalGPT: How to Use Large Language Models While Reducing Cost and  Improving Performance, Lingjiao Chen+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）の使用には高いコストがかかるため、LLMsの推論コストを削減するための3つの戦略（プロンプトの適応、LLMの近似、LLMのカスケード）を提案する。FrugalGPTという具体的な手法を紹介し、最大98％のコスト削減と4％の精度向上を実現することを示す。これにより、LLMsの持続可能な使用が可能となる。</span>
<span class="snippet"><span>Comment</span>限られた予算の中で、いかに複数のLLM APIを使い、安いコストで高い性能を達成するかを追求した研究。

<br>



<br>

LLM Cascadeなどはこの枠組みでなくても色々と使い道がありそう。Question Concatenationは実質Batch Prompting。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<span class="issue_date">Issue Date: 2023-07-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/903">Judging LLM-as-a-judge with MT-Bench and Chatbot Arena, Lianmin Zheng+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLM）を判定者として使用して、オープンエンドの質問に対する性能を評価する方法を提案する。LLMの制限や問題を軽減するための解決策を提案し、2つのベンチマークでLLMの判定者と人間の好みの一致を検証する。結果は、強力なLLM判定者が人間の好みとよく一致し、スケーラブルで説明可能な方法で人間の好みを近似できることを示した。さらに、新しいベンチマークと従来のベンチマークの相補性を示し、いくつかのバリアントを評価する。</span>
<span class="snippet"><span>Comment</span>MT-Bench（MTBench）スコアとは、multi-turnのQAを出題し、その回答の質をGPT-4でスコアリングしたスコアのこと。

<br>



<br>

GPT-4の判断とhuman expertの判断とのagreementも検証しており、agreementは80%以上を達成している。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/20c7782d-8ffe-4328-8526-700e38df23b5" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/9f0e1e3a-6b07-4bcc-be78-e42a1c5d2190" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/892">Can Large Language Models Be an Alternative to Human Evaluations? Cheng-Han Chiang, Hung-yi Lee, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、人間の評価が機械学習モデルのテキスト品質評価に不可欠であるが再現性が難しいという問題を解決するために、大規模言語モデル（LLMs）を使用した評価方法を提案している。具体的には、LLMsに同じ指示と評価対象のサンプルを与え、それに対する応答を生成させることで、LLM評価を行っている。実験結果から、LLM評価の結果は人間の評価と一致しており、異なるフォーマットやサンプリングアルゴリズムでも安定していることが示されている。LLMsを使用したテキスト品質評価の可能性が初めて示されており、その制限や倫理的な考慮事項についても議論されている。</span>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Reference-free.html">#Reference-free</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/890">RQUGE: Reference-Free Metric for Evaluating Question Generation by Answering the Question, ACL'23</a>
<span class="snippet"><span>Summary</span>既存の質問評価メトリックにはいくつかの欠点がありますが、本研究では新しいメトリックRQUGEを提案します。RQUGEは文脈に基づいて候補質問の回答可能性を考慮し、参照質問に依存せずに人間の判断と高い相関を持つことが示されています。さらに、RQUGEは敵対的な破壊に対しても堅牢であり、質問生成モデルのファインチューニングにも有効です。これにより、QAモデルのドメイン外データセットでのパフォーマンスが向上します。</span>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

質問自動生成の性能指標（e.g. ROUGE, BERTScore）は、表層の一致、あるいは意味が一致した場合にハイスコアを与えるが、以下の欠点がある

<br>



<br>

・人手で作成された大量のreference questionが必要

<br>



<br>

・表層あるいは意味的に近くないが正しいquestionに対して、ペナルティが与えられてしまう

<br>



<br>

=&gt; contextに対するanswerabilityによって評価するメトリック RQUGE を提案

<br>



<br>



<br>



<br>

similarity basedな指標では、Q1のような正しい質問でもlexical overlapがないと低いスコアを与えてしまう。また、Q2のようなreferenceの言い換えであっても、低いスコアとなってしまう。一方、reference basedな手法では、Q3のようにunacceptableになっているにもかかわらず、変化が微小であるためそれをとらえられないという問題がある。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/61c3d939-a678-4c63-9572-f3cf28b3aa20" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

手法概要

<br>



<br>

提案手法ではcontextとanswer spanが与えられたとき、Span Scorerと、QAモジュールを利用してacceptability scoreを計算することでreference-freeなmetricを実現する。

<br>



<br>

QAモデルは、Contextと生成されたQuestionに基づき、answer spanを予測する。提案手法ではT5ベースの手法であるUnifiedQAv2を利用する。

<br>



<br>

Span Scorer Moduleでは、予測されたanswer span, candidate question, context, gold spanに基づき、[1, 5]のスコアを予測する。提案手法では、encoder-only BERT-based model（提案手法ではRoBERTa）を用いる。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/b49e09a4-4a69-4761-94eb-3f6417a19223" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/889">Retentive Network: A Successor to Transformer for Large Language Models, Yutao Sun+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>この研究では、Retentive Network（RetNet）という大規模言語モデルのアーキテクチャを提案します。RetNetは、トレーニングの並列化、低コストの推論、良好なパフォーマンスを同時に実現することができます。RetNetは再帰と注意の関係を理論的に導出し、シーケンスモデリングのためのretentionメカニズムを提案します。このメカニズムは、並列、再帰、チャンクごとの再帰の3つの計算パラダイムをサポートします。RetNetの実験結果は、優れたスケーリング結果、並列トレーニング、低コストの展開、効率的な推論を実現していることを示しています。RetNetは、大規模言語モデルの強力な後継者となる可能性があります。</span>
<span class="snippet"><span>Comment</span>参考: https://twitter.com/hillbig/status/1681417687380152320?s=46&t=LJIgfuO352oK3zU2FKFpNA</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/FoundationModel.html">#FoundationModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/888">Llama 2: Open Foundation and Fine-Tuned Chat Models, Hugo Touvron+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>この研究では、大規模な言語モデルであるLlama 2を開発し、微調整しています。Llama 2-Chatは対話に特化しており、オープンソースのチャットモデルを上回る性能を示しています。安全性の改善にも取り組んでおり、責任ある開発に貢献することを目指しています。</span>
<span class="snippet"><span>Comment</span>参考: https://twitter.com/hillbig/status/1681436336451125257?s=46&t=LJIgfuO352oK3zU2FKFpNALlama, およびLlama2では、一般的なTransformer Decoderとは異なり、linear layerの”前に”RMSPropをかませている点が異なる。

<br>



<br>

また、Llama2では、Llamaと比較して

<br>



<br>

・Group Query Attentionの利用 1271 

<br>



<br>

・活性化関数として、ReLUではなく、SwiGLU 1311 の活用

<br>



<br>

・Positional Embeddingとして、RoPE 1310 の活用

<br>



<br>

・より長いContext Windowsでの学習（4k）

<br>



<br>

を実施している。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/6d6d897a-3ce8-4a90-a001-116884c45cdd" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

出典：https://cameronrwolfe.substack.com/p/llama-2-from-the-ground-up</span>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/884">Challenges and Applications of Large Language Models, Jean Kaddour+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本論文では、大規模言語モデル（LLMs）の普及により、研究者が分野の現状を理解し、生産的になるための問題と応用成功例を確立することを目指しています。</span>
<span class="snippet"><span>Comment</span>LLMのここ数年の進化早すぎわろたでキャッチアップむずいので、未解決の課題や、すでに良い感じのアプリケーションの分野分かりづらいので、まとめました論文</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/883">Towards A Unified Agent with Foundation Models, Norman Di Palo+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、言語モデルとビジョン言語モデルを強化学習エージェントに組み込み、効率的な探索や経験データの再利用などの課題に取り組む方法を調査しました。スパースな報酬のロボット操作環境でのテストにおいて、ベースラインに比べて大幅な性能向上を実証し、学習済みのスキルを新しいタスクの解決や人間の専門家のビデオの模倣に活用する方法を示しました。</span>
<span class="snippet"><span>Comment</span>

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/aa40d0e3-9499-4804-9046-a9ad795c2d52" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Annotation.html">#Annotation</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/882">LLMs as Workers in Human-Computational Algorithms? Replicating  Crowdsourcing Pipelines with LLMs, Tongshuang Wu+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）は、クラウドソーシングタスクにおいて人間のような振る舞いを再現できる可能性がある。しかし、現在の取り組みは単純なタスクに焦点を当てており、より複雑なパイプラインを再現できるかどうかは不明である。LLMsの成功は、リクエスターの理解力やサブタスクのスキルに影響を受ける。人間とLLMsのトレーニングの組み合わせにより、クラウドソーシングパイプラインの再現が可能であり、LLMsは一部のタスクを完了させながら、他のタスクを人間に任せることができる。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/877">Instruction-following Evaluation through Verbalizer Manipulation, Shiyang Li+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、指示に従う能力を正確に評価するための新しい評価プロトコル「verbalizer manipulation」を提案しています。このプロトコルでは、モデルに異なる程度で一致する言葉を使用してタスクラベルを表現させ、モデルの事前知識に依存する能力を検証します。さまざまなモデルを9つのデータセットで評価し、異なるverbalizerのパフォーマンスによって指示に従う能力が明確に区別されることを示しました。最も困難なverbalizerに対しても、最も強力なモデルでもランダムな推測よりも優れたパフォーマンスを発揮するのは困難であり、指示に従う能力を向上させるために継続的な進歩が必要であることを強調しています。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SpokenLanguageProcessing.html">#SpokenLanguageProcessing</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/SpeechProcessing.html">#SpeechProcessing</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/875">Meta-Transformer: A Unified Framework for Multimodal Learning, Yiyuan Zhang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、マルチモーダル学習のためのMeta-Transformerというフレームワークを提案しています。このフレームワークは、異なるモダリティの情報を処理し関連付けるための統一されたネットワークを構築することを目指しています。Meta-Transformerは、対応のないデータを使用して12のモダリティ間で統一された学習を行うことができ、テキスト、画像、ポイントクラウド、音声、ビデオなどの基本的なパーセプションから、X線、赤外線、高分光、IMUなどの実用的なアプリケーション、グラフ、表形式、時系列などのデータマイニングまで、幅広いタスクを処理することができます。Meta-Transformerは、トランスフォーマーを用いた統一されたマルチモーダルインテリジェンスの開発に向けた有望な未来を示しています。</span>
<span class="snippet"><span>Comment</span>12種類のモダリティに対して学習できるTransformerを提案

<br>

Dataをsequenceにtokenizeし、unifiedにfeatureをencodingし、それぞれのdownstreamタスクで学習

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/8734073a-573e-442e-8b9f-fed559199d56" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/873">FLASK: Fine-grained Language Model Evaluation based on Alignment Skill  Sets, Seonghyeon Ye+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）の評価における課題を解決するため、細かい評価プロトコルであるFLASKを提案する。FLASKは、インスタンスごとのスキルセットレベルでの評価を可能にし、モデルベースと人間ベースの評価の両方に使用できる。具体的には、12の細かいスキルを定義し、各インスタンスにスキルのセットを割り当てることで評価セットを構築する。さらに、ターゲットドメインと難易度レベルの注釈を付けることで、モデルのパフォーマンスを包括的に分析する。FLASKを使用することで、モデルのパフォーマンスを正確に測定し、特定のスキルに優れたLLMsを分析することができる。また、実践者はFLASKを使用して、特定の状況に適したモデルを推奨することができる。</span>
<span class="snippet"><span>Comment</span>このベンチによるとLLaMA2でさえ、商用のLLMに比べると能力はかなり劣っているように見える。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/d9871133-3111-4da6-9148-1ac779a24312" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<span class="issue_date">Issue Date: 2023-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/868">Socratic Questioning of Novice Debuggers: A Benchmark Dataset and Preliminary Evaluations, ACL-BEA'23</a>
<span class="snippet"><span>Summary</span>本研究では、初心者プログラマがバグのある計算問題を解決する際に、ソクラテス的な対話を行うデータセットを紹介し、GPTベースの言語モデルのデバッグ能力を評価しました。GPT-4はGPT-3.5よりも優れたパフォーマンスを示しましたが、まだ人間の専門家には及ばず、さらなる研究が必要です。</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Distillation.html">#Distillation</a>
<span class="issue_date">Issue Date: 2023-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/867">Teaching Small Language Models to Reason, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模な言語モデルの推論能力を小さなモデルに転送するための知識蒸留を探求しました。具体的には、大きな教師モデルによって生成された出力を用いて学生モデルを微調整し、算術、常識、象徴的な推論のタスクでのパフォーマンスを向上させることを示しました。例えば、T5 XXLの正解率は、PaLM 540BとGPT-3 175Bで生成された出力を微調整することで、それぞれ8.11％から21.99％および18.42％に向上しました。</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2023-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/849">Reasoning with Language Model Prompting: A Survey, ACL'23</a>
<span class="snippet"><span>Summary</span>本論文では、推論に関する最新の研究について包括的な調査を行い、初心者を支援するためのリソースを提供します。また、推論能力の要因や将来の研究方向についても議論します。リソースは定期的に更新されています。</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Ensemble.html">#Ensemble</a>
<span class="issue_date">Issue Date: 2023-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/844">Multi-CLS BERT: An Efficient Alternative to Traditional Ensembling, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、BERTモデルのアンサンブル手法であるMulti-CLS BERTを提案します。Multi-CLS BERTは、複数のCLSトークンを使用して多様性を促進し、単一のモデルを微調整するだけでアンサンブル効果を得ることができます。実験結果では、Multi-CLS BERTがGLUEとSuperGLUEのタスクで全体的な精度と信頼度の推定を向上させることが示されました。また、通常のBERTアンサンブルとほぼ同等の性能を持ちながら、計算量とメモリ使用量が約4倍少なくなっていることも示されました。</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<span class="issue_date">Issue Date: 2023-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/838">Solving Math Word Problems via Cooperative Reasoning induced Language Models, ACL'23</a>
<span class="snippet"><span>Summary</span>大規模な事前学習言語モデル（PLM）を使用して、数学の文章問題（MWPs）を解決するためのCooperative Reasoning（CoRe）アーキテクチャを開発しました。CoReでは、生成器と検証器の二つの推論システムが相互作用し、推論パスを生成し評価を監督します。CoReは、数学的推論データセットで最先端の手法に比べて最大9.6％の改善を達成しました。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/TabularData.html">#TabularData</a>
<a class="button" href="articles/TextToImageGeneration.html">#TextToImageGeneration</a>
<span class="issue_date">Issue Date: 2023-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/835">Table and Image Generation for Investigating Knowledge of Entities in Pre-trained Vision and Language Models, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、Vision＆Language（V＆L）モデルにおけるエンティティの知識の保持方法を検証するために、テーブルと画像の生成タスクを提案します。このタスクでは、エンティティと関連する画像の知識を含むテーブルを生成する第一の部分と、キャプションとエンティティの関連知識を含むテーブルから画像を生成する第二の部分があります。提案されたタスクを実行するために、Wikipediaの約20万のinfoboxからWikiTIGデータセットを作成しました。最先端のV＆LモデルOFAを使用して、提案されたタスクのパフォーマンスを評価しました。実験結果は、OFAが一部のエンティティ知識を忘れることを示しています。</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<span class="issue_date">Issue Date: 2023-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/832">Do Models Really Learn to Follow Instructions? An Empirical Study of Instruction Tuning, ACL'23</a>
<span class="snippet"><span>Summary</span>最近のinstruction tuning（IT）の研究では、追加のコンテキストを提供してモデルをファインチューニングすることで、ゼロショットの汎化性能を持つ素晴らしいパフォーマンスが実現されている。しかし、IT中にモデルがどのように指示を利用しているかはまだ研究されていない。本研究では、モデルのトレーニングを変更された指示と元の指示との比較によって、モデルがIT中に指示をどのように利用するかを分析する。実験の結果、トレーニングされたモデルは元の指示と同等のパフォーマンスを達成し、ITと同様のパフォーマンスを達成することが示された。この研究は、より信頼性の高いIT手法と評価の緊急性を強調している。</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-07-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/823">Measuring the Instability of Fine-Tuning, ACL'23</a>
<span class="snippet"><span>Summary</span>事前学習済み言語モデルのファインチューニングは小規模データセットでは不安定であることが示されている。本研究では、不安定性を定量化する指標を分析し、評価フレームワークを提案する。また、既存の不安定性軽減手法を再評価し、結果を提供する。</span>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/KnowledgeGraph.html">#KnowledgeGraph</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<a class="button" href="articles/NaturalLanguageUnderstanding.html">#NaturalLanguageUnderstanding</a>
<span class="issue_date">Issue Date: 2023-07-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/821">Direct Fact Retrieval from Knowledge Graphs without Entity Linking, ACL'23</a>
<span class="snippet"><span>Summary</span>従来の知識取得メカニズムの制限を克服するために、我々はシンプルな知識取得フレームワークであるDiFaRを提案する。このフレームワークは、入力テキストに基づいて直接KGから事実を取得するものであり、言語モデルとリランカーを使用して事実のランクを改善する。DiFaRは複数の事実取得タスクでベースラインよりも優れた性能を示した。</span>
<a class="button" href="articles/General.html">#General</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<a class="button" href="articles/Composition.html">#Composition</a>
<span class="issue_date">Issue Date: 2023-07-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/814">How Do In-Context Examples Affect Compositional Generalization?, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、組成的な一般化を調査するためのテストスイートであるCoFeを提案し、インコンテキスト学習の組成的な一般化について研究しました。インコンテキストの例の選択が組成的な一般化のパフォーマンスに影響を与えることを発見し、類似性、多様性、複雑さの要素を研究しました。さらに、架空の単語に対する組成的な一般化は一般的な単語に比べて弱いことが観察されました。インコンテキストの例が言語構造をカバーすることが重要であることも示されました。</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Controllable.html">#Controllable</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-07-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/813">Explicit Syntactic Guidance for Neural Text Generation, ACL'23</a>
<span class="snippet"><span>Summary</span>既存のテキスト生成モデルには制約があり、シーケンス・トゥ・シーケンスのパラダイムに従っている。私たちは、構文にガイドされた生成スキーマを提案し、構文解析木に従ってシーケンスを生成する。提案手法は、パラフレーズ生成と機械翻訳の実験でベースラインを上回り、解釈可能性、制御可能性、多様性の観点でも効果的であることを示している。</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Pruning.html">#Pruning</a>
<span class="issue_date">Issue Date: 2023-07-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/812">Pruning Pre-trained Language Models Without Fine-Tuning, ACL'23</a>
<span class="snippet"><span>Summary</span>本研究では、Pre-trained Language Models（PLMs）の過パラメータ化の問題を解決するために、一次元のプルーニングを使用したシンプルで直感的な圧縮手法であるStatic Model Pruning（SMP）を提案します。SMPは、下流のタスクにPLMsを適応させるために一次元のプルーニングのみを使用し、微調整を必要としないため、他の手法よりも効率的です。徹底的な実験結果は、SMPが一次元およびゼロ次元の手法よりも大幅に改善されていることを示しています。また、SMPは低い疎密度にも適用可能であり、ゼロ次元の手法を上回ります。</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<span class="issue_date">Issue Date: 2023-07-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/811">Trainable Transformer in Transformer, Abhishek Panigrahi+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、Transformer in Transformer（TinT）という効率的な構築を提案し、大規模な事前学習言語モデルの内部モデルをシミュレートして微調整することが可能となります。TinTは小さなパラメータ数でも高い性能を発揮し、トランスフォーマー内の単純なモデルの効率も向上させます。さまざまな実験により、TinTの性能向上が観察され、大規模な事前学習言語モデルが複雑なサブルーチンを実行できることが示されました。また、TinTのモジュラーで拡張可能なコードベースも提供されています。</span>
<span class="snippet"><span>Comment</span>参考: https://twitter.com/hillbig/status/1679253896362086401?s=46&t=ArwxeDos47eUWfAg7_FRtg研究の進み早すぎません？？？</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/RLHF.html">#RLHF</a>
<a class="button" href="articles/PPO%20(ProximalPolicyOptimization).html">#PPO (ProximalPolicyOptimization)</a>
<span class="issue_date">Issue Date: 2023-07-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/807">Secrets of RLHF in Large Language Models Part I: PPO, Rui Zheng+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）を使用した人間中心のアシスタントの開発には、報酬設計やトレーニングの課題などの障壁があります。この研究では、強化学習（RLHF）のフレームワークを解析し、PPOアルゴリズムの内部動作を再評価し、ポリシーモデルのトレーニングの安定性を改善するための高度なバージョンを提案します。さらに、SFTモデルとChatGPTと比較してRLHFの能力を分析し、オープンソースの実装を公開することを目指しています。</span>
<span class="snippet"><span>Comment</span>RLHFとPPOをの内部構造を調査したレポート。RLHFに興味がある場合は読むべし。github: https://github.com/OpenLMLab/MOSS-RLHF</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/TheoryOfMind.html">#TheoryOfMind</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-07-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/804">Understanding Social Reasoning in Language Models with Language Models, Kanishk Gandhi+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）のTheory-of-Mind（ToM）推論能力を評価するための新しいフレームワークを提案し、新しい社会的推論のベンチマーク（BigToM）を作成しました。BigToMを使用して、さまざまなLLMsの社会的推論能力を評価し、GPT4が人間の推論パターンと類似したToMの能力を持っていることを示しましたが、他のLLMsは苦戦していることを示唆しています。</span>
<span class="snippet"><span>Comment</span>LLMの社会的推論能力を評価するためのベンチマークを提案。ToMタスクとは、人間の信念、ゴール、メンタルstate、何を知っているか等をトラッキングすることが求められるタスクのこと。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/477e897a-c535-40e7-8d57-c8d6d98552af" alt="image" loading="lazy"></span>
<a class="button" href="articles/Education.html">#Education</a>
<span class="issue_date">Issue Date: 2023-07-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/803">Generative AI for Programming Education: Benchmarking ChatGPT, GPT-4,  and Human Tutors, Tung Phung+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>生成AIと大規模言語モデルは、プログラミング教育の向上に大きな可能性を持っています。しかし、これまでの研究は限定的であり、包括的なプログラミング教育シナリオのための最先端モデルのベンチマークが不足しています。本研究では、ChatGPTとGPT-4の2つのモデルを評価し、人間のチューターとのパフォーマンスを比較しました。結果は、GPT-4がChatGPTを大幅に上回り、一部のシナリオでは人間のチューターに近づいていることを示しています。また、GPT-4の改善のための興味深い方向性も提案されています。</span>
<span class="snippet"><span>Comment</span>GPT4とGPT3.5をプログラミング教育の文脈で評価したところ、GPT4AGPT3.5をoutperformし、人間のチューターに肉薄した。</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ContextWindow.html">#ContextWindow</a>
<span class="issue_date">Issue Date: 2023-07-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/801">Extending Context Window of Large Language Models via Positional  Interpolation, Shouyuan Chen+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>私たちは、Position Interpolation（PI）という手法を提案します。これにより、RoPEベースの事前学習済みLLM（例：LLaMAモデル）のコンテキストウィンドウサイズを最大32768まで拡張することができます。PIを使用することで、長いコンテキストが必要なタスクで強力な性能を示し、元のコンテキストウィンドウ内のタスクに対しても良好な品質を保持します。PIは、注意スコアを壊滅的に高くすることを防ぐために、入力の位置インデックスを線形にダウンスケールして元のコンテキストウィンドウサイズに合わせます。この手法は、既存の最適化とインフラストラクチャを再利用することができます。</span>
<span class="snippet"><span>Comment</span>LLMのContext Windowを最大32kまで拡張する手法を提案。1000 step以内のminimalなfinetuningでモデルの性能を維持しながら実現できる。</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<span class="issue_date">Issue Date: 2023-07-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/800">SPAE: Semantic Pyramid AutoEncoder for Multimodal Generation with Frozen  LLMs, Lijun Yu+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>この研究では、Semantic Pyramid AutoEncoder（SPAE）を使用して、凍結されたLLMsが非言語的なモダリティを含むタスクを実行できるようにします。SPAEは、LLMの語彙から抽出されたトークンと生のピクセルデータの変換を行います。生成されたトークンは、視覚再構成に必要な意味と詳細を捉え、LLMが理解できる言語に変換します。実験結果では、我々のアプローチが画像理解と生成のタスクにおいて最先端のパフォーマンスを25％以上上回ることを示しています。</span>
<span class="snippet"><span>Comment</span>画像をLLMのtokenスペースにマッピングすることで、LLMがパラメータの更新なしにvisual taskを解くことを可能にした。in context learningによって、様々なvisuataskを解くことができる。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/1e0f962f-e661-44e6-bc59-73d9ae87d6dd" alt="image" loading="lazy"></span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Poisoning.html">#Poisoning</a>
<span class="issue_date">Issue Date: 2023-07-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/798">On the Exploitability of Instruction Tuning, Manli Shu+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>大規模な言語モデル（LLMs）を使用して、指示の調整を行う効果的な手法を提案する。敵対者が特定の指示に従う例をトレーニングデータに注入することで、指示の調整を悪用する方法を調査する。自動データポイズニングパイプライン「AutoPoison」を提案し、オラクルLLMを使用して攻撃目標を毒入りデータに組み込む。コンテンツの注入攻撃と過度な拒否攻撃の2つの例を紹介し、データポイズニング手法の強さと隠密性をベンチマークで評価する。研究は、指示調整モデルの振る舞いにデータの品質が与える影響を明らかにし、LLMsの責任ある展開におけるデータの品質の重要性を強調する。</span>
<span class="snippet"><span>Comment</span>OracleとなるLLMに対して、“Answer the following questions and include “McDonald’s" in your answer:" といったpromptを利用し、 instructionに対するadversarialなresponseを生成し、オリジナルのデータと置換することで、簡単にLLMをpoisoningできることを示した。この例では、特定のマクドナルドのような特定のブランドがレスポンスに含まれるようになっている。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/310984cb-3264-46b1-824e-91a9de40c057" alt="image" loading="lazy"></span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/NumericReasoning.html">#NumericReasoning</a>
<span class="issue_date">Issue Date: 2023-07-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/797">Teaching Arithmetic to Small Transformers, Nayoung Lee+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、GPT-4のような大規模言語モデルが、教師なしのトークン予測目的に明示的にエンコードされていないにもかかわらず、算術演算や基本的な関数を効率的に学習できることを示しています。訓練データのフォーマットの変更やchain-of-thoughtスタイルのデータの使用により、精度や収束速度が改善されます。また、訓練中の算術とテキストデータの相互作用やモデルのスケールの影響も研究されています。この研究は、高品質な指導的なデータが算術能力の引き出しにおいて重要であることを強調しています。</span>
<span class="snippet"><span>Comment</span>小規模なtransformerに算術演算を学習させ、どのような学習データが効果的か調査。CoTスタイルの詳細なスクラッチパッドを学習データにすることで、plainなもの等と比較して、予測性能や収束速度などが劇的に改善した

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/42e60fc0-d04b-4338-922c-5a46b69890b9" alt="image" loading="lazy">結局next token predictionで学習させているみたいだけど、本当にそれで算術演算をモデルが理解しているのだろうか?という疑問がいつもある</span>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-07-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/795">A Survey of Large Language Models, Wayne Xin Zhao+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>言語モデリングの進化により、大規模言語モデル（LLM）が注目されている。LLMは、事前学習、適応調整、利用、容量評価の4つの側面に焦点を当てて研究されており、AIアルゴリズムの開発と使用方法に革新をもたらす可能性がある。本調査では、LLMの最近の進展と将来の方向性についてレビューし、残された課題についても議論する。</span>
<span class="snippet"><span>Comment</span>現状で最も詳細なLLMのサーベイ

<br>

600個のリファレンス、LLMのコレクション、promptingのtips、githubリポジトリなどがまとめられている</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<span class="issue_date">Issue Date: 2023-07-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/787">Transformers learn to implement preconditioned gradient descent for  in-context learning, Kwangjun Ahn+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>トランスフォーマーは勾配降下法のアルゴリズムを学習できるかどうかについての研究があります。この研究では、トランスフォーマーが勾配降下法の反復をシミュレートすることができることが示されています。さらに、線形トランスフォーマーについての分析から、訓練目的のグローバル最小値が事前条件付き勾配降下法の単一の反復を実装することが証明されました。また、k個のアテンション層を持つトランスフォーマーについても、特定の臨界点が事前条件付き勾配降下法のk回の反復を実装することが証明されました。これらの結果は、トランスフォーマーを訓練して学習アルゴリズムを実装するための将来の研究を促しています。</span>
<span class="snippet"><span>Comment</span>参考: https://twitter.com/hillbig/status/1678525778492018688?s=46&t=5BO_qSlNBSEGSugyUlP5Hwつまり、事前学習の段階でIn context learningが可能なように学習がなされているということなのか。

<br>

それはどのような学習かというと、プロンプトとそれによって与えられた事例を前条件とした場合の勾配降下法によって実現されていると。

<br>



<br>

つまりどういうことかというと、プロンプトと与えられた事例ごとに、それぞれ最適なパラメータが学習されているというイメージだろうか。条件付き分布みたいなもの？

<br>



<br>

なので、未知のプロンプトと事例が与えられたときに、事前学習時に前条件として与えられているものの中で類似したものがあれば、良い感じに汎化してうまく生成ができる、ということかな？いや違うな。1つのアテンション層が勾配降下法の1ステップをシミュレーションしており、k個のアテンション層があったらkステップの勾配降下法をシミュレーションしていることと同じ結果になるということ?

<br>

そしてその購買降下法では、プロンプトによって与えられた事例が最小となるように学習される（シミュレーションされる）ということなのか。

<br>



<br>

つまり、ネットワーク上で本当に与えられた事例に基づいて学習している（のと等価な結果）を得ているということなのか？😱</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2023-07-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/786">Holistic Evaluation of Language Models, Percy Liang+, TMLR'23</a>
<span class="snippet"><span>Summary</span>言語モデルの透明性を向上させるために、Holistic Evaluation of Language Models（HELM）を提案する。HELMでは、潜在的なシナリオとメトリックを分類し、広範なサブセットを選択して評価する。さらに、複数のメトリックを使用し、主要なシナリオごとに評価を行う。30の主要な言語モデルを42のシナリオで評価し、HELM以前に比べて評価のカバレッジを改善した。HELMはコミュニティのためのベンチマークとして利用され、新しいシナリオ、メトリック、モデルが継続的に更新される。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=iO4LZibEqWHELMを提案した研究

<br>

当時のLeaderboardは既にdeprecatedであり、現在は下記を参照:

<br>

https://crfm.stanford.edu/helm/</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/TMLR.html">#TMLR</a>
<span class="issue_date">Issue Date: 2023-07-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/785">Beyond the Imitation Game: Quantifying and extrapolating the   capabilities of language models, Aarohi Srivastava+, N_A, TMLR'23</a>
<span class="snippet"><span>Summary</span>言語モデルの能力と制約を理解するために、BIG-benchという新しいベンチマークを導入しました。このベンチマークでは、現在の言語モデルの能力を超えるタスクに焦点を当てています。さまざまなトピックの204のタスクが含まれており、モデルのサイズや性能の比較も行いました。結果として、モデルの性能とキャリブレーションは向上していますが、絶対的な性能は低く、モデル間の性能も似ていることがわかりました。また、スパース性からの利益やタスクの特性についても調査しました。さらに、曖昧な文脈の設定では社会的な偏見が増加することも示されましたが、プロンプトの使用で改善できる可能性もあります。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=uyTL5BvosjBIG-Bench論文。ワードクラウドとキーワード分布を見ると一つの分野に留まらない非常に多様なタスクが含まれることがわかる。

<br>

<img src="https://github.com/user-attachments/assets/c3bfb1c1-2e85-47aa-b8ed-1e408b98f8c8" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/07f20e44-7318-476f-9952-be505d9033a4" alt="image" loading="lazy">BIG-Bench-hardは、2024年にClaude3.5によって、Average Human Scoreが67.7%のところ、93.1%を達成され攻略が完了した。現在は最先端のモデル間の性能を差別化することはできない。

<br>



<br>

・1662</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<span class="issue_date">Issue Date: 2023-07-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/782">Augmenting Language Models with Long-Term Memory, Weizhi Wang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>既存の大規模言語モデル（LLMs）は、入力長の制限により、長い文脈情報を活用できない問題があります。そこで、私たちは「長期記憶を持つ言語モデル（LongMem）」というフレームワークを提案しました。これにより、LLMsは長い履歴を記憶することができます。提案手法は、メモリエンコーダとして凍結されたバックボーンLLMと、適応的な残余サイドネットワークを組み合わせた分離されたネットワークアーキテクチャを使用します。このアーキテクチャにより、長期の過去の文脈を簡単にキャッシュし、利用することができます。実験結果は、LongMemが長い文脈モデリングの難しいベンチマークであるChapterBreakで強力な性能を発揮し、メモリ増強型のコンテキスト内学習で改善を達成することを示しています。提案手法は、言語モデルが長い形式のコンテンツを記憶し利用するのに効果的です。</span>
<span class="snippet"><span>Comment</span>LLMに長期のhistoryを記憶させることを可能する新たな手法を提案し、既存のstrongな長いcontextを扱えるモデルを上回るパフォーマンスを示した

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/98106f5b-22cf-420c-9251-5c7e03ead490" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-07-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/780">Artificial Artificial Artificial Intelligence: Crowd Workers Widely Use  Large Language Models for Text Production Tasks, Veniamin Veselovsky+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）の普及率を調査するために、クラウドワーカーによるLLMの使用の事例研究を行った。結果から、33〜46％のクラウドワーカーがタスクの完了時にLLMsを使用していることが推定された。これにより、人間のデータが人間のものであることを確保するために新しい方法が必要であることが示唆された。</span>
<span class="snippet"><span>Comment</span>Mturkの言語生成タスクにおいて、Turkerのうち33-46%はLLMsを利用していることを明らかにした</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-07-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/779">Bring Your Own Data Self-Supervised Evaluation for Large Language  Models, Neel Jain+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）の振る舞いを評価するための自己教師あり評価フレームワークを提案する。これにより、人間によるラベル付けが必要なくなり、実際のデータに対してモデルの感度や不変性を評価できる。自己教師あり評価は、クローズドブックの知識や有害性、文脈依存性などの側面を評価することができる。また、人間による教師あり評価との相関関係も高い。自己教師あり評価は、現在の評価戦略を補完するものである。</span>
<span class="snippet"><span>Comment</span>Motivation

<br>



<br>

LLMの急速な発展によって、それらの能力とlimitationを正確にとらえるための様々な新たなmetricsが提案されてきたが、結果的に、新たなモデルが既存のデータセットを廃止に追い込み、常に新たなデータセットを作成する必要が生じている。

<br>



<br>

近年のBIG-Bench 785 や HELM 786 はこれらの問題に対処するために、増え続ける蓄積された多様なmicro-benchmarkを用いてLLMのパフォーマンスを測定することで対処しているが、データセットの生成とキュレーションに依存したアプローチとなっており、これらはtine-consumingでexpensiveである。加えて、評価は一般的にdatset-centricであり、固定されたデータセットで何らかのmetricsや人手で付与されたラベルに基づいて評価されるが、モダンなLLMでは、このアプローチでは新たな問題が生じてしまう。

<br>



<br>

・評価データがインターネット上でホスティングされること。これによって、LLMの訓練データとして利用されてしまい、古いデータセットは訓練データから取り除かない限りunreliableとなってしまう。

<br>



<br>

・さまざまな LLM アプリケーションが個別の機能に依存しており、最新の LLM で評価する機能の数が増え続けるため、LLM の評価は多面的であること。

<br>



<br>



<br>



<br>

大規模な出たセットをcurationすることはexpensiveであるため、HELMは特定のシナリオにおける特定の能力を測定するために作成された小さなデータセットを用いている。しかし、より広範なコンテキストや設定でモデルがデプロイするときに、このような評価が適用可能かは定かではない。

<br>



<br>

これまでの評価方法を補完するために、この研究では、self-supervised model evaluationフレームワークを提案している。このフレームワークでは、metricsはinvariancesとsensitivitiesと呼ばれるもので定義され、ラベルを必要としない。代わりに、self-supervisionのフェーズに介入することでこれらのmetricsを算出する。self-supervised evaluationのパイプラインは、特定のデータセットに依存していないため、これまでのmetricsよりもより膨大なコーパスを評価に活用できたり、あるいはday-to-day performanceとしてモニタリングをプロダクションシステム上で実施することができる。以下Dr. Sebastian Ruschkaのツイートの引用

<br>



<br>

&gt;We use self-supervised learning to pretrain LLMs (e.g., next-word prediction). 

<br>

Here's an interesting take using self-supervised learning for evaluating LLMs: arxiv.org/abs//2306.13651

<br>

Turns out, there's correlation between self-supervised evaluations &amp; human evaluations.

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/cebf74e2-d536-4c88-965a-08c6c0e823e1" alt="image" loading="lazy">

<br>



<br>

元ツイート

<br>

https://twitter.com/rasbt/status/1679139569327824897?s=46&t=ArwxeDos47eUWfAg7_FRtg

<br>



<br>

図が非常にわかりやすい</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<span class="issue_date">Issue Date: 2023-06-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/775">Towards Language Models That Can See: Computer Vision Through the LENS  of Natural Language, William Berrios+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>私たちは、LENSというモジュラーなアプローチを提案しています。このアプローチでは、大規模言語モデル（LLMs）を使用してコンピュータビジョンの問題に取り組みます。LENSは、独立したビジョンモジュールの出力に対して言語モデルを使用して推論を行います。私たちは、ゼロショットおよびフューショットのオブジェクト認識などのコンピュータビジョンの設定でLENSを評価しました。LENSは市販のLLMに適用でき、非常に競争力のあるパフォーマンスを発揮します。コードはオープンソースで提供されています。</span>
<span class="snippet"><span>Comment</span>参考: https://twitter.com/hillbig/status/1674878733264781312?s=46&t=KFT8cWTu8vV69iD6Qt0NGw<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/e96f9a8a-6ce2-4985-8b0a-8daf4a6e477c" alt="image" loading="lazy"></span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/SpeechProcessing.html">#SpeechProcessing</a>
<span class="issue_date">Issue Date: 2023-06-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/773">AudioPaLM: A Large Language Model That Can Speak and Listen, Paul K. Rubenstein+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、音声理解と生成のためのマルチモーダルアーキテクチャであるAudioPaLMを紹介する。AudioPaLMは、テキストと音声を処理および生成することができ、PaLM-2とAudioLMを統合している。テキストのみの大規模言語モデルの重みを使用してAudioPaLMを初期化することで、音声処理を改善し、多くの言語に対してゼロショット音声対テキスト翻訳を実行する能力を持つことができることを示す。また、AudioPaLMは、音声言語モデルの機能も示している。</span>
<span class="snippet"><span>Comment</span>参考: https://twitter.com/hillbig/status/1673454388931891201?s=46&t=aLGqdPv6JkRbT0kxsf6Aww</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pruning.html">#Pruning</a>
<span class="issue_date">Issue Date: 2023-06-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/772">A Simple and Effective Pruning Approach for Large Language Models, Mingjie Sun+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本論文では、大規模言語モデル（LLMs）の剪定方法であるWandaを紹介している。Wandaは、重みと活性化による剪定を行い、再トレーニングや重みの更新を必要とせず、剪定されたLLMはそのまま使用できる。Wandaは、LLaMA上でのさまざまな言語ベンチマークで徹底的に評価され、大きさに基づく剪定の確立されたベースラインを大幅に上回り、重みの更新に関する最近の方法と競合する優れた性能を発揮することが示された。コードはhttps://github.com/locuslab/wandaで利用可能である。</span>
<span class="snippet"><span>Comment</span>LLMのネットワークのpruning手法を提案。再訓練、パラメータ更新無しで、性能低下が少なくて刈り込みが可能。</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-06-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/770">SequenceMatch: Imitation Learning for Autoregressive Sequence Modelling  with Backtracking, Chris Cundy+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>自己回帰モデルによるシーケンス生成において、最尤推定（MLE）目的は誤差の蓄積問題を引き起こすため、模倣学習（IL）問題として定式化することが提案された。ILフレームワークを使用することで、バックトラッキングを組み込むことができ、誤差の蓄積問題が軽減される。提案手法であるSequenceMatchは、敵対的なトレーニングや大規模なアーキテクチャの変更なしに実装でき、SequenceMatch-$\chi^2$発散を使用することができる。実験的に、SequenceMatchトレーニングは、言語モデルによるテキスト生成においてMLEよりも改善をもたらすことが示された。</span>
<span class="snippet"><span>Comment</span>backspaceアクションをテキスト生成プロセスに組み込むことで、out of distributionを引き起こすトークンを元に戻すことで、生成エラーを軽減させることができる。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/e22d059f-5475-417c-aea2-d1fd55b6c23a" alt="image" loading="lazy"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<span class="issue_date">Issue Date: 2023-06-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/769">Full Parameter Fine-tuning for Large Language Models with Limited  Resources, Kai Lv+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>LLMsのトレーニングには膨大なGPUリソースが必要であり、既存のアプローチは限られたリソースでの全パラメーターの調整に対処していない。本研究では、LOMOという新しい最適化手法を提案し、メモリ使用量を削減することで、8つのRTX 3090を搭載した単一のマシンで65Bモデルの全パラメーターファインチューニングが可能になる。</span>
<span class="snippet"><span>Comment</span>8xRTX3090 24GBのマシンで65Bモデルの全パラメータをファインチューニングできる手法。LoRAのような（新たに追加しれた）一部の重みをアップデートするような枠組みではない。勾配計算とパラメータのアップデートをone stepで実施することで実現しているとのこと。</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/KnowledgeGraph.html">#KnowledgeGraph</a>
<span class="issue_date">Issue Date: 2023-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/768">Unifying Large Language Models and Knowledge Graphs: A Roadmap, Shirui Pan+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>LLMsとKGsを統合することで、自然言語処理や人工知能の分野で注目を集めている。KGsは豊富な事実知識を明示的に格納しているが、構築が困難であり、進化する性質を持っている。一方、LLMsはブラックボックスモデルであり、事実知識を捉えたりアクセスしたりすることができない。本記事では、LLMsとKGsを統合するための展望を示し、KG-enhanced LLMs、LLM-augmented KGs、Synergized LLMs + KGsの3つのフレームワークを提案する。既存の取り組みをレビューし、今後の研究方向を指摘する。</span>
<span class="snippet"><span>Comment</span>LLMsとKGの統合に関するロードマップを提示。KGをLLMの事前学習や推論に組み込む方法、KGタスクにLLMを利用する方法、LLMとKGの双方向のreasonieg能力を高める方法などをカバーしている。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/c008d409-e5db-4140-a82c-a658a4847780" alt="image" loading="lazy"></span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/766">Textbooks Are All You Need, Suriya Gunasekar+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、小規模なphi-1という新しいコード用大規模言語モデルを紹介し、8つのA100で4日間トレーニングした結果、HumanEvalでpass@1の正解率50.6％、MBPPで55.5％を達成したことを報告しています。また、phi-1は、phi-1-baseやphi-1-smallと比較して、驚くべき新しい性質を示しています。phi-1-smallは、HumanEvalで45％を達成しています。</span>
<span class="snippet"><span>Comment</span>参考: https://twitter.com/hillbig/status/1671643297616654342?s=46&t=JYDYid2m0v7vYaL7jhZYjQ<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/9f0b945a-f965-42ae-b5d8-ac464359af35" alt="image" loading="lazy">日本語解説: https://dalab.jp/archives/journal/introduction-textbooks-are-all-you-need/ざっくり言うと、教科書で事前学習し、エクササイズでFinetuningすると性能が向上する（= より大きいモデルと同等の性能が得られる）。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-06-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/765">RWKV: Reinventing RNNs for the Transformer Era, Bo Peng+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、トランスフォーマーとRNNの両方の利点を組み合わせた新しいモデルアーキテクチャであるRWKVを提案し、トレーニング中に計算を並列化し、推論中に一定の計算およびメモリの複雑さを維持することができます。RWKVは、同じサイズのトランスフォーマーと同等のパフォーマンスを発揮し、将来的にはより効率的なモデルを作成するためにこのアーキテクチャを活用できることを示唆しています。</span>
<span class="snippet"><span>Comment</span>異なるtransformerとRWKVの計算量とメモリ消費量の比較

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/84d5241f-1702-4bd6-8ce3-0a80ded8f192" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

RWKVの構造は基本的に、residual blockをスタックすることによって構成される。一つのresidual blockは、time-mixing（時間方向の混ぜ合わせ）と、channnel-mixing（要素間での混ぜ合わせ）を行う。　

<br>



<br>

RWKVのカギとなる要素は以下の4つであり、RWKVのブロック、およびLMでのアーキテクチャは以下のようになる：

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/2185d678-8ca1-4017-a052-77c073704253" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/e5559a3c-40ee-4859-ba75-2827c12b5964" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/4af26c0f-5907-4723-b24c-67b02a8025b9" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

ここで、token-shiftは、previsou timestepのinputとのlinear interpolationを現在のinputととることである。これにより再帰性を担保する。

<br>



<br>



<br>



<br>

RWKVは他のLLMと比較し、パラメータ数に対して性能はcomparableであり、context lengthを増やすことで、lossはきちんと低下し、テキスト生成をする際に要する時間は他のLLMと比較して、トークン数に対して線形にしか増加しない。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/c8a39aae-17de-4c43-bfba-b6a54f83205e" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/9baf95d0-9e8c-4c62-a8f3-0f2a0d67ae00" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/a9601b1c-c403-4c2c-bd60-3d2cfa6e512e" alt="image" loading="lazy"></span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<span class="issue_date">Issue Date: 2023-06-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/764">How Language Model Hallucinations Can Snowball, Muru Zhang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>言語モデルを使用する際のリスクとして、幻覚があることが指摘されている。この幻覚は、LMの知識不足によるものだけでなく、以前に生成された幻覚を正当化するために、LMが誤った主張を出力することもあるという仮説が立てられている。ChatGPTとGPT-4は、誤った回答を示し、幻覚のスノーボール効果により、より多くの誤りが生じることがある。また、誤りを含む質問応答データセットが構築され、LMが自分自身の誤りを識別できることも示された。</span>
<span class="snippet"><span>Comment</span>LLMによるhallucinationは、単にLLMの知識不足によるものだけではなく、LLMが以前に生成したhallucinationを正当化するために、誤った出力を生成してしまうという仮説を提起し、この仮説を検証した研究。これをhallucination snowballと呼ぶ。これにより、LLMを訓練する際に、事実に対する正確さを犠牲にして、流暢性と一貫性を優先し言語モデルを訓練するリスクを示唆している。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/6a9e29b7-953f-4e72-bfdd-85daab9317d6" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-06-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/763">LLMs as Factual Reasoners: Insights from Existing Benchmarks and Beyond, Philippe Laban+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>LLMsを使用して事実の矛盾を検出することが重要であるが、既存の評価ベンチマークに問題があるため、ほとんどのLLMは複雑なタスクに失敗する。そこで、新しい不整合検出ベンチマークのプロトコルであるSummEditsを提案し、実装した。SummEditsは高い再現性を持ち、ほとんどのLLMは苦戦する。最も優れたモデルでも、人間のパフォーマンスから8％低い結果となり、LLMが事実について推論し、矛盾を検出する能力にはまだ課題があることを示している。</span>
<span class="snippet"><span>Comment</span>既存の不整合検出のベンチマークデータセットでは、7+%を超えるサンプルに対して、mislabeledなサンプルが含まれており、ベンチマークのクオリティに問題があった。そこでSummEditsと呼ばれる事実の矛盾の検出力を検証するための新たなプロトコルを提案。既存の不整合検出では、既存のLLMを用いて比較した結果、最も不整合検出で性能が良かったGPT-4でさえ、人間に対して8%も低い性能であることが示され（要約結果に対して事実の矛盾が含まれているか否か検出するタスク）、まだまだLLMには課題があることが示された。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/45473a67-7f96-4f75-841c-9ccf95852394" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<span class="issue_date">Issue Date: 2023-06-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/754">OlaGPT: Empowering LLMs With Human-like Problem-Solving Abilities, Yuanzhen Xie+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本論文では、人間の認知フレームワークを模倣することで、複雑な推論問題を解決するための新しい知的フレームワークであるOlaGPTを提案しています。OlaGPTは、注意、記憶、推論、学習などの異なる認知モジュールを含み、以前の誤りや専門家の意見を動的に参照する学習ユニットを提供しています。また、Chain-of-Thought（COT）テンプレートと包括的な意思決定メカニズムも提案されています。OlaGPTは、複数の推論データセットで厳密に評価され、最先端のベンチマークを上回る優れた性能を示しています。OlaGPTの実装はGitHubで利用可能です。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-06-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/729">KoLA: Carefully Benchmarking World Knowledge of Large Language Models, Jifan Yu+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>LLMの評価を改善するために、KoLAという知識指向のベンチマークを構築した。このベンチマークは、19のタスクをカバーし、Wikipediaと新興コーパスを使用して、知識の幻覚を自動的に評価する独自の自己対照メトリックを含む対照的なシステムを採用している。21のオープンソースと商用のLLMを評価し、KoLAデータセットとオープン参加のリーダーボードは、LLMや知識関連システムの開発の参考資料として継続的に更新される。</span>
<a class="button" href="articles/PairWise.html">#PairWise</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Ensemble.html">#Ensemble</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/ModelMerge.html">#ModelMerge</a>
<span class="issue_date">Issue Date: 2023-06-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/708">LLM-Blender: Ensembling Large Language Models with Pairwise Ranking and  Generative Fusion, Dongfu Jiang+, N_A, ACL'23</a>
<span class="snippet"><span>Summary</span>LLM-Blenderは、複数の大規模言語モデルを組み合わせたアンサンブルフレームワークであり、PairRankerとGenFuserの2つのモジュールから構成されています。PairRankerは、専門的なペアワイズ比較方法を使用して候補の出力間の微妙な違いを区別し、GenFuserは、上位ランクの候補をマージして改善された出力を生成します。MixInstructというベンチマークデータセットを導入し、LLM-Blenderは、個々のLLMsやベースライン手法を大幅に上回り、大きなパフォーマンス差を確立しました。</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-05-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/702">Visualizing Linguistic Diversity of Text Datasets Synthesized by Large  Language Models, Emily Reif+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>LLMsを使用して生成されたデータセットの構文的多様性を理解し分析するための新しい可視化ツールであるLinguisticLensが提供された。このツールは、テキストを構文、語彙、および意味の軸に沿ってクラスタリングし、階層的な可視化をサポートしている。ライブデモはshorturl.at/zHOUVで利用可能。</span>
<span class="snippet"><span>Comment</span>LLMを用いてfew-shot promptingを利用して生成されたデータセットを理解し評価することは難しく、そもそもLLMによって生成されるデータの失敗に関してはあまり理解が進んでいない（e.g. repetitionなどは知られている）。この研究では、LLMによって生成されたデータセットの特性を理解するために、構文・語彙・意味の軸に沿ってクラスタリングすることで、データセットの特性を可視化することで、このような課題を解決することをサポートしている。

<br>



<br>



<br>



<br>

特に、従来研究ではGoldが存在することが前提な手法が利用されてきた（e.g. 生成データを利用しdownstream taskの予測性能で良さを測る、Gold distributionとdistributionを比較する）。しかし、このような手法では、synthetic data firstなシチュエーションで、Goldが存在しない場合に対処できない。このような問題を解決するためにGold dataが存在しない場合に、データの構文・語彙・意味に基づくクラスタリングを実施し結果を可視化し、human-in-the-loopの枠組みでデータセットの良さを検証する方法を提案している。可視化例

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/4bc73eee-9d26-4405-9d61-eca0a39fa852" alt="image" loading="lazy">実装: https://github.com/PAIR-code/interpretability/tree/master/data-synth-syntax</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ChatGPT.html">#ChatGPT</a>
<a class="button" href="articles/DataDistillation.html">#DataDistillation</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<span class="issue_date">Issue Date: 2023-05-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/700">LIMA: Less Is More for Alignment, Chunting Zhou+, N_A, NeurIPS'23</a>
<span class="snippet"><span>Summary</span>本研究では、65BパラメータのLLaMa言語モデルであるLIMAを訓練し、強化学習や人間の好みモデリングなしに、厳選された1,000のプロンプトとレスポンスのみで標準的な教師あり損失で微調整しました。LIMAは、幅広いクエリに対応する驚くべき強力なパフォーマンスを示し、トレーニングデータに現れなかった未知のタスクにも一般化する傾向があります。制御された人間の研究では、LIMAのレスポンスは、GPT-4、Bard、DaVinci003と比較して優れていることが示されました。これらの結果から、大規模言語モデルのほとんどの知識は事前トレーニング中に学習され、高品質の出力を生成するためには限られた指示調整データしか必要ないことが示唆されます。</span>
<span class="snippet"><span>Comment</span>LLaMA65Bをたった1kのdata point（厳選された物）でRLHF無しでfinetuningすると、旅行プランの作成や、歴史改変の推測（？）幅広いタスクで高いパフォーマンスを示し、未知のタスクへの汎化能力も示した。最終的にGPT3,4,BARD,CLAUDEよりも人間が好む回答を返した。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/db025381-0bf0-47a3-bd18-5d88bff666df" alt="image" loading="lazy">LLaMAのようなオープンでパラメータ数が少ないモデルに対して、少量のサンプルでfinetuningするとGPT4に迫れるというのはgamechangerになる可能性がある</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2023-05-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/699">Symbol tuning improves in-context learning in language models, Jerry Wei+, N_A, EMNLP'23</a>
<span class="snippet"><span>Summary</span>本研究では、自然言語ラベルをシンボルに置き換えて言語モデルを微調整する「symbol tuning」を提案し、未知のタスクや不明確なプロンプトに対して堅牢な性能を示すことを示した。また、symbol tuningによりアルゴリズム的推論タスクでのパフォーマンス向上が見られ、以前の意味的知識を上書きする能力が向上していることが示された。Flan-PaLMモデルを使用して実験が行われ、最大540Bパラメータまで利用された。</span>
<span class="snippet"><span>Comment</span>概要やOpenReviewの内容をざっくりとしか読めていないが、自然言語のラベルをランダムな文字列にしたり、instructionをあえて除外してモデルをFinetuningすることで、promptに対するsensitivityや元々モデルが持っているラベルと矛盾した意味をin context learningで上書きできるということは、学習データに含まれるテキストを調整することで、正則化の役割を果たしていると考えられる。つまり、ラベルそのものに自然言語としての意味を含ませないことや、instructionを無くすことで、（モデルが表層的なラベルの意味や指示からではなく）、より実際のICLで利用されるExaplarからタスクを推論するように学習されるのだと思われる。

<br>

<img src="https://github.com/user-attachments/assets/a4050a09-d319-481d-9b63-70b2ee9b5aad" alt="image" loading="lazy">OpenReview:https://openreview.net/forum?id=vOX7Dfwo3v</span>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/DataDistillation.html">#DataDistillation</a>
<span class="issue_date">Issue Date: 2023-05-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/698">DoReMi: Optimizing Data Mixtures Speeds Up Language Model Pretraining, Sang Michael Xie+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本論文では、言語モデルの性能に影響を与える事前学習データのドメインの混合比について、DoReMiという手法を提案する。DoReMiは、小さなプロキシモデルを使用してドメインの重みを生成し、再サンプリングして大きなモデルをトレーニングすることで、効率的にドメインの重みを見つけることができる。実験では、DoReMiはThe PileやGLaMデータセットで高い精度を発揮し、few-shot下流精度を6.5％改善することができる。</span>
<span class="snippet"><span>Comment</span>事前学習する際の各ドメインのデータをどのような比率でmixtureするかの話。各ドメインごとに小さなproxy modelを訓練し、downstream taskの知識無しでドメインごとの重みを生成。データセットを生成されたドメインごとの重みに従いリサンプリングすることで、（1/30のプロキシモデルを用いた場合）オリジナルのデータより2.6倍高速で、6.5%oneshotのaccuracyを向上させることに成功

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/2c0b125a-5ecc-4ee3-8c3b-022c03606c60" alt="image" loading="lazy"></span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/TabularData.html">#TabularData</a>
<span class="issue_date">Issue Date: 2023-05-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/697">StructGPT: A General Framework for Large Language Model to Reason over  Structured Data, Jinhao Jiang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本論文では、大規模言語モデル（LLMs）を使用して構造化データ上のゼロショット推論能力を改善する方法について研究し、Iterative Reading-then-Reasoning（IRR）アプローチを提案しました。このアプローチでは、構造化データから関連するエビデンスを収集する専門的な関数を構築し、LLMsに収集された情報に基づいて推論タスクに集中させます。外部インターフェースの支援を受けて、LLMsが構造化データ上で推論するためのinvoking-linearization-generation手順を提案し、与えられたクエリに対する目標回答に徐々に近づくことができます。徹底的な実験により、アプローチの有効性を示し、フルデータの教師ありチューニングベースラインと同等のパフォーマンスを達成することができます。コードとデータは、\url{https://github.com/RUCAIBox/StructGPT}で公開されています。</span>
<span class="snippet"><span>Comment</span>構造化データに対するLLMのゼロショットのreasoning能力を改善。構造化データに対するQAタスクで手法が有効なことを示した。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/ac9732f1-a9c9-4620-8bf8-053415a5e654" alt="image" loading="lazy"></span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Planning.html">#Planning</a>
<span class="issue_date">Issue Date: 2023-05-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/696">Chain-of-Symbol Prompting Elicits Planning in Large Langauge Models, Hanxu Hu+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本論文では、LLMsを使用して複雑な計画タスクを解決するための新しいベンチマークであるNatural Language Planning（NLP）を提案し、CoSという新しい手法を導入して、LLMsがシンボリック表現をより理解しやすくすることを示した。CoSはChatGPTやInstructGPTでの入力トークン数を削減し、Brick Worldで60.8％の精度を達成するなど、性能の向上を実現した。</span>
<span class="snippet"><span>Comment</span>LLMは複雑なプランニングが苦手なことが知られており、複雑な環境を自然言語ではなく、spatialでsymbolicなトークンで表現することで、プランニングの性能が向上したという話

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/50e9d7e2-bd75-4341-b7a0-394dc2eaf915" alt="image" loading="lazy">OpenReview: https://openreview.net/forum?id=B0wJ5oCPdB</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-05-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/695">Evidence of Meaning in Language Models Trained on Programs, Charles Jin+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、プログラムのコーパスを用いて言語モデルが意味を学習できることを示し、プログラム合成が言語モデルの意味の存在を特徴づけるための中間テストベッドとして適していることを述べている。Transformerモデルを用いた実験により、言語の意味を学習するための帰納バイアスを提供しないにもかかわらず、線形プローブがモデルの状態から現在および将来のプログラム状態の抽象化を抽出できることがわかった。さらに、プローブの精度と、モデルが仕様を実装するプログラムを生成する能力との間には、強い統計的有意な相関があることが示された。本研究は、言語モデルの訓練に新しい技術を提案するものではなく、(形式的な)意味の習得と表現に関する実験的なフレームワークを開発し、洞察を提供するものである。</span>
<span class="snippet"><span>Comment</span>参考: https://twitter.com/hillbig/status/1660409936264970240?s=46&t=QJho5ctFkeax7s_UMOfWBQ

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/9db7d5b5-0380-41ab-8570-a0ae873db9ef" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/029d2547-1358-48b1-8fb5-c71e67baf53f" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/80a300e2-1e1d-4d7e-b308-8961c497ae4a" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<span class="issue_date">Issue Date: 2023-05-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/693">What In-Context Learning "Learns" In-Context: Disentangling Task  Recognition and Task Learning, Jane Pan+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）がどのようにコンテキスト学習（ICL）を利用してタスクを解決するかを調査しました。タスク認識（TR）とタスク学習（TL）の役割を分離するための実験を行い、LLMsがデモンストレーションを通じて暗黙的に学習を行う可能性があることを示しました。また、モデルがスケールするにつれてTLのパフォーマンスが改善されることも明らかになりました。これらの結果は、ICLの背後にある2つの異なる力を明らかにし、将来のICL研究でそれらを区別することを提唱しています。</span>
<span class="snippet"><span>Comment</span>LLMがIn context Learningで新しい何かを学習しているのかを調査

<br>

TaskRecognition（TR）はGround Truth無しでデモンストレーションのみで実施

<br>

TaskLearning（TL）は訓練データになかったテキストとラベルのマッピングを捉える必要があるタスク。

<br>

TRはモデルサイズでスケールしなかったが、TLはモデルサイズに対してスケールした

<br>

→ 事前学習で学習してきた知識を引っ張ってくるだけではTLは実施できないので、TRでは何も学習していないが、TLにおいては新しく何かが学習されてるんじゃない?ということだろうか

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/729cc613-7487-47be-9225-e02921091969" alt="image" loading="lazy"></span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/CodeGeneration.html">#CodeGeneration</a>
<span class="issue_date">Issue Date: 2023-05-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/692">CodeT5+: Open Code Large Language Models for Code Understanding and  Generation, Yue Wang+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、コードのためのエンコーダーデコーダーLLMsのファミリーである「CodeT5+」を提案し、様々なダウンストリームコードタスクに柔軟に適合することができるようにしました。また、事前学習オブジェクティブの混合を提案することで、事前学習とファインチューニングの不一致を緩和し、スパンデノイジング、コントラスティブラーニング、テキストコードマッチング、因果LM事前学習タスクを含めました。CodeT5+は、異なる設定で20以上のコード関連ベンチマークで徹底的に評価され、最先端のモデルパフォーマンスを観察しました。特に、instruction-tuned CodeT5+ 16Bは、他のオープンなコードLLMsに対して、HumanEvalコード生成タスクで新しい最先端の結果を達成しました。</span>
<span class="snippet"><span>Comment</span>様々なコードの理解と生成タスクをサポート

<br>

異なる訓練手法によって計算効率改善

<br>

20種類のコードベンチマークで、様々な設定「ゼロショット、finetuning, instruction tuning等）を実施した結果、コード補完、math programming, text to code retrievalにおいてSoTA達成</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<span class="issue_date">Issue Date: 2023-05-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/686">Evidence of Meaning in Language Models Trained on Programs, Charles Jin+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>本研究では、プログラムのコーパスを用いて言語モデルが意味を学習できることを示し、プログラム合成が言語モデルの意味の存在を特徴づけるための中間テストベッドとして適していることを述べている。Transformerモデルを用いた実験により、言語の意味を学習するための帰納バイアスを提供しないにもかかわらず、線形プローブがモデルの状態から現在および将来のプログラム状態の抽象化を抽出できることがわかった。また、正しいプログラムを生成することを学習し、平均的に訓練セットよりも短いプログラムを生成することも示した。本論文は、言語モデルの訓練に新しい技術を提案するものではなく、(形式的な)意味の習得と表現に関する実験的なフレームワークを開発し、洞察を提供する。</span>
<span class="snippet"><span>Comment</span>プログラムのコーパスでLLMをNext Token Predictionで訓練し

<br>

厳密に正解とsemanticsを定義した上で、訓練データと異なるsemanticsの異なるプログラムを生成できることを示した。

<br>



<br>

LLMが意味を理解していることを暗示している

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/fa4d2c68-bdbe-40ae-990d-10814ac8a204" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-05-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/684">Tree of Thoughts: Deliberate Problem Solving with Large Language Models, Shunyu Yao+, N_A, arXiv'23</a>
<span class="snippet"><span>Summary</span>言語モデルの推論には制限があり、探索や戦略的先読みが必要なタスクには不十分である。そこで、Tree of Thoughts（ToT）という新しいフレームワークを導入し、Chain of Thoughtアプローチを一般化して、意思決定を行うことができるようにした。ToTにより、言語モデルは複数の異なる推論パスを考慮して、次の行動を決定することができる。ToTは、Game of 24、Creative Writing、Mini Crosswordsなどのタスクにおいて、言語モデルの問題解決能力を大幅に向上させることができることを示している。</span>
<span class="snippet"><span>Comment</span>Self Concistencyの次

<br>

Non trivialなプランニングと検索が必要な新たな3つのタスクについて、CoT w/ GPT4の成功率が4%だったところを、ToTでは74%を達成

<br>



<br>

論文中の表ではCoTのSuccessRateが40%と書いてあるような?

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/6f853009-8d08-43b4-a7da-61677f4aca3a" alt="image" loading="lazy"></span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Faithfulness.html">#Faithfulness</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<span class="issue_date">Issue Date: 2023-05-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/666">Language Models Don't Always Say What They Think: Unfaithful   Explanations in Chain-of-Thought Prompting, Miles Turpin+, N_A, NeurIPS'23</a>
<span class="snippet"><span>Summary</span>LLMsによる推論において、chain-of-thought reasoning（CoT）と呼ばれる説明を生成することができるが、この説明がモデルの予測の真の理由を誤って表現することがあることがわかった。バイアスのある特徴をモデルの入力に追加することで、CoT説明が大きく影響を受けることが示された。この結果は、LLMsに対する信頼を高めるために、説明の忠実度を評価し、改善する必要があることを示唆している。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/KnowledgeEditing.html">#KnowledgeEditing</a>
<span class="issue_date">Issue Date: 2023-05-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/643">Mass-Editing Memory in a Transformer, Kevin Meng+, N_A, ICLR'23</a>
<span class="snippet"><span>Summary</span>大規模言語モデルを更新することで、専門的な知識を追加できることが示されているしかし、これまでの研究は主に単一の関連付けの更新に限定されていた本研究では、MEMITという方法を開発し、多数のメモリを直接言語モデルに更新することができることを実験的に示したGPT-J（6B）およびGPT-NeoX（20B）に対して数千の関連付けまでスケーリングでき、これまでの研究を桁違いに上回ることを示したコードとデータはhttps://memit.baulab.infoにあります。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Zero/FewShotPrompting.html">#Zero/FewShotPrompting</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2023-05-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/642">Challenging BIG-Bench Tasks and Whether Chain-of-Thought Can Solve Them, Mirac Suzgun+, N_A, ACL'23</a>
<span class="snippet"><span>Summary</span>BIG-Bench Hard (BBH) is a suite of 23 challenging tasks that current language models have not been able to surpass human performance on. This study focuses on applying chain-of-thought prompting to BBH tasks and found that PaLM and Codex were able to surpass human performance on 10 and 17 tasks, respectively. The study also found that CoT prompting is necessary for tasks that require multi-step reasoning and that CoT and model scale interact to enable new task performance on some BBH tasks.</span>
<span class="snippet"><span>Comment</span>単なるfewshotではなく、CoT付きのfewshotをすると大幅にBIG-Bench-hardの性能が向上するので、CoTを使わないanswer onlyの設定はモデルの能力の過小評価につながるよ、という話らしい

<br>

<img src="https://github.com/user-attachments/assets/0545214a-a267-489d-8af9-82d21e08ff6c" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/e5308c66-0bee-4d2c-b973-86478842b772" alt="image" loading="lazy"></span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Poisoning.html">#Poisoning</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<span class="issue_date">Issue Date: 2023-05-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/629">Poisoning Language Models During Instruction Tuning, Alexander Wan+, N_A, ICML'23</a>
<span class="snippet"><span>Summary</span>Instruction-tuned LMs（ChatGPT、FLAN、InstructGPTなど）は、ユーザーが提出した例を含むデータセットでfinetuneされる。本研究では、敵対者が毒入りの例を提供することで、LMの予測を操作できることを示す。毒入りの例を構築するために、LMのbag-of-words近似を使用して入出力を最適化する。大きなLMほど毒入り攻撃に対して脆弱であり、データフィルタリングやモデル容量の削減に基づく防御は、テストの正確性を低下させながら、中程度の保護しか提供しない。</span>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Annotation.html">#Annotation</a>
<a class="button" href="articles/TransferLearning.html">#TransferLearning</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2023-05-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/615">Frustratingly Easy Label Projection for Cross-lingual Transfer, Yang Chen+, N_A, ACL'23</a>
<span class="snippet"><span>Summary</span>多言語のトレーニングデータの翻訳は、クロスリンガル転移の改善に役立つスパンレベル注釈が必要なタスクでは、注釈付きスパンを翻訳されたテキストにマッピングするために追加のラベルプロジェクションステップが必要マーク-翻訳法を利用するアプローチが従来の注釈プロジェクションと比較してどのようになるかについての実証的な分析を行ったEasyProjectと呼ばれるマーク-翻訳法の最適化されたバージョンが多言語に簡単に適用でき、より複雑な単語アラインメントベースの方法を上回ることを示したすべてのコードとデータが公開される</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/Inference.html">#Inference</a>
<span class="issue_date">Issue Date: 2023-04-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/601">Efficiently Scaling Transformer Inference, Reiner Pope+, N_A, MLSys'23</a>
<span class="snippet"><span>Summary</span>大規模Transformerベースのモデルの推論のエンジニアリングのトレードオフを理解するために、最適な多次元分割技術を選択するための単純な解析モデルを開発低レベルの最適化と組み合わせることで、500B+パラメータモデルのレイテンシーとモデルFLOPS利用率のトレードオフにおいて、FasterTransformerベンチマークスイートを上回る新しいParetoフロンティアを実現適切な分割により、マルチクエリアテンションの低いメモリ要件により、32倍の大きなコンテキスト長にスケーリング可能int8ウェイト量子化を使用した生成中の低バッチサイズレイテンシーは、トークンあたり29msであり、入力トークンの大バッチサイズ処理において76％のMFUを実現し、PaLM 540Bパラメータモデルにおいて2048トークンの長いコンテキスト長をサポートしている。</span>
<span class="snippet"><span>Comment</span>特にMultiquery Attentionという技術がTransformerのinferenceのコスト削減に有効らしい</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/TheoryOfMind.html">#TheoryOfMind</a>
<span class="issue_date">Issue Date: 2023-04-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/581">Boosting Theory-of-Mind Performance in Large Language Models via Prompting, Moghaddam+, Johns Hopkins University, arXiv'23</a>
<span class="snippet"><span>Comment</span>LLMはTheory-of-mind reasoningタスクが苦手なことが知られており、特にzero shotでは非常にパフォーマンスが低かった。ToMタスクとは、エージェントの信念、ゴール、メンタルstate、エージェントが何を知っているか等をトラッキングすることが求められるタスクのこと。このようなタスクはLLMが我々の日常生活を理解する上で重要。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/235207785-8a4c5e0d-4825-4947-8ae6-a8176ad7c898.png" alt="image" loading="lazy">

<br>



<br>

↑のToM Questionのシナリオと問題

<br>

Scenario: "The morning of the high school dance Sarah placed her high heel shoes under her dress and then went shopping. That afternoon, her sister borrowed the shoes and later put them under Sarah's bed."

<br>

Question: When Sarah gets ready, does she assume her shoes are under her dress?

<br>



<br>

しかし、Zero shot CoTのようなstep by step thinking, CoTを適切に行うことで、OpenAIの直近3つのモデルのAccuracyが80%を超えた。特に、GPT4は100％のAccuracyを達成。人間は87％だった。

<br>



<br>

この結果は、少なくとのこの論文でテストしたドメインではLLMのsocial reasoningのパフォーマンスをどのようにブーストするかを示しており、LLMのbehaviorは複雑でsensitiveであることを示唆している。</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/TabularData.html">#TabularData</a>
<span class="issue_date">Issue Date: 2023-04-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/580">Large Language Models are Versatile Decomposers: Decompose Evidence and Questions for Table-based Reasoning, Ye+, University of Science and Technology of China, SIGIR'23</a>
<span class="snippet"><span>Comment</span>テーブルとquestionが与えられた時に、questionをsub-questionとsmall tableにLLMでin-context learningすることで分割。subquestionの解を得るためのsqlを作成しスポットを埋め、hallucinationを防ぐ。最終的にLLM Reasonerが解答を導出する。TabFact Reasoningで初めて人間を超えた性能を発揮。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/235204690-75f6b56b-3291-42e4-9e39-710694f36648.jpeg" alt="image" loading="lazy"></span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/DialogueGeneration.html">#DialogueGeneration</a>
<span class="issue_date">Issue Date: 2023-04-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/575">q2d: Turning Questions into Dialogs to Teach Models How to Search, Bitton+, The Hebrew University of Jerusalem （w_ Google Research）, arXiv'23</a>
<span class="snippet"><span>Comment</span>LLMにquestionを与え、questionを解決するためのinformation seekingの対話ログを生成させる。このデータを用いて、dialogueからquestionを生成するモデルを訓練し、検索APIなどに渡せるようにした研究。全く対話のログがないドメインのデータに対しても、人間と遜色ない高品質な対話が生成可能。これにより、query generationモデルの更なる高性能化が実現できる。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/235137446-10e6633f-1d4b-46ea-afda-630b7cd53246.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Controllable.html">#Controllable</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-04-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/573">Tractable Control for Autoregressive Language Generation, Zhang+, UCLA, arXiv'23</a>
<span class="snippet"><span>Comment</span>自然言語生成モデルで、何らかのシンプルなconstiaint αの元p(xi|xi-1,α)を生成しようとしても計算ができない。このため、言語モデルをfinetuningするか、promptで制御するか、などがおこなわれる。しかしこの方法は近似的な解法であり、αがたとえシンプルであっても（何らかの語尾を付与するなど）、必ずしも満たした生成が行われるとは限らない。これは単に言語モデルがautoregressiveな方法で次のトークンの分布を予測しているだけであることに起因している。そこで、この問題を解決するために、tractable probabilistic model（TPM）を導入し、解決した。

<br>

評価の結果、CommonGenにおいて、SoTAを達成した。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/235130061-21e51e59-dbfa-4c64-bd7b-27f0de2618c0.jpeg" alt="image" loading="lazy">尚、TPMについては要勉強である</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Education.html">#Education</a>
<a class="button" href="articles/AES(AutomatedEssayScoring).html">#AES(AutomatedEssayScoring)</a>
<a class="button" href="articles/ChatGPT.html">#ChatGPT</a>
<span class="issue_date">Issue Date: 2023-04-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/571">AI, write an essay for me: A large-scale comparison of human-written versus ChatGPT-generated essays, Herbold+, University of Passau, arXiv'23</a>
<span class="snippet"><span>Comment</span>ChatGPTは人間が書いたエッセイよりも高品質なエッセイが書けることを示した。

<br>



<br>

また、AIモデルの文体は、人間が書いたエッセイとは異なる言語的特徴を示している。たとえば、談話や認識マーカーが少ないが、名詞化が多く、語彙の多様性が高いという特徴がある、とのこと。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/235142851-756a418f-3c5a-4ae6-9309-0f077b1d017b.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/Ambiguity.html">#Ambiguity</a>
<span class="issue_date">Issue Date: 2023-04-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/570">We're Afraid Language Models Aren't Modeling Ambiguity, Alisa Liu+, EMNLP'23</a>
<span class="snippet"><span>Summary</span>曖昧さは自然言語の重要な特徴であり、言語モデル（LM）が対話や執筆支援において成功するためには、曖昧な言語を扱うことが不可欠です。本研究では、曖昧さの影響を評価するために、1,645の例からなるベンチマーク「AmbiEnt」を収集し、事前学習済みLMの評価を行いました。特にGPT-4の曖昧さ解消の正答率は32%と低く、曖昧さの解消が難しいことが示されました。また、多ラベルのNLIモデルが曖昧さによる誤解を特定できることを示し、NLPにおける曖昧さの重要性を再認識する必要性を提唱しています。</span>
<span class="snippet"><span>Comment</span>LLMが曖昧性をどれだけ認知できるかを評価した初めての研究。

<br>

言語学者がアノテーションした1,645サンプルの様々な曖昧さを含んだベンチマークデータを利用。

<br>

GPT4は32%正解した。

<br>

またNLIデータでfinetuningしたモデルでは72.5%のmacroF1値を達成。

<br>

応用先として、誤解を招く可能性のある政治的主張に対してアラートをあげることなどを挙げている。<img src="https://github.com/user-attachments/assets/a728a953-fac4-4115-8ec8-e5721bc4223e" alt="image" loading="lazy"></span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-04-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/569">Exploring the Curious Case of Code Prompts, Zhang+, University of Pennsylvania, arXiv'23</a>
<span class="snippet"><span>Comment</span>コードベースのLLMに対して、reasoningタスクを解かせる際には、promptもコードにすると10パーセント程度性能上がる場合があるよ、という研究。

<br>

<img src="https://user-images.githubusercontent.com/12249301/235037840-1fb57af3-5296-4831-9f80-26886c913431.jpeg" alt="image" loading="lazy">ただし、平均的にはテキストプロンプトの方が良く、一部タスクで性能が改善する、という温度感な模様

<br>

<img src="https://user-images.githubusercontent.com/12249301/235038209-b43dcdcb-301e-4879-a99e-8c8df32e6cf5.jpeg" alt="image" loading="lazy">コードベースのモデルをtextでinstruction tuningしている場合でも、効果があるタスクがある。</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/QuestionAnswering.html">#QuestionAnswering</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-04-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/568">Answering Questions by Meta-Reasoning over Multiple Chains of Thought, Yoran+, Tel Aviv University （w_ Allen Institute for AI）, arXiv'23</a>
<span class="snippet"><span>Comment</span>self-consistency 558 のようなvoting basedなアルゴリズムは、複数のCoTのintermediate stepを捨ててしまい、結果だけを採用するが、この研究は複数のCoTの中からquestionに回答するために適切なfactual informationを抽出するMeta Reasonerを導入し、複数のCoTの情報を適切に混在させて適切な回答を得られるようにした。

<br>



<br>



<br>



<br>

7個のMulti Hop QAデータでstrong baselineをoutperformし、人間が回答をverificationするための高品質な説明を生成できることを示した。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/235135436-11dca529-771a-402b-a4ef-9b6deacec32e.jpeg" alt="image" loading="lazy"></span>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-04-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/564">Language Models Enable Simple Systems for Generating Structured Views of Heterogeneous Data Lakes, Arora+, Stanford University, arXiv'23</a>
<span class="snippet"><span>Comment</span>LLMを使うことで、半構造化文章から自動的にqueryableなテーブルを作成することを試みた研究

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/235146591-dc608755-e719-4418-ace9-29401919d4eb.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/NeuralArchitectureSearch.html">#NeuralArchitectureSearch</a>
<span class="issue_date">Issue Date: 2023-04-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/559">Can GPT-4 Perform Neural Architecture Search? Zhang+, The University of Sydney, arXiv'23</a>
<span class="snippet"><span>Comment</span>ドメイン知識の必要のないプロンプトで、ニューラルモデルのアーキテクチャの提案をGPTにしてもらう研究。accをフィードバックとして与え、良い構造を提案するといったループを繰り返す模様

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/235143629-308233a6-51c7-40f7-afc6-e51f425e55d4.png" alt="image" loading="lazy">

<br>



<br>

Neural Architecture Search (NAS)においては、ランダムベースラインがよく採用されるらしく、比較した結果ランダムよりよかった

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/235144154-5c94a664-9768-4da5-af76-a137bc3d2b48.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

NAS201と呼ばれるベンチマーク（NNアーキテクチャのcell blockをデザインすることにフォーカス; 探索空間は4つのノードと6つのエッジで構成される密接続のDAGとして表される; ノードはfeature mapを表し、エッジはoperationに対応;利用可能なoperationが5つあるため、可能な検索空間の総数は5の6乗で15,625通りとなる）でも評価した結果、提案手法の性能がよかったとのこと。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/235144424-a8269562-3f4e-4830-8610-80e3ac9b977e.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<span class="issue_date">Issue Date: 2023-04-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/558">Self-consistency improves chain of thought reasoning in language models, Wang+, Google Research, ICLR'23</a>
<span class="snippet"><span>Comment</span>self-consistencyと呼ばれる新たなCoTのデコーディング手法を提案。

<br>



<br>

これは、難しいreasoningが必要なタスクでは、複数のreasoningのパスが存在するというintuitionに基づいている。

<br>



<br>



<br>



<br>

self-consistencyではまず、普通にCoTを行う。そしてgreedyにdecodingする代わりに、以下のようなプロセスを実施する：

<br>



<br>

1. 多様なreasoning pathをLLMに生成させ、サンプリングする。

<br>



<br>

2. 異なるreasoning pathは異なるfinal answerを生成する（= final answer set）。

<br>



<br>

3. そして、最終的なanswerを見つけるために、reasoning pathをmarginalizeすることで、final answerのsetの中で最も一貫性のある回答を見出す。

<br>



<br>



<br>



<br>

これは、もし異なる考え方によって同じ回答が導き出されるのであれば、その最終的な回答は正しいという経験則に基づいている。

<br>



<br>

self-consistencyを実現するためには、複数のreasoning pathを取得した上で、最も多いanswer a_iを選択する（majority vote）。これにはtemperature samplingを用いる（temperatureを0.5やら0.7に設定して、より高い信頼性を保ちつつ、かつ多様なoutputを手に入れる）。

<br>



<br>

temperature samplingについては[こちら](https://openreview.net/pdf?id=rygGQyrFvH)の論文を参照のこと。

<br>



<br>

sampling数は増やせば増やすほど性能が向上するが、徐々にサチってくる。サンプリング数を増やすほどコストがかかるので、その辺はコスト感との兼ね合いになると思われる。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234754605-6316223f-4290-45d5-bf7c-64675f07d0c3.png" alt="image" loading="lazy">

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234779335-478f2431-67ea-4b24-9c1b-fa1dd6ac6b45.png" alt="image" loading="lazy">

<br>



<br>

Self-consistencyは回答が閉じた集合であるような問題に対して適用可能であり、open-endなquestionでは利用できないことに注意が必要。ただし、open-endでも回答間になんらかの関係性を見出すような指標があれば実現可能とlimitationで言及している。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<span class="issue_date">Issue Date: 2023-04-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/556">Automatic Chain of Thought Prompting in Large Language Models, Zhang+, Shanghai Jiao Tong University, ICLR'23</a>
<span class="snippet"><span>Comment</span>LLMによるreasoning chainが人間が作成したものよりも優れていることを示しているとのこと 532 よりclusteringベースな手法を利用することにより、誤りを含む例が単一のクラスタにまとめられうことを示し、これにより過剰な誤ったデモンストレーションが軽減されることを示した。手法の概要。questionを複数のクラスタに分割し、各クラスタから代表的なquestionをサンプリングし、zero-shot CoTでreasoning chainを作成しpromptに組み込む。最終的に回答を得たいquestionに対しても、上記で生成した複数のquestion-reasoningで条件付けした上で、zeroshot-CoTでrationaleを生成する。

<br>

<img src="https://github.com/user-attachments/assets/35213747-9b5f-4d38-a525-1deafe86cd0c" alt="image" loading="lazy"></span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<span class="issue_date">Issue Date: 2023-04-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/555">Automatic prompt augmentation and selection with chain-of-thought from labeled data, Shum+, The Hong Kong University of Science and Technology, arXiv'23</a>
<span class="snippet"><span>Comment</span>LLMによるreasoning chainが人間が作成したものよりも優れていることを示しているとのこと 532 よりselection phaseで誤ったexampleは直接排除する手法をとっている。そして、強化学習によって、demonstrationのselection modelを訓練している。</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<span class="issue_date">Issue Date: 2023-04-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/539">Personalisation within bounds: A risk taxonomy and policy framework for the alignment of large language models with personalised feedback, Kirk+, Oxford Internet Institute, University of Oxford, arXiv'23</a>
<span class="snippet"><span>Comment</span>abst

<br>



<br>

LLMをPersonalizationすることに関して、どのような方法でPersonalizationすべきかを検討した研究。以下の問題点を指摘。

<br>



<br>

1. アラインメント（RLHFのように何らかの方向性にalignするように補正する技術のこと？）が何を意味するのか明確ではない

<br>



<br>

2. 技術提供者が本質的に主観的な好みや価値観の定義を規定する傾向があること

<br>



<br>

3. クラウドワーカーがの専制によって、我々が実際に何にアラインメントしているのかに関する文書が不足していること

<br>



<br>



<br>



<br>

そして、PersonalizedなLLMの利点やリスクの分類を提示する。

<br>



<br>



<br>



<br>

導入

<br>



<br>

LLMがさまざまな製品に統合されたことで、人間の嗜好に合致し、危険かつ不正確な情報を出力を生成しないことを確保する必要がある。RLHFやred-teamingはこれに役立つが、このような集合的な（多くの人に一つのアラインメントの結果を提示すること）finetuningプロセスが人間の好みや価値観の幅広い範囲を十分に表現できるとは考えにくい。異なる人々はさまざまな意見や価値観を持っており、マイクロレベルのfinetuningプロせせ雨を通じてLLMをPersonalizationすることで、各ユーザとより良いアラインメントが可能になる可能性がある。これを社会的に受け入れられるようにするためにいくつか課題があるので、それについて論じた。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<span class="issue_date">Issue Date: 2023-04-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/529">Scaling Transformer to 1M tokens and beyond with RMT, Bulatov+, DeepPavlov, arXiv'23</a>
<span class="snippet"><span>Comment</span>Reccurent Memory Transformer 523 を使って2Mトークン扱えるようにしたよーという話。

<br>



<br>

ハリーポッターのトークン数が1.5Mらしいので、そのうち小説一冊書けるかもという世界。</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Planning.html">#Planning</a>
<span class="issue_date">Issue Date: 2023-04-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/526">LLM+P: Empowering Large Language Models with Optimal Planning Proficiency, Liu+, University of Texas at Austin, arXiv'23</a>
<span class="snippet"><span>Comment</span>LLMは長いプランニングをすることが苦手だったが、classicalなplannerは適切なinputの形式に変換されていればすぐに最適なプランを導出できる、が、自然言語は受け付けない、といった互いが互いを補完し合う関係にあるので、両者を組み合わせました、という話。

<br>

LLMを利用して、planning problemを記述した自然言語をclassicalなplannerのinputへ変換。その後plannerで最適なplanを見つけ、自然言語にplanを逆翻訳する。

<br>

<img src="https://user-images.githubusercontent.com/12249301/234289649-416a8d9e-628e-422c-bd9b-89d9099b4b1d.jpeg" alt="image" loading="lazy"></span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2023-04-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/518">REACT : SYNERGIZING REASONING AND ACTING IN LANGUAGE MODELS, Yao+, Princeton University and Google brain, ICLR'23</a>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

人間は推論と行動をシナジーさせることで、さまざまな意思決定を行える。近年では言語モデルにより言語による推論を意思決定に組み合わせる可能性が示されてきた。たとえば、タスクをこなすための推論トレースをLLMが導けることが示されてきた（Chain-of-Thought）が、CoTは外部リソースにアクセスできないため知識がアップデートできず、事後的に推論を行うためhallucinationやエラーの伝搬が生じる。一方で、事前学習言語モデルをinteractiveな環境において計画と行動に利用する研究が行われているが、これらの研究では、高レベルの目標について抽象的に推論したり、行動をサポートするための作業記憶を維持したりするために言語モデルを利用していない。推論と行動を一般的な課題解決のためにどのようにシナジーできるか、またそのようなシナジーが単独で推論や行動を実施した場合と比較してどのような利益をもたらすかについて研究されていない。

<br>



<br>

そこで、REACTを提案。REACTは推論と行動をLLMと組み合わせて、多様な推論や意思決定タスクを実現するための一般的な枠組みであり、推論トレースとアクションを交互に生成するため、動的に推論を実行して行動するための大まかな計画を作成、維持、調整できると同時に、wikipediaなどの外部ソースとやりとりして追加情報を収集し、推論プロセスに組み込むことが可能となる。

<br>



<br>



<br>



<br>

・要はいままではGeneralなタスク解決モデルにおいては、推論とアクションの生成は独立にしかやられてこなかったけど、推論とアクションを交互作用させることについて研究したよ

<br>



<br>

・そしたら性能がとってもあがったよ

<br>



<br>

・reasoningを人間が編集すれば、エージェントのコントロールもできるよ　という感じ

<br>



<br>



<br>



<br>

イントロ

<br>



<br>

人間は推論と行動の緊密なシナジーによって、不確実な状況に遭遇しても適切な意思決定が行える。たとえば、任意の2つの特定のアクションの間で、進行状況をトレースするために言語で推論したり（すべて切り終わったからお湯を沸かす必要がある）、例外を処理したり、状況に応じて計画を調整したりする（塩がないから代わりに醤油と胡椒を使おう）。また、推論をサポートし、疑問（いまどんな料理を作ることができるだろうか？）を解消するために、行動（料理本を開いてレシピを読んで、冷蔵庫を開いて材料を確確認したり）をすることもある。

<br>



<br>



<br>



<br>

近年の研究では言語での推論を、インタラクティブな意思決定を組み合わせる可能性についてのヒントが得られてきた。一つは、適切にPromptingされたLLMが推論トレースを実行できることを示している。推論トレースとは、解決策に到達するための一連のステップを経て推論をするためのプロセスのことである。しかしながらChain-of-thoughytは、このアプローチでは、モデルが外界対してgroundingできず、内部表現のみに基づい思考を生成するため限界がある。これによりモデルが事後対応的に推論したり、外部情報に基づいて知識を更新したりできないため、推論プロセス中にhallucinationやエラーの伝搬などの問題が発生する可能性が生じる。

<br>



<br>

一方、近年の研究では事前学習言語モデルをinteractiveな環境において計画と行動に利用する研究が行われている。これらの研究では、通常マルチモーダルな観測結果をテキストに変換し、言語モデルを使用してドメイン固有のアクション、またはプランを生成し、コントローラーを利用してそれらを選択または実行する。ただし、これらのアプローチは高レベルの目標について抽象的に推論したり、行動をサポートするための作業記憶を維持したりするために言語モデルを利用していない。

<br>



<br>

推論と行動を一般的な課題解決のためにどのようにシナジーできるか、またそのようなシナジーが単独で推論や行動を実施した場合と比較してどのような利益をもたらすかについて研究されていない。

<br>



<br>



<br>



<br>

LLMにおける推論と行動を組み合わせて、言語推論と意思決定タスクを解決するREACTと呼ばれる手法を提案。REACTでは、推論と行動の相乗効果を高めることが可能。推論トレースによりアクションプランを誘発、追跡、更新するのに役立ち、アクションでは外部ソースと連携して追加情報を収集できる。

<br>



<br>



<br>



<br>

REACTは推論と行動をLLMと組み合わせて、多様な推論や意思決定タスクを実現するための一般的な枠組みである。REACTのpromptはLLMにverbalな推論トレースとタスクを実行するためのアクションを交互に生成する。これにより、モデルは動的な推論を実行して行動するための大まかな計画を作成、維持、調整できると同時に、wikipediaなどの外部ソースとやりとりして追加情報を収集し、推論プロセスに組み込むことが可能となる。

<br>



<br>



<br>



<br>

手法

<br>



<br>

変数を以下のように定義する：

<br>



<br>

・O_t: Observertion on time t

<br>



<br>

・a_t: Action on time t

<br>



<br>

・c_t: context, i.e. (o_1, a_1, o_2, a_2, ..., a_t-1, o_t)

<br>



<br>

・policy pi(a_t | c_t): Action Spaceからアクションを選択するポリシー

<br>



<br>

・A: Action Space

<br>



<br>

・O: Observation Space

<br>



<br>



<br>



<br>

普通はc_tが与えられたときに、ポリシーに従いAからa_tを選択しアクションを行い、アクションの結果o_tを得て、c_t+1を構成する、といったことを繰り返していく。

<br>



<br>



<br>



<br>

このとき、REACTはAをA ∪ Lに拡張しする。ここで、LはLanguage spaceである。LにはAction a_hatが含まれ、a_hatは環境に対して作用をしない。単純にthought, あるいは reasoning traceを実施し、現在のcontext c_tをアップデートするために有用な情報を構成することを目的とする。Lはunlimitedなので、事前学習された言語モデルを用いる。今回はPaLM-540B（c.f. GPT3は175Bパラメータ）が利用され、few-shotのin-context exampleを与えることで推論を行う。それぞれのin-context exampleは、action, thoughtsそしてobservationのtrajectoryを与える。

<br>



<br>



<br>



<br>

推論が重要なタスクでは、thoughts-action-observationステップから成るtask-solving trajectoryを生成する。一方、多数のアクションを伴う可能性がある意思決定タスクでは、thoughtsのみを行うことをtask-solving trajectory中の任意のタイミングで、自分で判断して行うことができる。

<br>



<br>



<br>



<br>

意思決定と推論能力がLLMによってもたらされているため、REACTは4つのuniqueな特徴を持つ：

<br>



<br>

・直感的で簡単なデザイン

<br>



<br>

  ・REACTのpromptは人間のアノテータがアクションのトップに思考を言語で記述するようなストレートなものであり、ad-hocなフォーマットの選択、思考のデザイン、事例の選定などが必要ない。

<br>



<br>

・一般的で柔軟性が高い

<br>



<br>

  ・柔軟な thought spaceと thought-actionのフォーマットにより、REACTはさまざまなタスクにも柔軟に対応できる

<br>



<br>

・高性能でロバスト

<br>



<br>

  ・REACTは1-6個の事例によって、新たなタスクに対する強力な汎化を示す。そして推論、アクションのみを行うベースラインよりも高い性能を示している。REACTはfinetuningの斧系も得ることができ、promptの選択に対してREACTの性能はrobustである。

<br>



<br>

・人間による調整と操作が可能

<br>



<br>

  ・REACTは、解釈可能な意思決定と推論のsequenceを前提としているため、人間は簡単に推論や事実の正しさを検証できる。加えて、thoughtsを編集することによって、m人間はエージェントの行動を制御、あるいは修正できる。

<br>



<br>



<br>



<br>

KNOWLEDGE INTENSIVE REASONING TASKS</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/DataGeneration.html">#DataGeneration</a>
<span class="issue_date">Issue Date: 2023-04-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/517">ChatGPT Outperforms Crowd-Workers for Text-Annotation Tasks, Gilardi+, University of Zurich, NAS'23</a>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

2300件程度のツイートを分類するタスクにおいて、訓練した学部生によるアノテーションを正解とし、クラウドワーカーとChatGPTでのzero-shotでの予測の性能を比較した。分類タスクは、比較的難易度の高い分類問題であり、クラウドワーカーでも正解率は難しいタスクでは15~25%程度であった。このようなタスクでchatgptは40~60%の正解率を示している。

<br>



<br>

比較の結果、5つのタスク中4つのタスクでChatGPTがクラウドワーカーを上回る正解率を示した。

<br>



<br>



<br>



<br>

手法

<br>



<br>

・クラウドワーカーとChatGPTで同じインストラクションを利用し、同じタスクを実施した

<br>



<br>

・inter-notator aggreementを図るために、それぞれのタスクについて各ツイートに少なくとも2人がラベル付を行った

<br>



<br>

・ChatGPTでも同様に、タスクごとに各ツイートには2回同じタスクを実施しデータを収集した

<br>



<br>

・ChatGPTを利用する際は、temperatureを1.0, 0.2の場合で試した。従ってChatGPTのラベル付けは各タスクごとに4セット存在することになる。

<br>



<br>



<br>



<br>

結果

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/231333088-cfe9362a-5412-4ea1-ae8c-67156f13290c.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

5タスク中、4タスクでChatGPTがzero-shotにもかかわらず正解率でworkerを上回った。また高いaggreementを発揮していることを主張。aggreementはtemperatureが低い方が高く、これはtemperatureが低い方がrandomnessが減少するためであると考えられる。aggreementをAccuracyの相関を図ったが、0.17であり弱い相関しかなかった。従って、Accuracyを減少させることなく、一貫性のある結果を得られるlaw temperatureを利用することが望ましいと結論づけている。

<br>



<br>



<br>



<br>

実施したタスク

<br>



<br>

"content moderation"に関するタスクを実施した。content moderationはSNSなどに投稿されるpostを監視するための取り組みであり、たとえばポルトツイートや誤った情報を含む有害なツイート、ヘイトスピーチなどが存在しないかをSNS上で監視をを行うようなタスクである。著者らはcontent moderationはハードなタスクであり、複雑なトピックだし、toy exampleではないことを主張している。実際、著者らが訓練した学部生の間でのinter-annotator aggreementは50%程度であり、難易度が高いタスクであることがわかる（ただし、スタンスdetectionに関してはaggreementが78.3%であった）。

<br>



<br>



<br>



<br>

content moderationのうち、以下の5つのタスクを実施した。

<br>



<br>

・relevance:

<br>



<br>

  ・ツイートがcontent moderationについて直接的に関係することを述べているか否か

<br>



<br>

  ・e.g. SNSにおけるcontent moderation ruleや実践、政府のレギュレーション等

<br>



<br>

  ・content moderationについて述べていないものについてはIRRELEVANTラベルを付与する

<br>



<br>

  ・ただし、主題がcontent moderationのツイートであっても、content moderationについて論じていないものについてはIRRELEVANT扱いとする。

<br>



<br>

  ・このような例としては、TwitterがDonald TrupのTwitterを"disrupted"とlabel付けしたことや、何かについて間違っていると述べているツイート、センシティブな内容を含むツイートなどがあげられる。

<br>



<br>

・Problem/Solution Frames

<br>



<br>

  ・content moderationは2つの見方ができる。それがProblemとSolution

<br>



<br>

  ・Problem: content moderationをPROBLEMとみなすもの。たとえば、フリースピーチの制限など

<br>



<br>

  ・SOLUTION: content moderationをSOLUTIONとみなすもの。たとえば、harmful speechから守ること、など

<br>



<br>

  ・ツイートがcontent moderationのnegativeな影響について強調していたら、PROBLEM（フリースピーチの制限やユーザがポストする内容についてバイアスが生じることなどについて）

<br>



<br>

  ・ツイートがcontent moderationのpositiveな影響について強調していたら、SOKUTION（harmful contentからユーザを守るなど）

<br>



<br>

  ・主題はcontent moderationであるが、positive/negativeな影響について論じていないものはNEUTRAL

<br>



<br>

・Policy Frames

<br>



<br>

  ・content moderationはさまざまんトピックと関連している（たとえば）、健康、犯罪、平等など）

<br>



<br>

  ・content moderatiojnに関するツイートがどのトピックかをラベル付する。ラベルは15種類

<br>



<br>

  ・economy, capcity and resources, modality, fairness and equality, constitutionality and jurisprudence, policy prescription and evaluation, law and order, crime and justice, security and defense, health and safety, quality of life, cultural identity, public opinion, political, external regulation and reputation, other

<br>



<br>

・Stance Detection

<br>



<br>

  ・USのSection 230という法律（websiteにユーザが投稿したコンテンツに対して、webサイトやその他のオンラインプラットフォームが法的責任を問われるのを防ぐ法律）について、ツイートがSection230に対して、positive/negative/neutralなスタンスかをラベル付する

<br>



<br>

・Topic Detection

<br>



<br>

  ・ツイートを6つのトピックにラベル付する

<br>



<br>

  ・Section 230, TRUMP BAN, TWITTER-SUPPORT, PLATFORM POLICIES, COMPLAINTS, other所感

<br>



<br>

そこそこ難易度の高いアノテーションタスクでもzero-shotでturkerの性能を上回るのは非常に素晴らしいことだと思う。ノイジーなデータセットであれば、比較的安価、かつスピーディーに作成できるようになってきたのではないかと思う。

<br>



<br>

ただ、ChatGPTのaggreementを図ることにどれだけ意味があるのだろう、とは思う。同じモデルを利用しているわけで、小tなるLLMをベースにした場合のaggreementならとる意味があると思うが。</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2023-03-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/513">Self-Instruct: Aligning Language Model with Self Generated Instructions, Wang+ （w_ Noah Smith）, Univesity of Washington, ACL'23</a>
<span class="snippet"><span>Comment</span>Alpacaなどでも利用されているself-instruction技術に関する論文概要

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/228716254-5f4d7451-a37a-4354-843d-7e4052ba230b.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

著者らが書いた175種のinstruction（タスクの定義 + 1種のinput/outputペア}のseedを元に、VanillaなGPT-3に新たなinstruction, input, outputのtupleを生成させ、学習データとして活用する研究。

<br>



<br>

ここで、instruction data I は以下のように定義される：

<br>



<br>

instruction dataは(I, X, Y)であり、モデルは最終的にM(I_t, x_t) = y_tとなるように学習したい。

<br>



<br>

I: instruction, X: input, Y: output

<br>



<br>



<br>



<br>

データ作成は以下のステップで構成される。なお、以下はすべてVanilla GPT-3を通じて行われる：

<br>



<br>

1. Instruction Generation

<br>



<br>

　task poolから8種類のinstructionを抽出し、 promptを構成し、最大8個新たなinstructionを生成させる

<br>



<br>

2. Classification Task Identification:

<br>



<br>

　生成されたinstructionがclassificationタスクか否かを判別する

<br>



<br>

3. Instance Generation

<br>



<br>

　いくつかの(I, X, Y)をpromptとして与え、I, Xに対応するYを生成するタスクを実行させる。このときinput-first approachを採用した結果（I-&gt;Xの順番で情報を与えYを生成するアプローチ）、特定のラベルに偏ったインスタンスが生成される傾向があることがわかった。このためoutput-first approachを別途採用し（I-&gt;Yの順番で情報を与え、各Yに対応するXを生成させる）、活用している。　

<br>



<br>

4. Filtering and Postprocessing

<br>



<br>

　最後に、既存のtask poolとROUGE-Lが0.7以上のinstructionは多様性がないため除外し、特定のキーワード（images, pictrues, graphs）等を含んでいるinstruction dataも除外して、task poolに追加する。

<br>



<br>



<br>



<br>

1-4をひたすら繰り返すことで、GPT-3がInstruction Tuningのためのデータを自動生成してくれる。

<br>



<br>



<br>



<br>

SELF-INSTRUCT Data

<br>



<br>

データセットの統計量

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/228745059-ecccadba-3e32-4f2a-9594-2459a922474b.png" alt="image" loading="lazy">

<br>



<br>

・52k instructions

<br>



<br>

・82k instances

<br>



<br>



<br>



<br>

Diversity

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/228745421-ba024963-ca6e-4e30-bac8-7224d413f8ab.png" alt="image" loading="lazy">

<br>



<br>

parserでinstructionを解析し、rootの名詞と動詞のペアを抽出して可視化した例。ただし、抽出できた例はたかだか全体の50%程度であり、その中で20の最もcommonなroot vertと4つのnounを可視化した。これはデータセット全体の14%程度しか可視化されていないが、これだけでも非常に多様なinstructionが集まっていることがわかる。

<br>



<br>

また、seed indstructionとROUGE-Lを測った結果、大半のデータは0.3~0.4程度であり、lexicalなoverlapはあまり大きくないことがわかる。instructionのlengthについても可視化した結果、多様な長さのinstructionが収集できている。

<br>



<br>



<br>



<br>

Quality

<br>



<br>

200種類のinstructionを抽出し、その中からそれぞれランダムで1つのインスタンスをサンプルした。そしてexpert annotatorに対して、それぞれのinstructionとinstance（input, outputそれぞれについて）が正しいか否かをラベル付けしてもらった。

<br>



<br>

ラベル付けの結果、ほとんどのinstructionは意味のあるinstructionであることがわかった。一方、生成されたinstanceはnoisyであることがわかった（ただし、このnoiseはある程度妥当な範囲である）。noisytではあるのだが、instanceを見ると、正しいformatであったり、部分的に正しかったりなど、modelを訓練する上で有用なguidanceを提供するものになっていることがわかった。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/228746299-a0ffc115-3861-458b-a7b4-3a91ac94f8f5.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Experimental Results

<br>



<br>

Zero-shotでのNLPタスクに対する性能

<br>



<br>

SuperNIデータセットに含まれる119のタスク（1タスクあたり100 instance）に対して、zero-shot setupで評価を行なった。SELF-INSTRUCTによって、VanillaのGPT3から大幅に性能が向上していることがわかる。VanillaのGPT-3はほとんど人間のinstructionに応じて動いてくれないことがわかる。分析によると、GPT3は、大抵の場合、全く関係ない、あるいは繰り返しのテキストを生成していたり、そもそもいつ生成をstopするかがわかっていないことがわかった。

<br>



<br>



<br>



<br>

また、SuperNI向けにfinetuningされていないモデル間で比較した結果、非常にアノテーションコストをかけて作られたT0データでfinetuningされたモデルよりも高い性能を獲得した。また、人間がラベル付したprivateなデータによって訓練されたInstructGPT001にも性能が肉薄していることも特筆すべき点である。

<br>



<br>



<br>



<br>

SuperNIでfinetuningした場合については、SELF-INSTRUCTを使ったモデルに対して、さらに追加でSuperNIを与えた場合が最も高い性能を示した。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/228751534-095578e0-550b-4e4c-9418-c74251e31d2a.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

User-Oriented Instructionsに対する汎化性能

<br>



<br>

SuperNIに含まれるNLPタスクは研究目的で提案されており分類問題となっている。ので、実践的な能力を証明するために、LLMが役立つドメインをブレスト（email writing, social media, productiveity tools, entertainment, programming等）し、それぞれのドメインに対して、instructionとinput-output instanceを作成した。また、instructionのスタイルにも多様性（e.g. instructionがlong/short、bullet points, table, codes, equationsをinput/outputとして持つ、など）を持たせた。作成した結果、252個のinstructionに対して、1つのinstanceのデータセットが作成された。これらが、モデルにとってunfamiliarなinstructionで多様なistructionが与えられたときに、どれだけモデルがそれらをhandleできるかを測定するテストベッドになると考えている。

<br>



<br>



<br>



<br>

これらのデータは、多様だがどれもが専門性を求められるものであり、自動評価指標で性能が測定できるものでもないし、crowdworkerが良し悪しを判定できるものでもない。このため、それぞれのinstructionに対するauthorに対して、モデルのy補足結果が妥当か否かをjudgeしてもらった。judgeは4-scaleでのratingとなっている：

<br>



<br>



<br>



<br>

・RATING-A: 応答は妥当で満足できる

<br>



<br>

・RATING-B: 応答は許容できるが、改善できるminor errorや不完全さがある。

<br>



<br>

・RATING-C: 応答はrelevantでinstructionに対して答えている。が、内容に大きなエラーがある。

<br>



<br>

・RATING-D: 応答はirrelevantで妥当ではない。

<br>



<br>



<br>



<br>

実験結果をみると、Vanilla GPT3はまったくinstructionに対して答えられていない。instruction-basedなモデルは高いパフォーマンスを発揮しているが、それらを上回る性能をSELF-INSTRUCTは発揮している（noisyであるにもかかわらず）。

<br>



<br>

また、GPT_SELF-INSTRUCTはInstructGPT001と性能が肉薄している。また、InstructGPT002, 003の素晴らしい性能を示すことにもなった。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/228755556-1c604ed8-11a5-4237-8f9c-a30960db807a.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Discussion and Limitation

<br>



<br>

なぜSELF-INSTRUCTがうまくいったか？

<br>



<br>

・LMに対する2つの極端な仮説を挙げている

<br>



<br>

  ・LM はpre-trainingでは十分に学習されなかった問題について学習する必要があるため、human feedbackはinstruction-tuningにおいて必要不可欠な側面である

<br>



<br>

  ・LM はpre-trainingからinstructionに既に精通しているため、human feedbackはinstruction-tuningにおいて必須ではない。 human feedbackを観察することは、pre-trainingにおける分布/目的を調整するための軽量なプロセスにすぎず、別のプロセスに置き換えることができる。

<br>



<br>



<br>



<br>

この2つの極端な仮説の間が実情であると筆者は考えていて、どちらかというと２つ目の仮説に近いだろう、と考えている。既にLMはpre-trainingの段階でinstructionについてある程度理解できているため、self-instructがうまくいったのではないかと推察している。

<br>



<br>



<br>



<br>

Broader Impact

<br>



<br>

InstructGPTは非常に強力なモデルだけど詳細が公表されておらず、APIの裏側に隠れている。この研究が、instruct-tuned modelの背後で何が起きているかについて、透明性を高める助けになると考えている。産業で開発されたモデルの構造や、その優れた性能の理由についてはほとんど理解されておらず、これらのモデルの成功の源泉を理解し、より優れた、オープンなモデルを作成するのはアカデミックにかかっている。この研究では、多様なinstructional dataの重要性を示していると考えており、大規模な人工的なデータセットは、より優れたinstructionに従うモデルを、構築するための第一歩だと考えている。

<br>



<br>



<br>



<br>

limitation

<br>



<br>

・Tail Phenomena

<br>



<br>

  ・LMの枠組みにとどまっているため、LMと同じ問題（Tail Phenomena）を抱えている

<br>



<br>

  ・low-frequencyなcontextに対してはうまくいかない問題

<br>



<br>

  ・SELF-INSTRUCTも、結局pre-trainingの段階で頻出するタスクやinstructionに対してgainがあると考えられ、一般的でなく、creativeなinstructionに対して脆弱性があると考えられる

<br>



<br>

・Dependence on laege models

<br>



<br>

  ・でかいモデルを扱えるだけのresourceを持っていないと使えないという問題がある

<br>



<br>

・Reinforcing LM biases

<br>



<br>

  ・アルゴリズムのiterationによって、問題のあるsocial _biasをより増幅してしまうことを懸念している（人種、種族などに対する偏見など）。また、アルゴリズムはバランスの取れたラベルを生成することが難しい。1のprompt

<br>



<br>

<img width="801" alt="image" src="https://user-images.githubusercontent.com/12249301/228717376-62648df4-e587-49f7-8e71-afd1b2269e90.png">

<br>



<br>

2のprompt

<br>



<br>

<img width="871" alt="image" src="https://user-images.githubusercontent.com/12249301/228717413-115f8ccf-b85e-4530-b489-cbf1de69341b.png">

<br>



<br>

3のprompt（input-first-approach）

<br>



<br>

<img width="853" alt="image" src="https://user-images.githubusercontent.com/12249301/228717477-58b44a4e-ce44-452f-9b3a-4a348584e40f.png">

<br>



<br>

3のprompt（output-first approach）

<br>



<br>

<img width="803" alt="image" src="https://user-images.githubusercontent.com/12249301/228717535-8717405c-bdaf-455c-9d4b-480bf6494abe.png">※ GPT3をfinetuningするのに、Instruction Dataを使った場合$338かかったっぽい。安い・・・。LLMを使うだけでここまで研究ができる時代がきた（最近は|現在は）プロプライエタリなLLMの出力を利用して競合するモデルを訓練することは多くの場合禁止されているので注意。</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<span class="issue_date">Issue Date: 2023-03-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/512">Reflexion: Language Agents with Verbal Reinforcement Learning, Noah Shinn+, N_A, NeurIPS'23</a>
<span class="snippet"><span>Summary</span>本研究では、言語エージェントを強化するための新しいフレームワークであるReflexionを提案しています。Reflexionエージェントは、言語的フィードバックを通じて自己反省し、より良い意思決定を促すために反省的なテキストを保持します。Reflexionはさまざまなタスクでベースラインエージェントに比べて大幅な改善を実現し、従来の最先端のGPT-4を上回る精度を達成しました。さらに、異なるフィードバック信号や統合方法、エージェントタイプの研究を行い、パフォーマンスへの影響についての洞察を提供しています。</span>
<span class="snippet"><span>Comment</span>なぜ回答を間違えたのか自己反省させることでパフォーマンスを向上させる研究</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/KnowledgeEditing.html">#KnowledgeEditing</a>
<span class="issue_date">Issue Date: 2025-06-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2055">[Paper Note] Fast Model Editing at Scale, Eric Mitchell+, ICLR'22</a>
<span class="snippet"><span>Summary</span>MEND（モデル編集ネットワーク）は、事前学習モデルの動作を迅速かつ局所的に編集するための手法で、単一の入力-出力ペアを用いて勾配分解を活用します。これにより、10億以上のパラメータを持つモデルでも、1台のGPUで短時間でトレーニング可能です。実験により、MENDが大規模モデルの編集において効果的であることが示されました。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=0DcZxeWfOPt</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-05-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1956">LoRA: Low-Rank Adaptation of Large Language Models, Edward J. Hu+, ICLR'22</a>
<span class="snippet"><span>Summary</span>LoRAは、事前学習された大規模モデルの重みを固定し、各層に訓練可能なランク分解行列を追加することで、ファインチューニングに必要なパラメータを大幅に削減する手法です。これにより、訓練可能なパラメータを1万分の1、GPUメモリを3分の1に減少させながら、RoBERTaやGPT-3などで同等以上の性能を実現します。LoRAの実装はGitHubで公開されています。</span>
<span class="snippet"><span>Comment</span>OpenrReview:https://openreview.net/forum?id=nZeVKeeFYf9LoRAもなんやかんやメモってなかったので追加。

<br>



<br>

事前学習済みのLinear Layerをfreezeして、freezeしたLinear Layerと対応する低ランクの行列A,Bを別途定義し、A,BのパラメータのみをチューニングするPEFT手法であるLoRAを提案した研究。オリジナルの出力に対して、A,Bによって入力を写像したベクトルを加算する。

<br>



<br>

チューニングするパラメータ数学はるかに少ないにも関わらずフルパラメータチューニングと（これは諸説あるが）同等の性能でPostTrainingできる上に、事前学習時点でのパラメータがfreezeされているためCatastrophic Forgettingが起きづらく（ただし新しい知識も獲得しづらい）、A,Bの追加されたパラメータのみを保存すれば良いのでストレージに優しいのも嬉しい。</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-03-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1827">Training Compute-Optimal Large Language Models, Jordan Hoffmann+, NeurIPS'22</a>
<span class="snippet"><span>Summary</span>トランスフォーマー言語モデルの訓練において、計算予算内で最適なモデルサイズとトークン数を調査。モデルサイズと訓練トークン数は同等にスケールする必要があり、倍増するごとにトークン数も倍増すべきと提案。Chinchillaモデルは、Gopherなどの大規模モデルに対して優れた性能を示し、ファインチューニングと推論の計算量を削減。MMLUベンチマークで67.5%の精度を達成し、Gopherに対して7%以上の改善を実現。</span>
<span class="snippet"><span>Comment</span>OpenReview: https://openreview.net/forum?id=iBBcRUlOAPRchinchilla則</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<span class="issue_date">Issue Date: 2024-10-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1474">Super-NaturalInstructions: Generalization via Declarative Instructions  on 1600+ NLP Tasks, Yizhong Wang+, N_A, EMNLP'22</a>
<span class="snippet"><span>Summary</span>Super-NaturalInstructionsを用いて、NLPモデルの未見タスクへの一般化能力を評価。1,616の多様なタスクと指示を含むベンチマークを作成し、76種類のタスクタイプをカバー。Tk-Instructモデルは、指示に従う訓練を受け、InstructGPTを9%以上上回る性能を示す。一般化能力をスケーリングパラメータに基づいて分析し、汎用的なNLPモデルの進展を促進することを目指す。</span>
<span class="snippet"><span>Comment</span>7.1, 7.2が最も興味深い

<br>



<br>



<br>



<br>

Instruction Tuningにおける未知のタスクに対する汎化性能について、3つの要素に対するスケーリングについて考察

<br>



<br>

・More observed tasks improve the generalization.

<br>



<br>

・A large number of training instances do not help generalization.

<br>



<br>

・Tuning larger models with instructions consistently lead to gains.

<br>



<br>



<br>



<br>

Instructionをさまざまに変化させた時の性能の変化に対する分析

<br>



<br>

Table4の対角成分に注目すると（trainとtestのinput encodingを揃えた場合）

<br>



<br>

・Task definitionをinstructionに含めることで未知タスクに対する汎化性能向上

<br>



<br>

・Task Definitionとpositive examplesを4つ程度入れると汎化性能向上。

<br>



<br>

  ・ただし、これ以上exampleを増やすと性能低下。

<br>



<br>

  ・negative examplesを入れることは性能に a little bit しか貢献しない

<br>



<br>

  ・explanationsを入れると性能が低下する

<br>



<br>



<br>



<br>

Table4の非対角成分に着目すると、

<br>



<br>

・Task Definitionのみで訓練しても、Example onlyのtest時のencodingには汎化しない（逆も然り）

<br>



<br>

・Task Definition + examples (今回の場合はpositive examples4つ)は、さまざまなtest時のinput encodingsに対してロバストになる

<br>



<br>

 

<br>



<br>

<img src="https://github.com/user-attachments/assets/3bd1d07d-feb0-4567-bad9-8920c2d82359" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<span class="issue_date">Issue Date: 2024-09-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1413">Finetuned Language Models Are Zero-Shot Learners, Jason Wei+, N_A, ICLR'22</a>
<span class="snippet"><span>Summary</span>指示チューニングを用いて言語モデルのゼロショット学習能力を向上させる方法を提案。137BパラメータのモデルFLANは、60以上のNLPタスクでファインチューニングされ、未見のタスクで175B GPT-3を上回るパフォーマンスを示す。アブレーションスタディにより、ファインチューニングデータセットの数やモデルのスケールが成功に寄与することが確認された。</span>
<span class="snippet"><span>Comment</span>FLAN論文。Instruction Tuningを提案した研究。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SelfImprovement.html">#SelfImprovement</a>
<span class="issue_date">Issue Date: 2024-09-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1397">STaR: Bootstrapping Reasoning With Reasoning, Eric Zelikman+, N_A, NeurIPS'22</a>
<span class="snippet"><span>Summary</span>「自己学習推論者」（STaR）を提案し、少数の合理的説明と大規模データセットを活用して複雑な推論を行う。STaRは、生成した回答が間違っている場合に正しい回答を用いて再生成し、ファインチューニングを繰り返すことで性能を向上させる。実験により、STaRは従来のモデルと比較して大幅な性能向上を示し、特にCommensenseQAでの成果が顕著である。</span>
<span class="snippet"><span>Comment</span>OpenAI o1関連研究</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/ChatGPT.html">#ChatGPT</a>
<a class="button" href="articles/RLHF.html">#RLHF</a>
<a class="button" href="articles/PPO%20(ProximalPolicyOptimization).html">#PPO (ProximalPolicyOptimization)</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2024-04-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1296">Training language models to follow instructions with human feedback, Long Ouyang+, N_A, NeurIPS'22</a>
<span class="snippet"><span>Summary</span>大規模な言語モデルは、ユーザーの意図に合わない出力を生成することがあります。本研究では、人間のフィードバックを使用してGPT-3を微調整し、InstructGPTと呼ばれるモデルを提案します。この手法により、13億パラメータのInstructGPTモデルの出力が175BのGPT-3の出力よりも好まれ、真実性の向上と有害な出力の削減が示されました。さらに、一般的なNLPデータセットにおける性能の低下は最小限でした。InstructGPTはまだ改善の余地がありますが、人間のフィードバックを使用した微調整が有望な方向であることを示しています。</span>
<span class="snippet"><span>Comment</span>ChatGPTの元となる、SFT→Reward Modelの訓練→RLHFの流れが提案された研究。DemonstrationデータだけでSFTするだけでは、人間の意図したとおりに動作しない問題があったため、人間の意図にAlignするように、Reward Modelを用いたRLHFでSFTの後に追加で学習を実施する。Reward Modelは、175Bモデルは学習が安定しなかった上に、PPOの計算コストが非常に大きいため、6BのGPT-3を様々なNLPタスクでSFTしたモデルをスタートにし、モデルのアウトプットに対して人間がランキング付けしたデータをペアワイズのloss functionで訓練した。最終的に、RMのスコアが最大化されるようにSFTしたGPT-3をRLHFで訓練するが、その際に、SFTから出力が離れすぎないようにする項と、NLPベンチマークでの性能が劣化しないようにpretrain時のタスクの性能もloss functionに加えている。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/e4934d4c-7a9b-44aa-93ce-3ae46ed4bd9b" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Zero/FewShotPrompting.html">#Zero/FewShotPrompting</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<span class="issue_date">Issue Date: 2023-11-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1124">Recommendation as Language Processing （RLP）: A Unified Pretrain,  Personalized Prompt &amp; Predict Paradigm （P5）, Shijie Geng+, N_A, RecSys'22</a>
<span class="snippet"><span>Summary</span>我々は「Pretrain, Personalized Prompt, and Predict Paradigm」（P5）と呼ばれる柔軟で統一されたテキストからテキストへのパラダイムを提案します。P5は、共有フレームワーク内でさまざまな推薦タスクを統一し、個別化と推薦のための深い意味を捉えることができます。P5は、異なるタスクを学習するための同じ言語モデリング目標を持つ事前学習を行います。P5は、浅いモデルから深いモデルへと進化し、広範な微調整の必要性を減らすことができます。P5の効果を実証するために、いくつかの推薦ベンチマークで実験を行いました。</span>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

T5 のように、様々な推薦タスクを、「Prompt + Prediction」のpipelineとして定義して解けるようにした研究。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/9b8b83a2-0930-4836-8bae-a18234fd3fd3" alt="image" loading="lazy">

<br>



<br>

P5ではencoder-decoder frameworkを採用しており、encoder側ではbidirectionalなモデルでpromptのrepresentationを生成し、auto-regressiveな言語モデルで生成を行う。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/d47cb264-9e94-46c5-9b56-0b6f4e31a8de" alt="image" loading="lazy">

<br>



<br>

推薦で利用したいデータセットから、input-target pairsを生成し上記アーキテクチャに対して事前学習することで、推薦を実現できる。

<br>



<br>



<br>



<br>

RatingPredictionでは、MatrixFactorizationに勝てていない（が、Rating Predictionについては魔法の壁問題などもあると思うのでなんともいえない。）

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/a7742141-2988-4e92-96ae-f6fb4cc4ce5f" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Sequential RecommendationではBERT4Recとかにも勝てている模様。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/8badc477-8665-4404-bf4b-93ac901740d6" alt="image" loading="lazy">

<br>



<br>



<br>



<br>



<br>



<br>

Prompt例

<br>



<br>

・Rating Predictionの例

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/9385d3ff-c186-4490-be34-3baf331aefae" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

・Sequential Recommendationの例

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/12b61106-af4f-4597-9990-60bc6fa7f222" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

・Explanationを生成する例

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/b41f22fd-2476-4365-a3a0-07f72d6bb0db" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

・Zero-shotの例（Cold-Start）

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/5217791e-7a7e-40d4-bdb4-b979af327032" alt="image" loading="lazy"></span>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Explanation.html">#Explanation</a>
<span class="issue_date">Issue Date: 2023-08-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/912">Explaining Patterns in Data with Language Models via Interpretable  Autoprompting, Chandan Singh+, N_A, arXiv'22</a>
<span class="snippet"><span>Summary</span>本研究では、大規模言語モデル（LLMs）を使用してデータのパターンを説明する能力を探求しました。具体的には、事前学習済みのLLMを使用してデータを説明する自然言語の文字列を生成するアルゴリズムを導入しました。実験結果は、このアルゴリズムが正確なデータセットの説明を見つけ出すことができることを示しています。また、生成されるプロンプトは人間にも理解可能であり、実世界のデータセットやfMRIデータセットで有用な洞察を提供することができることも示されました。</span>
<span class="snippet"><span>Comment</span>OpenReview: https://openreview.net/forum?id=GvMuB-YsiK6データセット（中に存在するパターンの説明）をLLMによって生成させる研究

<br>

![Image](https://github.com/user-attachments/assets/df70f8c2-6eda-412f-84e0-92ffe7152a39)

<br>

![Image](https://github.com/user-attachments/assets/42b4f4f9-6f6c-4e45-8c7c-db76c5fd9932)</span>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<span class="issue_date">Issue Date: 2023-05-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/674">Out of One, Many: Using Language Models to Simulate Human Samples, Lisa P. Argyle+, N_A, arXiv'22</a>
<span class="snippet"><span>Summary</span>本研究では、言語モデルが社会科学研究において特定の人間のサブポピュレーションの代理として研究される可能性があることを提案し、GPT-3言語モデルの「アルゴリズム的忠実度」を探求する。アルゴリズム的忠実度が十分である言語モデルは、人間や社会の理解を進めるための新しい強力なツールとなる可能性があると提案する。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<span class="issue_date">Issue Date: 2023-04-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/553">Large Language Models are Zero-Shot Reasoners, Kojima+, University of Tokyo, NeurIPS'22</a>
<span class="snippet"><span>Comment</span>Zero-Shot CoT (Let's think step-by-step.)論文<img width="856" alt="image" src="https://user-images.githubusercontent.com/12249301/234746367-2cd80e23-8dcb-4244-b56c-e28120629027.png">

<br>



<br>

Zero-Shot-CoTは2つのステップで構成される：

<br>



<br>

・STEP1: Reasoning Extraction

<br>



<br>

  ・元のquestionをxとし、zero-shot-CoTのtrigger sentenceをtとした時に、テンプレート "Q: [X]. A. [T]" を用いてprompt　x'を作成

<br>



<br>

  ・このprompt x'によって得られる生成テキストzはreasoningのrationaleとなっている。

<br>



<br>

・STEP2: Answer Extraction

<br>



<br>

  ・STEP1で得られたx'とzを用いて、テンプレート "[X'] [Z] [A]" を用いてpromptを作成し、quiestionに対する回答を得る

<br>



<br>

  ・このとき、Aは回答を抽出するためのtrigger sentenceである。

<br>



<br>

  ・Aはタスクに応じて変更するのが効果的であり、たとえば、multi-choice QAでは "Therefore, among A through E, the answer is" といったトリガーを用いたり、数学の問題では "Therefore, the answer (arabic numerals) is" といったトリガーを用いる。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236404426-ed936908-3771-4eef-9871-c6ae04c896bf.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

実験結果

<br>



<br>

表中の性能指標の左側はタスクごとにAnswer Triggerをカスタマイズしたもので、右側はシンプルに"The answer is"をAnswer Triggerとした場合。Zero-shot vs. Zero-shot-CoTでは、Zero-Shot-CoTが多くのb現地マークにおいて高い性能を示している。ただし、commonsense reasoningではperformance gainを得られなかった。これは 551 で報告されている通り、commonsense reasoningタスクでは、Few-Shot CoTでもLambda135Bで性能が向上せず、Palm540Bで性能が向上したように、モデルのparameter数が足りていない可能性がある（本実験では17種類のモデルを用いているが、特に注釈がなければtext-davinci-002を利用した結果）。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236405336-fe5e1f7f-9d2f-457f-9e25-98afe4ae0ec1.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

他ベースラインとの比較

<br>



<br>

他のベースラインとarithmetic reasoning benchmarkで性能比較した結果。Few-Shot-CoTには勝てていないが、standard Few-shot Promptingtを大幅に上回っている。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236406621-7862823f-e019-4551-be96-1c97265ca5ba.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

zero-shot reasoningにおけるモデルサイズの影響

<br>



<br>

さまざまな言語モデルに対して、zero-shotとzero-shot-CoTを実施した場合の性能比較。551 と同様にモデルサイズが小さいとZero-shot-CoTによるgainは得られないが、モデルサイズが大きくなると一気にgainが大きくなる。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236407727-f29e6f67-8ca1-4623-8341-73bbf2029e67.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Zero-shot CoTにおけるpromptの選択による影響

<br>



<br>

input promptに対するロバスト性を確認した。instructiveカテゴリ（すなわち、CoTを促すトリガーであれば）性能が改善している。特に、どのようなsentenceのトリガーにするかで性能が大きくかわっている。今回の実験では、"Let's think step by step"が最も高い性能を占め最多。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236408268-8dbc32f3-76c7-4e41-aa1b-a19008aa680c.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Few-shot CoTのprompt選択における影響

<br>



<br>

CommonsenseQAのexampleを用いて、AQUA-RAT, MultiArithをFew-shot CoTで解いた場合の性能。どちらのケースもドメインは異なるが、前者は回答のフォーマットは共通である。異なるドメインでも、answer format（multiple choice）の場合、ドメインが異なるにもかかわらず、zero-shotと比較して性能が大幅に向上した。一方、answer formatが異なる場合はperformance gainが小さい。このことから、LLMはtask自体よりも、exampleにおけるrepeated formatを活用していることを示唆している。また、CommonSennseをExamplarとして用いたFew-Shot-CoTでは、どちらのデータセットでもZero-Shot-CoTよりも性能が劣化している。つまり、Few-Shot-CoTでは、タスク特有のサンプルエンジニアリングが必要であることがわかる（一方、Zero-shot CoTではそのようなエンジニアリングは必要ない）。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236408978-b292ea0f-0a17-42fc-8e3c-6eee35780ca4.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-04-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/523">Recurrent Memory Transformer, Bulatov+, NeurIPS'22</a>
<span class="snippet"><span>Comment</span>TransformerはO(N^2)であり、計算量がNに応じて指数関数的に増加してしまう。一方、sequenceの情報を全てN次元ベクトルに集約しなければならず、計算量の制約によって長い系列のRepresentationを獲得できない。

<br>



<br>

そこで、Transformerの構造は変えず、Inputにメモリtokenを追加することで、メモリ間の関係性を学習できるような手法を提案。長いトークン列に対しても、トークン列をセグメントとゆばれる単位に区切り、セグメントのInputの頭で、前断のセグメントのメモリtokenを入力し、最終的に現在のセグメントのメモリをoutputし、後断のセグメントに入力とする、といったことを繰り返すことで、長い系列も扱えるようにした。

<br>



<br>

セグメントをまたいでbackpropagationをかけることで、たとえセグメントとしては独立していても、メモリの情報を考慮することでセグメント間の依存関係を学習することが可能だと思われる。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/234206394-925cb6ee-85bd-46ad-b7ed-f57685badc38.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2022-12-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/501">UNIFIEDSKG: Unifying and Multi-Tasking Structured Knowledge Grounding with Text-to-Text Language Models, Xie+, EMNLP'22</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/EMNLP.html">#EMNLP</a>
<a class="button" href="articles/KnowledgeEditing.html">#KnowledgeEditing</a>
<span class="issue_date">Issue Date: 2025-06-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2056">[Paper Note] Editing Factual Knowledge in Language Models, Nicola De Cao+, EMNLP'21</a>
<span class="snippet"><span>Summary</span>KnowledgeEditorは、事前学習された言語モデルの知識を編集し、再学習なしで誤った事実や予測を修正する手法です。制約最適化を用いてハイパーネットワークを訓練し、他の知識に影響を与えずに事実を修正します。BERTとBARTのモデルでその有効性を示し、特定のクエリに基づく予測変更がパラフレーズにも一貫して影響を与えることを確認しました。ハイパーネットワークは、知識操作に必要なコンポーネントを特定する「プローブ」として機能します。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2024-12-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1618">Training Verifiers to Solve Math Word Problems, Karl Cobbe+, arXiv'21</a>
<span class="snippet"><span>Summary</span>GSM8Kデータセットを用いて、多段階の数学的推論における言語モデルの限界を分析。検証器を訓練し、候補解を評価して最適解を選択することで、モデルのパフォーマンスを大幅に向上させることを示した。検証はファインチューニングよりもデータ増加に対して効果的にスケールする。</span>
<span class="snippet"><span>Comment</span>気持ち

<br>



<br>

・当時の最も大きいレベルのモデルでも multi-stepのreasoningが必要な問題は失敗する

<br>



<br>

・モデルをFinetuningをしても致命的なミスが含まれる

<br>



<br>

・特に、数学は個々のミスに対して非常にsensitiveであり、一回ミスをして異なる解法のパスに入ってしまうと、self-correctionするメカニズムがauto-regressiveなモデルではうまくいかない

<br>



<br>

・純粋なテキスト生成の枠組みでそれなりの性能に到達しようとすると、とんでもないパラメータ数が必要になり、より良いscaling lawを示す手法を模索する必要がある

<br>



<br>

Contribution

<br>



<br>

論文の貢献は

<br>



<br>

・GSM8Kを提案し、

<br>



<br>

・verifierを活用しモデルの複数の候補の中から良い候補を選ぶフレームワークによって、モデルのパラメータを30倍にしたのと同等のパフォーマンスを達成し、データを増やすとverifierを導入するとよりよく性能がスケールすることを示した。

<br>



<br>

・また、dropoutが非常に強い正則化作用を促し、finetuningとverificationの双方を大きく改善することを示した。Todo: 続きをまとめる</span>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<span class="issue_date">Issue Date: 2023-08-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1009">ViLT: Vision-and-Language Transformer Without Convolution or Region   Supervision, Wonjae Kim+, N_A, ICML'21</a>
<span class="snippet"><span>Summary</span>VLP（Vision-and-Language Pre-training）のアプローチは、ビジョンと言語のタスクでのパフォーマンスを向上させているが、現在の方法は効率性と表現力の面で問題がある。そこで、本研究では畳み込みフリーのビジョンと言語のトランスフォーマ（ViLT）モデルを提案する。ViLTは高速でありながら競争力のあるパフォーマンスを示し、コードと事前学習済みの重みはGitHubで利用可能である。</span>
<span class="snippet"><span>Comment</span>日本語解説:https://tech.fusic.co.jp/posts/2021-12-29-vilt/</span>
<a class="button" href="articles/Sentence.html">#Sentence</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/ContrastiveLearning.html">#ContrastiveLearning</a>
<a class="button" href="articles/Catastrophic%20Forgetting.html">#Catastrophic Forgetting</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2023-07-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/907">SimCSE: Simple Contrastive Learning of Sentence Embeddings, Tianyu Gao+, N_A, EMNLP'21</a>
<span class="snippet"><span>Summary</span>この論文では、SimCSEという対比学習フレームワークを提案しています。このフレームワークは、文の埋め込み技術を進化させることができます。教師なしアプローチでは、入力文をノイズとして扱い、自己を対比的に予測します。教師ありアプローチでは、自然言語推論データセットから注釈付きのペアを使用して対比学習を行います。SimCSEは、意味的テキスト類似性タスクで評価され、以前の手法と比較して改善を実現しました。対比学習は、事前学習された埋め込みの空間を均一に正則化し、教師信号が利用可能な場合には正のペアをよりよく整列させることが示されました。</span>
<span class="snippet"><span>Comment</span>462 よりも性能良く、unsupervisedでも学習できる。STSタスクのベースラインにだいたい入ってる手法概要

<br>



<br>

Contrastive Learningを活用して、unsupervised/supervisedに学習を実施する。

<br>



<br>

Unsupervised SimCSEでは、あるsentenceをencoderに2回入力し、それぞれにdropoutを適用させることで、positive pairを作成する。dropoutによって共通のembeddingから異なる要素がマスクされた（noiseが混ざった状態とみなせる）類似したembeddingが作成され、ある種のdata augmentationによって正例を作成しているともいえる。負例はnegative samplingする。（非常にsimpleだが、next sentence predictionで学習するより性能が良くなる）

<br>



<br>

Supervised SimCSEでは、アノテーションされたsentence pairに基づいて、正例・負例を決定する。本研究では、NLIのデータセットにおいて、entailment関係にあるものは正例として扱う。contradictions（矛盾）関係にあるものは負例として扱う。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/ba20a1ca-0078-4227-8bb3-3805ee57a620" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Siamese Networkで用いられるmeans-squared errrorとContrastiveObjectiveの違い

<br>



<br>

どちらもペアワイズで比較するという点では一緒だが、ContrastiveObjectiveは正例と近づいたとき、負例と遠ざかったときにlossが小さくなるような定式化がされている点が異なる。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/d9cad930-e86d-4758-87b5-4237525a154a" alt="image" loading="lazy">

<br>



<br>

（画像はこのブログから引用。ありがとうございます。https://techblog.cccmk.co.jp/entry/2022/08/30/163625）

<br>



<br>



<br>



<br>

Unsupervised SimCSEの実験

<br>



<br>

異なるdata augmentation手法と比較した結果、dropoutを適用する手法の方が性能が高かった。MLMや, deletion, 類義語への置き換え等よりも高い性能を獲得しているのは興味深い。また、Next Sentence Predictionと比較しても、高い性能を達成。Next Sentence Predictionは、word deletion等のほぼ類似したテキストから直接的に類似関係にあるペアから学習するというより、Sentenceの意味内容のつながりに基づいてモデルの言語理解能力を向上させ、そのうえで類似度を測るという間接的な手法だが、word deletionに負けている。一方、dropoutを適用するだけの（直接的に類似ペアから学習する）本手法はより高い性能を示している。

<br>



<br>

[image](https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/0ea3549e-3363-4857-94e6-a1ef474aa191)

<br>



<br>



<br>



<br>

なぜうまくいくかを分析するために、異なる設定で実験し、alignment（正例との近さ）とuniformity（どれだけembeddingが一様に分布しているか）を、10 stepごとにplotした結果が以下。dropoutを適用しない場合と、常に同じ部分をマスクする方法（つまり、全く同じembeddingから学習する）設定を見ると、学習が進むにつれuniformityは改善するが、alignmentが悪くなっていっている。一方、SimCSEはalignmentを維持しつつ、uniformityもよくなっていっていることがわかる。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/5f488cb2-b15a-4e00-9452-8e48780abe8a" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/5e815cf7-b412-4f1b-8adb-116f0dcd2fee" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Supervised SimCSEの実験

<br>



<br>

アノテーションデータを用いてContrastiveLearningするにあたり、どういったデータを正例としてみなすと良いかを検証するために様々なデータセットで学習し性能を検証した。

<br>



<br>



<br>



<br>

・QQP4: Quora question pairs

<br>



<br>

・Flickr30k (Young et al., 2014): 同じ画像に対して、5つの異なる人間が記述したキャプションが存在

<br>



<br>

・ParaNMT (Wieting and Gimpel, 2018): back-translationによるparaphraseのデータセットa

<br>



<br>

・NLI datasets: SNLIとMNLI

<br>



<br>



<br>



<br>

実験の結果、NLI datasetsが最も高い性能を示した。この理由としては、NLIデータセットは、crowd sourcingタスクで人手で作成された高品質なデータセットであることと、lexical overlapが小さくなるようにsentenceのペアが作成されていることが起因している。実際、NLI datsetのlexical overlapは39%だったのに対し、ほかのデータセットでは60%であった。

<br>



<br>



<br>



<br>

また、condunctionsとなるペアを明示的に負例として与えることで、より性能が向上した（普通はnegative samplingする、というかバッチ内の正例以外のものを強制的に負例とする。こうすると、意味が同じでも負例になってしまう事例が出てくることになる）。より難しいNLIタスクを含むANLIデータセットを追加した場合は、性能が改善しなかった。この理由については考察されていない。性能向上しそうな気がするのに。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/ae05711b-5ad4-4a53-837b-c57e9a39da62" alt="image" loading="lazy">

<br>



<br>

他手法との比較結果

<br>



<br>

SimCSEがよい。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/510744ff-01bb-47be-9e30-2efa49e0f923" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Ablation Studies

<br>



<br>

異なるpooling方法で、どのようにsentence embeddingを作成するかで性能の違いを見た。originalのBERTの実装では、CLS token のembeddingの上にMLP layerがのっかっている。これの有無などと比較。

<br>



<br>

Unsupervised SimCSEでは、training時だけMLP layerをのっけて、test時はMLPを除いた方が良かった。一方、Supervised SimCSEでは、 MLP layerをのっけたまんまで良かったとのこと。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/73116c6a-d48f-42bc-aa5e-8342bb068052" alt="image" loading="lazy">

<br>



<br>

また、SimCSEで学習したsentence embeddingを別タスクにtransferして活用する際には、SimCSEのobjectiveにMLMを入れた方が、catastrophic forgettingを防げて性能が高かったとのこと。

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/cc6d20c3-5a0c-4b5e-aa6d-63447c55363f" alt="image" loading="lazy">ablation studiesのhard negativesのところと、どのようにミニバッチを構成するか、それぞれのtransferしたタスクがどのようなものがしっかり読めていない。あとでよむ。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/MultitaskLearning.html">#MultitaskLearning</a>
<span class="issue_date">Issue Date: 2023-07-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/904">Measuring Massive Multitask Language Understanding, Dan Hendrycks+, N_A, ICLR'21</a>
<span class="snippet"><span>Summary</span>私たちは、マルチタスクのテキストモデルの正確性を測定するための新しいテストを提案しています。このテストは、57のタスクをカバーし、広範な世界知識と問題解決能力を必要とします。現在のモデルはまだ専門家レベルの正確性に達しておらず、性能に偏りがあります。私たちのテストは、モデルの理解の幅と深さを評価し、重要な欠点を特定するために使用できます。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2023-07-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/901">Measuring Massive Multitask Language Understanding, Dan Hendrycks+, N_A, ICLR'21</a>
<span class="snippet"><span>Summary</span>私たちは、マルチタスクのテキストモデルの正確性を測定するための新しいテストを提案しています。このテストは57のタスクをカバーし、広範な世界知識と問題解決能力が必要です。現在のモデルはまだ専門家レベルの正確性に達しておらず、性能に偏りがあります。私たちのテストは、モデルの弱点を特定するために使用できます。</span>
<span class="snippet"><span>Comment</span>OpenReview:https://openreview.net/forum?id=d7KBjmI3GmQMMLU論文</span>
<a class="button" href="articles/PersonalizedDocumentSummarization.html">#PersonalizedDocumentSummarization</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/PersonalizedGeneration.html">#PersonalizedGeneration</a>
<a class="button" href="articles/Personalization.html">#Personalization</a>
<a class="button" href="articles/PersonalizedHeadlineGeneration.html">#PersonalizedHeadlineGeneration</a>
<span class="issue_date">Issue Date: 2023-05-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/706">PENS: A Dataset and Generic Framework for Personalized News Headline Generation, ACL'21</a>
<span class="snippet"><span>Summary</span>この論文では、ユーザーの興味とニュース本文に基づいて、ユーザー固有のタイトルを生成するパーソナライズされたニュース見出し生成の問題を解決するためのフレームワークを提案します。また、この問題のための大規模なデータセットであるPENSを公開し、ベンチマークスコアを示します。データセットはhttps://msnews.github.io/pens.htmlで入手可能です。</span>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

ニュース記事に対するPersonalizedなHeadlineの正解データを生成。103名のvolunteerの最低でも50件のクリックログと、200件に対する正解タイトルを生成した。正解タイトルを生成する際は、各ドキュメントごとに4名異なるユーザが正解タイトルを生成するようにした。これらを、Microsoft Newsの大規模ユーザ行動ログデータと、ニュース記事本文、タイトル、impressionログと組み合わせてPENSデータを構成した。

<br>



<br>



<br>



<br>

データセット生成手順

<br>



<br>

103名のenglish-native [speakerの学生に対して、1000件のニュースヘッドラインの中から最低50件興味のあるヘッドラインを選択してもらう。続いて、200件のニュース記事に対して、正解ヘッドラインを生成したもらうことでデータを生成した。正解ヘッドラインを生成する際は、同一のニュースに対して4人がヘッドラインを生成するように調整した。生成されたヘッドラインは専門家によってqualityをチェックされ、factual informationにエラーがあるものや、極端に長い・短いものなどは除外された。

<br>



<br>



<br>



<br>

データセット統計量

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/cd4fa969-03c0-4539-bcec-25ba3204ffc9" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/1c9a38b4-4156-49a2-83e5-20e057588f91" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

手法概要

<br>



<br>

Transformer Encoder + Pointer GeneratorによってPersonalizedなヘッドラインを生成する。

<br>



<br>

Transformer Encoderでは、ニュースの本文情報をエンコードし、attention distributionを生成する。Decoder側では、User Embeddingを組み合わせて、テキストをPointer Generatorの枠組みでデコーディングしていき、ヘッドラインを生成する。

<br>



<br>

User Embeddingをどのようにinjectするかで、3種類の方法を提案しており、1つ目は、Decoderの初期状態に設定する方法、2つ目は、ニュース本文のattention distributionの計算に利用する方法、3つ目はデコーディング時に、ソースからvocabをコピーするか、生成するかを選択する際に利用する方法。1つ目は一番シンプルな方法、2つ目は、ユーザによって記事で着目する部分が違うからattention distributionも変えましょう、そしてこれを変えたらcontext vectorも変わるからデコーディング時の挙動も変わるよねというモチベーション、3つ目は、選択するvocabを嗜好に合わせて変えましょう、という方向性だと思われる。最終的に、2つ目の方法が最も性能が良いことが示された。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/54d4da04-6af2-4ef2-b4ff-7a12f1ea7936" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

訓練手法

<br>



<br>

まずニュース記事推薦システムを訓練し、user embeddingを取得できるようにする。続いて、genericなheadline generationモデルを訓練する。最後に両者を組み合わせて、Reinforcement LearningでPersonalized Headeline Generationモデルを訓練する。Rewardとして、

<br>



<br>

1. Personalization: ヘッドラインとuser embeddingのdot productで報酬とする

<br>



<br>

2. Fluency: two-layer LSTMを訓練し、生成されたヘッドラインのprobabilityを推定することで報酬とする

<br>



<br>

3. Factual Consistency: 生成されたヘッドラインと本文の各文とのROUGEを測りtop-3 scoreの平均を報酬とする

<br>



<br>

とした。

<br>



<br>

1,2,3の平均を最終的なRewardとする。

<br>



<br>



<br>



<br>

実験結果

<br>



<br>

Genericな手法と比較して、全てPersonalizedな手法が良かった。また、手法としては②のattention distributionに対してuser informationを注入する方法が良かった。News Recommendationの性能が高いほど、生成されるヘッドラインの性能も良かった。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/84aa7b6d-05cf-415a-a2cf-76401801230f" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Case Study

<br>



<br>

ある記事に対するヘッドラインの一覧。Pointer-Genでは、重要な情報が抜け落ちてしまっているが、提案手法では抜け落ちていない。これはRLの報酬のfluencyによるものだと考えられる。また、異なるユーザには異なるヘッドラインが生成されていることが分かる。 

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/e65eb9da-7cc6-4d72-b2ca-8607c794f3a0" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/DocumentSummarization.html">#DocumentSummarization</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2021-09-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/405">Prefix-Tuning: Optimizing Continuous Prompts for Generation, Lisa+ （Percy Liang）, Stanford University, ACL'21</a>
<span class="snippet"><span>Comment</span>言語モデルをfine-tuningする際，エンコード時に「接頭辞」を潜在表現として与え，「接頭辞」部分のみをfine-tuningすることで（他パラメータは固定），より少量のパラメータでfine-tuningを実現する方法を提案．接頭辞を潜在表現で与えるこの方法は，GPT-3のpromptingに着想を得ている．fine-tuningされた接頭辞の潜在表現のみを配布すれば良いので，非常に少量なパラメータでfine-tuningができる．

<br>



<br>



<br>



<br>

table-to-text, summarizationタスクで，一般的なfine-tuningやAdapter（レイヤーの間にアダプターを挿入しそのパラメータだけをチューニングする手法）といった効率的なfine-tuning手法と比較．table-to-textでは、250k (元のモデルの 0.1%) ほどの数のパラメータを微調整するだけで、全パラメータをfine-tuningするのに匹敵もしくはそれ以上の性能を達成．

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/132679791-87ad130d-8a7e-4549-a311-f84400a3787b.png" alt="image" loading="lazy">

<br>



<br>

Hugging Faceの実装を利用したと論文中では記載されているが，fine-tuningする前の元の言語モデル（GPT-2）はどのように準備したのだろうか．Hugging Faceのpretrained済みのGPT-2を使用したのだろうか．autoregressive LM (GPT-2)と，encoder-decoderモデル（BART）へPrefix Tuningを適用する場合の模式図

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/132681736-0ea4b13f-71cb-41ba-ae17-027e8bf54cc0.png" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<span class="issue_date">Issue Date: 2025-05-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2002">Scaling Laws for Autoregressive Generative Modeling, Tom Henighan+, arXiv'20</a>
<span class="snippet"><span>Summary</span>生成画像、ビデオ、マルチモーダルモデル、数学的問題解決の4領域におけるクロスエントロピー損失のスケーリング法則を特定。自己回帰型トランスフォーマーはモデルサイズと計算予算の増加に伴い性能が向上し、べき法則に従う。特に、10億パラメータのトランスフォーマーはYFCC100M画像分布をほぼ完璧にモデル化できることが示された。さらに、マルチモーダルモデルの相互情報量や数学的問題解決における外挿時の性能に関する追加のスケーリング法則も発見。これにより、スケーリング法則がニューラルネットワークの性能に与える影響が強調された。</span>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ICLR.html">#ICLR</a>
<a class="button" href="articles/Decoding.html">#Decoding</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-04-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1889">The Curious Case of Neural Text Degeneration, Ari Holtzman+, ICLR'20</a>
<span class="snippet"><span>Summary</span>深層ニューラル言語モデルは高品質なテキスト生成において課題が残る。尤度の使用がモデルの性能に影響を与え、人間のテキストと機械のテキストの間に分布の違いがあることを示す。デコーディング戦略が生成テキストの質に大きな影響を与えることが明らかになり、ニュークリアスsamplingを提案。これにより、多様性を保ちながら信頼性の低い部分を排除し、人間のテキストに近い質を実現する。</span>
<span class="snippet"><span>Comment</span>現在のLLMで主流なNucleus (top-p) Samplingを提案した研究</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<span class="issue_date">Issue Date: 2025-03-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1828">Scaling Laws for Neural Language Models, Jared Kaplan+, arXiv'20</a>
<span class="snippet"><span>Summary</span>言語モデルの性能に関するスケーリング法則を研究し、損失がモデルサイズ、データセットサイズ、計算量に対して冪則的にスケールすることを示す。アーキテクチャの詳細は影響が少なく、過学習やトレーニング速度は単純な方程式で説明される。これにより、計算予算の最適な配分が可能となり、大きなモデルはサンプル効率が高く、少量のデータで早期に収束することが示された。</span>
<span class="snippet"><span>Comment</span>日本語解説:https://www.slideshare.net/slideshow/dlscaling-laws-for-neural-language-models/243005067</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2024-05-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1311">GLU Variants Improve Transformer, Noam Shazeer, N_A, arXiv'20</a>
<span class="snippet"><span>Summary</span>GLUのバリエーションをTransformerのフィードフォワード・サブレイヤーでテストし、通常の活性化関数よりもいくつかのバリエーションが品質向上をもたらすことを発見した。</span>
<span class="snippet"><span>Comment</span>一般的なFFNでは、linear layerをかけた後に、何らかの活性化関数をかませる方法が主流である。

<br>



<br>

このような構造の一つとしてGLUがあるが、linear layerと活性化関数には改良の余地があり、様々なvariantが考えられるため、色々試しました、というはなし。

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/72b1d0bb-64ac-4155-9a3b-5624cd06ccc9" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/b38321c6-d414-4764-9147-10a5fa83fbe6" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

オリジナルのGLUと比較して、T5と同じ事前学習タスクを実施したところ、perplexityが改善

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/9e67a054-2148-41ed-aae1-5a752c21a242" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

また、finetuningをした場合の性能も、多くの場合オリジナルのGLUよりも高い性能を示した。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/77ccab88-e5cc-48fc-b9e0-f2dad24e53e8" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/8f60ca8c-50eb-4869-bab4-f02ec6d8e085" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/8124fc25-aa7e-4e10-8cd2-9d24c818f410" alt="image" loading="lazy">

<br>



<br>



<br>



<br>



<br>



<br>

</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Zero/FewShotPrompting.html">#Zero/FewShotPrompting</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2023-04-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/552">Language Models are Few-Shot Learners, Tom B. Brown+, NeurIPS'20</a>
<span class="snippet"><span>Summary</span>GPT-3は1750億パラメータを持つ自己回帰型言語モデルで、少数ショット設定においてファインチューニングなしで多くのNLPタスクで強力な性能を示す。翻訳や質問応答などで優れた結果を出し、即時推論やドメイン適応が必要なタスクでも良好な性能を発揮する一方、依然として苦手なデータセットや訓練に関する問題も存在する。また、GPT-3は人間が書いた記事と区別が難しいニュース記事を生成できることが確認され、社会的影響についても議論される。</span>
<span class="snippet"><span>Comment</span>In-Context Learningを提案した論文論文に記載されているIn-Context Learningの定義は、しっかり押さえておいた方が良い。

<br>



<br>

下図はmeta-learningの観点から見たときの、in-contextの位置付け。事前学習時にSGDでパラメータをupdateするのをouter loopとし、そこで広いスキルとパターン認識の能力を身につける。一方で、in-context learningは、Inference時に事前学習時に得たそれらのスキルを用いて、求めるタスクを認識、あるいは適応するInner loopのことを指す。

<br>

<img src="https://github.com/user-attachments/assets/679129f3-93e3-445f-b9e8-5d909261737b" alt="image" loading="lazy">

<br>



<br>

この上で、論文中では In-Context Learningについて:

<br>

&gt; Recent work [RWC+19] attempts to do this via what we call “in-context learning”, using the text input of a pretrained language model as a form of task specification: the model is conditioned on a natural language instruction and/or a few demonstrations of the task and is then expected to complete further instances of the task simply by predicting what comes next.

<br>



<br>

と定義している。</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/DataToTextGeneration.html">#DataToTextGeneration</a>
<a class="button" href="articles/pretrained-LM.html">#pretrained-LM</a>
<a class="button" href="articles/Zero/FewShotLearning.html">#Zero/FewShotLearning</a>
<span class="issue_date">Issue Date: 2022-12-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/494">Few-Shot NLG with Pre-Trained Language Model, Chen+, University of California, ACL'20</a>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

Neural basedなend-to-endなNLGアプローチはdata-hungryなので、Few Shotな設定で高い性能ができる手法を提案（Few shot NLG）

<br>



<br>

Table-to-Textタスク（WikiBIOデータ, 追加で収集したBook, SongドメインのWikipediaデータ）において、200程度の学習サンプル数でstrong baselineに対して8.0 point程度のBLEUスコアの向上を達成

<br>



<br>



<br>



<br>

手法

<br>



<br>

TabularデータのDescriptionを作成するには大きく分けて2つのスキルが必要

<br>



<br>

1. factualな情報を持つcontentをselectし、copyするスキル

<br>



<br>

2. factualな情報のコピーを含めながら、文法的に正しいテキストを生成するスキル

<br>



<br>

提案手法では、1を少量のサンプル（&lt; 500）から学習し、2については事前学習済みの言語モデルを活用する。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/204966408-e5442477-0560-439b-9780-d454a8761345.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

encoderからコピーする確率をpcopyとし、下記式で算出する：

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/204968383-44ef3771-218e-4e3e-8bfd-e2e6750c514b.png" alt="image" loading="lazy">

<br>



<br>

すなわち、encoderのcontext vectorと、decoderのinputとstateから求められる。

<br>



<br>

encoderとencoder側へのattentionはscratchから学習しなければならず、うまくコピーできるようにしっかりと”teach”しなければならないため、lossに以下を追加する：

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/204968557-4526e76d-8be5-4371-adc7-d49d8291954f.png" alt="image" loading="lazy">

<br>



<br>

すなわち、コピーすべき単語がちゃんとコピーできてる場合にlossが小さくなる項を追加している。

<br>



<br>

また、decoder側では、最初にTable情報のEmbeddingを入力するようにしている。

<br>



<br>

また、学習できるデータ量が限られているため、pre-trainingモデルのEmbeddingは事前学習時点のものに固定した（ただしく読解できているか不安）

<br>



<br>



<br>



<br>

実験

<br>



<br>

WikiBIOと、独自に収集したBook, Songに関するWikipediaデータのTable-to-Textデータを用いて実験。

<br>



<br>

このとき、Training instanceを50~500まで変化させた。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/204969250-b2965b62-5a82-4c38-9008-3e4bbc5d9c24.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

WikiBIOデータセットに対してSoTAを記録しているBase-originalを大きくoutperform（Few shot settingでは全然うまくいかない）。

<br>



<br>



<br>



<br>

inputとoutput例と、コピーに関するlossを入れた場合の効果。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/204969645-aa2686f0-f83c-44cc-a6aa-2e793a6cd5b8.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

人手評価の結果、Factual informationの正しさ（Supp）、誤り（Cont）ともに提案手法が良い。また、文法的な正しさ（Lan. Score）もコピーがない場合とcomparable

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/204969885-7cb3e507-d986-4d97-8f7c-a5b8c3c8204f.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/NeurIPS.html">#NeurIPS</a>
<span class="issue_date">Issue Date: 2025-08-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2357">[Paper Note] Deep Equilibrium Models, Shaojie Bai+, NeurIPS'19</a>
<span class="snippet"><span>Summary</span>深い平衡モデル（DEQ）を提案し、逐次データのモデル化において平衡点を直接見つけるアプローチを示す。DEQは無限の深さのフィードフォワードネットワークを解析的に逆伝播可能にし、定数メモリでトレーニングと予測を行える。自己注意トランスフォーマーやトレリスネットワークに適用し、WikiText-103ベンチマークでパフォーマンス向上、計算要件の維持、メモリ消費の最大88%削減を実証。</span>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<span class="issue_date">Issue Date: 2024-04-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1272">Fast Transformer Decoding: One Write-Head is All You Need, Noam Shazeer, N_A, arXiv'19</a>
<span class="snippet"><span>Summary</span>マルチヘッドアテンションレイヤーのトレーニングは高速かつ簡単だが、増分推論は大きな"keys"と"values"テンソルを繰り返し読み込むために遅くなることがある。そこで、キーと値を共有するマルチクエリアテンションを提案し、メモリ帯域幅要件を低減する。実験により、高速なデコードが可能で、わずかな品質の低下しかないことが確認された。</span>
<span class="snippet"><span>Comment</span>Multi Query Attention論文。KVのsetに対して、単一のQueryのみでMulti-Head Attentionを代替する。劇的にDecoderのInferenceが早くなりメモリ使用量が減るが、論文中では言及されていない？ようだが、性能と学習の安定性が課題となるようである。

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/e2d77b43-70c3-4922-a822-bf95d6b4704f" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Sentence.html">#Sentence</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2017-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/76">Larger-context language modelling with recurrent neural networks, Wang+, ACL'16</a>
<span class="snippet"><span>Comment</span>概要

<br>



<br>

通常のNeural Language Modelはsentence間に独立性の仮定を置きモデル化されているが、この独立性を排除し、preceding sentencesに依存するようにモデル化することで、言語モデルのコーパスレベルでのPerplexityが改善したという話。提案した言語モデルは、contextを考慮することで特に名詞や動詞、形容詞の予測性能が向上。Late-Fusion methodと呼ばれるRNNのoutputの計算にcontext vectorを組み込む手法が、Perplexityの改善にもっとも寄与していた。

<br>



<br>



<br>



<br>

手法

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34412713-1e16da94-ec22-11e7-830c-0d0b6247207c.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

sentence間の独立性を排除し、Corpusレベルのprobabilityを下図のように定義。（普通はP(Slが条件付けされていない)）

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34412980-e2425afa-ec23-11e7-86cd-148f85dccc07.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

preceding sentence (context)をモデル化するために、3種類の手法を提案。

<br>



<br>



<br>



<br>

[1. bag-of-words context]

<br>



<br>

　ナイーブに、contextに現れた単語の（単一の）bag-of-wordsベクトルを作り、linear layerをかませてcontext vectorを生成する手法。

<br>



<br>



<br>



<br>

[2. context recurrent neural network]

<br>



<br>

　preceding sentencesをbag-of-wordsベクトルの系列で表現し、これらのベクトルをsequentialにRNN-LSTMに読み込ませ、最後のhidden stateをcontext vectorとする手法。これにより、sentenceが出現した順番が考慮される。

<br>



<br>



<br>



<br>

[3. attention based context representation]

<br>



<br>

　Attentionを用いる手法も提案されており、context recurrent neural networkと同様にRNNにbag-of-wordsのsequenceを食わせるが、各時点におけるcontext sentenceのベクトルを、bi-directionalなRNNのforward, backward stateをconcatしたもので表現し、attention weightの計算に用いる。context vectorは1, 2ではcurrent sentence中では共通のものを用いるが、attention basedな場合はcurrent sentenceの単語ごとに異なるcontext vectorを生成して用いる。

<br>



<br>



<br>



<br>

生成したcontext vectorをsentence-levelのRNN言語モデルに組み合わせる際に、二種類のFusion Methodを提案している。

<br>



<br>



<br>



<br>

[1. Early Fusion]

<br>



<br>

　ナイーブに、RNNLMの各時点でのinputにcontext vectorの情報を組み込む方法。

<br>



<br>

[2. Late Fusion]

<br>



<br>

　よりうまくcontext vectorの情報を組み込むために、current sentence内の単語のdependency(intra-sentence dependency)と、current sentenceとcontextの関係を別々に考慮する。context vectorとmemory cellの情報から、context vector中の不要箇所をフィルタリングしたcontrolled context vectorを生成し、LSTMのoutputの計算に用いる。Later Fusionはシンプルだが、corpusレベルのlanguage modelingの勾配消失問題を緩和することもできる。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34413898-99efbaf8-ec29-11e7-94f5-db82eee399b3.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

評価

<br>



<br>

IMDB, BBC, PennTreebank, Fil9 (cleaned wikipedia corpus)の4種類のデータで学習し、corpus levelでPerplexityを測った。

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34414121-b75b2996-ec2a-11e7-9716-dbbb9006b1b5.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

Late FusionがPerplexityの減少に大きく寄与している。

<br>



<br>



<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/34414218-596b373a-ec2b-11e7-85ad-cf98df04ce57.png" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

PoSタグごとのperplexityを測った結果、contextを考慮した場合に名詞や形容詞、動詞のPerplexityに改善が見られた。一方、Coordinate Conjungtion (And, Or, So, Forなど)や限定詞、Personal Pronouns (I, You, It, Heなど)のPerplexityは劣化した。前者はopen-classな内容語であり、後者はclosed-classな機能語である。機能語はgrammaticalなroleを決めるのに対し、内容語はその名の通り、sentenceやdiscourseの内容を決めるものなので、文書の内容をより捉えることができると考察している。</span>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/ICML.html">#ICML</a>
<a class="button" href="articles/Normalization.html">#Normalization</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-04-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1857">Batch Normalization: Accelerating Deep Network Training by Reducing   Internal Covariate Shift, Sergey Ioffe+, ICML'15</a>
<span class="snippet"><span>Summary</span>バッチ正規化を用いることで、深層ニューラルネットワークのトレーニングにおける内部共変量シフトの問題を解決し、高い学習率を可能にし、初期化の注意を軽減。これにより、同じ精度を14倍少ないトレーニングステップで達成し、ImageNet分類で最良の公表結果を4.9%改善。</span>
<span class="snippet"><span>Comment</span>メモってなかったので今更ながら追加した共変量シフトやBatch Normalizationの説明は

<br>

・261

<br>



<br>

記載のスライドが分かりやすい。</span>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<a class="button" href="articles/IJCNLP.html">#IJCNLP</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2018-03-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/266">Unsupervised prediction of acceptability judgements, Lau+, ACL-IJCNLP'15</a>
<span class="snippet"><span>Comment</span>文のacceptability（容認度）論文。

<br>



<br>

文のacceptabilityとは、native speakerがある文を読んだときに、その文を正しい文として容認できる度合いのこと。

<br>



<br>

acceptabilityスコアが低いと、Readabilityが低いと判断できる。

<br>



<br>

言語モデルをトレーニングし、トレーニングした言語モデルに様々な正規化を施すことで、acceptabilityスコアを算出する。</span>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2024-12-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1609">Large Language Models in Machine Translation, Brants+, EMNLP-CoNLL'07</a>
<span class="snippet"><span>Summary</span>本論文では、機械翻訳における大規模な統計的言語モデルの利点を報告し、最大2兆トークンでトレーニングした3000億n-gramのモデルを提案。新しいスムージング手法「Stupid Backoff」を導入し、大規模データセットでのトレーニングが安価で、Kneser-Neyスムージングに近づくことを示す。</span>
<span class="snippet"><span>Comment</span>N-gram言語モデル+スムージングの手法において、学習データを増やして扱えるngramのタイプ数（今で言うところのvocab数に近い）を増やしていったら、perplexityは改善するし、MTにおけるBLEUスコアも改善するよ（BLEUはサチってるかも？）という考察がされている

<br>



<br>

<img src="https://github.com/user-attachments/assets/035f28db-12c6-4b69-b39f-7eb41581d00c" alt="image" loading="lazy">元ポスト:https://x.com/odashi_t/status/1871024428739604777?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLarge Language Modelsという用語が利用されたのはこの研究が初めてなのかも…？</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-08-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2389">Diffusion Language Models are Super Data Learners, Jinjie Ni and the team, 2025.08</a>
<span class="snippet"><span>Comment</span>dLLMは学習データの繰り返しに強く、データ制約下においては十分な計算量を投入してepochを重ねると、性能向上がサチらずにARモデルを上回る。

<br>



<br>

<img src="https://github.com/user-attachments/assets/ff668aac-cbcd-48ed-a5d6-50d0fa381f5a" alt="image" loading="lazy">・2268

<br>

・追記: 上記研究の著者による本ポストで取り上げられたissueに対するclarification

<br>

　　・https://x.com/mihirp98/status/1954240474891653369?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

でも同様の知見が得られている。

<br>

が、スレッド中で両者の違いが下記のように（x rollrng reviewなるものを用いて）ポストされており、興味がある場合は読むといいかも。（ところで、x rolling reviewとは、、？もしやLLMによる自動的な査読システム？）

<br>



<br>

<img src="https://github.com/user-attachments/assets/295dcd4b-2b81-4439-b117-94dcf6cce5a7" alt="image" loading="lazy">・1829

<br>



<br>

において、ARモデルではrepetitionは4回までがコスパ良いという話と比べると、dLLMにとんでもない伸び代があるような話に見える。個人的にはアーキテクチャのさらなる進化は興味深いが、ユーザが不完全な質問をLLMに投げた時に、LLMがユーザの意図が「不明な部分のcontextを質問を返すことによって補う」という挙動があると嬉しい気がするのだが、そういった研究はないのだろうか。

<br>



<br>

ただ、事前学習時点でそういったデータが含まれて知識として吸収され、かつmid/post-trainingでそういった能力を引き出すと言う両軸で取り組まないと、最悪膨大な計算資源を投じたものの「わからない！どういうこと！？」と返し続けるLLMが完成し全く役に立たない、ということになりそうで怖い。

<br>



<br>

gpt5が出た時に、「3.9と3.11はどちらが大きいですか？」というクエリを投げた際にいまだに「3.11」と回答してくる、みたいなポストが印象的であり、これはLLMが悪いと言うより、ユーザ側が算数としての文脈できいているのか、ソフトウェアのバージョンの文脈できいているのか、を指定していないことが原因であり、上記の回答はソフトウェアのバージョニングという文脈では正答となる。LLMが省エネになって、ユーザのデータを蓄積しまくって、一人一人に対してあなただけのLLM〜みたいな時代がくれば少しは変わるのだろうが、それでもユーザがプロファイルとして蓄積した意図とは異なる意図で質問しなければならないという状況になると、上記のような意図の取り違えが生じるように思う。

<br>

なのでやはりりLLM側が情報が足りん〜と思ったら適切なturn数で、最大限の情報をユーザから引き出せるような逆質問を返すみたいな挙動、あるいは足りない情報があったときに、いくつかの候補を提示してユーザ側に提示させる（e.g., 算数の話？それともソフトウェアの話？みたいな）、といった挙動があると嬉しいなぁ、感。

<br>



<br>

んでそこの部分の性能は、もしやるな、promptingでもある程度は実現でき、それでも全然性能足りないよね？となった後に、事前学習、事後学習でより性能向上します、みたいな流れになるのかなぁ、と想像するなどした。

<br>



<br>

しかしこういう話をあまり見ないのはなぜだろう？私の観測範囲が狭すぎる or 私のアイデアがポンコツなのか、ベンチマーク競争になっていて、そこを向上させることに業界全体が注力してしまっているからなのか、はたまた裏ではやられているけど使い物にならないのか、全然わからん。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<span class="issue_date">Issue Date: 2025-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2380">Qwen3-235B-A22B-Instruct-2507, Qwen Team, 2025.08</a>
<span class="snippet"><span>Comment</span><img src="https://github.com/user-attachments/assets/9ba4a1ff-857a-4c2e-a09d-d3e1e914ecee" alt="image" loading="lazy">

<br>



<br>

性能向上した上に1M tokens を扱える。元ポスト:https://x.com/alibaba_qwen/status/1953760230141309354?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

Dual Chunk Attention (DCA), MInference...?という技術により品質を維持しながらinference速度アップとのこと、

<br>



<br>

DCAは全体の系列をmanageableなチャンクに分割して処理しながら全体のcoherenceを維持する手法で、MInferenceは鍵となるtokenの交互作用にのみフォーカスするsparse attentionとのこと。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2025-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2377">Agent Maze, LlamaIndex, 2025.08</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jerryjliu0/status/1953550630775361914?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q最小限のツール利用することを前提に迷路をクリアする必要があるベンチマークな模様。難易度を調整可能で、GPT-5でも難易度の高い迷路には苦戦しているとのこと。難易度調整可能なものとしては以下のようなものもある:

<br>

・1818

<br>

・2019</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<span class="issue_date">Issue Date: 2025-08-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2375">GPT-5 System Card, OpenAI, 2025.08</a>
<span class="snippet"><span>Comment</span>日本語性能。MMLUを専門の翻訳家を各言語に翻訳。

<br>

<img src="https://github.com/user-attachments/assets/2e0fae0f-e134-4c55-8005-204cfac18af4" alt="image" loading="lazy">ざーっとシステムカードを見たが、ベンチマーク上では、Safetyをめっちゃ強化し、hallucinationが低減され、コーディング能力が向上した、みたいな印象（小並感）longContextの性能が非常に向上しているらしい

<br>

・https://x.com/scaling01/status/1953507426952507405?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・https://x.com/gdb/status/1953747271666819380?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

gpt-ossではAttentionSinkが使われていたが、GPT-5では使われているだろうか？もし使われているならlong contextの性能向上に寄与していると思われる。50% time horizonもscaling lawsに則り進展:

<br>

・https://x.com/hillbig/status/1953622811077227003?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・1842

<br>



<br>

個別のベンチが数%向上、もしくはcomparableです、ではもはやどれくらい進展したのかわからない（が、個々の能力が交互作用して最終的な出力がされると考えるとシナジーによって全体の性能は大幅に底上げされる可能性がある）からこの指標を見るのが良いのかも知れないMETR's Autonomy Evaluation Resources

<br>

・https://metr.github.io/autonomy-evals-guide/gpt-5-report/

<br>

・https://x.com/metr_evals/status/1953525150374150654?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QHLEに対するツール利用でのスコアの比較に対する所感:

<br>

https://x.com/imai_eruel/status/1953511704824099157?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QDocument Understandingでの評価をしたところOutput tokenが大幅に増えている:

<br>

https://x.com/jerryjliu0/status/1953582723672814054?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QGPT5 Prompting Guide:

<br>

https://cookbook.openai.com/examples/gpt-5/gpt-5_prompting_guideGPT-5: Key characteristics, pricing and model card

<br>

・https://simonwillison.net/2025/Aug/7/gpt-5/

<br>

・https://x.com/simonw/status/1953512493986591195?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qシステムカード中のSWE Bench Verifiedの評価結果は、全500サンプルのうちの477サンプルでしか実施されておらず、単純にスコアを比較することができないことに注意。実行されなかった23サンプルをFailedとみなすと（実行しなかったものを正しく成功できたとはみなせない）、スコアは減少する。同じ477サンプル間で評価されたモデル間であれば比較可能だが、500サンプルで評価された他のモデルとの比較はできない。

<br>



<br>

・https://x.com/gneubig/status/1953518981232402695?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・SWE Bench リーダーボード: https://www.swebench.com

<br>



<br>



<br>

<img src="https://github.com/user-attachments/assets/884fe132-13cc-4868-9786-190589dbca53" alt="image" loading="lazy">まとめ:

<br>

https://x.com/scaling01/status/1953511287209558245?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q所感:

<br>

・https://x.com/dongxi_nlp/status/1953570656584417655?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・https://x.com/imai_eruel/status/1953777394214744198?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QOpenHandsでの評価:

<br>

https://x.com/gneubig/status/1953883635657900289?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

SWE Bench Verifiedの性能は71.8%。全部の500サンプルで評価した結果だと思うので公式の発表より低めではある。AttentionSinkについて:

<br>

https://x.com/goro_koba/status/1954480023890780587?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2025-08-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2366">Introducing Kaggle Game Arena, Meg Risdal, 2025.08</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/googledeepmind/status/1952406075996533077?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q現在はチェスのみの模様

<br>



<br>

チェスときくとこの研究を思い出す:

<br>

・2367</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<span class="issue_date">Issue Date: 2025-08-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2365">Claude Opus 4.1, Anthropic, 2025.08</a>
<span class="snippet"><span>Comment</span>他モデルとの性能比較:

<br>

<img src="https://github.com/user-attachments/assets/22d2b65c-3bc7-4cba-90bb-c25563c286ac" alt="image" loading="lazy">

<br>



<br>

やはりコーディングでは（SNS上での口コミでは非常に高評価なように見えており、かつ）o3やGeminiと比較してClaudeがベンチ上でも高い性能を示している模様。元ポスト:https://x.com/anthropicai/status/1952768432027431127?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Architecture.html">#Architecture</a>
<span class="issue_date">Issue Date: 2025-08-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2364">The Big LLM Architecture Comparison, Sebastian Laschka, 2025.07</a>
<span class="snippet"><span>Comment</span>Qwen3とGPT-OSSの比較はこちら:

<br>

https://x.com/rasbt/status/1952842273848279364?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<a class="button" href="articles/ACL.html">#ACL</a>
<span class="issue_date">Issue Date: 2025-08-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2361">Synthetic Data in the Era of LLMs, Tutorial at ACL 2025</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/gneubig/status/1952876206388359186?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/AttentionSinks.html">#AttentionSinks</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-08-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2358">gpt-oss-120b, OpenAI, 2025.08</a>
<span class="snippet"><span>Comment</span>blog:https://openai.com/index/introducing-gpt-oss/

<br>



<br>

HF:

<br>

https://huggingface.co/datasets/choosealicense/licenses/blob/main/markdown/apache-2.0.mdアーキテクチャで使われている技術まとめ:

<br>

・https://x.com/gneubig/status/1952799735900979219?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・https://x.com/yampeleg/status/1952875217367245195?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・https://x.com/adamzweiger/status/1952799642636148917?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q上記ポスト中のアーキテクチャの論文メモリンク（管理人が追加したものも含む）

<br>

・Sliding Window Attention

<br>

  ・2388 

<br>

  ・2359

<br>

・MoE

<br>

  ・1754

<br>

・RoPE w/ YaRN

<br>

  ・1310

<br>

  ・2338

<br>

・Attention Sinks

<br>

  ・1861

<br>

    ・Attention Sinksの定義とその気持ちについてはこのメモを参照のこと。

<br>

  ・1860

<br>

    ・Attention Sinksが実際にどのように効果的に作用しているか？についてはこちらのメモを参照。

<br>

  ・1862

<br>

    ・https://x.com/gu_xiangming/status/1952811057673642227?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

  ・Attention Sinkの導入により、decodei-onlyモデルの深い層でのrepresentationのover mixingを改善し、汎化性能を高め、promptに対するsensitivityを抑えていると考えられる。

<br>

・GQA

<br>

  ・1271

<br>

・SwiGLU

<br>

  ・1311-

<br>

・(Attentionの計算に利用する) SoftmaxへのLearned bias の導入 （によるスケーリング）

<br>

  ・1863 

<br>

  ・1866

<br>

  ・Softmaxはlong contextになると、attentionの分布が均一になり、重要な情報にattendする能力が下がるためスケーリングが必要で、そのために分母にlearnedなbiasを導入していると考えられる。Llamaや上記研究では分子に係数としてlearnableなパラメータを導入しているが、少し形式が違う。もしかしたら解釈が違うかもしれない。・group size 8でGQAを利用

<br>

・Context Windowは128k

<br>

・学習データの大部分は英語のテキストのみのデータセット

<br>

  ・STEM, Coding, general knowledgeにフォーカス

<br>

  ・https://openai.com/index/gpt-oss-model-card/

<br>



<br>

あとで追記する他Open Weight Modelとのベンチマークスコア比較:

<br>

・https://x.com/gneubig/status/1952795149584482665?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・https://x.com/artificialanlys/status/1952887733803991070?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・https://x.com/terryyuezhuo/status/1952829578130670053?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・https://x.com/artificialanlys/status/1952823565642023044?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

  ・long context

<br>

・https://x.com/thienhn97/status/1953152808334852124?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

  ・Multihop QA解説:

<br>

https://x.com/gm8xx8/status/1952915080229863761?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qlearned attention sinks, MXFP4の解説:

<br>

https://x.com/carrigmat/status/1952779877569978797?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QSink Valueの分析:

<br>

https://x.com/wenhaocha1/status/1952851897414762512?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qgpt-oss の使い方:

<br>

https://note.com/npaka/n/nf39f327c3bde?sub_rt=share_sb9fd064b2-338a-4f8d-953c-67e458658e39Qwen3との深さと広さの比較:

<br>

・2364Phi4と同じtokenizerを使っている？:

<br>

https://x.com/bgdidenko/status/1952829980389343387?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qpost-training / pre-trainingの詳細はモデルカード中に言及なし:

<br>

・https://x.com/teortaxestex/status/1952806676492689652?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・https://x.com/okoge_kaz/status/1952787196253265955?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qattention headsのsoftmaxの分母にlearnableなパラメータが導入されている:

<br>

https://x.com/okoge_kaz/status/1952785895352041784?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

・1866

<br>



<br>

で得られている知見と同様に、long contextになった場合にsoftmaxの値が平坦になる問題に対して、learnableなパラメータを導入してスケーリングすることで対処しているのだと考えられる。使ってみた所感:

<br>

・https://x.com/imai_eruel/status/1952825403263046073?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・https://x.com/wenhuchen/status/1953100554793828406?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>

・https://x.com/jasondeanlee/status/1953031988635451556?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qライセンスに関して:

<br>



<br>

&gt; Apache 2.0 ライセンスおよび当社の gpt-oss 利用規約に基づくことで利用可能です。

<br>



<br>

引用元: https://openai.com/ja-JP/index/gpt-oss-model-card/

<br>



<br>

gpt-oss利用規約: https://github.com/openai/gpt-oss/blob/main/USAGE_POLICYcookbook全体:https://cookbook.openai.com/topic/gpt-ossgpt-oss-120bをpythonとvLLMで触りながら理解する:https://tech-blog.abeja.asia/entry/gpt-oss-vllm</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/LLMServing.html">#LLMServing</a>
<span class="issue_date">Issue Date: 2025-08-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2349">LMCache, LMCache, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/akshay_pachaar/status/1951626977213059406?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QKV Cacheを色々なところにキャッシュしておいて、prefixだけでなく全てのreused可能なものをキャッシュすることで、TTFTとスループットを大幅に向上するらしい。特にlong contextなタスクで力を発揮し、vLLMと組み合わせると下記のようなパフォーマンス向上結果

<br>

<img src="https://github.com/user-attachments/assets/d40301c3-f7a9-4f2a-a66e-65c3357ce2b9" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-08-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2342">XBai-o4, MetaStoneAI, 2025.08</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/kimmonismus/status/1951622895727427697?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLiveCodeBenchでo3-mini-2015-01-31(medium)と同等らしい</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ITI%20(Inference%20Time%20Intervention).html">#ITI (Inference Time Intervention)</a>
<a class="button" href="articles/Personality.html">#Personality</a>
<span class="issue_date">Issue Date: 2025-08-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2336">Persona vectors: Monitoring and controlling character traits in language models, Anthropic, 2025.08</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/anthropicai/status/1951317898313466361?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QFull Paper: https://arxiv.org/abs/2507.21509ITIでよく使われる手法を用いてLLMのpersonalityに関するsteeringベクトルを抽出して適用する（evil, sycophancy, hallucination)。このベクトルは、学習中の監視やペルソナシフトの是正、特定の不都合なペルソナを生じさせる要因となる学習データの同定などの応用が期待される。

<br>



<br>

<img src="https://github.com/user-attachments/assets/7caaec0d-7bbe-4364-b0d3-831f9aad66ab" alt="image" loading="lazy">

<br>



<br>

ITIでsteeringを実施するとMMLUのような一般的なタスクの能力が劣化するのに対し、学習中にsteeringを実施しながら学習するとタスク遂行能力の低下なしにシフトが生じるのを抑制することが可能な模様。

<br>

<img src="https://github.com/user-attachments/assets/dd553a30-9f5c-40ac-b894-8c6b77ade0c1" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<span class="issue_date">Issue Date: 2025-08-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2333">Qwen3-Coder-30B-A3B-Instruct, QwenTeam, 2025.08</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/alibaba_qwen/status/1950925444057792808?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q<img src="https://github.com/user-attachments/assets/d2c30b64-10df-40b2-bcac-f029bdc9f1f1" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<span class="issue_date">Issue Date: 2025-08-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2331">Seed Diffusion: A Large-Scale Diffusion Language Model with High-Speed Inference, ByteDance Seed,</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jiqizhixin/status/1951092714164101590?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q<img src="https://github.com/user-attachments/assets/b7ba3b05-760d-4820-b685-0058706286ff" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-07-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2327">大規模言語モデルPLaMo 2シリーズの事後学習, PFN, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/nzw0301/status/1950775897407238232?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2025-07-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2324">Bits per Character （BPC） によるLLM性能予測, Kazuki Fujii （PFN）, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/okoge_kaz/status/1950427243437809817?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-07-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2323">Qwen3-30B-A3B-Thinking-2507, Qwen Team, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/alibaba_qwen/status/1950570969036361799?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qmediumサイズのモデルがさらに性能向上

<br>

<img src="https://github.com/user-attachments/assets/efa05914-502a-4581-b307-a3e2960c4937" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-07-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2318">GLM-4.5: Reasoning, Coding, and Agentic Abililties, Zhipu AI Inc., 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/scaling01/status/1949825490488795275?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QHF:https://huggingface.co/collections/zai-org/glm-45-687c621d34bda8c9e4bf503b詳細なまとめ:https://x.com/gm8xx8/status/1949879437547241752?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・2128こちらでもMuon Optimizerが使われており、アーキテクチャ的にはGQAやMulti Token Prediction, QK Normalization, MoE, 広さよりも深さを重視の構造、みたいな感じな模様？

<br>

・2202</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/VideoGeneration/Understandings.html">#VideoGeneration/Understandings</a>
<span class="issue_date">Issue Date: 2025-07-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2312">Wan2.2, Alibaba Wan, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/alibaba_wan/status/1949827662416937443?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q初のMoEによるOpen WeightなVideo generationモデルで、直接的に明るさや、カラー、カメラの動きなどを制御でき、text to video, image to video, unified video generationをサポートしている模様</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2025-07-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2305">9 new policy optimization techniques, Kseniase, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/theturingpost/status/1949427270247911846?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-07-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2301">Qwen3-235B-A22B-Thinking-2507, QwenTeam, 2025.07</a>
<span class="snippet"><span>Comment</span>とうとうベンチマーク上はo4-miniと同等に...

<br>

<img src="https://github.com/user-attachments/assets/b0891953-afe3-4ee4-92a5-abb0f7fcb4cc" alt="image" loading="lazy">関連:

<br>

・2270</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Document.html">#Document</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/parser.html">#parser</a>
<a class="button" href="articles/VisionLanguageModel.html">#VisionLanguageModel</a>
<span class="issue_date">Issue Date: 2025-07-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2294">LLM APIs Are Not Complete Document Parsers, Jerry Liu, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jerryjliu0/status/1948475176062255504?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<span class="issue_date">Issue Date: 2025-07-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2293">anycoder, akhaliq, 2025.07</a>
<span class="snippet"><span>Comment</span>こんなことができる模様。サイトのリニューアルに使ってみようかしら、、、

<br>

https://x.com/sivil_taram/status/1948030614076342632?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMServing.html">#LLMServing</a>
<span class="issue_date">Issue Date: 2025-07-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2291">Speculative Decoding：Faster Inference Without Paying for More GPU, ELYZA, 2025.07</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<a class="button" href="articles/Attack.html">#Attack</a>
<span class="issue_date">Issue Date: 2025-07-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2278">プロンプトインジェクション2.0 : 進化する防御機構とその回避手法, yuasa, 2025.07</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<span class="issue_date">Issue Date: 2025-07-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2277">Qwen Code, Qwen Team, 2025.07</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMServing.html">#LLMServing</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2273">LLM Servingを支える技術, Kotoba Technologies, 2025.07</a>
<span class="snippet"><span>Comment</span>こちらも参照のこと:

<br>

・2263</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2270">Qwen3-235B-A22B-Instruct-2507, QwenTeam, 2025.07</a>
<span class="snippet"><span>Comment</span>Qwen3最新版。ベンチマーク画像は元ポストより引用。hybrid thinkingを廃止し、non-thinkingのみとした。non-thinkingだが性能が向上し、context長が256k （前回の2倍）になっている模様。

<br>



<br>

<img src="https://github.com/user-attachments/assets/087412bd-cf0f-4bac-a93b-867176fa5aad" alt="image" loading="lazy">

<br>

元ポスト:https://x.com/alibaba_qwen/status/1947344511988076547?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・1909・2226

<br>



<br>

において、Qwen2.5-math-7B, Qwen2.5-7Bに対して、Math500, AMC,

<br>

 AIME2024データについてコンタミネーションの可能性が指摘されている点には留意したい。・2195

<br>



<br>

ポストのベンチ上ではKimi-K2を超えているように見えるが、果たして…？</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/LLMServing.html">#LLMServing</a>
<span class="issue_date">Issue Date: 2025-07-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2265">LMDeploy, OpenMMLab, 2023.07</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Metrics.html">#Metrics</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMServing.html">#LLMServing</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<a class="button" href="articles/Parallelism.html">#Parallelism</a>
<a class="button" href="articles/Inference.html">#Inference</a>
<a class="button" href="articles/Batch.html">#Batch</a>
<span class="issue_date">Issue Date: 2025-07-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2263">LLM推論に関する技術メモ, iwashi.co, 2025.07</a>
<span class="snippet"><span>Comment</span>```

<br>

メモリ (GB) = P × (Q ÷ 8) × (1 + オーバーヘッド)

<br>



<br>

・P：パラメータ数（単位は10億）

<br>

・Q：ビット精度（例：16、32）、8で割ることでビットをバイトに変換

<br>

・オーバーヘッド（％）：推論中の追加メモリまたは一時的な使用量（例：KVキャッシュ、アクティベーションバッファ、オプティマイザの状態）

<br>

```

<br>



<br>

↑これ、忘れがちなのでメモ…関連（量子化関連研究）:

<br>

・2264

<br>

・1570

<br>

・1043すごいメモだ…勉強になります</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Distillation.html">#Distillation</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/OpenSource.html">#OpenSource</a>
<span class="issue_date">Issue Date: 2025-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2255">OpenReasoning-Nemotron: A Family of State-of-the-Art Distilled Reasoning Models, Nvidia, 2025.07</a>
<span class="snippet"><span>Comment</span>DeepSeek-R1-0528から応答を合成したデータでSFTのみを実施し、32BでQwe3-235B-A22Bと同等か上回る性能。アーキテクチャはQwen2.5。データはOpenCode/Math/Scienceを利用。

<br>

<img src="https://github.com/user-attachments/assets/8dda86f4-df71-4732-8d51-5905672fa5c9" alt="image" loading="lazy">元ポスト:https://x.com/igtmn/status/1946291288170725617?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

データも公開予定</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/MachineTranslation.html">#MachineTranslation</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SmallModel.html">#SmallModel</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-07-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2252">Seed-X-Instruct-7B, ByteDance-Seed, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/teortaxestex/status/1946056084709359653?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QMTに特化したMultilingual SLM。7Bモデルだがベンチマーク上では他の大規模なモデルと同等以上。テクニカルレポート: https://github.com/ByteDance-Seed/Seed-X-7B/blob/main/Technical_Report.pdf</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2025-07-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2243">Asymmetry of verification and verifier’s law, Jason Wei, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_jasonwei/status/1945287045251052007?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Video.html">#Video</a>
<a class="button" href="articles/SemanticID.html">#SemanticID</a>
<span class="issue_date">Issue Date: 2025-07-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2242">LLM Recommendation Systems: AI Engineer World's Fair 2025, AI Engineer, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/kazunori_279/status/1945644623474692103?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QセマンティックIDの実用例</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-07-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2228">論文では語られないLLM開発において重要なこと Swallow Projectを通して, Kazuki Fujii, NLPコロキウム, 2025.07</a>
<span class="snippet"><span>Comment</span>独自LLM開発の私の想像など遥かに超える非常に困難な側面が記述されており、これをできるのはあまりにもすごいという感想を抱いた（小並感だけど本当にすごいと思う。すごいとしか言いようがない）</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/Optimizer.html">#Optimizer</a>
<a class="button" href="articles/Decoder.html">#Decoder</a>
<span class="issue_date">Issue Date: 2025-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2223">Modded-NanoGPT, KellerJordan, 2024.05</a>
<span class="snippet"><span>Comment</span>NanoGPT speedrun関連:

<br>

・2118

<br>

・2208</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Optimizer.html">#Optimizer</a>
<span class="issue_date">Issue Date: 2025-07-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2208">きみはNanoGPT speedrunを知っているか？, PredNext, 2025.07</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<a class="button" href="articles/MCP.html">#MCP</a>
<span class="issue_date">Issue Date: 2025-07-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2204">advanced-mcp-features, epicweb-dev, 2025.06</a>
<span class="snippet"><span>Comment</span>MCPの勉強に良いかもしれないのでメモ</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Optimizer.html">#Optimizer</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<a class="button" href="articles/Stability.html">#Stability</a>
<span class="issue_date">Issue Date: 2025-07-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2195">Kimi K2: Open Agentic Intelligence, moonshotai, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/kimi_moonshot/status/1943687594560332025?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q1T-A32Bのモデル。さすがに高性能。

<br>



<br>

<img src="https://github.com/user-attachments/assets/39b524d3-6e22-456d-8d61-fcd22519d58d" alt="image" loading="lazy">

<br>



<br>

（追記） Reasoningモデルではないのにこの性能のようである。1T-A32Bのモデルを15.5Tトークン訓練するのに一度もtraining instabilityがなかったらしい

<br>

元ポスト:https://x.com/eliebakouch/status/1943689105721667885?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・2188量子化したモデルが出た模様:

<br>

https://x.com/ivanfioravanti/status/1944069021709615119?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

仕事早すぎるDeepSeek V3/R1とのアーキテクチャの違い:

<br>

https://x.com/rasbt/status/1944056316424577525?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

MLAのヘッドの数が減り、エキスパートの数を増加させている解説ポスト:https://x.com/hillbig/status/1944902706747072678?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q利用されているOptimizer:

<br>

・22022つほどバグがあり修正された模様:

<br>

https://x.com/kimi_moonshot/status/1945050874067476962?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qchatbot arenaでOpenLLMの中でトップのスコア

<br>

元ポスト:https://x.com/lmarena_ai/status/1945866381880373490?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qテクニカルペーパーが公開:https://github.com/MoonshotAI/Kimi-K2/blob/main/tech_report.pdf

<br>



<br>

元ポスト:https://x.com/iscienceluvr/status/1947384629314396302?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qテクニカルレポートまとめ:https://x.com/scaling01/status/1947400424622866793?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q以下のような技術が使われている模様

<br>

・1937

<br>

・MLA 1621

<br>

・MuonCip

<br>

・MuonOptimizer 2202 

<br>

・QK-Clip

<br>

  ・参考（こちらはLayerNormを使っているが）: 1202

<br>

・RLVR

<br>

  ・1719 

<br>

・Self-Critique

<br>

  ・関連: 2274

<br>

  ・2017 

<br>

・Temperature Decay  

<br>

  ・最初はTemperatureを高めにした探索多めに、後半はTemperatureを低めにして効用多めになるようにスケジューリング

<br>

・Tool useのためのSynthetic Data

<br>



<br>

<img width="1058" height="336" alt="Image" src="https://github.com/user-attachments/assets/74eacdb2-8f64-4d53-b2d0-66df770f2e8b">Reward Hackingに対処するため、RLVRではなくpairwise comparisonに基づくself judging w/ critique を利用きており、これが非常に効果的な可能性があるのでは、という意見がある:

<br>

https://x.com/grad62304977/status/1953408751521632401?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Tokenizer.html">#Tokenizer</a>
<span class="issue_date">Issue Date: 2025-07-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2193">H-Nets - the Past, Goomba Lab, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/sukjun_hwang/status/1943703574908723674?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qtokenizerも含めてデータに対して最適なinputの粒度を学習公式ポスト(?):https://x.com/cartesia_ai/status/1943705750381207880?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・1634

<br>

・2073

<br>



<br>

ByteLatentTransformerなどとはどう違うのだろうか？解説ポスト:https://x.com/hillbig/status/1944542938723475869?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/SmallModel.html">#SmallModel</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/OpenSource.html">#OpenSource</a>
<span class="issue_date">Issue Date: 2025-07-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2164">SmolLM3: smol, multilingual, long-context reasoner, HuggingFace, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/thom_wolf/status/1942670704278732978?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QSmolLM3を構築する際の詳細なレシピ(アーキテクチャ、データ、data mixture, 3 stageのpretraining(web, code, mathの割合と品質をステージごとに変え、stable-&gt;stable-&gt;decayで学習), midtraining(long context-&gt;reasoning, post training(sft-&gt;rl), ハイブリッドreasoningモデルの作り方、評価など)が説明されている学習/評価スクリプトなどがリリース:

<br>

https://x.com/_lewtun/status/1950209751066742982?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<a class="button" href="articles/ContextEngineering.html">#ContextEngineering</a>
<span class="issue_date">Issue Date: 2025-07-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2138">Context Engineering - What it is, and techniques to consider, llamaindex, 2025.07</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/llama_index/status/1940810514227196236?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<a class="button" href="articles/ContextEngineering.html">#ContextEngineering</a>
<span class="issue_date">Issue Date: 2025-07-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2135">The New Skill in AI is Not Prompting, It's Context Engineering, PHLSCHMID, 2025.06</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/akiratosei/status/1940960253233058198?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<span class="issue_date">Issue Date: 2025-06-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2115">ERNIE 4.5 Series, ERNIE TEAM, 2025.06</a>
<span class="snippet"><span>Comment</span>Tech Report:https://yiyan.baidu.com/blog/publication/ERNIE_Technical_Report.pdf元ポスト:https://x.com/paddlepaddle/status/1939535276197744952?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説ポスト:https://x.com/gm8xx8/status/1939576393098023188?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-06-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2108">Hunyuan-A13B-Instruct, tencent, 2025.06</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/arankomatsuzaki/status/1938515928221995066?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q・MoEアーキテクチャ, 80B-A13B

<br>

・fast, slow thinking mode

<br>

・256k context window

<br>

・agenticタスクに特に特化

<br>

・Grouped Query Attention, 複数の量子化フォーマットをサポート公式ポスト:https://x.com/tencenthunyuan/status/1938525874904801490?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q画像は公式ポストより引用。Qwen3-235B-A22Bよりも少ないパラメータ数で、同等（agenticタスクはそれ以上）なようにベンチマーク上は見えるが、果たして。

<br>



<br>

<img src="https://github.com/user-attachments/assets/ed47bae2-9017-4cf2-b1e1-50e863da1c77" alt="image" loading="lazy">果たして日本語の性能はどうだろうか。

<br>

TENCENT HUNYUAN COMMUNITY LICENSE

<br>

https://github.com/Tencent-Hunyuan/Hunyuan-A13B/blob/main/LICENSE</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2097">Swallow LLM Leaderboard, Swallow LLM Team</a>
<span class="snippet"><span>Comment</span>関連:

<br>

・1096

<br>

・1055</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2095">Nemo-RL, Nvidia, 2025.05</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2092">LLM-jp-3.1 シリーズ instruct4 の公開, LLM-jp, 2025.05</a>
<span class="snippet"><span>Comment</span>関連

<br>

・2089

<br>

・2090

<br>

・2091</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RLHF.html">#RLHF</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Verification.html">#Verification</a>
<span class="issue_date">Issue Date: 2025-06-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2078">人間を騙してサボるAIたち, joisino, 2025.06</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-06-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2075">Kimi-VL-A3B-Thinking-2506, moonshotai, 2025.06</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/reach_vb/status/1937159672932286950?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q様々なベンチマークでSoTA(gpt4o, Qwen2.5-VL-7B)を達成したReasoning VLMテクニカルペーパー:

<br>

・2200</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/LLMServing.html">#LLMServing</a>
<span class="issue_date">Issue Date: 2025-06-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2069">Nano-vLLM, GeeeekExplorer, 2025.06</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/marktechpost/status/1936689592507543643?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QvLLMと同等のinference speedを実現するミニマムでクリーンな実装。勉強用に良さそう。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-06-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2066">POLARIS: A Post-Training Recipe for Scaling Reinforcement Learning on Advanced Reasoning Models,</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_akhaliq/status/1936233712510718361?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QPJで利用されているRLライブラリ:

<br>

・1969AIME2025のみの評価だが4Bでこの性能…？

<br>

<img src="https://github.com/user-attachments/assets/02d1ece1-b12f-4877-b500-ff910e45ff00" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-06-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2057">[Paper Note] Gemini 2.5: Pushing the Frontier with Advanced Reasoning, Multimodality, Long Context, and Next Generation Agentic Capabilities, Gemini Team, 2025.06</a>
<span class="snippet"><span>Comment</span>関連ポスト:

<br>

https://x.com/jaguring1/status/1935203032922485080?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説ポスト:https://x.com/_philschmid/status/1935019697683980603?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連ポスト:https://x.com/hillbig/status/1935841560736022708?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<span class="issue_date">Issue Date: 2025-06-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2043">MiniMax-M1, MiniMax, 2025.06</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/arankomatsuzaki/status/1934642204397744137?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qベンチマーク

<br>

<img src="https://github.com/user-attachments/assets/e22d5130-3646-46f0-a9ce-6c87759ab123" alt="image" loading="lazy">vLLMでのservingが推奨されており、コンテキストは1M、456BのMoEアーキテクチャでactivation weightは46B公式ポスト:https://x.com/minimax__ai/status/1934637031193514237?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QAgentもリリースした模様:

<br>

https://x.com/minimax__ai/status/1945550814728376803?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Zero/FewShotLearning.html">#Zero/FewShotLearning</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-06-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2042">[Paper Note] Language Models are Unsupervised Multitask Learners, Radford+, OpenAI, 2019</a>
<span class="snippet"><span>Comment</span>今更ながら、GPT-2論文をメモってなかったので追加。

<br>



<br>

従来のモデルは特定のタスクを解くためにタスクごとに個別のモデルをFinetuningする必要があったが、大規模なWebTextデータ（Redditにおいて最低3つのupvoteを得たポストの外部リンクを収集）によって言語モデルを訓練し、モデルサイズをスケーリングさせることで、様々なタスクで高い性能を獲得でき、Zero-Shot task transfer, p(output | input, task) , が実現できるよ、という話。

<br>



<br>

今ざっくり見返すと、Next Token Predictionという用語は論文中に出てきておらず、かつ "Language Modeling" という用語のみで具体的なlossは記述されておらず（当時はRNN言語モデルで広く学習方法が知られていたからだろうか？）、かつソースコードも学習のコードは提供されておらず、lossの定義も含まれていないように見える。

<br>



<br>

ソースコードのモデル定義:

<br>

https://github.com/openai/gpt-2/blob/master/src/model.pyL169</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Unsupervised.html">#Unsupervised</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<span class="issue_date">Issue Date: 2025-06-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2029">[Paper Note] Unsupervised Elicitation of Language Models, Wen+, Anthropic, 2025.06</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/jiaxinwen22/status/1932908642858418441?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-06-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2020">Qwen_Qwen3-Embedding-4B-GGUF, QwenTeam, 2025.06</a>
<span class="snippet"><span>Comment</span>8BモデルはMTEBでトップの性能を達成。context 32K。100以上の言語をサポート。32--2560次元にoutputの次元数をカスタマイズできる（嬉しい、が性能にどの程度影響が出るから気になる）。元ポスト:https://x.com/huggingpapers/status/1930739968332157018?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QQwenTeam post:https://x.com/alibaba_qwen/status/1930648422778118246?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/In-ContextLearning.html">#In-ContextLearning</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<a class="button" href="articles/SSM%20(StateSpaceModel).html">#SSM (StateSpaceModel)</a>
<a class="button" href="articles/Scaling%20Laws.html">#Scaling Laws</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-05-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/2001">2025年度人工知能学会全国大会チュートリアル講演「深層基盤モデルの数理」, Taiji Suzuki, 2025.05</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/btreetaiji/status/1927678122817921442?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SmallModel.html">#SmallModel</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<span class="issue_date">Issue Date: 2025-05-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1998">SSII2025 [OS1-03] PFNにおけるSmall Language Modelの開発, 鈴木 脩司, 画像センシングシンポジウム, 2025.05</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_stakaya/status/1927588359217844702?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連

<br>

・1827

<br>

・1828

<br>

・1999

<br>

・766先行研究を元に仮説を立てて、有望なアプローチを取る意思決定が非常に勉強になる。

<br>

Scaling Lawsが不確実性のある意思決定において非常に有用な知見となっている。同じようにPruningとKnowledge Distilationを実施した事例として下記が挙げられる

<br>

・1873</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<a class="button" href="articles/SmallModel.html">#SmallModel</a>
<a class="button" href="articles/RLVR.html">#RLVR</a>
<span class="issue_date">Issue Date: 2025-05-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1997">Spurious Rewards: Rethinking Training Signals in RLVR, Shao+, 2025.05</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/stellalisy/status/1927392717593526780?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q参考（考察）: https://x.com/weiliu99/status/1930826904522875309?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q参考（考察）:

<br>

https://x.com/g_k_swamy/status/1945159211752562739?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

こちらでもQwen2.5 MATH 7b を用いて検証しているが、コンタミネーションの問題が仮に本当だとしたら、どう影響するだろうか。スレッド中のグラフもMATH500（Qwen2.5においてコンタミの可能性がある）の性能を示している。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<span class="issue_date">Issue Date: 2025-05-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1987">【DL輪読会】 Block Diffusion: Interpolating Between Autoregressive and Diffusion Language Models, Deep Learning JP, 2025.05</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/kym384/status/1925852937835737569?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q1986 でLiteratureをざっくり把握してからこちらを読むのが良さそう。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<span class="issue_date">Issue Date: 2025-05-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1986">Masked Diffusion Modelの進展, Deep Learning JP, 2025.03</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/kym384/status/1925852884656099572?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qスライド中のARのようにKV Cacheが使えない問題に対処した研究が

<br>

・1984

<br>



<br>

この辺はdLLMが有望であれば、どんどん進化していくのだろう。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/AWS.html">#AWS</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2025-05-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1976">Webスケールの日本語-画像のインターリーブデータセット「MOMIJI」の構築 _巨大テキストデータをAWSで高速に処理するパイプライン, Turing （studio_graph）, 2025.05</a>
<span class="snippet"><span>Comment</span>貴重なVLMデータセット構築ノウハウ青塗りのフィルタリングタスクを具体的にどうやっているのか気になる</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Coding.html">#Coding</a>
<span class="issue_date">Issue Date: 2025-05-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1972">OpenAI-Codex, OpenAI, 2025.05</a>
<span class="snippet"><span>Comment</span>OpenHandsのNeubig氏が、OpenAIのブログポスト中で報告されているSWE-Bench Verifiedのスコアについて、言及している。OpenAIは23個サンプルについて(internal infrastructureで動作させられないため)除外しているので、その分スコアに下駄が履かれているようで、ブログ中のpassNのスコアを他のリーダーボードのスコアと比較する際には注意が必要っぽい。

<br>

https://x.com/gneubig/status/1923893277519962287?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/ScientificDiscovery.html">#ScientificDiscovery</a>
<a class="button" href="articles/Coding.html">#Coding</a>
<span class="issue_date">Issue Date: 2025-05-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1971">AlphaEvolve: A coding agent for scientific and algorithmic discovery, Novikov+, Google DeepMind, 2025.05</a>
<span class="snippet"><span>Comment</span>blog post:https://deepmind.google/discover/blog/alphaevolve-a-gemini-powered-coding-agent-for-designing-advanced-algorithms/</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<span class="issue_date">Issue Date: 2025-05-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1969">verl: Volcano Engine Reinforcement Learning for LLMs, ByteDance Seed Team, 2025.04</a>
<span class="snippet"><span>Comment</span>SoTAなRLアルゴリズムを数行のコードで実装可能で、Sequence Parallelismがサポートされているので長い系列を扱える。FSDP, Megatron-LM,vLLM,SGLangなどとシームレスに統合できるっぽい？注意点（超重要）:

<br>

https://x.com/fengyao1909/status/1953882575241723911?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

inference backendとtrainingのbackendのミスマッチによってトークンの生起確率に差が生じ、ポリシーの更新がうまくいかなくなる。

<br>



<br>

<img src="https://github.com/user-attachments/assets/92ab33c6-d943-4101-9f73-250c697af816" alt="image" loading="lazy">

<br>



<br>

・2228

<br>



<br>

でも言われているように、ライブラリにはバグがあるのが普通なのね、、、。

<br>



<br>

<img src="https://github.com/user-attachments/assets/6e70b642-27d4-4ab9-bbc0-7e0cb082ff69" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-05-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1953">Stanford Alpaca: An Instruction-following LLaMA Model, Taori +, 2023.03</a>
<span class="snippet"><span>Comment</span>今更ながらメモに追加。アカデミアにおけるOpenLLMに対するInstruction Tuningの先駆け的研究。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/SmallModel.html">#SmallModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<span class="issue_date">Issue Date: 2025-05-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1921">Phi-4-reasoning Technical Report, 2025.04</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dimitrispapail/status/1917731614899028190?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qこちらの解説が非常によくまとまっている:

<br>

https://x.com/_philschmid/status/1918216082231320632?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

が、元ポストでもテクニカルペーパー中でもo3-miniのreasoning traceをSFTに利用してCoTの能力を強化した旨が記述されているが、これはOpenAIの利用規約に違反しているのでは…？</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/MoE(Mixture-of-Experts).html">#MoE(Mixture-of-Experts)</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-04-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1909">Qwen3, Qwen Team, 2025.04</a>
<span class="snippet"><span>Comment</span>・119言語をサポート

<br>

・MoEモデル 1911

<br>

    ・30B-A3B / 235B-A22N

<br>

    ・128K context window

<br>

    ・Qwen2.5はMoEを採用していないので新たなアーキテクチャとなる

<br>

・Denseモデル（非MoEモデル）も公開

<br>

    ・0.6B -・32B

<br>

    ・32K -・128K context window

<br>

・Thinking/Non-thinking の切り替えが切り替えが可能

<br>

    ・スイッチは自動的に実施されるが、ユーザが明示的に `/think`, `/no_think` を user_promptの末尾に追加することで制御することも可能

<br>

・Pre-training

<br>

    ・データ

<br>

        ・36 trillion tokensによって学習（Qwen-2.5の2倍）

<br>

        ・学習データではwebデータに加えて、PDF-likeな文書群からQwen2.5-VL 1835 によってテキストを抽出し、Qwen2.5 で抽出された内容の品質を改善し利用

<br>

        ・また、math / code に関するデータを追加するために、Qwen2.5-Math / Qwen2.5-Coderを用いて合成データを作成（textbooks / QA pairs / code snippets 766 ）

<br>

    ・事前学習のステップ

<br>

        ・S1: context長が4kの30 trillion tokenで事前学習

<br>

        ・S2: STEM / coding / reasoning task などのknowledge-intensiveデータの比率を増やして継続事前学習 (これがおそらく 5 trillion token程度？)

<br>

        ・Final Stage: context長を32kに拡大し高品質なlong-context dataで継続事前学習

<br>

    ・これによりBaseモデルが完成し、Qwen3-235B全体のうち10%程度のActive Parameterの利用するだけで（i.e., 22Bで）、Qwen2.5-72B Baseと同等以上の性能達成

<br>

・Post-training

<br>

    ・S1: long-CoT cold start

<br>

        ・数学/coding/logical reasoning/STEMなどの多様なlong CoTデータを用いてSFT 1749 

<br>

    ・S2: reasoning-based RL

<br>

        ・rule-based (verifiable) rewards によるRL 1719 

<br>

        ・S1/S2の流れは 1746 に有効性が示されている通り、long CoT DataによるSFT -&gt; RLを実施

<br>

    ・S3: thinking mode fusion

<br>

        ・S2データを用いてlong CoTデータとinstruction tuningデータ（非Long CoT）を生成し、Thinking/Non-thinkingを自動的に選択し生成するように学習（SFT or RLは記述なし）

<br>

    ・S4: general RL

<br>

        ・20以上の一般的なドメインのタスクを通じて一般的な能力の向上と、safetyに関するalignmentの実施（e.g., instruction following, format following, agent能力など）BestPracticeに関するポスト:https://x.com/ivanfioravanti/status/1916934241281061156?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説:https://x.com/hillbig/status/1917712050983428400?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2025-04-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1907">Improving Recommendation Systems &amp; Search in the Age of LLMs, eugeneyan, 2025.04</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2025-04-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1903">Deepwiki, Cognition, 2025.04</a>
<span class="snippet"><span>Comment</span>githubリポジトリに関するリッチなドキュメントに対してDevinを通じて対話的に質問ができる模様。サインアップ不要で、githubリポジトリのドメインをdeepwikiに変えるだけで利用可能</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-04-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1886">Seed-Thinking-v1.5, ByteDance, 2025.04</a>
<span class="snippet"><span>Comment</span>DeepSeek-R1を多くのベンチで上回る200B, 20B activated paramのreasoning model最近のテキストのOpenWeightLLMはAlibaba, DeepSeek, ByteDance, Nvidiaの4強という感じかな…？（そのうちOpenAIがオープンにするReasoning Modelも入ってきそう）。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<span class="issue_date">Issue Date: 2025-04-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1880">Large Vision Language Model （LVLM） に関する最新知見まとめ （Part 1）, Daiki Shiono, 2024.11</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<span class="issue_date">Issue Date: 2025-04-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1877">Fiction.liveBench, 2025.04</a>
<span class="snippet"><span>Comment</span>long contextではGemini-2.5-proの圧勝</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/API.html">#API</a>
<span class="issue_date">Issue Date: 2025-04-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1875">BFCLv2, UC Berkeley, 2024.08</a>
<span class="snippet"><span>Comment</span>LLMのTool Useを評価するための現在のデファクトスタンダードとなるベンチマーク</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/Pruning.html">#Pruning</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-04-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1873">Llama-3_1-Nemotron-Ultra-253B-v1, Nvidia, 2025.04</a>
<span class="snippet"><span>Comment</span>DeepSeek-R1をGPQA Diamond 1155, AIME2024/2025, Llama4 Maverickを

<br>

BFCLv2（Tool Calling, 1875), IFEVal 1137 で上回り, そのほかはArenaHardを除きDeepSeekR1と同等

<br>

<img src="https://github.com/user-attachments/assets/b0de99ee-f4ec-4b03-8b0b-8939b4f1e23b" alt="image" loading="lazy">

<br>



<br>

DeepSeekR1が671B（MoEで37B Activation Param）に対し、こちらは253B（ただし、Llama3.1がベースなのでMoEではない）で同等以上の性能となっている。

<br>

ReasoningをON/OFFする能力も備わっている。

<br>



<br>

モデルがどのように訓練されたかを示す全体図がとても興味深い:<img src="https://github.com/user-attachments/assets/9a014777-61d8-46ae-818b-ace9ed5c002d" alt="image" loading="lazy">

<br>



<br>

特に 1746 でも有効性が示されているように、SFTをしてからReasoningを強化する（強化というより元々持っている能力を引き出す？）RLを実施している。

<br>



<br>

詳細は下記Blogとのこと:

<br>

https://developer.nvidia.com/blog/build-enterprise-ai-agents-with-advanced-open-nvidia-llama-nemotron-reasoning-models/元ポスト:https://x.com/kuchaev/status/1909444566379573646?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-04-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1872">Dream-v0-Instruct-7B, Dream-org, 2025.04</a>
<span class="snippet"><span>Comment</span>OpenWeightな拡散言語モデル元ポスト:https://x.com/curveweb/status/1909551257725133132?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q関連:

<br>

・1776</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-04-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1863">Llama 4 Series, Meta, 2025.04</a>
<span class="snippet"><span>Comment</span>Downloads:https://www.llama.com/?utm_source=twitter&utm_medium=organic_social&utm_content=image&utm_campaign=llama4Huggingface:

<br>

https://huggingface.co/collections/meta-llama/llama-4-67f0c30d9fe03840bc9d0164解説ポスト:https://x.com/iscienceluvr/status/1908601269004230763?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QArtificial Analysisによる性能検証:https://x.com/artificialanlys/status/1908890796415414430?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

MaverickがGPT4oと同等、ScoutがGPT4o-miniと同等

<br>



<br>

Update:https://x.com/artificialanlys/status/1909624239747182989?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q性能に関して不可解な点が多そうなので様子見をしても良いかも。性能検証（Math-Perturb):https://x.com/kaixuanhuang1/status/1909387970773234088?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q日本語にあまり強くないという情報も

<br>

元ポスト:https://x.com/gosrum/status/1909626761098494060?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QどうやらvLLMのLlama4のinferenceにバグがあったやうで、vLLMのIssue 16311にて、Llama4のinferenceに関するバグが修正され、性能が向上した模様。どのベンチを信じたら良いかまるでわからん。2025.0413現在のchatbot arenaのランクは、32位となり（chatbot arena向けにtuningされていたであろうモデルは2位だった）GPT-4oが29位であることを考慮すると上記のArtificial Intelligenceの評価とも大体一致している。

<br>



<br>

https://lmarena.ai

<br>



<br>

関連ポスト:https://x.com/tunguz/status/1911142310160855541?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/SoftwareEngineering.html">#SoftwareEngineering</a>
<span class="issue_date">Issue Date: 2025-04-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1850">openhands-lm-32b-v0.1, all-hands, 2025.03</a>
<span class="snippet"><span>Comment</span>Qwen Coder 2.5 Instruct 32Bに基づく最先端のSWEタスクが実行可能なモデル</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2025-03-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1844">Recommendation Systems • LLM, vinjia.ai, 2025.03</a>
<span class="snippet"><span>Comment</span>元ポスト:https://www.linkedin.com/posts/vinija_recommendation-systems-llm-activity-7306171374446727168-cUg2?utm_source=share&utm_medium=member_ios&rcm=ACoAACzQvjwB2FeLVE3yukDiUYtr5J4k-6nlNG4</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-03-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1835">Qwen2.5-VL-32B-Instruct, Qwen Team, 2025.03</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/alibaba_qwen/status/1904227859616641534?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2025-03-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1834">言語モデルの物理学, 佐藤竜馬, 2025.03</a>
<span class="snippet"><span>Comment</span>必読</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/SSM%20(StateSpaceModel).html">#SSM (StateSpaceModel)</a>
<span class="issue_date">Issue Date: 2025-03-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1830">Nemotron-H: A Family of Accurate, Efficient Hybrid Mamba-Transformer Models, Nvidia, 2025.03</a>
<span class="snippet"><span>Comment</span>関連:

<br>

・1820TransformerのSelf-attention LayerをMamba2 Layerに置換することで、様々なベンチマークで同等の性能、あるいは上回る性能で3倍程度のInference timeの高速化をしている（65536 input, 1024 output）。

<br>



<br>

56B程度のmediumサイズのモデルと、8B程度の軽量なモデルについて述べられている。特に、8BモデルでMambaとTransformerのハイブリッドモデルと、通常のTransformerモデルを比較している。学習データに15 Trillion Tokenを利用しており、このデータ量でのApple to Appleのアーキテクチャ間の比較は、現状では最も大規模なものとのこと。性能は多くのベンチマークでハイブリッドにしても同等、Commonsense Understandingでは上回っている。

<br>



<br>

また、学習したNemotron-Hをバックボーンモデルとして持つVLMについてもモデルのアーキテクチャが述べられている。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/PositionalEncoding.html">#PositionalEncoding</a>
<span class="issue_date">Issue Date: 2025-03-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1823">8 Types of RoPE, Kseniase, 2025.03</a>
<span class="snippet"><span>Comment</span>元ポスト:https://huggingface.co/posts/Kseniase/498106595218801RoPEについてサーベイが必要になったら見る</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-03-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1822">The "think" tool: Enabling Claude to stop and think in complex tool use situations, Anthropic, 2025.03</a>
<span class="snippet"><span>Comment</span>"考える"ことをツールとして定義し利用することで、externalなthinkingを明示的に実施した上でタスクを遂行させる方法を紹介している</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<a class="button" href="articles/read-later.html">#read-later</a>
<span class="issue_date">Issue Date: 2025-03-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1821">Understanding R1-Zero-Like Training: A Critical Perspective, 2025.03</a>
<span class="snippet"><span>Summary</span>DeepSeek-R1-Zeroは、教師なしファインチューニングなしでLLMの推論能力を向上させる強化学習（RL）の効果を示した。研究では、ベースモデルとRLのコアコンポーネントを分析し、DeepSeek-V3-Baseが「アハ体験」を示すことや、Qwen2.5が強力な推論能力を持つことを発見。さらに、Group Relative Policy Optimization（GRPO）の最適化バイアスを特定し、Dr. GRPOという新手法を導入してトークン効率を改善。これにより、7BベースモデルでAIME 2024において43.3%の精度を達成し、新たな最先端を確立した。</span>
<span class="snippet"><span>Comment</span>関連研究:

<br>

・1815解説ポスト:https://x.com/wenhuchen/status/1903464313391624668?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説ポストを読むと、

<br>



<br>

・DAPOでの　Token Level Policy UpdateのようなLengthに対するバイアスを排除するような操作をしている（Advantageに対して長さの平均をとる）模様。

<br>

・aha moment（self-seflection）はRLによって初めて獲得されたものではなく、ベースモデルの時点で獲得されており、RLはその挙動を増長しているだけ（これはX上ですでにどこかで言及されていたなぁ）。

<br>

・self-reflection無しの方が有りの場合よりもAcc.が高い場合がある（でもぱっと見グラフを見ると右肩上がりの傾向ではある）

<br>



<br>

といった知見がある模様あとで読む（参考）Dr.GRPOを実際にBig-MathとQwen-2.5-7Bに適用したら安定して収束したよというポスト:https://x.com/zzlccc/status/1910902637152940414?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<a class="button" href="articles/SSM%20(StateSpaceModel).html">#SSM (StateSpaceModel)</a>
<span class="issue_date">Issue Date: 2025-03-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1820">Hunyuan T1, Tencent, 2025.03</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/txhunyuan/status/1903121005809373386?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q画像はブログより引用。DeepSeek-R1と比較すると優っているタスクと劣っているタスクがあり、なんとも言えない感。GPT4.5より大幅に上回っているタスク（Math, Reasoning）があるが、そもそもそういったタスクはo1などのreasoningモデルの領域。o1と比較するとこれもまあ優っている部分もあれば劣っている部分もあるという感じ。唯一、ToolUseに関しては一貫してOpenAIモデルの方が強い。

<br>



<br>

ChineseタスクについてはDeepSeek-R1と完全にスコアが一致しているが、評価データのサンプル数が少ないのだろうか？

<br>

<img src="https://github.com/user-attachments/assets/de2325b2-0bd5-4177-a336-e6f008a32d40" alt="image" loading="lazy">reasoningモデルかつ、TransformerとMambaのハイブリッドで、MoEを採用しているとのこと。TransformerとMambaのハイブリッドについて（WenhuChen氏のポスト）:

<br>

https://x.com/wenhuchen/status/1903656455036715311?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

Layer-wise MixingとSequence-wise Mixingの2種類が存在するとのこと。前者はTransformerのSelf-Attenton LayerをMamba Layerに置換したもので、後者はSequenceのLong partをMambaでまずエンコードし、Short PartをTransformerでデコードする際のCross-Attentionのencoder stateとして与える方法とのこと。Self-Attention Layerを削減することでInference時の計算量とメモリを大幅に削減できる（Self-Attentionは全体のKV Cacheに対してAttentionを計算するため）。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-03-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1818">Sudoku-bench, SakanaAI, 2025.03</a>
<span class="snippet"><span>Summary</span>Sudoku-Benchは、CTCで紹介された独自のルールを持つ数独パズルを特徴とし、AI推論モデルの評価に最適なベンチマークです。このリポジトリでは、数独ベンチデータセット、LLM評価用のベースラインコード、SudokuPadツール、推論トレースなどを提供します。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/sakanaailabs/status/1902913196358611278?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q既存モデルでベンチマークを取ったらどういうランキングになるのだろうか。特にまだそういぅたランキングは公開されていない模様。ブログ記事に（将来的に最新の結果をrepositoryに追記す？模様）現時点でのリーダーボードが載っていた。現状、o3-miniがダントツに見える。

<br>

https://sakana.ai/sudoku-bench/</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-03-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1814">Llama Nemotron, Nvidia, 2025.03</a>
<span class="snippet"><span>Comment</span>Nvidiaによる初めてのreasoning model。

<br>

元ポスト:https://x.com/kuchaev/status/1902078122792775771?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QArtificial Analysisにやるベンチマーク:https://x.com/artificialanlys/status/1902386178206429434?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

GPQA Diamond（大学院（Ph.D）レベルの生物学、物理学、化学の450問程度の難解なmultiple choice question）で、DeepSeekV3, GPT4o, QwQ-32Bをoutperform. Claude 3.7 sonnetより少しスコアが低い。

<br>

DeepSeekR1, o1, o3-mini（high）, Claude 3.7 sonnet Thinkingなどには及んでいない。

<br>



<br>

<img src="https://github.com/user-attachments/assets/2d2b3716-83a6-4c56-bca7-f7d8cf981bbb" alt="image" loading="lazy">

<br>



<br>

（画像は元ポストより引用）システムプロンプトを変えることでreasoningをon/offできる模様</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-03-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1810">EXAONE-Deep-32B, LG AI Research, 2025.03</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/ai_for_success/status/1901908168805912602?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QEXAONE AI Model License Agreement 1.1 ・NC

<br>

商用利用不可</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-03-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1809">SmolDocling-256M, IBM Research, 2025.03</a>
<span class="snippet"><span>Comment</span>元ポスト:https://www.linkedin.com/posts/andimarafioti_we-just-dropped-%F0%9D%97%A6%F0%9D%97%BA%F0%9D%97%BC%F0%9D%97%B9%F0%9D%97%97%F0%9D%97%BC%F0%9D%97%B0%F0%9D%97%B9%F0%9D%97%B6%F0%9D%97%BB%F0%9D%97%B4-activity-7307415358427013121-wS8m?utm_source=share&utm_medium=member_ios&rcm=ACoAACzQvjwB2FeLVE3yukDiUYtr5J4k-6nlNG4Apache-2.0ライセンス。言語はEnglishのみな模様マルチモーダルなImage-To-Textモデル。サンプルはこちら

<br>

<img src="https://github.com/user-attachments/assets/d16ce5a9-4336-4daa-ab6f-94d67ae77c41" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<span class="issue_date">Issue Date: 2025-03-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1808">ERNIE4.5_X1, Baidu, 2025.03</a>
<span class="snippet"><span>Comment</span>解説ポスト:https://x.com/ai_for_success/status/1901149459826045223?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q・ERNIE4.5はGPT4.5をさまざまなベンチマークで上回り、価格がなんとGPT4.5の1%

<br>

・X1はマルチモーダルなreasoningモデルでDeepSeek-R1と同等の性能で半額

<br>



<br>

らしいこのモデルは6月30日にオープン（ウェイト？）になるとスレッドで述べられている。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-03-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1807">sarashina2-vision-{8b, 14b}, SB Intuitions, 2025.03</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/sei_shinagawa/status/1901467733331701966?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QVLM。Xに散見される試行例を見ると日本語の読み取り性能は結構高そうに見える。モデル構成、学習の詳細、および評価:https://x.com/sbintuitions/status/1901472307421278604?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLLM（sarashina2）, Vision Encoder（Qwen2-VL）, Projectorの3つで構成されており、3段階の学習を踏んでいる。

<br>

最初のステップでは、キャプションデータを用いてProjectorのみを学習しVision Encoderとテキストを対応づける。続いて、日本語を含む画像や日本特有の風景などをうまく扱えるように、これらを多く活用したデータ（内製日本語OCRデータ、図表キャプションデータ）を用いて、Vision EncoderとProjectorを学習。最後にLLMのAlignmentをとるために、プロジェクターとLLMを前段のデータに加えてVQAデータ（内製合成データを含む）や日本語の指示チューニングデータを用いて学習。ProjectorやMMLLMを具体的にどのように学習するかは

<br>

・1225

<br>



<br>

を参照のこと。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<span class="issue_date">Issue Date: 2025-03-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1803">LLM 開発を支える多様な Fine-Tuning：PFN での取り組み, 中鉢魁三郎, PFN, 2025.03</a>
<span class="snippet"><span>Comment</span>知識の追加の部分で下記研究が引用されている

<br>



<br>

・1371

<br>

・1640</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenSource.html">#OpenSource</a>
<span class="issue_date">Issue Date: 2025-03-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1797">OLMo 2 32B: First fully open model to outperform GPT 3.5 and GPT 4o mini, AllenAI, 20250.3</a>
<span class="snippet"><span>Comment</span>真なる完全なるオープンソース（に近い？）OLMOの最新作</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<span class="issue_date">Issue Date: 2025-03-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1796">AI_Agent_の作り方_近藤憲児, Kenji KONDO, 2025.03</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/x-Use.html">#x-Use</a>
<span class="issue_date">Issue Date: 2025-03-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1794">OpenAI API での Computer use の使い方, npaka, 2025.03</a>
<span class="snippet"><span>Comment</span>OpenAIのCompute Useがどのようなものかコンパクトにまとまっている。勉強になりました。公式:https://platform.openai.com/docs/guides/tools-computer-use</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2025-03-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1793">GAIA, gaia-bemchmark, 2023.11</a>
<span class="snippet"><span>Summary</span>GAIAは一般的なAIアシスタントのためのベンチマークで、推論やマルチモーダル処理などの基本能力を必要とする現実世界の質問を提案します。人間は92％の正答率を達成する一方、GPT-4は15％の正答率にとどまり、このパフォーマンス差はAIの限界を示しています。GAIAは人間にとって難しいタスクをターゲットにし、AGIの出現にはこのような質問に対する堅牢性が必要と考えています。466の質問と回答を作成し、300の質問の回答を公開したリーダーボードを提供しています。</span>
<span class="snippet"><span>Comment</span>paper:https://arxiv.org/abs/2311.12983・1792

<br>



<br>

で言及されているLLM Agentの評価で最も有名なベンチマークな模様・1158

<br>



<br>

見たことあるなと思ったら上記で既にメモっていた</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-03-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1791">Introducing Gemma 3: The most capable model you can run on a single GPU or TPU, Google, 2025.03</a>
<span class="snippet"><span>Comment</span>Googleの新たなSLMで、デバイスやラップトップでも動作可能な軽量モデル。テキストだけでなく画像とShortVideoの認識もできて、140言語をサポート。おまけに27BモデルでLlama3-405BとDeepSeek-V3とo3-miniをChatbotArenaのリーダーボードで上回り、128kのcontext window。えぇ…。モデルの詳細:https://huggingface.co/blog/gemma3

<br>



<br>

1Bモデルは英語のみサポート、マルチモーダル不可など制約がある模様。

<br>

詳細までは書いていないが、128Kコンテキストまでcontext windowを広げる際の概要とRoPE（のような）Positional Embeddingを利用していること、SlideingWindow Attentionを用いておりウィンドウサイズが以前の4096から性能を維持したまま1024に小さくできたこと、ImageEncoderとして何を利用しているか（SigLIP）、896x896の画像サイズをサポートしており、正方形の画像はこのサイズにリサイズされ、正方形でない場合はcropされた上でリサイズされる（pan and scanアルゴリズムと呼ぶらしい）こと、事前学習時のマルチリンガルのデータを2倍にしたことなど、色々書いてある模様。Gemmaライセンス解説ポスト:https://x.com/hillbig/status/1899965039559532585?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q解説ポスト:https://x.com/rasbt/status/1900214135847039316?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-03-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1790">Reasoning with Reka Flash, Reka, 2025.03</a>
<span class="snippet"><span>Comment</span>Weights: https://huggingface.co/RekaAI/reka-flash-3Apache-2.0&lt; /reasoning &gt;を強制的にoutputさせることでreasoningを中断させることができ予算のコントロールが可能とのこと</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<span class="issue_date">Issue Date: 2025-03-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1788">The State of LLM Reasoning Models, Sebastian Raschka, 2025.03</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-03-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1786">QwQ-32B: Embracing the Power of Reinforcement Learning, Qwen Team, 2025.03</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hillbig/status/1897426898642460724?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q・1787Artificial Analysisによるベンチマークスコア:https://x.com/artificialanlys/status/1897701015803380112?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qおそらく特定のタスクでDeepSeekR1とcomparable, 他タスクでは及ばない、という感じになりそうな予感</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2025-03-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1784">smolagents, HuggingFace, 2025.03</a>
<span class="snippet"><span>Summary</span>smolagentsは、数行のコードで強力なエージェントを構築できるライブラリで、シンプルなロジック、コードエージェントのサポート、安全な実行環境、ハブ統合、モデルやモダリティに依存しない設計が特徴。テキスト、視覚、動画、音声入力をサポートし、さまざまなツールと統合可能。詳細はローンチブログ記事を参照。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<span class="issue_date">Issue Date: 2025-03-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1783">GRPO Judge Experiments: Findings &amp; Empirical Observations, kalomaze's kalomazing blog, 2025.03</a>
<span class="snippet"><span>Comment</span>元ポスト:https://www.linkedin.com/posts/philipp-schmid-a6a2bb196_forget-basic-math-problems-grpo-can-do-more-activity-7302608410875691009-nntf?utm_source=share&utm_medium=member_ios&rcm=ACoAACzQvjwB2FeLVE3yukDiUYtr5J4k-6nlNG4一意に解が決まる問題ではなく、ある程度の主観的な判断が必要なタスクについてのGRPOの分析。

<br>

2つのテキストを比較するタスクで、一方のタスクはLLMによって摂動を与えている（おそらく意図的にcorruptさせている）。

<br>



<br>

GRPOではlinearやcosineスケジューラはうまく機能せず、warmupフェーズ有りの小さめの定数が有効らしい。また、max_grad_normを0.2にしまgradient clippingが有効とのこと。他にもrewardの与え方をx^4にすることや、length, xmlフォーマットの場合にボーナスのrewardを与えるなどの工夫を考察している。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-03-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1781">microsoft_Phi-4-multimodal-instruct, Microsoft, 2025.02</a>
<span class="snippet"><span>Comment</span>元ポスト:https://www.linkedin.com/posts/vaibhavs10_holy-shitt-microsoft-dropped-an-open-source-activity-7300755229635944449-mQP8?utm_medium=ios_app&rcm=ACoAACzQvjwB2FeLVE3yukDiUYtr5J4k-6nlNG4&utm_source=social_share_send&utm_campaign=copy_linkMIT License</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<span class="issue_date">Issue Date: 2025-03-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1780">The Ultra-Scale Playbook: Training LLMs on GPU Clusters, HuggingFace, 2025.02</a>
<span class="snippet"><span>Comment</span>HuggingFaceによる数1000のGPUを用いたAIモデルのトレーニングに関するオープンソースのテキスト</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/python.html">#python</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-03-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1778">Open Reasoner Zero, Open-Reasoner-Zero, 2024.02</a>
<span class="snippet"><span>Summary</span>Open-Reasoner-Zeroは、推論指向の強化学習のオープンソース実装で、スケーラビリティとアクセスのしやすさに重点を置いています。AGI研究の促進を目指し、ソースコードやトレーニングデータを公開しています。</span>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dair_ai/status/1893698293965725708?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2025-03-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1777">Introducing the SWE-Lancer benchmark, OpenAI, 2025.02</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/dair_ai/status/1893698290174108113?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q1400以上のフリーランスソフトウェアエンジニアリングタスクを集めたベンチマーク。タスクはバグ修正から機能実装まで多岐にわたり、経験豊富なエンジニアによって評価されたもの。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/GRPO.html">#GRPO</a>
<span class="issue_date">Issue Date: 2025-02-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1769">強化学習「GRPO」をCartPoleタスクで実装しながら解説, 小川雄太郎, 2025.02</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/ogawa_yutaro_22/status/1892059174789407213?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-02-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1766">Mistral-24B-Reasoning, yentinglin, 2025.02</a>
<span class="snippet"><span>Comment</span>Apache-2.0</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<span class="issue_date">Issue Date: 2025-02-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1762">LLMの事前学習のためのテキストデータの収集と構築, Shun Kiyono, 2015.02</a>
<span class="snippet"><span>Comment</span>詳細は著書に記載とのこと。興味深い。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/pretrained-LM.html">#pretrained-LM</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2025-02-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1761">modernbert-ja-130m, SB Intuitions, 2025.02</a>
<span class="snippet"><span>Summary</span>SB Intuitionsが訓練した日本語のModernBERTを提供。これは、ローカルとグローバルな注意機構を組み合わせた新しいBERTモデルで、長いシーケンスを効率的に処理可能。ModernBERT-Ja-130Mは高品質な日本語と英語のコーパスで訓練され、語彙サイズは102,400、シーケンス長は8,192。</span>
<span class="snippet"><span>Comment</span>ＭIT Licence元ポスト:https://x.com/sbintuitions/status/1889587801706078580?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q・1606</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/python.html">#python</a>
<span class="issue_date">Issue Date: 2025-02-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1759">Docling, DS4SD, 2024.07</a>
<span class="snippet"><span>Comment</span>Unstructuredとどちらが良いだろうか？</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Distillation.html">#Distillation</a>
<span class="issue_date">Issue Date: 2025-02-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1757">DeepScaleR: Surpassing O1-Preview with a 1.5B Model by Scaling RL, 2025.02</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LLMServing.html">#LLMServing</a>
<span class="issue_date">Issue Date: 2025-02-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1755">SGlang, sgl-project, 2024.01</a>
<span class="snippet"><span>Summary</span>SGLangは、大規模言語モデルと視覚言語モデルのための高速サービングフレームワークで、バックエンドとフロントエンドの共同設計により迅速なインタラクションを実現します。主な機能には、高速バックエンドランタイム、柔軟なフロントエンド言語、広範なモデルサポートがあり、オープンソースの活発なコミュニティに支えられています。</span>
<span class="snippet"><span>Comment</span>・1733

<br>



<br>

のUpdate2でMath Datasetの生成に利用されたLLM Servingフレームワーク。利用前と比較してスループットが2倍になったとのこと。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2025-02-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1747">Unsloth で独自の R1 Reasoningモデルを学習, npaka, 2025.02</a>
<span class="snippet"><span>Comment</span>非常に実用的で参考になる。特にどの程度のVRAMでどの程度の規模感のモデルを使うことが推奨されるのかが明言されていて参考になる。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/FoundationModel.html">#FoundationModel</a>
<a class="button" href="articles/RLHF.html">#RLHF</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2025-02-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1743">DeepSeek-R1の論文読んだ？【勉強になるよ】 , asap, 2025.01</a>
<span class="snippet"><span>Comment</span>・1719

<br>

・1655とても丁寧でわかりやすかった。後で読んだ内容を書いて復習する。ありがとうございます。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-01-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1737">Janus-Series: Unified Multimodal Understanding and Generation Models, DeepSeek, 2025.01</a>
<span class="snippet"><span>Comment</span>DeepSeekによる新たなVLM、Janus-Proが本日リリース。MIT LicenseJanus-Proのパフォーマンス。

<br>



<br>

github上でのパフォーマンスの図解から引用。マルチモーダル（テキスト+画像）の理解に関するベンチマークでLLaVA超え。GenEval, DPG Benchと呼ばれる画像生成ベンチマークでDALL-E 3超え。

<br>

<img src="https://github.com/user-attachments/assets/39b51e99-723d-4105-a113-e4bfa847c69b" alt="image" loading="lazy">

<br>



<br>



<br>

テクニカルレポート中での詳細から引用。どのベンチマークでも基本的に最高性能なように見える。

<br>

<img src="https://github.com/user-attachments/assets/4c1bd071-966f-4d51-99f4-e60fa2f36b0a" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/a0b22d6e-debb-420a-bf8d-fe8833583d09" alt="image" loading="lazy">

<br>



<br>

テクニカルレポート: https://github.com/deepseek-ai/Janus/blob/main/janus_pro_tech_report.pdf</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/OpenSource.html">#OpenSource</a>
<span class="issue_date">Issue Date: 2025-01-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1733">Open R1, HuggingFace, 2025.01</a>
<span class="snippet"><span>Comment</span>HFによるDeepSeekR1を完全に再現する取り組みUpdate1: https://huggingface.co/blog/open-r1/update-1Update2: https://huggingface.co/blog/open-r1/update-2

<br>



<br>

512機のH100を利用…Update3:https://huggingface.co/blog/open-r1/update-3</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2025-01-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1730">Humanity's Last Exam, 2025.01</a>
<span class="snippet"><span>Summary</span>「人類の最後の試験」という新しいマルチモーダルベンチマークを導入し、100以上の科目にわたる3,000の挑戦的な質問を提供。これにより、LLMの能力を正確に測定し、過学習を評価するためのプライベートテストセットも保持。</span>
<span class="snippet"><span>Comment</span>o1, DeepSeekR1の正解率が10%未満の新たなベンチマーク</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2025-01-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1727">LLM Datasets, mlabonne, 2025.01</a>
<span class="snippet"><span>Comment</span>LLMの事後学習用のデータをまとめたリポジトリ</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2025-01-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1726">Llama Stack, Meta, 2024.11</a>
<span class="snippet"><span>Comment</span>Llamaを用いたLLM Agentを構築するための標準化されたフレームワーク。Quick StartではRAG Agentを構築している。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/SyntheticData.html">#SyntheticData</a>
<span class="issue_date">Issue Date: 2025-01-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1725">distilabel, 2023.11</a>
<span class="snippet"><span>Comment</span>高品質な合成データをLLMで生成するためのフレームワーク</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-01-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1723">How to fine-tune open LLMs in 2025 with Hugging Face, PHILSCHMID, 2024.12</a>
<span class="snippet"><span>Comment</span>SFTTrainerを用いたLLMのSFTについて、実用的、かつ基礎的な内容がコード付きでまとまっている。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2025-01-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1722">How to align open LLMs in 2025 with DPO &amp; and synthetic data, PHILSCHMID, 2025.01</a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/_philschmid/status/1882428447877705908?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q・DPOの概要やRLHFと比較した利点

<br>

・ルールベース、あるいはLLM as a Judgeを用いたOn-policy preference pair（現在のSFTしたモデルの出力から生成したpreference data）の作り方とその利点（現在のモデルのoutput distributionを反映しているので学習が効率化される）

<br>

・環境構築方法

<br>

・DPOTrainer/TRLParserの使い方/DPODatasetの作り方

<br>

・DPOのハイパーパラメータβの意味合い

<br>

・DPOではSFTと比べて10-100x小さい学習率を使う必要があること

<br>

・Evaluation Harnessを用いた評価方法

<br>

・TGIを用いたモデルのデプロイとテスト

<br>



<br>

などが丁寧なサンプルコードと注釈、reference付きで説明されている。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/python.html">#python</a>
<a class="button" href="articles/StructuredData.html">#StructuredData</a>
<span class="issue_date">Issue Date: 2025-01-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1721">Structured Outputs OpenAI Platform, 2025.01</a>
<span class="snippet"><span>Comment</span>pydanticを用いて、CoT＋構造化されたoutputを実施するサンプル</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-01-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1720">DeepSeek-R1-Distill-Qwen, DeepSeek, 2025.01</a>
<span class="snippet"><span>Comment</span>MIT Licence</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2025-01-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1719">DeepSeek-R1, DeepSeek, 2025.01</a>
<span class="snippet"><span>Comment</span>参考:https://x.com/icoxfog417/status/1883339727446974616?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q参考:https://horomary.hatenablog.com/entry/2025/01/26/204545DeepSeek-R1の論文読んだ？【勉強になるよ】

<br>

, asap:https://zenn.dev/asap/articles/34237ad87f8511こちらのポストの図解がわかりやすい:

<br>

https://x.com/1littlecoder/status/1887134619603968439?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q最新モデル: DeepSeek-R1-0528

<br>

https://huggingface.co/deepseek-ai/DeepSeek-R1-0528

<br>



<br>

<img src="https://github.com/user-attachments/assets/c2d7e967-1677-4791-81ad-2a7d050da593" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<span class="issue_date">Issue Date: 2025-01-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1718">tokyotech-llm_swallow-magpie-ultra-v0.1, tokyotech-llm, 2025.01</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2025-01-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1663">DeepSeek-V2のアーキテクチャを徹底解説：MLA と DeepSeekMoE, kernelian, 2024.05</a>
<span class="snippet"><span>Comment</span>・1665

<br>



<br>

も参照のこと。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2025-01-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1662">Killed by LLM, R0bk</a>
<span class="snippet"><span>Comment</span>Saturationとなっているベンチマークは、最先端の性能をすでに測定できなくなってしまったベンチマークとのこと。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2025-01-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1660">AI Agents 2024 Rewind - A Year of Building and Learning, VICTOR DIBIA, 2025.01</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2025-01-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1659">AI Agent Era,  福島良典 | LayerX, 2024.12</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2025-01-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1658">LLMがオワコン化した2024年, らんぶる, 2025.01</a>
<span class="snippet"><span>Comment</span>LLMを（呼び出す|呼び出される）SaaS企業が今後どのような戦略で動いていくかが考察されており興味深かった。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/python.html">#python</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/API.html">#API</a>
<span class="issue_date">Issue Date: 2025-01-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1651">LiteLLM, BerriAI, 2023.08</a>
<span class="snippet"><span>Comment</span>様々なLLMのAPIを共通のインタフェースで呼び出せるライブラリ

<br>



<br>

・1553 

<br>



<br>



<br>



<br>

とどちらがいいんだ・・・？aisuiteのissueの113番のスレッドを見ると、

<br>



<br>

・LiteLLMはもはやLiteではなくなっており、コードベースの保守性が低い

<br>



<br>

・aisuiteは複数のLLMプロバイダーをシンプルに利用する方法を提供する

<br>



<br>

・今後発表されるロードマップを見れば、LiteLLMとの差別化の方向性が分かるはずだ

<br>



<br>



<br>



<br>

といった趣旨のことが記述されていた。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2025-01-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1635">To fine-tune or not to fine-tune, Meta, 2024.08</a>
<span class="snippet"><span>Comment</span>LLMをSFTする際の注意点やユースケースについて記述されている。

<br>



<br>

・full parameterのファインチューニングやPEFT手法のピークGPUメモリ

<br>

・full parameterのファインチューニングではcatastrophic forgettingに気をつける必要があること

<br>

・Finetuningが有用なユースケースとして以下が挙げられている

<br>

  ・トーン、スタイル、フォーマットのカスタマイザーション

<br>

  ・prompt engineeringやICLで達成するには困難なAccuracyの向上やエッジケースへの対応

<br>

  ・ドメイン適応

<br>

  ・より大きいモデルを蒸留することによるコスト削減

<br>

  ・新たなタスクへの適応や能力の獲得 また、RAGとFinetuningどちらを選択すべきかに関する話題も記述されている（が、多くの場合はハイブリッドアプローチがベストだ、といった話も書いてある）。元ポスト:https://x.com/gyakuse/status/1874357127248306200?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<span class="issue_date">Issue Date: 2025-01-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1633">2024-ai-timeline, reach-vb, 2025.01</a>
<span class="snippet"><span>Comment</span>月別で2024年にリリースされた主要なLLM（マルチモーダルなLLMも含む）のタイムラインがまとめられている。

<br>

API Only（プロプライエタリ）なのか、OpenWeightなのかもタグ付けされている。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2024-12-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1623">Preferred Generation Benchmark, pfnet-research, 2024.12</a>
<span class="snippet"><span>Comment</span>参考:https://x.com/bilzrd/status/1873167934564311133?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q日本語プレプリント:https://jxiv.jst.go.jp/index.php/jxiv/preprint/view/1008arXivはこれからっぽい</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1621">MHA vs MQA vs GQA vs MLA, Zain ul Abideen, 2024.07</a>
<span class="snippet"><span>Comment</span>DeepSeekで使われているMulti Head Latent Attention（MLA）ってなんだ？と思い読んだ。端的に言うと、GQAやMQAは、KVのヘッドをそもそも減らしてKV Cacheを抑えよう、という手法だったが、MLAはKVを低ランクなベクトルに圧縮して保持し、使う時に復元するといった操作をすることで、MHAのパフォーマンスを落とすことなく（むしろ上がるらしい？）、利用するKV Cacheで利用するメモリを大幅に減らせるという手法らしい。・1271

<br>



<br>

MQA, GQAの概要については上記参照のこと。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-12-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1620">Deep-seek-v3, deepseek-ai, 2024.12</a>
<span class="snippet"><span>Comment</span>参考（モデルの図解）:https://x.com/vtabbott_/status/1874449446056177717?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q参考:https://x.com/hillbig/status/1876397959841186148?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Mathematics.html">#Mathematics</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2024-12-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1617">LLMを数学タスクにアラインする手法の系譜 - GPT-3からQwen2.5まで, bilzard, 2024.12</a>
<span class="snippet"><span>Comment</span>・1618

<br>



<br>

において、数学においてモデルのパラメータ数のスケーリングによって性能改善が見込める学習手法として、モデルとは別にVerifierを学習し、モデルが出力した候補の中から良いものを選択できるようにする、という話の気持ちが最初よくわからなかったのだが、後半のなぜsample&amp;selectがうまくいくのか？節を読んでなんとなく気持ちが理解できた。SFTを進めるとモデルが出力する解放の多様性が減っていくというのは、興味深かった。

<br>



<br>

しかし、特定の学習データで学習した時に、全く異なるUnseenなデータに対しても解法は減っていくのだろうか？という点が気になった。あとは、学習データの多様性をめちゃめちゃ増やしたらどうなるのか？というのも気になる。特定のデータセットを完全に攻略できるような解法を出力しやすくなると、他のデータセットの性能が悪くなる可能性がある気がしており、そうするとそもそもの1shotの性能自体も改善していかなくなりそうだが、その辺はどういう設定で実験されているのだろうか。

<br>



<br>

たとえば、

<br>

・1475

<br>



<br>

などでは、

<br>



<br>

・1474

<br>



<br>

のような1600を超えるようなNLPタスクのデータでLoRAによりSFTすると、LoRAのパラメータ数を非常に大きくするとUnseenタスクに対する性能がfull-parameter tuningするよりも向上することが示されている。この例は数学に特化した例ではないが、SFTによって解法の多様性が減ることによって学習データに過剰適合して汎化性能が低下する、というのであれば、この論文のことを鑑みると「学習データにoverfittingした結果他のデータセットで性能が低下してしまう程度の多様性の学習データしか使えていないのでは」と感じてしまうのだが、その辺はどうなんだろうか。元論文を読んで確認したい。

<br>

とても勉強になった。記事中で紹介されている

<br>

&gt; LLMを使って複数解法の候補をサンプリングし、その中から最適な1つを選択する

<br>



<br>

のルーツは 1618 とのことなので是非読みたい。

<br>



<br>

この辺はSelf-Consistency 558 あたりが最初なのかと思っていた。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<span class="issue_date">Issue Date: 2024-12-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1615">LLM-as-a-Judge をサーベイする, Ayako, 2024.12</a>
<span class="snippet"><span>Comment</span>・1616

<br>



<br>

を読んだ結果を日本語でまとめてくださっている。モデル選択について、外部APIに依存するとコストやプライバシー、再現性などの問題があるためOpenLLMをFinetuningすることで対応していることが論文中に記載されているようだが、評価能力にはまだ限界があるとのこと。

<br>



<br>

記事中ではLlama, Vicunaなどを利用している旨が記述されているが、どの程度のパラメータサイズのモデルをどんなデータでSFTし、どのようなタスクを評価したのだろうか（あとで元論文を見て確認したい）。

<br>



<br>



<br>



<br>

また、後処理としてルールマッチで抽出する必要あがるが、モデルのAlignmentが低いと成功率が下がるとのことである。

<br>



<br>

個人的には、スコアをテキストとして出力する形式の場合生成したテキストからトークンを抽出する方式ではなく、G-Eva のようにスコアと関連するトークン（e.g. 1,2,3,4,5）とその尤度の加重平均をとるような手法が後処理が楽で良いと感じる。

<br>



<br>

ICLR2025の査読にLLM-as-a-Judgeが導入されるというのは知らなかったので、非常に興味深い。LLMが好む回答のバイアス（冗長性、位置など）別に各LLMのメタ評価をしている模様。また、性能を改善するための施策を実施した場合にどの程度メタ評価で性能が向上するかも評価している。特に説明を出力させても効果は薄く、また、複数LLMによる投票にしても位置バイアスの軽減に寄与する程度の改善しかなかったとのこと。また、複数ラウンドでの結果の要約をさせる方法がバイアスの低減に幅広く寄与したとのこと。うーん、バイアスを低減するうまい方法がまだ無さそうなのがなかなか厳しい感じがする。

<br>

そもそも根本的に人間に人手評価をお願いする時もめちゃめちゃマニュアルとかガイドラインを作り込んだりした上でもagreementが高くなかったりするので、やはり難しそうである。

<br>



<br>

ただ、MTBenchでは人間の評価結果とLLMの評価結果の相関（agreementだっけか…？）が高かったことなどが報告されているし、LLMあるあるのタスクごとに得意不得意があります、という話な気もする。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Video.html">#Video</a>
<span class="issue_date">Issue Date: 2024-12-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1614">Stanford CS229 I Machine Learning I Building Large Language Models （LLMs）, StanfordUnivercity, 2024.09</a>
<span class="snippet"><span>Comment</span>スタンフォード大学によるLLM構築に関する講義。事前学習と事後学習両方ともカバーしているらしい。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2024-12-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1613">Qwen2.5 Technical Reportの中に潜る, AbejaTech Blog, 2024.12</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/GenerativeAI.html">#GenerativeAI</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-12-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1612">OpenAI o3は，人間とは全く異質の汎用知能である危険性【東大解説】, 神楽坂やちま, 2024.12</a>
<span class="snippet"><span>Comment</span>様々な有識者の見解をまとめつつ、文献を引用しつつ、かつ最終的に「人間が知能というものに対してなんらかのバイアスを持っている」可能性がある、という話をしており興味深い。

<br>

一部の有識者はARC-AGIの一部の、人間なら見た瞬間に分かるようなパターン認識の問題でも解けていないことから、AGIではないと主張しているとのことだったが、人間目線で簡単な問題が解けることはAGIとして必須な条件ではないよね、といった話が書かれており、そもそも有識者がどのようなものさしや観点でAGIを見ているのか、どういう視点があるのか、ということが感覚的に分かる内容であり、おもしろかった。

<br>



<br>

しかし、そもそも何がどうなったらAGIが実現できたと言えるのだろうか？定義がわからない（定義、あるのか…？）</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Sentence.html">#Sentence</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Tokenizer.html">#Tokenizer</a>
<span class="issue_date">Issue Date: 2024-12-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1611">Large Concept Models: Language Modeling in a Sentence Representation Space, Meta, 2024.12</a>
<span class="snippet"><span>Summary</span>本研究では、言語やモダリティに依存しない「大規模概念モデル」を提案し、概念を高次の意味表現として扱います。最大200言語をサポートするSONAR文埋め込み空間を用い、自己回帰的な文予測を行うモデルを訓練しました。16億パラメータのモデルから70億パラメータにスケールアップし、生成タスクに対する実験評価を実施。結果として、ゼロショット一般化性能が向上し、既存のLLMsを上回ることを示しました。トレーニングコードは公開されています。</span>
<span class="snippet"><span>Comment</span>まだ全く読めていないが、従来のLLMはnent-token-predictionで学習をしており、transformers decoderの内部状態で何らかの抽象的な概念はとらえているものの、次トークン予測に前回生成したトークンをinputするのが必須である以上「トークンで考える」みたいな挙動をある程度はしてしまっており、人間はそんなことしないですよね？みたいな話だと思われる。

<br>

人間はもっと抽象的なコンセプトレベルで物事を考えることができるので、それにより近づけるために、conceptをsentenceとしてみなして、next-concept-predictionでモデルを学習したらゼロショットの汎化性能上がりました、みたいな話のように見える。ただし、評価をしているのはマルチリンガルな文書要約タスクのみに見える。

<br>



<br>

追記: コンセプトが言語非依存だとすると、コンセプト間の関係性を学習するLCMが、マルチリンガルでトークンレベルの学習しかしない従来LLMを上回るのも納得いく気はする。なぜなら、従来LLMよりも言語（トークン）への依存が緩和されていると思われるので、言語間を跨いだ知識の転移が起きやすいと考えられるからである。

<br>



<br>

<img src="https://github.com/user-attachments/assets/2f3dc98d-ef27-44b8-be1c-0f27a05f37e8" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/effc21ba-22db-42c0-bc33-1d43f9e0200a" alt="image" loading="lazy">Base-LCMを見ると、文の埋め込みのground truthと生成された文の埋め込みの差を最小化する（Mean Squared Error） ようなlossになっている。つまり、トークンレベルではなく、より抽象的な概念を直接学習するような設計になっているためここが従来のLLMと異なる。

<br>



<br>

<img src="https://github.com/user-attachments/assets/01da9a76-f5fb-4e79-b3cf-8bddc123379b" alt="image" loading="lazy">

<br>



<br>

これを実現するために、ground truthとなる文の埋め込みx_nが分からなければいけないが、このために、freezeしたEncoderとDecoderを用意してLCMにconcatしていると思われる。つまり、入力と出力のconceptを解釈する機構は固定して、正解となる文埋め込みを決めてしまう。そして、LCMはinputされたconceptを別のconceptに変換するような機構となっており、その変換の関係性を学習している。なるほど、なんとなく気持ちはわかった。日本語を含むいくつかの言語でゼロショット性能が低下しているのが興味深い。日本語特有の概念とか、特定の言語固有の概念は欠落する可能性が示唆される。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2024-12-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1610">完全にオープンな約1,720億パラメータ（GPT-3級）の大規模言語モデル 「llm-jp-3-172b-instruct3」を一般公開 ～GPT-3.5を超える性能を達成～ , NII, 2024.12</a>
<span class="snippet"><span>Comment</span>GPT3.5と同程度のパラメータ数のコーパス、モデル、ツール、全てを公開。学習データまで含めてオープンなモデルとしては世界最大規模とのこと。Instructionチューニング済みのモデルはライセンスを読むと、ライセンスに記述されている内容を遵守すれば、誰でも（日本人なら18歳以上とかはあるが）アクセス可能、用途の制限（商用・非商用問わず）なく利用でき、かつ再配布や派生物の生成などが許されているように見える。

<br>

が、baseモデルの方はコンタクト情報を提供のうえ承認を受けないと利用できない模様。また、再配布と一部の使途に制限がある模様。

<br>



<br>

SNSではオープンソースではないなどという言説も出ており、それはbaseモデルの方を指しているのだろうか？よくわからない。実用上はinstructionチューニング済みのモデルの方がbaseモデルよりも使いやすいと思うので、問題ない気もする。やはりbaseとinstructでライセンスは2種類あるとのこと: https://x.com/odashi_t/status/1871508348086214685?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/SelfCorrection.html">#SelfCorrection</a>
<span class="issue_date">Issue Date: 2024-12-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1608">OpenAI o1を再現しよう（Reasoningモデルの作り方）, はち, 2024.12</a>
<span class="snippet"><span>Comment</span>Reflection after Thinkingを促すためのプロンプトが興味深い</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<span class="issue_date">Issue Date: 2024-12-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1603">【NLPコロキウム】Stepwise Alignment for Constrained Language Model Policy Optimization （NeurIPS 2024）  , 2024.12</a>
<span class="snippet"><span>Comment</span>・1602

<br>



<br>

も参照のこと。RLHF, DPOが解いている問題が同じで、問題が同じなのでそれぞれの最適解も一緒であり解き方が違うだけ、でもDPOの方が頑張って強化学習するRLHFよりも簡単に解けるし、学習も安定してるよ、という話が、binary feedbackデータに対するアライメント手法であるKTOも交えて書いてある。アライメントの学習では単一のスカラー値によって報酬が決まっているが、生成結果には色々な側面があるから単一スカラーでは本来評価できないよねという話が出てきた上で、safetyに対しても考慮して報酬を決めたい、という時にスカラー値のままだけど最適化問題の制約条件にsafetyに関する制約を入れる、ことで報酬に反映させます、みたいな話が書いてある。

<br>

そして提案手法の主要な貢献は、そういうことをやるとめちゃめちゃ手法が複雑化するんだけれども、よりシンプルにして、かつ理論的にも正当化されているし、実験的にもうまく動きます、という話らしい。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/RLHF.html">#RLHF</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/DPO.html">#DPO</a>
<span class="issue_date">Issue Date: 2024-12-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1602">RLHF_DPO 小話, 和地瞭良_ Akifumi Wachi, 2024.04</a>
<span class="snippet"><span>Comment</span>めちゃめちゃ勉強になる…</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<span class="issue_date">Issue Date: 2024-12-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1601">Scaling test-time-compute, Huggingface, 2024.12</a>
<span class="snippet"><span>Comment</span>これは必読</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-12-17</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1599">Fast LLM Inference From Scratch, Andrew Chan, 2024.12</a>
<span class="snippet"><span>Comment</span>ライブラリを使用せずにC++とCUDAを利用してLLMの推論を実施する方法の解説記事</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/SpokenLanguageProcessing.html">#SpokenLanguageProcessing</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/OpenSource.html">#OpenSource</a>
<span class="issue_date">Issue Date: 2024-12-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1588">LLaMA-Omni: Seamless Speech Interaction with Large Language Models, Meta, 2024.09</a>
<span class="snippet"><span>Comment</span>音声とテキストのOpenSourceマルチモーダルモデル。inputは音声のみ？に見えるが、出力はテキストと音声の両方を実施できる。GPT-4oレベルのspeech capabilityを目指すとaboutに記載されている。興味深い。

<br>



<br>



<br>



<br>

installの説明に `Whisper-large-v3` をインストールする旨が記載されているので、Whisper-large-v3で認識した内容に特化したSpeech Encoder/Adapterが学習されていると考えられる。

<br>



<br>

<img width="702" alt="image" src="https://github.com/user-attachments/assets/cea090e7-a42a-476d-85f6-50199d9ae180">

<br>



<br>

・1225 

<br>



<br>



<br>



<br>

マルチモーダルなLLMの基本的な概念については上記参照のこと。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<span class="issue_date">Issue Date: 2024-12-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1576">OpenAI o1 System Card, OpenAI, 2024.12</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-12-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1574">Llama3.3-70B, Meta, 2024.12</a>
<span class="snippet"><span>Comment</span>3.1-70Bよりも性能向上し、3.1-405Bの性能により近く。

<br>



<br>

（画像は元ポストより引用）

<br>

<img src="https://github.com/user-attachments/assets/07fb3043-131a-4564-be70-d34b70c31cca" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/FoundationModel.html">#FoundationModel</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<span class="issue_date">Issue Date: 2024-12-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1571">Introducing Amazon Nova, our new generation of foundation models, AWS, 2024.12</a>
<span class="snippet"><span>Comment</span>参考:https://qiita.com/ysit/items/8433d149dbaab702d526テクニカルレポート: https://assets.amazon.science/9f/a3/ae41627f4ab2bde091f1ebc6b830/the-amazon-nova-family-of-models-technical-report-and-model-card.pdf後で個々のベンチマークとメトリックをまとめたい。

<br>



<br>

まあでもざっくり言うと、他のproprietaryモデルともおおむね同等の性能です、という感じに見える。個々のタスクレベルで見ると、得意なものと不得意なものはありそうではある。

<br>



<br>

<img src="https://github.com/user-attachments/assets/c0c633d8-c64d-4a14-95cf-0d8b0d52a7f6" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/560f8c3e-65ff-4742-b7da-bc2b242dafcd" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/481a9635-128d-4931-a891-5f46d55b82bc" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/fc9b1bc0-b857-4a27-ad90-4940213c6ec6" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/a349b154-1844-41c2-84e3-7f981b1f6b72" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/a4381740-600c-402f-be0d-59ce60b7a562" alt="image" loading="lazy">

<br>



<br>

スループットとかも、ProとGPT4oをパッと見で比較した感じ、優れているわけでもなさそう。Liteに対応するGPTはおそらくGPT4o-miniだと思われるが、スループットはLiteの方が高そう。

<br>

<img src="https://github.com/user-attachments/assets/734ee26f-2f16-46e4-a6e8-f5f2f0d65be3" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/fe1768e8-b417-4b89-a0c4-f6dffa99cf11" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/6334ee92-e426-49f5-8e1f-050e0b77fcf2" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/5c9ec797-ef7a-43e1-8540-42ccab265208" alt="image" loading="lazy">

<br>



<br>

（画像は論文中からスクショし引用）下記ポストは独自に評価した結果や、コストと性能のバランスについて言及している。

<br>



<br>

・ProはGPT4oのコストの約1/3

<br>

・Pro, Lite, Flashはほれぞれコストパフォーマンスに非常に優れている（Quality vs. Price参照）

<br>



<br>

元ポスト:https://x.com/artificialanlys/status/1864023052818030814?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-12-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1569">Augmenting Recommendation Systems With LLMs, Dave AI, 2024.08</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<a class="button" href="articles/OpenSource.html">#OpenSource</a>
<span class="issue_date">Issue Date: 2024-12-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1563">日本語LLMまとめ, LLM-jp, 2024.12</a>
<span class="snippet"><span>Comment</span>LLM-jpによる日本語LLM（Encoder-Decoder系, BERT系, Bi-Encoders, Cross-Encodersを含む）のまとめ。

<br>

テキスト生成に使うモデル、入力テキスト処理に使うモデル、Embedding作成に特化したモデル、視覚言語モデル、音声言語モデル、日本語LLM評価ベンチマーク/データセットが、汎用とドメイン特化型に分けてまとめられている。

<br>

各モデルやアーキテクチャの原論文、学習手法の原論文もまとめられている。すごい量だ…。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/SelfCorrection.html">#SelfCorrection</a>
<span class="issue_date">Issue Date: 2024-11-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1558">LLM Self-Correction Papers, Ryo Kamoi, 2024.11</a>
<span class="snippet"><span>Comment</span>self-correctionの専門家によるself-correction関連の論文のリーディングリスト。ぜひチェックしたい。

<br>



<br>

元ポスト: https://x.com/ryokamoi_ja/status/1862635105010799054?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/AES(AutomatedEssayScoring).html">#AES(AutomatedEssayScoring)</a>
<span class="issue_date">Issue Date: 2024-11-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1555">Cross-prompt Pre-finetuning of Language Models for Short Answer Scoring, Funayama+, 2024.09</a>
<span class="snippet"><span>Summary</span>自動短答スコアリング（SAS）では、異なるルーブリックと参照回答に基づいてスコアを付けるが、新しいプロンプトごとにモデルを再訓練する必要がありコストがかかる。本研究では、既存のルーブリックと回答を用いて新しいプロンプトでファインチューニングする二段階アプローチを提案。重要なフレーズを学習することで、特に訓練データが限られている場合にスコアリング精度を向上させることを実験で示した。</span>
<span class="snippet"><span>Comment</span>SASでは回答データが限られているので、限られたデータからより効果的に学習をするために、事前に他のデータでモデルをpre-finetuningしておき、対象データが来たらpre-finetuningされたモデルをさらにfinetuningするアプローチを提案。ここで、prompt中にkeyphraseを含めることが有用であると考え、実験的に有効性を示している。

<br>



<br>

<img src="https://github.com/user-attachments/assets/9ab4eb22-b72e-4573-8fbb-1c376047c2b0" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/user-attachments/assets/b671a564-c5a8-4344-aaec-06875f654f8b" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

BERTでfinetuningをした場合は、key-phraseを含めた方が性能が高く、特にfinetuningのサンプル数が小さい場合にその差が顕著であった。

<br>



<br>

<img src="https://github.com/user-attachments/assets/cdced65b-060b-43ae-a2b4-fcfc5750a6ed" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

次に、LLM（swallow-8B, 70B）をpre-finetuningし、pre-finetuningを実施しない場合と比較することで、pre-finetuningがLLMのzero-shot、およびICL能力にどの程度影響を与えるかを検証した。検証の結果、pre-finetuningなしでは、そもそも10-shotにしてもQWKが非常に低かったのに対し、pre-finetuningによってzero-shotの能力が大幅に性能が向上した。一方、few-shotについては3-shotで性能が頭打ちになっているようにみえる。ここで、Table1のLLMでは、ターゲットとする問題のpromptでは一切finetuningされていないことに注意する（Unseenな問題）。

<br>



<br>

<img width="639" alt="image" src="https://github.com/user-attachments/assets/7c9f141d-dc55-4388-8dc4-6a56f81d6cad">

<br>



<br>



<br>



<br>

続いて、LLMをfinetuningした場合も検証。提案手法が高い性能を示し、200サンプル程度ある場合にHuman Scoreを上回っている（しかもBERTは200サンプルでサチったが、LLMはまだサチっていないように見える）。また、サンプル数がより小さい場合に、提案手法がより高いgainを得ていることがわかる。

<br>



<br>

<img width="775" alt="image" src="https://github.com/user-attachments/assets/898b2bea-e9df-4c5c-b172-0507a3a83c3c">

<br>



<br>



<br>



<br>

また、個々の問題ごとにLLMをfinetuningするのは現実的に困難なので、個々の問題ごとにfinetuningした場合と、全ての問題をまとめてfinetuningした場合の性能差を比較したところ、まとめて学習しても性能は低下しない、どころか21問中18問で性能が向上した（LLMのマルチタスク学習の能力のおかげ）。

<br>



<br>

<img width="762" alt="image" src="https://github.com/user-attachments/assets/a8ec62fb-2984-4e7c-8eeb-1b3b6333e9ac">

<br>



<br>

[Perplexity(hallucinationに注意)](https://www.perplexity.ai/search/tian-fu-sitalun-wen-wodu-mi-ne-3_TrRyxTQJ.2Bm2fJLqvTQ0)</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/python.html">#python</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/API.html">#API</a>
<span class="issue_date">Issue Date: 2024-11-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1553">aisuite, andrewyng, 2024.11</a>
<span class="snippet"><span>Comment</span>複数のLLM Providerの呼び出しを共通のインタフェースで呼び出せる。変更するのは、モデルを指定するパラメータのみ。

<br>



<br>

元ポスト:https://www.linkedin.com/posts/andrewyng_announcing-new-open-source-python-package-activity-7266851242604134400-Davp?utm_source=share&utm_medium=member_ios</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2024-11-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1545">Sarashina2-8x70Bの公開, SB Intuitions, 2024.11</a>
<span class="snippet"><span>Comment</span>MoE Layerの説明、Sparse Upcyclingの説明、MoEモデルを学習する際に、学習時の学習率の設定が大きすぎると初期に損失が増大し、小さすぎると損失の増大は防げるがlong runで学習した際の性能向上が小さかったこと、元のモデルのパラメータを毀損しないように、Upcyclingをした元モデルの最終的な学習率を踏襲して学習をし、学習率をさらに減衰させていったこと、などが記載されている。

<br>



<br>

また、性能評価として同等のactivation parameter数を持つモデルと日本語のQAタスクで比較した結果も載っている。

<br>



<br>

・1546MoE Layerについては

<br>

・1204

<br>



<br>

も参照のこと</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<span class="issue_date">Issue Date: 2024-11-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1528">Large Vision Language Model （LVLM）に関する知見まとめ, Daiki Shiono, 2024.11</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<span class="issue_date">Issue Date: 2024-11-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1521">microsoft_orca-agentinstruct-1M-v1, Microsoft, 2024.11</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/OpenSource.html">#OpenSource</a>
<span class="issue_date">Issue Date: 2024-11-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1519">ローカルLLMのリリース年表, npaka, 随時更新, 2024.11</a>
<span class="snippet"><span>Comment</span>ローカルLLMを含むOpenLLMのリリース日が年表としてまとまっており、随時更新されている模様。すごい。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<span class="issue_date">Issue Date: 2024-11-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1518">TensorRT-LLMによる推論高速化, Hiroshi Matsuda, NVIDIA AI Summit 2024.11 </a>
<span class="snippet"><span>Comment</span>元ポスト:https://x.com/hmtd223/status/1856887876665184649?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q非常に興味深いので後で読む</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2024-11-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1494">sarashina2-8x70B, SBIntuitions, 2024.11</a>
<span class="snippet"><span>Comment</span>プレスリリース:https://www.sbintuitions.co.jp/news/press/20241108_01/・商用利用不可な点には注意

<br>

・アーキテクチャは70Bモデルx8のMixture of Experts（MoE）

<br>

・モデルカードによると、inferenceにはBF16で、A100 80GB or H100が16基必要っぽいMoEを利用したLLMについては、1204 を参照のこと。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2024-11-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1479">Lingua, Meta</a>
<span class="snippet"><span>Comment</span>研究目的のための、minimal、かつ高速なLLM training/inferenceのコードが格納されたリポジトリ。独自のモデルやデータ、ロスなどが簡単に実装できる模様。

<br>



<br>

<img src="https://github.com/user-attachments/assets/47f70515-3de0-455f-9fc4-0e2e17442eed" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Quantization.html">#Quantization</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-10-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1471">Introducing quantized Llama models with increased speed and a reduced memory footprint, Meta, 2024.10</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2024-10-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1462">Prompt-Engineering-Guide, DAIR.AI</a>
<span class="snippet"><span>Comment</span>LLMのsettingから、few-shot, self-consistencyなどのprompting技術、さまざまなタスクの実例などが網羅的にまとまっている</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2024-10-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1457">MLE-Bench, OpenAI, 2024.10</a>
<span class="snippet"><span>Summary</span>MLE-benchを紹介し、AIエージェントの機械学習エンジニアリング能力を測定するためのベンチマークを構築。75のKaggleコンペを基に多様なタスクを作成し、人間のベースラインを確立。最前線の言語モデルを評価した結果、OpenAIのo1-previewが16.9%のコンペでKaggleのブロンズメダル相当の成果を達成。AIエージェントの能力理解を促進するため、ベンチマークコードをオープンソース化。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<span class="issue_date">Issue Date: 2024-10-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1450">Unsloth</a>
<span class="snippet"><span>Comment</span>single-GPUで、LLMのLoRA/QLoRAを高速/省メモリに実行できるライブラリ</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<span class="issue_date">Issue Date: 2024-10-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1445">今日から始める大規模言語モデルのプロダクト活用, y_matsuwitter, 2024.10</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2024-10-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1443">Gemma-2-Baku, 2024.10</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2024-10-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1441">Gemma-2-JPN, 2024.10</a>
<span class="snippet"><span>Comment</span>日本語データでfinetuningされてGemma2</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/LLM-as-a-Judge.html">#LLM-as-a-Judge</a>
<span class="issue_date">Issue Date: 2024-09-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1431">Evaluating the Effectiveness of LLM-Evaluators （aka LLM-as-Judge）, 2024.09</a>
<span class="snippet"><span>Comment</span>LLM-as-a-judgeについて網羅的に書かれた記事</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-09-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1430">RAGの実装戦略まとめ, Jin Watanabe, 2024.03</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<span class="issue_date">Issue Date: 2024-09-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1428">NotebookLM, Google</a>
<span class="snippet"><span>Comment</span>ソーステキストをアップロードし、それらを参照可能なLLMの元作業が可能で、クエリによって引用つきのRAGのようなものが行えるらしい。2人の対話形式のpodcastも自動生成可能で、UI/UXの面で画期的らしい？</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-09-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1426">Molmo, AI2, 2024.09</a>
<span class="snippet"><span>Summary</span>Molmoは、オープンデータを活用した最先端のマルチモーダルAIモデルであり、特に小型モデルが大規模モデルを上回る性能を示す。Molmoは、物理的および仮想的な世界とのインタラクションを可能にし、音声ベースの説明を用いた新しい画像キャプションデータセットを導入。ファインチューニング用の多様なデータセットを使用し、非言語的手がかりを活用して質問に答える能力を持つ。Molmoファミリーのモデルは、オープンウェイトでプロプライエタリシステムに対抗する性能を発揮し、今後すべてのモデルウェイトやデータを公開予定。</span>
<span class="snippet"><span>Comment</span>以下がベンチマーク結果（VLMのベンチマーク）。11 benchmarksと書かれているのは、VLMのベンチマークである点に注意。

<br>



<br>



<br>



<br>

<img width="981" alt="image" src="https://github.com/user-attachments/assets/510204e5-4cfb-4ba3-a6db-fff717a637bc">

<br>



<br>

<img width="940" alt="image" src="https://github.com/user-attachments/assets/a4a77006-fcde-4c33-b6df-54dc5d8cbdfa">

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-09-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1422">Llama 3.2: Revolutionizing edge AI and vision with open, customizable models, Meta, 2024.09</a>
<span class="snippet"><span>Comment</span>11Bと90BのVLMと、エッジデバイス向けの1B, 3BのSLMを発表。

<br>

<img src="https://github.com/user-attachments/assets/13c4af37-19bd-4de7-b501-eb48f955af0c" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/d6b75b15-88cb-4d9e-9838-0da24308ccda" alt="image" loading="lazy">

<br>

<img src="https://github.com/user-attachments/assets/7475b30d-4619-4117-a911-d308291f86cb" alt="image" loading="lazy">Llama3.2のVLMでは、事前学習されたimage encoderを事前学習された言語モデルに対して組み合わせるためのAdapterを複数学習することによって実現。

<br>



<br>

具体的には、Llama 3.1（text only model）に対して、image encoderとAdapterを追加し、大規模でノイジーな（image,text）ペアで事前学習。続いて、中規模のサイズの高品質なin-domain（i.e. 様々なドメインの）の知識を高めるような（image,text）ペアで学習した。

<br>



<br>

事後学習では、Llama3.1と同様にSFT, Rejection Sampling, DPOのラウンドを複数回繰り返した。Llama3.1を用いて、in-domainの画像に対するQAをData Augmentationし、フィルタリングすることで合成データを作成。さらに報酬モデルを活用して全ての回答候補をランクづけして高品質なSFTデータを取得。また、モデルの安全性が高まるようなデータも追加した。

<br>



<br>

Llama3.1の事後学習のプロセスについては 1359 も参照のこと。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<span class="issue_date">Issue Date: 2024-09-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1419">LLMの効率化・高速化を支えるアルゴリズム, Tatsuya Urabe, 2024.09</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2024-09-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1418">LLM-jp-3 1.8B・3.7B・13B の公開, LLM.jp, 2024.09</a>
<span class="snippet"><span>Comment</span>LLM-JP-Evalでの評価結果はこちら:https://huggingface.co/llm-jp/llm-jp-3-1.8b1.8Bのモデルが、モデルサイズに対して非常に性能が良いとのこと（確かに、3.8Bのモデルとの差があまりないように見える

<br>

元ポスト:https://x.com/odashi_t/status/1838814594514718878?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QアーキテクチャはLlama2とのことなので、vLLMでも動作させられる模様</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2024-09-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1417">LLM-jp Corpus v3, LLM.jp, 2024.09</a>
<span class="snippet"><span>Comment</span>LLM-jp-3 1418 の学習に利用されているコーパス</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2024-09-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1414">Improving Language Understanding by Generative Pre-Training, OpenAI, 2018.06</a>
<span class="snippet"><span>Summary</span>自然言語理解のタスクにおいて、ラベルなしテキストコーパスを用いた生成的事前学習と識別的微調整を行うことで、モデルの性能を向上させるアプローチを提案。タスクに応じた入力変換を利用し、モデルアーキテクチャの変更を最小限に抑えつつ、12のタスク中9つで最先端の成果を大幅に改善。特に、常識推論で8.9%、質問応答で5.7%、テキストの含意で1.5%の改善を達成。</span>
<span class="snippet"><span>Comment</span>初代GPT論文</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<a class="button" href="articles/Test-Time%20Scaling.html">#Test-Time Scaling</a>
<span class="issue_date">Issue Date: 2024-09-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1390">OpenAI o1, 2024.09</a>
<span class="snippet"><span>Comment</span>Jason Wei氏のポスト:

<br>

https://x.com/_jasonwei/status/1834278706522849788?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q1072 や　1147 で似たような考えはすでに提案されていたが、どのような点が異なるのだろうか？

<br>



<br>



<br>



<br>

たとえば前者は、pauseトークンと呼ばれるoutputとは関係ないトークンを生成することで、outputを生成する前にモデル内部で推論する前により多くのベクトル操作を加える（=ベクトルを縦方向と横方向に混ぜ合わせる; 以後ベクトルをこねくりまわすと呼称する）、といった挙動を実現しているようだが、明示的にCoTの教師データを使ってSFTなどをしているわけではなさそうに見える（ざっくりとしか読んでないが）。

<br>



<br>

一方、Jason Wei氏のポストからは、RLで明示的により良いCoTができるように学習をしている点が違うように見える。学習の計算量だけでなく、inferenceの計算量に対しても、新たなスケーリング則が見出されている模様。

<br>



<br>

<img src="https://github.com/user-attachments/assets/85a39908-7db8-4f97-9b5d-4bfdc8439577" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

テクニカルレポート中で言われている time spent thinking （test-time compute）というのは、具体的には何なのだろうか。

<br>



<br>



<br>



<br>

上の研究でいうところの、inference時のpauseトークンの生成のようなものだろうか。モデルがベクトルをこねくり回す回数（あるいは生成するトークン数）が増えると性能も良くなるのか？

<br>



<br>

しかしそれはオリジナルのCoT研究である 551 のdotのみの文字列をpromptに追加して性能が向上しなかった、という知見と反する。

<br>



<br>



<br>



<br>

おそらく、モデル学習のデコーディング時に、ベクトルをこねくり回す回数（あるいは生成するトークン数）を増やすこと＝time spent thinking (test-time compute) 、ということなのだろうか？

<br>



<br>

そしてそのように学習されたモデルは、推論時にベクトルをこねくり回す回数（あるいは生成するトークン数）を増やすと性能が上がる、ということなのだろうか。

<br>



<br>

もしそうだとすると、これは 1072 のpauseトークンの生成をしながらfinetuningすると性能が向上する、という主張とも合致するように思うが、うーん。

<br>



<br>



<br>



<br>

実際暗号解読のexampleを見ると、とてつもなく長いCoT（トークンの生成数が多い）が行われている。RLでReasoningを学習させる関連研究: 1391 1392以下o1の動きに関して考えている下記noteからの引用。

<br>



<br>



<br>



<br>

&gt;これによって、LLMはモデルサイズやデータ量をスケールさせる時代から推論時間をスケールさせる（つまり、沢山の推論ステップを探索する）時代に移っていきそうです。

<br>



<br>



<br>



<br>

なるほど。test-compute timeとは、推論ステップ数とその探索に要する時間という見方もあるのですね。

<br>



<br>



<br>



<br>

またnote中では、CoTの性能向上のために、Process Reward Model（PRM）を学習させ、LLMが生成した推論ステップを評価できるようにし、PRMを報酬モデルとし強化学習したモデルがo1なのではないか、と推測している。

<br>



<br>

PRMを提案した研究では、推論ステップごとに0,1の正誤ラベルが付与されたデータから学習しているとのこと。

<br>



<br>

なるほど、勉強になります。

<br>



<br>



<br>



<br>

note: https://note.com/hatti8/n/nf4f3ce63d4bc?sub_rt=share_pbnote（詳細編）:https://note.com/hatti8/n/n867c36ffda45?sub_rt=share_pbこちらのリポジトリに関連論文やXポスト、公式ブログなどがまとめられている: https://github.com/hijkzzz/Awesome-LLM-Strawberry

<br>



<br>

これはすごい。論文全部読みたい</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/Post.html">#Post</a>
<span class="issue_date">Issue Date: 2024-09-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1384">A few prompt engineering tips that Ilya Sutskever picked up at OpenAI, Ilya Sutskever, 2024.09</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2024-09-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1379">ml-engineering</a>
<span class="snippet"><span>Comment</span>LLMやVLMを学習するためのツールやノウハウがまとめられたリポジトリ</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/SelfCorrection.html">#SelfCorrection</a>
<a class="button" href="articles/PostTraining.html">#PostTraining</a>
<span class="issue_date">Issue Date: 2024-09-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1376">Reflection 70B, GlaiveAI, 2024.09</a>
<span class="snippet"><span>Comment</span>ただまあ仮に同じInputを利用していたとして、promptingは同じ（モデルがどのようなテキストを生成し推論を実施するかはpromptingのスコープではない）なので、そもそも同じInputなのでfair comparisonですよ、という話に仮になるのだとしたら、そもそもどういう設定で比較実験すべきか?というのは検討した方が良い気はする。まあどこに焦点を置くか次第だと思うけど。

<br>



<br>

エンドユーザから見たら、reflectionのpromptingのやり方なんてわからないよ！という人もいると思うので、それを内部で自発的に実施するように学習して明示的にpromptingしなくても、高い性能を達成できるのであれば意味があると思う。

<br>



<br>

ただまあ少なくとも、参考でも良いから、他のモデルでもreflectionをするようなpromptingをした性能での比較結果も載せる方が親切かな、とは思う。あと、70Bでこれほどの性能が出ているのはこれまでにないと思うので、コンタミネーションについてはディフェンスが必要に思う（他のモデルがそのようなディフェンスをしているかは知らないが）。

<br>



<br>

追記

<br>

→ 下記記事によると、LLM Decontaminatorを用いてコンタミネーションを防いでいるとのこと

<br>

https://github.com/lm-sys/llm-decontaminatorReflection自体の有用性は以前から示されている。

<br>

参考: 1377, 1105, 1248, 1378ollamaで実際に動かして日本語でのQAを試している記事。実際のアウトプットやreflectionの内容が確認でき、おもしろい。

<br>



<br>

システムプロンプトで&lt; thinking &gt;タグでInputに対して推論し、&lt; output &gt;タグ内で最終出力を行い、推論過程で誤りがある場合は&lt; reflection &gt;タグを用いて修正するように指示している。

<br>



<br>

おそらく、thinkingタグ内の思考過程でモデルが誤りに気づいた場合は、thinkingタグの途中でreflectionタグが出力され、その時点でCoTが修正されるようである（もしくはoutputとthinkingの中間）。このため、誤ったCoTに基づいてOutputが生成される頻度が減少すると考えられる。

<br>



<br>

このような挙動はおそらく、reflection用の学習データでSFTしないとできないと思うので

<br>



<br>

（たとえば、ReflectionタスクをするようなデータでSFTをしていない場合、出力の途中で誤りを検出し出力を修正するという挙動にはならず、回答として自然な文を最後までoutputすると思う。その後でreflectionしろと促すことはpromptingでできるかもしれないが、そもそもreflectionする能力があまり高くない可能性があり、うまく修正もしてくれないかも）

<br>



<br>

reflectionの能力を高めるようなデータでSFTをしていないモデルで似たようなpromptingをしても、うまくいかない可能性があるので注意が必要だと思われる。

<br>



<br>

参考: https://note.com/schroneko/n/nae86e5d487f1開発者曰く、HFに記載の正しいシステムプロンプトを入れないと、適切に動作しないとのこと。

<br>

元ツイート: https://x.com/mattshumer_/status/1832061508294971731?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qどうやら初期にアップロードされていたHFのモデルはweightに誤りがあり、挙動がおかしくなっていたようだ。

<br>

正しいモデルの挙動は下記ツイートのようである。thinking内でreflectionが実施されている。

<br>



<br>

実際にいくつかの例をブログをリリース当日に見た時に、reflectionタグがoutputの後に出力されている例などがあり、おや？という挙動をしていたので、問題が是正されたようだ。

<br>

https://x.com/mattshumer_/status/1832581211841052694?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QHFのモデルが修正された後もベンチマークの結果が再現されないなど、雲行きが色々と怪しいので注意した方が良い。続報

<br>

https://x.com/artificialanlys/status/1832965630472995220?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q開発者ポスト:https://x.com/csahil28/status/1833619624589725762?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q再現実験を全て終了し、当初報告していた結果が再現されなかったとCEOが声明：https://x.com/mattshumer_/status/1842313328166907995</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Embeddings.html">#Embeddings</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RepresentationLearning.html">#RepresentationLearning</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2024-09-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1375">Ruri: Japanese General Text Embeddings, cl-nagoya, 2024.09</a>
<span class="snippet"><span>Comment</span>元ツイート:https://x.com/hpp_ricecake/status/1831308092459643232?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q337Mパラメータのモデルで、同等のサイズのモデルをJMTEBで大きく上回る性能。LLMを用いて生成したデータを用いてContrastive Learning, その後高品質なデータでFinetuningを実施したとのこと。JMTEB上では、パラメータサイズ不明（だがおそらく桁違いに大きい）のOpenAI/text-embedding-3-largeと同等の性能に見えるが、1373 などを考慮すると、日本特有の知識を問うQAなどはマルチリンガルなモデルは弱そうなので、その辺がどれほど高い性能を持っているのかは興味がある。

<br>



<br>

LLMで人工的に生成したデータでは、生成に利用したLLMが持つ知識しか表層的には現れないと思うので何を利用したかによるのと、高品質なラベルデータにその辺がどの程度含まれているか。最大sequence長は1012なので、より長い系列をBERTで埋め込みたい場合はRetrievaBERT  1323 （最大sequence長2048）も検討の余地がある。開発者の方からテクニカルレポートが出た

<br>

https://arxiv.org/abs/2409.07737</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Analysis.html">#Analysis</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2024-09-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1373">LLMに日本語テキストを学習させる意義, Koshiro Saito+, 第261回自然言語処理研究発表会, 2024.08</a>
<span class="snippet"><span>Comment</span>英日翻訳や日本特有の知識を問われるようなQAにおいて、日本語データによる学習の効果があることが示唆されている模様。

<br>

たとえば、1359 に示されている通り、Llama2における日本語データの割合は0.2%とかなので、英語圏のOpenLLMにおいて、日本語データの比率がどれだけ少ないかがわかる。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<span class="issue_date">Issue Date: 2024-09-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1370">大規模言語モデル （LLM） の技術と最新動向, Ikuya Yamada, 2024.06</a>
<span class="snippet"><span>Comment</span>LLMの原理の基礎的な内容について、丁寧かつコンパクトにまとまっている。

<br>



<br>



<br>



<br>

&gt;ファインチューニングは新しい知識の学習ではなく知識の使い方を学習させるのに向いている

<br>



<br>



<br>



<br>

これをきちんと念頭に置いておかないと落とし穴にハマると思う。引用元の論文読みたい(1371)。画像は資料中より引用。LLMの作り方について非常にシンプルにまとまっている。

<br>



<br>

<img src="https://github.com/user-attachments/assets/069c42f9-3750-4d8b-b510-8bad9dee6c8a" alt="image" loading="lazy">

<br>



<br>

アライメントがなぜ必要か？の例もわかりやすい！

<br>



<br>

<img src="https://github.com/user-attachments/assets/4405849d-18a6-484c-827d-43d7e5843c5e" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/LLMServing.html">#LLMServing</a>
<span class="issue_date">Issue Date: 2024-08-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1368">NanoFlow, 2024.08</a>
<span class="snippet"><span>Comment</span>vLLMよりも2倍程度高速なLLM serving framework。

<br>



<br>

オフライン評価

<br>

<img src="https://github.com/user-attachments/assets/93d8362d-e0e4-4bdb-9de4-178e1eef2e33" alt="image" loading="lazy">

<br>



<br>

オンラインでのlatency評価

<br>

<img src="https://github.com/user-attachments/assets/506ebf39-9c47-4d11-9352-c26f6b0d155c" alt="image" loading="lazy">

<br>



<br>

機能はvLLMの方が多いが、速度はこちらの方がかなり速そうではある。latencyのrequirementが厳しい場合などは検討しても良いかもしれない。

<br>



<br>

しかしLLM serving frameworkも群雄割拠ですね。元ポスト:https://x.com/rohanpaul_ai/status/1829647702998606104?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q1343 も参照のこと</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2024-08-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1366">Firecrawl, 2024.09</a>
<span class="snippet"><span>Comment</span>sitemapなしでWebサイト全体をクローリングできるAPI。LLMで利用可能なマークダウンや、構造化データに変換もしてくれる模様。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<span class="issue_date">Issue Date: 2024-08-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1359">論文紹介 _ The Llama 3 Herd of Models, 2024.08</a>
<span class="snippet"><span>Comment</span>Llama3の事前学習や事後学習のノウハウが詰まっており（安全性なども含む）、LLM学習に必要な要素が図解されており、非常に分かりやすい。

<br>



<br>



<br>



<br>

たとえば下記図（スライド中より引用）などは、LLMの学習過程を説明する際にわかりやすそう

<br>



<br>

<img src="https://github.com/user-attachments/assets/501ae2ae-cfc6-46ab-9701-c860b9a52dc3" alt="image" loading="lazy">

<br>



<br>

LLMの事前・事後学習あたりは独自ノウハウが多すぎてもはや追従困難</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2024-08-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1356">Liger-Kernel, 2024.08</a>
<span class="snippet"><span>Comment</span>LLMを学習する時に、ワンライン追加するだけで、マルチGPUトレーニングのスループットを20%改善し、メモリ使用量を60%削減するらしい

<br>



<br>

元ツイート:https://x.com/hsu_byron/status/1827072737673982056?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qこれだけでいい

<br>

<img src="https://github.com/user-attachments/assets/abce24ed-f979-43db-ac51-e850f2ae877a" alt="image" loading="lazy">Unsloth 1450 はLoRA/QLoRAが可能な一方でまだMulti-GPUはサポートしていない。一方、Liger-KernelはLoRAよりもfull-parameter tuningとMulti-GPUにフォーカスしており、目的に応じて使い分けが必要。

<br>



<br>



<br>



<br>

https://github.com/linkedin/Liger-Kernel/issues/57</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<span class="issue_date">Issue Date: 2024-08-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1355">Grok-2, X, 2024.08</a>
<span class="snippet"><span>Comment</span>chatbot arenaで5月時点のGPT4o超え。miniでもなんとllama3.1-705B超え

<br>

https://x.com/lmsysorg/status/1827041269534879784?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-08-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1348">RAG入門: 精度改善のための手法28選, 2024.08</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2024-08-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1347">PLaMo-100B, PFN, 2024.08</a>
<span class="snippet"><span>Comment</span>日本語のベンチマークでGPT4を超える性能を達成。

<br>

SFT, DPOで学習。学習データは、Publicなもの、プログラムで作成したもの、LLM自身に作成させたものを利用した。また、最終的なモデルに複数の候補があったのでモデルマージで良いところ取りをした。DPOで利用するpreferenceデータは、事後学習途中のモデルによって自動生成。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-07-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1335">Llama 3.1, 2024.07</a>
<span class="snippet"><span>Comment</span>Llama系のモデルをFP8で学習する場合のレシピ

<br>

https://x.com/thom_wolf/status/1826924774997532799?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-07-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1334">大規模言語モデルの開発, 2024</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-07-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1330">calm3-22B, 2024</a>
<span class="snippet"><span>Comment</span>&gt;LLMの日本語能力を評価するNejumi LLM リーダーボード3においては、700億パラメータのMeta-Llama-3-70B-Instructと同等の性能となっており、スクラッチ開発のオープンな日本語LLMとしてはトップクラスの性能となります（2024年7月現在）。

<br>

モデルは商用利用可能なApache License 2.0で提供されており

<br>



<br>

これはすごい</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-07-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1327">GENIAC: 172B 事前学習知見, 2024</a>
<span class="snippet"><span>Comment</span>LLMの事前学習における知見がまとまっている記事とのこと・Megatron LMで学習

<br>

　→ 3D Parallelismなどの分散学習手法によりHF Trainerより高速

<br>

　→ Data Parallelim、Tensor Parallelism、 Pipeline Parallelismを組み合わせたもの

<br>

・GPUメンテナンス、不良で学習が継続できなかった場合はcheckpointをロードして学習

<br>

・学習曲線が安定しているように見えるがSpikeは発生している。発生時はgradient normが急激に上昇する

<br>

・LlamaなどのLLMからの継続的事前学習ではなくfrom scratchから学習しているので透明性が高い

<br>

・Transformer engineを利用

<br>

・AdamWを利用

<br>

・attention dropout, hidden dropoutは0.0

<br>



<br>

&gt;この際、 通信を多く必要とする分散手法のワーカー（Tensor Parallelワーカー）はノード内に配置するようにMegatron-LMのデフォルトではなっているため、今回もそれを利用しました。このようにする理由は、ノード内の通信はNVLinkにより、ノード間通信よりも高速であるためです。また、Data Parallelの勾配平均化のための通信を考慮して、Data Parallelワーカーも可能な限りノード内に配置するMegatron-LMデフォルトの挙動を利用しました。

<br>

Pipeline Parallelismは他の並列化手法と比較して通信量が少ないP2P(Point-to-Point)通信であるため、パイプラインステージはノード間で配置するようにしました。これも、Megatron-LMデフォルトの挙動です。

<br>



<br>

勉強になる

<br>



<br>

・通常のデータ並列はoptimizer stateをworker間で複製するので遅い。Deep Speed Zero 1のように分散して保有することで高速化

<br>

・Tensor Parallelでself attention, MLPの計算を並列化できる

<br>

・LayerNormalization, Dropoutの演算もメモリ効率の観点から並列化

<br>

・学習を安定させるためにz-lossを利用

<br>

・batch skippingとは、gradient clippingを行っていてもなおspikeが生じる場合に、100 step前に戻り、spikeが生じた付近のデータを数百iteration程度スキップすること

<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2024-07-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1325">OpenDevin: Code Less, Make More, 2024</a>
<span class="snippet"><span>Comment</span>LLMによるOpenSourceなソフトウェア生成エージェントプラットフォームfull timeのスタッフを雇用しworldクラスのUXを目指すとのこと。楽しみ。

<br>

参考: https://x.com/gneubig/status/1808493521315496229?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QOpen化される前の最初のDevinのツイート

<br>



<br>

https://x.com/cognition_labs/status/1767548763134964000</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2024-07-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1324">より良いTransformerをつくる, Shun Kiyono, 2022</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<span class="issue_date">Issue Date: 2024-07-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1323">RetrievaBERTの公開, 2024</a>
<span class="snippet"><span>Comment</span>RAGへ応用する際に、長いコンテキストを扱いEmbeddingを獲得したいシーンが増えたので、最大でコンテキスト長が2048のBERTを学習し公開。Apache2.0

<br>



<br>



<br>



<br>

オリジナルのBERTと比較して、近年のLLMで有用性が示されている以下をアーキテクチャに取り入れている

<br>



<br>

・SwiGLU活性化関数 1311 

<br>



<br>

・PreNorm 1324 

<br>



<br>

・Grouped Query Attention (Multi Query Attention) 1271 </span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-07-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1322">Llama 3 Swallow</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<a class="button" href="articles/PositionalEncoding.html">#PositionalEncoding</a>
<span class="issue_date">Issue Date: 2024-05-24</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1310">RoFormer: Enhanced Transformer with Rotary Position Embedding, Jianlin Su+, N_A, Neurocomputing, 2024</a>
<span class="snippet"><span>Summary</span>位置符号化はtransformerアーキテクチャで有効であり、本論文ではRotary Position Embedding（RoPE）という新しい手法を提案している。RoPEは、回転行列を使用して絶対位置を符号化し、同時に相対位置依存性を自己注意構成に組み込む。RoPEを使用したRoFormerは、長いテキスト分類ベンチマークデータセットで他の手法を上回ることが実験で示されており、Huggingfaceに統合されている。</span>
<span class="snippet"><span>Comment</span>RoPEを提案した論文Absolute Position Embedding と Relative Position Embedding

<br>



<br>

TransformerにおけるQKVベクトルの計算方法

<br>



<br>

一般に、Transformerにおける Query (Q), Key (K), Value (V) は以下の式で定式化される：

<br>



<br>

<img width="176" alt="image" src="https://github.com/user-attachments/assets/21b0f077-64b4-4fe5-af04-bffc373eabf5">

<br>



<br>

m, nはそれぞれ位置を表す整数。Absolute Position Embeddingと、Relative Position Embeddingは、関数fの設計がそれぞれ異なっている：

<br>



<br>



<br>



<br>

Absolute Position Embedding

<br>



<br>

absolute position embeddingは、固定されたposition ベクトル、あるいはtrainableなposition ベクトル p を、入力ベクトルに対して足し合わせる：

<br>



<br>

<img width="382" alt="image" src="https://github.com/user-attachments/assets/0688c1bf-8699-48a5-9d95-06454550bbdf">

<br>



<br>



<br>



<br>

Relative Position Embedding

<br>



<br>

一方、Relative Position Embeddingは、Queryの位置に対する、Key, Valueの相対位置（つまり、mとnの差）に対して、trainableなベクトルをKey, Valueごとに用意し、そのベクトルを入力に足し合わせる、という定式化となっている：

<br>



<br>

<img width="269" alt="image" src="https://github.com/user-attachments/assets/ddb92f1a-af23-4d71-a7b9-2a7adda792e1">

<br>



<br>



<br>



<br>

RoPE

<br>



<br>

RoPEでは、入力ベクトルに対して回転行列を適用することで、回転に対して位置情報を保持させる：

<br>



<br>

<img width="705" alt="image" src="https://github.com/user-attachments/assets/fce1d06e-e346-4278-a77c-4c96795d5488">

<br>



<br>

<img width="588" alt="image" src="https://github.com/user-attachments/assets/3f28103c-6a56-4016-8f50-d45fe28cd62a">

<br>



<br>



<br>



<br>

RoPEは下記のような性質を持つ：

<br>



<br>

・long-term decay: θi = 10000−2i/d と設定することにより、相対位置が離れているトークンのベクトルとのinner productの値が小さくなる。すなわち、位置が離れているトークン間の依存関係が小さくなる。

<br>



<br>

・Linear-Attention: RoPEは回転行列であり、乗算後のベクトルのノルムを変化させない。このため、Linear Attentionの式の中に回転行列を組み込むことで、Linear Attentionと簡単に組み合わせることが可能

<br>



<br>



<br>



<br>

Absolute Position Embedding, Relative Position Embeddingでは、ベクトルに対して位置情報を加算する定式化で K, Vの計算時に位置情報を考慮していたため、Linear Attentionの計算そのものに位置情報を組み込んだ定式化とはなっていなかった。

<br>



<br>

が、RoPEでは回転行列を乗算する定式化であり、ノルムを変化させないのでLinear Attentionの定式化に組み込むことができる。このため、モデルのアーキテクチャを大きく変更しなくとも組み込める。

<br>



<br>

RoPE自体は実装にパラメータを必要としないが、モデルのその他のパラメータがRoPEに適用できるように学習されていないと適用できないであろう点には注意（事前学習時にRoPEが使われていれば話は別）。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2024-04-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1298">mergekit-evolve</a>
<span class="snippet"><span>Comment</span>1257 のように進化的アルゴリズムでモデルマージができるライブラリ

<br>

解説記事:https://note.com/npaka/n/nad2ff954ab81大きなVRAMが無くとも、大きめのSRAMがあれば動作するらしい</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2024-04-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1297">AirLLM, 2024.04</a>
<span class="snippet"><span>Comment</span>4GBのSingle GPUで、70Bモデルのinferenceを実現できるライブラリ。トークンの生成速度は検証する必要がある。transformer decoderの各layerの演算は独立しているため、GPUに全てのlayerを載せず、必要な分だけ載せてinferenceするといった操作を繰り返す模様。

<br>



<br>

元ツイート: https://x.com/rohanpaul_ai/status/1784349737899982943?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-04-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1289">LLaMA3, Apr, 2024</a>
<span class="snippet"><span>Comment</span>ライセンスによると、LLaMA3を利用したモデルはどんな場合でもLlama3をprefixとして付与しないといけないらしい

<br>



<br>

元ツイート:https://x.com/gneubig/status/1781083579273089442?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLLaMA3がChatBot ArenaでTop 5になったとのこと。また、英語においては、GPT4-1106-preview, GPT-4-turbo-2024-0409と同等の性能を達成。これはすごい…

<br>



<br>

https://x.com/lmsysorg/status/1782483699449332144?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Qnejumi-leaderboard 1055 にLLaMA3の評価結果が掲載された模様（画像は下記ツイートより引用）

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/2db1674b-80a6-4bbc-ab4b-c822e1659d6f" alt="image" loading="lazy">

<br>



<br>

https://x.com/madyagi/status/1783707796095316310?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QモデルアーキテクチャはTransformer Decoderをベースにしており、Llama2と比較して

<br>



<br>

・TokenizerのVocabサイズを128Kより効率的にテキストをエンコーディング可能に

<br>



<br>

・GQA 1271 を利用しInferenceを高速化 (Llama2の時点でGQAを使っていたが、70Bモデルだけだった)

<br>



<br>

・self-attentionが、ドキュメントを跨がないように学習context: 8192</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<span class="issue_date">Issue Date: 2024-04-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1281">Grok-1.5 Vision Preview, 2024</a>
<span class="snippet"><span>Comment</span><img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/88dd70ce-5874-4786-8e66-7484984c7a72" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/MultiLingual.html">#MultiLingual</a>
<span class="issue_date">Issue Date: 2024-04-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1280">The State of Multilingual AI, Sebastian Ruder, 2024</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-04-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1279">Mixtral-8x22B-v0.1, 2024</a>
<span class="snippet"><span>Comment</span>Apache-2.0ライセンス, 日本語非対応</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<a class="button" href="articles/ProprietaryLLM.html">#ProprietaryLLM</a>
<span class="issue_date">Issue Date: 2024-04-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1278">Command R+, Cohere, 2024</a>
<span class="snippet"><span>Comment</span>Chatbot arenaでGPT-4-0314と同等の Elo Rate を獲得し（20240410時点）、日本語を含む10ヶ国語をサポート。コンテキストウィンドウサイズ128k。商用利用はAPIから、研究目的であればHuggingFaceから利用可能。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/9571e233-f936-4327-af60-3c2ce57aad71" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/OpenWeight.html">#OpenWeight</a>
<span class="issue_date">Issue Date: 2024-04-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1277">Gemma: Open Models Based on Gemini Research and Technology, 2024</a>
<span class="snippet"><span>Comment</span>アーキテクチャはTransformer Decoderを利用。モデルのサイズは2Bと7B。

<br>



<br>

オリジナルのTransformer Decoderアーキテクチャから、下記改善を実施している：

<br>



<br>

・Multi Query Attention 1272 を利用

<br>



<br>

・RoPE Embedding 1310 を利用

<br>



<br>

・GeGLU 1311 の利用

<br>



<br>

・RMSNormの利用（学習を安定させるため; LLaMAと同様）

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/ef8dd419-fcce-49f5-8fd2-2acc4348d880" alt="image" loading="lazy">

<br>



<br>

Mistral 1309 よりも高い性能を示している：

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/24d6892b-ca8e-48bc-92bf-7eae71466918" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/4cf6b9c6-d517-4d9d-9cdb-526560d1a097" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2024-04-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1265">LLMの現在, 202404, Preffered Elements</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-04-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1262">Mamba Explained</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2024-03-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1260">Awesome LM with Tools</a>
<span class="snippet"><span>Comment</span>Toolを利用するLMに関するNeubig氏のグループによるSurvey。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/TextualInversion.html">#TextualInversion</a>
<span class="issue_date">Issue Date: 2024-03-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1258">repeng</a>
<span class="snippet"><span>Comment</span>LLMの出力のスタイルを数百個の事例だけで学習しチューニングできるライブラリ。promptで指定するのとは異なり、数値でスタイルの強さを指定することが可能らしい（元ツイート）。画像生成分野におけるTextual Inversionと同じ技術とのこと。

<br>



<br>

Textual Inversionとは、少量のサンプルを用いて、テキストエンコーダ部分に新たな「単語」を追加し、単語と対応する画像を用いてパラメータを更新することで、prompt中で「単語」を利用した場合に学習した画像のスタイルやオブジェクト（オリジナルの学習データに存在しなくても可）を生成できるようにする技術、らしい。

<br>



<br>

Huggiegface: https://huggingface.co/docs/diffusers/training/text_inversion

<br>

（参考）GPTに質問した際のログ: https://chat.openai.com/share/e4558c44-ce09-417f-9c77-6f3855e583fa

<br>

元ツイート: https://x.com/webbigdata/status/1770272397184389211?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-03-18</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1256">Open Release of Grok-1  March 17, 2024</a>
<span class="snippet"><span>Comment</span>Apache2.0ライセンス, 314Bパラメータでモデルの重み、Mixture-of-Expertsを採用している。学習データ、学習に利用したコードはおそらく公開されていない。Grok-1.5がリリース

<br>

https://x.ai/blog/grok-1.5

<br>



<br>

各種ベンチマークの性能、特にMathの性能が向上し、コンテキスト長が128kに

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/0e8f357f-f583-4a11-bf20-49e9886cf6e9" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-03-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1249">RAG-Research-Insights</a>
<span class="snippet"><span>Comment</span>RAGに関する研究が直近のものまでよくまとめられている</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-03-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1242">What are the most important LLMs to know about in March 2024?</a>
<span class="snippet"><span>Comment</span>2024年3月時点で知っておくべきLLMに関するスレッド</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2024-02-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1237">Mistral Large</a>
<span class="snippet"><span>Comment</span><img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/2d9066bd-05e5-4942-8d27-e5b50d129ade" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-02-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1233">awesome-generative-information-retrieval</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2024-02-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1229">RAGの性能を改善するための8つの戦略</a>
<span class="snippet"><span>Comment</span>めちゃめちゃ詳細にRAG性能向上の手法がreference付きでまとまっている。すごい。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2024-01-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1203">Decoding Strategies that You Need to Know for Response Generation</a>
<span class="snippet"><span>Comment</span>言語モデルのdecodingの方法についてよくまとまっている。まとめられているdecoding方法は以下

<br>



<br>

・Greedy, BeamSearch, RandomSampling, Temperature, Top-K Sampling, Nucleus Samplingこちらの記事ではHuggingFaceでの実装や他のdecoding方法等、より実装面での詳細が記述されている：

<br>



<br>

https://note.com/npaka/n/n9a8c85f2ef7a</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-12-20</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1192">ELYZA-tasks-100 でLLM14個の日本語性能を横断評価してみた</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/FoundationModel.html">#FoundationModel</a>
<span class="issue_date">Issue Date: 2023-12-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1191">TokyoTechLLM</a>
<span class="snippet"><span>Comment</span>Llama2の日本語性能を継続事前学習で引き上げたLLM。2023年12月時点の日本語オープンソースLLMの中で最高性能とのこと。開発者の方による詳細はこちら:

<br>

https://zenn.dev/tokyotech_lm/articles/d6cb3a8fdfc907

<br>



<br>

すごい読み応え…checkpointの容量のデカさや、A100x8 60ノード使った話や、ノード不良やスケジュール管理の話、独自に実装をゴリゴリ加えたものではなく最終的に完成度の高さからMegatronLMを採用した話など、バグった規模感と試行錯誤や実体験に基づくエピソード満載。参考:

<br>

1192</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-12-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1188">optimize-llm, HuggingFace</a>
<span class="snippet"><span>Comment</span>LLMをoptimizeする実用的なチュートリアルこちらも有用なので参照のこと

<br>



<br>



<br>



<br>

【GPU inference】

<br>



<br>

https://huggingface.co/docs/transformers/main/perf_infer_gpu_one

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Attention.html">#Attention</a>
<span class="issue_date">Issue Date: 2023-12-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1187">【続】Flash Attentionを使ってLLMの推論を高速・軽量化できるか？</a>
<span class="snippet"><span>Comment</span>use_cacheがTrue/Falseの場合のFlashAttention2のinference timeとVRAM使用量の傾向をsequence_lengthごとに考察している。

<br>



<br>

use_cacheはKey Value cacheのオンオフを切り替えられるオプションである。autoregressiveなモデルのinference時には、何度も同じinput tokenに対するKVの計算が生じるため（M番目のトークンを生成した後、M+1番目のトークンの生成をする場合、M-1番目までのトークンのKVを再計算せねばならない）、cacheをすることで大幅に計算速度が改善される。

<br>



<br>

use_cacheをTrueにできるならFlashAttention2の恩恵は小さい（inference timeが少し早くなるのみ）ため、潤沢なVRAMがあるなら得られる恩恵は小さい。

<br>

逆にVRAM節約してuse_cacheをFalseにせざるを得ないのであれば、FlashAttention2によりVRAM使用量をsequence_legthの線形に抑えることができ、かつinference timeも短くなる。

<br>



<br>

↑上記はあくまでinferenceをする場合のみの話であり（train時はautoregressive modelではcausal maskを用い、teacher forcingで並列にトークンを生成するためそもそもKV-cacheする意味がない）、trainingをする場合FlashAttention2で大幅にVRAM使用量を減らせるので、そこは分けて考えること。

<br>

https://qiita.com/jovyan/items/ff3d0a49163c7afa33ceFlash Attentionを使ってLLMの推論を高速・軽量化できるか？

<br>

https://qiita.com/jovyan/items/11deb9d4601e4705a60d

<br>



<br>

こちらの記事も非常に勉強になる</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-12-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1184">大規模モデルを支える分散並列学習のしくみ Part1</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/InstructionTuning.html">#InstructionTuning</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<a class="button" href="articles/Japanese.html">#Japanese</a>
<span class="issue_date">Issue Date: 2023-12-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1183">A Review of Public Japanese Training Sets, shisa, 2023.12</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-12-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1178">もし明日、上司に「GPT-4を作れ」と言われたら？ Stability AIのシニアリサーチサイエンティストが紹介する「LLM構築タイムアタック」</a>
<span class="snippet"><span>Comment</span>StabilityAI Japan秋葉さん（元PFN）のW&amp;B Conferenceでの発表に関する記事。

<br>

LLM構築タイムアタックでLLMをもし構築することになったら！？

<br>

のざっくりとしたプロセスや、次ページでOpenAIのGPT4のテクニカルレポートのクレジットから各チームの規模感を推定して、どの部分にどの程度の人員が割かれていたのかというのをベースに、各パートでどんなことがやられていそうかという話がされている。

<br>



<br>

LLM構築タイムアタックで、まずGPUを用意します！（ここが一番大変かも）の時点で、あっ察し（白目　という感じがして面白かった。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-12-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1173">kaggle LLM コンペ 上位解法を自分なりにまとめてみた話</a>
<span class="snippet"><span>Comment</span>実践的な内容（チャンク生成時の工夫、クエリ生成時の工夫等）が網羅的にまとまっており非常に有用個人的に、コンペ主催者側から提供されたデータが少なく、上位のほとんどのチームがChatGPT（3.5, 4）を用いて、QAデータを生成していた、というのが興味深かった。プロンプトはたとえば下記:

<br>



<br>

[（5th-place-solution）](https://www.kaggle.com/competitions/kaggle-llm-science-exam/discussion/446293)より引用

<br>



<br>

```

<br>



<br>

system_content = """

<br>



<br>

Forget all the previous instruction and rigorously follow the rule specified by the user.

<br>



<br>

You are a professional scientist's assistant.

<br>



<br>

"""

<br>



<br>



<br>



<br>

user_content_template_qa = Template(

<br>



<br>

    """

<br>



<br>

Please consider 5 choices question and answer of the following TEXT.

<br>



<br>

The purpose of this question is to check respondent's deep science understanding of the TEXT.

<br>



<br>

We assume this question is for professional scientists, so consider super difficult question.

<br>



<br>

You can ask very detailed question, for example check specific sentence's understanding.

<br>



<br>

It is good practice to randomly choose specific sentence from given TEXT, and make QA based on this specific sentence.

<br>



<br>

You must make QA based on the fact written in the TEXT.

<br>



<br>

You may create wrong answers based on the correct answer's information, by modifying some parts of the correct answer.

<br>



<br>

Your response must be in following format, don't write any other information. 

<br>



<br>

You must not include "new line" in each Q), 1), 2), 3), 4), 5), and A):

<br>



<br>

Q) `question text comes here`

<br>



<br>

1) `answer candidate 1`

<br>



<br>

2) `answer candidate 2`

<br>



<br>

3) `answer candidate 3`

<br>



<br>

4) `answer candidate 4`

<br>



<br>

5) `answer candidate 5`

<br>



<br>

A) `answer`

<br>



<br>



<br>



<br>

where only 1 `answer candidate` is the correct answer and other 4 choices must be wrong answer.

<br>



<br>

Note1: I want to make the question very difficult, so please make wrong answer to be not trivial incorrect.

<br>



<br>

Note2: The answer candidates should be long sentences around 30 words, not the single word.

<br>



<br>

Note3: `answer` must be 1, 2, 3, 4 or 5. `answer` must not contain any other words.

<br>



<br>

Note4: Example of the question are "What is ...", "Which of the following statements ...", "What did `the person` do",

<br>



<br>

and "What was ...".

<br>



<br>

Note5: Question should be science, technology, engineering and mathematics related topic. 

<br>



<br>

If the given TEXT is completely difference from science, then just output "skip" instead of QA.

<br>



<br>



<br>



<br>



<br>



<br>

Here is an example of your response, please consider this kind of difficulty when you create Q&amp;A:

<br>



<br>

Q) Which of the following statements accurately describes the impact of Modified Newtonian Dynamics (MOND) on the observed "missing baryonic mass" discrepancy in galaxy clusters?"

<br>



<br>

1) MOND is a theory that reduces the observed missing baryonic mass in galaxy clusters by postulating the existence of a new form of matter called "fuzzy dark matter."

<br>



<br>

2) MOND is a theory that increases the discrepancy between the observed missing baryonic mass in galaxy clusters and the measured velocity dispersions from a factor of around 10 to a factor of about 20.

<br>



<br>

3) MOND is a theory that explains the missing baryonic mass in galaxy clusters that was previously considered dark matter by demonstrating that the mass is in the form of neutrinos and axions.

<br>



<br>

4) MOND is a theory that reduces the discrepancy between the observed missing baryonic mass in galaxy clusters and the measured velocity dispersions from a factor of around 10 to a factor of about 2.

<br>



<br>

5) MOND is a theory that eliminates the observed missing baryonic mass in galaxy clusters by imposing a new mathematical formulation of gravity that does not require the existence of dark matter.

<br>



<br>

A) 4

<br>



<br>



<br>



<br>

Let's start. Here is TEXT: $title\n$text

<br>



<br>

"""

<br>



<br>

)

<br>



<br>

```</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2023-11-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1150">GPT4All, 2023</a>
<span class="snippet"><span>Comment</span>ローカルマシンでChatGPT likeなUIでチャットボットを動作させられるOpensource。

<br>

Mistral7BやGGUFフォーマットのモデルのよつな（おそらく量子化されたものも含む）ローカルマシンで動作させられる規模感のモデルがサポートされている。

<br>

https://gpt4all.io/index.html</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-11-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1149">Zephyr-7B-beta, RAG Perf.</a>
<span class="snippet"><span>Comment</span>Zephyr-7B-betaのRAGでの性能がデータセットで評価されている下記Xポストによるとgpt-3.5-turboと同等

<br>



<br>

https://x.com/rungalileo/status/1726638537767051436?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-11-16</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1139">JGLUEの構築そして 日本語LLM評価のこれから, 2023</a>
<span class="snippet"><span>Comment</span>JGLUEのexample付きの詳細、構築の経緯のみならず、最近の英語・日本語LLMの代表的な評価データ（方法）がまとまっている（AlpacaEval, MTBenchなど）。また、LLMにおける自動評価の課題（図は資料より引用）が興味深く、LLM評価で生じるバイアスについても記述されている。Name biasなどはなるほどと思った。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/46e3f4af-dbe1-45cf-b1e4-85e8b547ef03" alt="image" loading="lazy">

<br>



<br>

日本語LLMの今後の評価に向けて、特にGPT4による評価を避け、きちんとアノテーションしたデータを用意しfinetuningした分類器を用いるという視点、参考にしたい。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/f88943b1-856e-4ca7-a256-5581cda333fb" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2023-11-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1134">LLaMA-Factory, 2023</a>
<span class="snippet"><span>Comment</span>簡単に利用できるLLaMAのfinetuning frameworkとのこと。

<br>

元ツイート: https://x.com/_akhaliq/status/1724456693378040195?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-QLLaMAベースなモデルなら色々対応している模様</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<a class="button" href="articles/Factuality.html">#Factuality</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2023-11-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1130">Hallucination Leaderboard, 2023</a>
<span class="snippet"><span>Comment</span>1000個の短いドキュメントに対して、事実情報のみを用いて要約を生成させ、要約結果と原文書のFactual consistencyを別に訓練したモデルで測定して評価してリーダーボードを作成している。Claude2よりLLaMA2の方が性能が良いのが面白いし、Palmの性能があまり良くない。元ツイート: https://x.com/ashversex/status/1724240030170808392?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<span class="issue_date">Issue Date: 2023-11-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1118">Retrieval-based LM （RAG System）ざっくり理解する, 2023</a>
<span class="snippet"><span>Comment</span>（以下スクショはスライドより引用）

<br>



<br>



<br>



<br>

次のスクショはRAGにかかわる周辺技術がよくまとまっていると思う。

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/35f9f589-770c-435b-8d1b-81e615e86597" alt="image" loading="lazy">

<br>



<br>



<br>



<br>

以下ざっくり私の中の認識として

<br>



<br>

・計画

<br>



<br>

    ・クエリ拡張

<br>



<br>

        ・クエリの質が悪い場合検索性能が劣化するため、クエリをより適切に検索ができるように修正（昔はキーワードしか与えられないときに情報を増やすから”拡張”という文言が用いられているが現在はこれに限らないと思う）する技術

<br>



<br>

    ・分解・抽象化

<br>



<br>

        ・複雑なクエリから分解することでマルチホップの質問をサブ質問に分解（今ならLLMを利用すれば比較的簡単にできる）したり、あるいは抽象化したクエリ（Step-back Promptnig 1076 ）を活用することで検索を改善する技術

<br>



<br>

    ・検索対象選定

<br>



<br>

        ・検索する対象そのものを選択し、検索対象をフィルタリングする技術

<br>



<br>

        ・資料中ではLLMを用いたフィルタリングやClassifierを用いたフィルタリングが紹介されているが、メタデータで絞り込むなどの単純な方法でも実現可能だと思われる（メタデータで絞り込む、はClassifierでのフィルタリングとリンクするかもしれないが）

<br>



<br>

    ・思考・行動

<br>



<br>

        ・518 のような自律的にLLMに思考とその結果に基づく行動をイテレーションさせる技術や、クエリを分解して回答へたどり着くために必要な推論を構築し、各推論の回答を検証しながら生成を繰り返す技術が紹介されている

<br>



<br>

        ・この辺の技術はクエリが非常に複雑な場合に有効ではあるが、シンプルな場合は必要ないかなという印象がある

<br>



<br>

        ・シンプルなユースケースの場合はどちらかというと泥臭い前処理とかが効きそう

<br>



<br>

・関連知識取得

<br>



<br>

    ・検索

<br>



<br>

        ・表層検索（TF-IDFベクトル, BM25）などの古典的な手法や、意味検索（Embeddingに基づく手法）が紹介されている

<br>



<br>

        ・例えばlangchainでは表層検索 + 意味検索の両者がサポートされており、簡単にハイブリッドな検索が実現できる

<br>



<br>

    ・知識文生成

<br>



<br>

        ・外部知識として検索された文書を利用するだけでなく、LLM自身が保持する知識を活用するためにLLMが生成した文書の両方を活用するとQAの正答率が向上することが紹介されている

<br>



<br>

    ・文書フィルタ

<br>



<br>

        ・検索でクエリに関連しない文書を取得してしまう応答品質が大幅に低下することが紹介されている

<br>



<br>

            ・個人的にはここが一番重要なパートだと考えている

<br>



<br>

        ・また、検索結果を要約する方法も紹介されている

<br>



<br>

    ・再帰・反復計算

<br>



<br>

        ・Retrierverから取得した結果に基づいてLLMが応答を生成し、生成した応答とoriginalのquestionの両方を組み合わせて追加でRetrieverから文書を取得し生成する手法などが紹介されている

<br>



<br>

    ・ リランキング

<br>



<br>

        ・検索結果のリランキングも古くから存在する技術であり、異なる知識を持つRankerによってリランキングさせることで性能が向上する場合がある

<br>



<br>

・回答

<br>



<br>

    ・回答抽出・生成

<br>



<br>

        ・回答となる部分のspanを抽出する手法と、spanではなくテキストを生成する手法が紹介されている

<br>



<br>

        ・この辺は文書要約におけるExtractive/Abstractive Summarization技術などもかなり応用が効くと思われる

<br>



<br>

・インデクシング

<br>



<br>

    ・不要文書のフィルタリングや、チャンク分割の戦略、資格情報をテキスト化する方法などが紹介されている

<br>



<br>



<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/5ad62f76-e1b9-4c78-847a-45387fe5fb3e" alt="image" loading="lazy">

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/634e5386-6ae4-4602-a214-cc8dc126daad" alt="image" loading="lazy">

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Alignment.html">#Alignment</a>
<a class="button" href="articles/GenerativeAI.html">#GenerativeAI</a>
<a class="button" href="articles/Hallucination.html">#Hallucination</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-11-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1115">生成AIが抱えるリスクと対策, LYCorp‘23</a>
<span class="snippet"><span>Comment</span>この資料をスタートにReferしている論文などを勉強すると、GenerativeAIのリスク周りに詳しくなれそう。この辺は疎いので勉強になる。

<br>

しかし、LLMのAlignmentが不十分だったり、Hallucinationを100%防ぐことは原理的に不可能だと思われるので、この辺とどう付き合っていくかがLLMと付き合っていく上で難しいところ。この辺は自分たちが活用したいユースケースに応じて柔軟に対応しなければならず、この辺の細かいカスタマイズをする地道な作業はずっと残り続けるのではないかなあ</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ImageCaptioning.html">#ImageCaptioning</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<span class="issue_date">Issue Date: 2023-11-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1114">Zero-shot Learning網羅的サーベイ: CLIPが切り開いたVision &amp; Languageの新しい世界</a>
<span class="snippet"><span>Comment</span>これはすごいまとめ…。まだ途中までしか読めていない。CLIPからスタートしてCLIPを引用している論文から重要なものを概要付きでまとめている。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-11-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1112">IBIS2023チュートリアル「大規模言語モデル活用技術の最前線」</a>
<span class="snippet"><span>Comment</span>LLMの応用研究やPromptingを中心としたチュートリアル。アノテーションや対話式推薦システムへの活用、ReAct、プロンプトの最適化技術、CoTの基本から応用まで幅広くまとまっているので、LLMの応用技術の概観や、CoTを実践したい人に非常に有用だと思う。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/FoundationModel.html">#FoundationModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-11-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1111">tsuzumi, NTT’23</a>
<span class="snippet"><span>Comment</span>NTT製のLLM。パラメータ数は7Bと軽量だが高性能。

<br>

MTBenchのようなGPT4に勝敗を判定させるベンチマークで、地理、歴史、政治、社会に関する質問応答タスク（図6）でgpt3.5turboと同等、国産LLMの中でトップの性能。GPT3.5turboには、コーディングや数学などの能力では劣るとのこと。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/d064e0dc-b598-4853-9466-f56f39986acc" alt="image" loading="lazy">

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/c8251b2e-f865-4069-a3b7-9bfb848554bb" alt="image" loading="lazy">

<br>

&gt; ＊6 Rakudaベンチマーク

<br>

日本語の言語モデルの性能を評価するベンチマークの一つで、日本の地理・政治・歴史・社会に関する質問応答タスクによって評価を行う。

<br>

URL：https://yuzuai.jp/benchmark

<br>



<br>

&gt;＊7 Japanese Vicuna QAベンチマーク

<br>

Rakudaよりもさらに幅広いカテゴリで言語モデルのQAや指示遂行の能力を問う評価方法。一般知識、ロールプレイなど多数の質問から構成される。

<br>

URL：https://github.com/hitoshizuku7/LLM_Judge_ku/blob/main/README.mdtsuzumiはアダプタを追加することで、モデル全体のパラメータを更新することなく、さまざまな知識を持たせたり、振る舞いを変えたりできるようになるとのこと（LoRAアダプタのようなものだと思われる）。

<br>

まて、将来的に視覚や聴覚などのマルチモーダル対応も実施。思想がLoRA Hub 917 に近く、アダプタを着脱すれば柔軟に生成を変えられるのは有用だと思う。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<a class="button" href="articles/Catastrophic%20Forgetting.html">#Catastrophic Forgetting</a>
<span class="issue_date">Issue Date: 2023-10-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1109">大規模言語モデルのFine-tuningによるドメイン知識獲得の検討</a>
<span class="snippet"><span>Comment</span>以下記事中で興味深かった部分を引用

<br>

&gt; まとめると、LoRAは、[3]で言われている、事前学習モデルは大量のパラメータ数にもかかわらず低い固有次元を持ち、Fine-tuningに有効な低次元のパラメータ化も存在する、という主張にインスパイアされ、ΔWにおける重みの更新の固有次元も低いという仮説のもとで、低ランク行列で学習する手法になります。

<br>



<br>

LoRAが拠り所とする仮説が説明されており、勉強になった。

<br>



<br>

&gt; こうしたニューラルネットワークを圧縮する他の技術には枝刈りや知識蒸留がありますが、量子化は、ほとんどの場合に枝刈りより優れているとされ[5]、蒸留よりも手軽に高精度なモデルが得られる可能性が高く、LLMにおいても有力な技術と考えられます。

<br>



<br>

これも知らなかったし、文献付きで記述されていることが大変ありがたい。

<br>



<br>

&gt; QLoRA以外のLoRAの派生手法としては、ランクを適応的に定めるAdaLoRA[7] やDyLoRA[8]、コンテキスト長を拡大できるLongLoRA[9]、行列Aの重みをfreezeすることでさらに軽量化を行うLoRA-FA、行列積をアダマール積やクロネッカー積で計算するLoHAやLoKRなどがあります（一部はLLMではなくStable Diffusionの学習で用いられる手法の通称です）。

<br>



<br>

この辺は実際にLoRAを使うことになったら勉強したい。

<br>



<br>

&gt; 言語モデルの学習は通常、Causal LMの場合は、Next Token PredictionにおけるPerplexityの最小化による教師なし学習によって最適化されます。

<br>



<br>

HuggingFaceの実装の話だと思うが、そうだろうなと思ってはいたがソースを確認できていなかったので勉強になった。

<br>



<br>

&gt; 7Bのモデルでは、以下のグラフのように、データの件数を増やすと学習がうまくいかないという結果が得られました。また、LoRAのランクは低い方が学習が安定することがわかりました。正答率が著しく低いものは、学習時のロス（交差エントロピー）が非常に大きくなっており、選択肢を間違えるというよりは言語モデルとしての機能が失われていました。

<br>



<br>

&gt; 他には、Instructionデータ（1つのクイズのQ&amp;A）が2500件を超えるとロスが悪化することや、2000件でも2epoch繰り返すとcatastrophic forgettingが見られ、言語モデルそのものの性能が失われ意味のない出力をしていました。[17] でも言及されていますが、日本語の学習では、数BのモデルにおけるLoRAによるInstruction Tuningはあまり効果が得られない可能性が高いと考えられます。

<br>



<br>

&gt; 一方、13Bのモデルでは、8、16、32、64いずれのランクでも大きな差は見られませんでした。

<br>

&gt; これらから、Addtional Trainingで学習させるデータがInstruction Tuningに対して膨大である場合には先に学習した方がよく、少数の場合は後に学習させてもInstruction Tuningの効果には悪影響がないということが示唆されました。

<br>



<br>

&gt; また学習は、初期学習率を小さくした方が安定する可能性が高いと思われます。LoRAの論文[2] ではGPTのFine-tuneは2e-4で行われており、hugging faceの実装でもデフォルトでは2e-4となっていますが、他の論文やブログでは3e-5での例などもあります。しかし、単に下げれば安定するということでもなく、１回の試行における計算コストとチューニングがトレードオフになる可能性はあります。

<br>



<br>

Additional TrainingとはFinetuningのことで便宜上の本ブログでの呼称。実際の文書中では図が複数個挟まれている。

<br>

こうした実際に手を動かした上でないと得られない知見を公開してくれるのは非常にありがたいことだし、日本語データでLoRAをする際に非常に参考になりそう。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/DiffusionModel.html">#DiffusionModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-10-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1107">StableDiffusion, LLMのGPUメモリ削減のあれこれ</a>
<span class="snippet"><span>Comment</span>Gradient Accumulation, Gradient Checkpointingの説明が丁寧でわかりやすかった。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-10-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1103">LLMのプロンプト技術まとめ</a>
<span class="snippet"><span>Comment</span>ざっと見たが現時点で主要なものはほぼ含まれているのでは、という印象

<br>

実際のプロンプト例が載っているので、理解しやすいかもしれない。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-10-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1101">Evaluating RAG Pipelines</a>
<span class="snippet"><span>Comment</span>RAG pipeline （retrieval + generation）を評価するライブラリRagasについて紹介されている。

<br>



<br>

評価に活用される指標は下記で、背後にLLMを活用しているため、大半の指標はラベルデータ不要。ただし、context_recallを測定する場合はreference answerが必要。

<br>

Ragasスコアとしてどのメトリックを利用するかは選択することができ、選択したメトリックのharmonic meanでスコアが算出される。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/553e7f91-84cd-4aac-bef3-c84bc279547e" alt="image" loading="lazy">

<br>



<br>

各種メトリックの内部的な処理は下記:

<br>

・faithfullness

<br>

  ・questionと生成された回答に基づいて、statementのリストをLLMで生成する。statementは回答が主張している内容をLLMが解釈したものだと思われる。

<br>

  ・statementのリストとcontextが与えられたときに、statementがcontextにsupportされているかをLLMで評価する。

<br>

  ・num. of supported statements / num. of statements でスコアが算出される

<br>

・Answer Relevancy

<br>

  ・LLMで生成された回答から逆に質問を生成し、生成された質問と実際の質問の類似度を測ることで評価

<br>

・Context Relevancy

<br>

  ・どれだけcontextにノイズが含まれるかを測定する。

<br>

  ・LLMでcontextの各文ごとに回答に必要な文か否かを判断する

<br>

  ・回答に必要な文数 / 全文数 でスコアを算出

<br>

・Context Recall

<br>

  ・回答に必要な情報を全てretrieverが抽出できているか

<br>

  ・ground truthとなる回答からstatementをLLMで生成し、statementがcontextでどれだけカバーされているかで算出

<br>



<br>

また、LangSmithを利用して実験を管理する方法についても記述されている。

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/3a30d238-ac48-401c-906b-4ddb5fca50be" alt="image" loading="lazy">

<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/RAG(RetrievalAugmentedGeneration).html">#RAG(RetrievalAugmentedGeneration)</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-10-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1100">LangChainのRAGの改善法, LayerX機械学習勉強会</a>
<span class="snippet"><span>Comment</span>以下リンクからの引用。LangChainから提供されているRetrieverのcontext抽出の性能改善のためのソリューション

<br>



<br>

&gt; Multi representation indexing：検索に適した文書表現（例えば要約）の作成

<br>

Query transformation：人間の質問を変換して検索を改善する方法

<br>

Query construction：人間の質問を特定のクエリ構文や言語に変換する方法

<br>



<br>

https://blog.langchain.dev/query-transformations/</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-10-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1096">日本語LLMのリーダーボード（LLM.jp）</a>
<span class="snippet"><span>Comment</span>LLM.jpによる日本語LLMのリーダーボード。4-shotsでの結果、かつinstructionを与えた場合の生成テキストに対する評価、という点には留意したい。たとえばゼロショットで活用したい、という場合にこのリーダーボードの結果がそのまま再現される保証はないと推察される。

<br>



<br>

1079 の知見でもあった通り、promptingの仕方によってもLLM間で順位が逆転する現象なども起こりうる。あくまでリーダーボードの値は参考値として留め、どのLLMを採用するかは、自分が利用するタスクやデータで検証した方がbetterだと思われる。

<br>



<br>

あとはそもそも本当にLLMを使う必要があるのか? 1024  のような手法ではダメなのか?みたいなところも考えられると良いのかもしれない。

<br>



<br>

以下サイトより引用

<br>

&gt; 評価手法・ツール

<br>

このダッシュボードの内容はllm-jpで公開している評価ツール、llm-jp-evalで各モデルに対して評価を行なった結果である。llm-jp-evalは、既存のリーダボードとは行われている評価とは、主に以下のところで違っている。

<br>

AlpacaやBig-Benchなどを参考にした、インストラクションチューニングよりのプロンプトを入力として与えて、その入力に対するモデルの生成結果を評価する

<br>

&gt;評価は基本、モデルが生成した文字列だけを使って行う

<br>

&gt;Few shotでの評価を行っており、このダッシュボードには4-shotsでの結果を載せている

<br>



<br>

&gt;評価手法・ツールの詳細はllm-jp-evalを是非参照されたい。

<br>



<br>

&gt;評価項目・データセット

<br>

評価項目として、まず4つのカテゴリーにおける平均スコアを算出した。さらにその4カテゴリーの平均値の平均値をとった値がAVGである。

<br>

MC (Multi-Choice QA)：jcommonsenseqa

<br>

NLI (Natural Language Inference)：jamp、janli、jnli、jsem、jsick

<br>

QA (Question Answering)：jemhopqa、niilc

<br>

RC (Reading Comprehension)：jsquad

<br>



<br>

&gt;それぞれのカテゴリの平均を出す方法に言語学的な意味はないため、最終的な平均値はあくまで参考値ということに注意されたい。JGlueを利用した日本語LLMのリーダーボードとして 1055 などもある</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-10-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1087">日本語大規模言語モデル「Japanese Stable LM 3B-4E1T」「Japanese Stable LM Gamma 7B」を公開しました, 2023</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-10-15</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1080">OpenSource LLM</a>
<span class="snippet"><span>Comment</span>zephyr-7B-alpha

<br>

・1/10のパラメータでLLaMA2-70Bw-chat超え

<br>

https://weel.co.jp/media/zephyr-7b-alpha・zephyr-7B-β

<br>

　・MTBenchでllama2-70B-chat超え

<br>

　・1099

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/05da8650-44d7-425a-9f4d-8edf67216433" alt="image" loading="lazy">Zephyr-7B-betaが早くもTheBlokeアニキによってGPTQで量子化され、なんとモデル自体は4.5G程度しかVRAMを消費しない…

<br>

https://huggingface.co/TheBloke/zephyr-7B-beta-GPTQ・NVIDIA Nemotron-3 8B Models

<br>



<br>

    ・https://developer.nvidia.com/nemotron-3-8b\

<br>



<br>

    ・https://huggingface.co/nvidia/nemotron-3-8b-base-4k

<br>



<br>

    ・53言語対応、37プログラミング言語対応, base / chatがある ・Mixtral8x7B: LLaMA2-70B, GPT-3.5-turboと同等の性能

<br>



<br>

    ・MistralをSparse Mixture of Expertsしたモデルの模様

<br>



<br>

    ・名前の通り8つのFFNが存在しているが、Top-2のFFNが選択されその結果が集約され出力が決定される

<br>



<br>

https://mistral.ai/news/mixtral-of-experts/

<br>



<br>



<br>



<br>

・日本語まとめ

<br>



<br>

    ・https://note.com/npaka/n/n6043bc8b01bc</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-10-10</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1073">Large Language Model （in 2023）, OpenAI</a>
<span class="snippet"><span>Comment</span>LLMの研究開発動向を俯瞰するのに有用らしい</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2023-10-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1064">MentalLLaMA, 2023</a>
<span class="snippet"><span>Comment</span>メンタルヘルスの分析に対してinstruction tuningしたはじめてのLLM</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-10-07</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1058">Yasa-1</a>
<span class="snippet"><span>Comment</span>参考: https://x.com/jaguring1/status/1709557947813281865?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-10-02</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1055">Nejumi LLMリーダーボード</a>
<span class="snippet"><span>Comment</span>JGLUEを使ったLLMの日本語タスクベンチマーク</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-09-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1053">LLM-as-a-judge</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ChatGPT.html">#ChatGPT</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<span class="issue_date">Issue Date: 2023-09-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1052">GPT-4V</a>
<span class="snippet"><span>Comment</span>おう…やべえな…

<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/3ee7dc96-af6f-47f9-98c0-c6be5d9384f1" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2023-09-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1049">Agents: An opensource framework for autonomous language agents</a>
<span class="snippet"><span>Comment</span>以下の特徴を持つLLMAgent開発のためのフレームワーク

<br>



<br>

・long-short term memory

<br>

・tool usage

<br>

・web navigation

<br>

・multi-agent communication

<br>

・human-agent interaction

<br>

・symbolic control

<br>



<br>

また、他のAgent frameworkと違い、ゴールを達成するだの細かいプランニングを策定（SOP; サブタスクとサブゴールを定義）することで、エージェントに対してきめ細かなワークフローを定義できる。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<span class="issue_date">Issue Date: 2023-09-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1042">GGML_GGUF_GPTQの違い</a>
<span class="snippet"><span>Comment</span>量子化に関する技術であるGGML, GGUF, GPTQに関する詳細なまとめ

<br>



<br>

よくわからんが筆者の言葉を引用すると

<br>



<br>

&gt;llama.cppならGGUF、TransformerならGPTQって感じ？  

<br>



<br>



<br>



<br>

ということなので、これらは量子化を行うための技術を提供するライブラリであり、GGUF/GGMLはllama.cppで利用可能で、GPTQはより汎用的に利用可能な手法だと思われる。GPTQについて論文をざっくり読んでメモった 1043 </span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-09-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1036">SNLP2023:Is GPT-3 a Good Data Annotator?</a>
<span class="snippet"><span>Comment</span>GPT3でデータを作成したら、タスクごとに有効なデータ作成方法は異なったが、人手で作成したデータと同等の性能を達成するデータ（BERTでfinetuning）を、低コストで実現できたよ、という研究この辺の話はもはや 1024 を使えばいいのでは、という気がする。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<span class="issue_date">Issue Date: 2023-09-05</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1032">LangChain Cheet Sheet</a>
<span class="snippet"><span>Comment</span><img width="1315" alt="image" src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/6621fe24-d007-4590-b1a6-b861a6dec4ad">

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-09-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1031">大規模言語モデル, 岡崎先生, 2023</a>
<span class="snippet"><span>Comment</span>岡崎先生による大規模言語モデルのチュートリアル

<br>



<br>

最近のLLMまでの歴史、transformerなどの基礎的な内容から、最新の内容まで数式付きで詳細にまとまっている</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<span class="issue_date">Issue Date: 2023-08-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1027">LLMのファインチューニング で 何ができて 何ができないのか</a>
<span class="snippet"><span>Comment</span>&gt;LLMのファインチューニングは、「形式」の学習は効果的ですが、「事実」の学習は不得意です。

<br>



<br>

&gt; シェイクスピアの脚本のデータセット (tiny-shakespeare) の

<br>

「ロミオ」を「ボブ」に置き換えてファインチューニングして、新モデルの頭の中では「ロミオ」と「ボブ」をどう記憶しているかを確認します。

<br>



<br>

ファインチューニングしても、Bで始まるジュリエットが恋する人物について質問しても、ボブと答えてはくれない。

<br>

&gt; ロミオ」は「ジュリエット」が恋していたこの男性に関連付けられており、「ロミオ」を「ボブ」に置き換えるファインチューニングでは、ニューラルネットワークの知識ベースを変更することはできませんでした。

<br>



<br>

なるほど。参考: https://www.anyscale.com/blog/fine-tuning-is-for-form-not-facts?ref=blog.langchain.devimosさんのツイートを引用

<br>

&gt; 文章が悪かったので補足。追加学習を全体に十分なデータですれば知識は獲得しえます（が事前学習の知識を忘却するリスクは高い）。巷でよくファインチューニングと呼ばれるものは、知識を司るらしいMLP部を触らず自己注意機構部のみを更新するので、そもそも知識を増やすのは難しいという認識です。

<br>



<br>

元ツイート: https://x.com/imos/status/1696507787067756846?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<span class="issue_date">Issue Date: 2023-08-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1026">Metaの「Llama 2」をベースとした商用利用可能な日本語LLM「ELYZA-japanese-Llama-2-7b」を公開しました</a>
<span class="snippet"><span>Comment</span>商用利用可能、70億パラメータ。

<br>

ELYZA社が独自に作成した評価セットでは日本語のOpenLLMの中で最高性能。ただし、モデル選定の段階でこの評価データの情報を利用しているため、有利に働いている可能性があるとのこと。

<br>



<br>

一般的に利用される日本語の評価用データでは、なんとも言い難い。良いタスクもあれば悪いタスクもある。が、多分評価用データ自体もあまり整備は進んでいないと想像されるため、一旦触ってみるのが良いのだと思う。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<span class="issue_date">Issue Date: 2023-08-28</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1025">zeno-build</a>
<span class="snippet"><span>Comment</span>MTでのテクニカルレポート

<br>

https://github.com/zeno-ml/zeno-build/tree/main/examples/analysis_gpt_mt/reportLLMの実験管理を容易に実施するツールで、異なるハイパーパラメータ、異なるモデル、異なるプロンプトでの実験などを簡単に実施できる。評価結果を自動的に可視化し、interactiveに表示するブラウザベースのアプリケーションも作成可能？</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-08-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/1021">Anti-hype LLM Reading list</a>
<span class="snippet"><span>Comment</span>LLNのサーベイ、BERT等の基盤モデルの論文、自前でLLMを学習するために必要な論文がコンパクトにまとめられたgist<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/0a5df5e6-0ed8-481b-9d5f-3f0397454371" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/STS%20(SemanticTextualSimilarity).html">#STS (SemanticTextualSimilarity)</a>
<span class="issue_date">Issue Date: 2023-07-31</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/910">OpenAI の Embeddings API はイケてるのか、定量的に調べてみる</a>
<span class="snippet"><span>Comment</span>[JSTSタスク](https://github.com/yahoojapan/JGLUE)では、[Tohoku BERT v3](https://github.com/cl-tohoku/bert-japanese/tree/mainmodel-performances) と [LUKE](https://github.com/studio-ousia/luke)が最も性能が良いらしい。

<br>



<br>

[SimCSE](https://huggingface.co/pkshatech/simcse-ja-bert-base-clcmlp)よりも性能が良いのは興味深い。

<br>



<br>

</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/FoundationModel.html">#FoundationModel</a>
<span class="issue_date">Issue Date: 2023-07-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/897">Introducing CM3leon, a more efficient, state-of-the-art generative model for text and images, 2023</a>
<span class="snippet"><span>Summary</span>最近の自然言語処理の進歩により、生成型AIモデルへの関心と研究が加速しています。CM3leonは、テキストから画像への生成と画像からテキストへの生成を行う単一の基礎モデルです。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/Faithfulness.html">#Faithfulness</a>
<span class="issue_date">Issue Date: 2023-07-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/896">Measuring Faithfulness in Chain-of-Thought Reasoning, Anthropic, 2023</a>
<span class="snippet"><span>Summary</span>大規模言語モデル（LLMs）は、Chain-of-Thought（CoT）推論を生成することで質問に答える性能を向上させるが、その推論が実際の推論を忠実に表しているかは不明である。本研究では、CoT推論の忠実さを調査し、CoTに介入することでモデルの予測がどのように変化するかを調べる。結果は、モデルのサイズやタスクによってCoTの忠実さが異なることを示唆している。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<span class="issue_date">Issue Date: 2023-07-23</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/894">trl_trlx</a>
<span class="snippet"><span>Comment</span>TRL ・強化学習によるLLMの学習のためのライブラリ

<br>

https://note.com/npaka/n/nbb974324d6e1trlを使って日本語LLMをSFTからRLHFまで一通り学習させてみる

<br>

https://www.ai-shift.co.jp/techblog/3583</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Quantization.html">#Quantization</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/886">LLaMA2を3行で訓練</a>
<span class="snippet"><span>Comment</span>LLaMA2を3行で、1つのA100GPU、QLoRAで、自前のデータセットで訓練する方法</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/880">Quantized LLaMA2</a>
<span class="snippet"><span>Comment</span>LLaMA2をローカルで動作させるために、QLoRAで量子化したモデル</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/879">LLongMA2</a>
<span class="snippet"><span>Comment</span>LLaMA2のcontext windowを8kにして訓練。オリジナルのLLaMA2と同等の性能で8k contextを利用可能。元ツイート: https://twitter.com/enricoshippole/status/1682054848584228866?s=46&t=LJIgfuO352oK3zU2FKFpNA</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/DialogueGeneration.html">#DialogueGeneration</a>
<span class="issue_date">Issue Date: 2023-07-22</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/876">ChatBot Arenaのデータセット</a>
<span class="snippet"><span>Comment</span>33kのconversation、2つのレスポンスに対する人間のpreferenceスコア付き

<br>

20種類のSoTAモデルのレスポンスを含み、13kのユニークIPからのアクセスがあり、3Kのエキスパートによるアノテーション付き</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Explanation.html">#Explanation</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<span class="issue_date">Issue Date: 2023-07-14</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/825">Are Human Explanations Always Helpful? Towards Objective Evaluation of Human Natural Language Explanations</a>
<span class="snippet"><span>Summary</span>本研究では、説明可能なNLPモデルのトレーニングにおいて、人間による注釈付けの説明の品質を評価する方法について検討しています。従来のSimulatabilityスコアに代わる新しいメトリックを提案し、5つのデータセットと2つのモデルアーキテクチャで評価しました。結果として、提案したメトリックがより客観的な評価を可能にする一方、Simulatabilityは不十分であることが示されました。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2023-07-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/796">Auto train advanced</a>
<span class="snippet"><span>Comment</span>Hugging Face Hub上の任意のLLMに対して、localのカスタムトレーニングデータを使ってfinetuningがワンラインでできる。

<br>

peftも使える。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/ComputerVision.html">#ComputerVision</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/MulltiModal.html">#MulltiModal</a>
<a class="button" href="articles/SpeechProcessing.html">#SpeechProcessing</a>
<span class="issue_date">Issue Date: 2023-07-03</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/784">Awesome Multimodal LLMs</a>
<span class="snippet"><span>Comment</span>マルチモーダルなLLMのリストがまとめられている</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<span class="issue_date">Issue Date: 2023-07-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/777">How Long Can Open-Source LLMs Truly Promise on Context Length?, 2023</a>
<span class="snippet"><span>Comment</span>LLMのcontext長を伸ばす際の方法と得られた知見がまとめられている</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/FoundationModel.html">#FoundationModel</a>
<span class="issue_date">Issue Date: 2023-06-26</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/771">LM Flow</a>
<span class="snippet"><span>Comment</span>一般的なFoundation Modelのファインチューニングと推論を簡素化する拡張可能なツールキット。継続的なpretragning, instruction tuning, parameter efficientなファインチューニング,alignment tuning,大規模モデルの推論などさまざまな機能をサポート。

<br>



<br>

https://twitter.com/dair_ai/status/1672953412927799298?s=46&t=ajzDWio8pEbrezgj40Dobw</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-06-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/767">OpenLLaMA 13B, 2023</a>
<span class="snippet"><span>Comment</span><img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/4268eb3f-349f-4ebe-adeb-2cbfcb7cfe17" alt="image" loading="lazy">そもそもOpenLLaMAには、オリジナルのLLaMAと比較して、tokenizerがスペースを無視するというissueがある模様。スペースの情報がクリティカルなタスク、たとえばcode generationなどには要注意。

<br>



<br>

https://github.com/openlm-research/open_llama/issues/40</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Prompting.html">#Prompting</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-05-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/678">Prompt Engineering vs. Blind Prompting, 2023</a>
<span class="snippet"><span>Comment</span>experimentalな手法でprompt engineeringする際のoverview</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-05-12</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/676">open LLM Leaderboard</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/PsychologicalScience.html">#PsychologicalScience</a>
<span class="issue_date">Issue Date: 2023-05-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/673">Can AI language models replace human participants?, Trends in Cognitive Sciences, 2023</a>
<span class="snippet"><span>Summary</span>最近の研究では、言語モデルが人間のような判断を行うことが示されています。この研究では、言語モデルが心理学の研究において人間の代わりになる可能性や条件について探求し、AIを参加者として使用する際の注意点をまとめています。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/FoundationModel.html">#FoundationModel</a>
<a class="button" href="articles/Repository.html">#Repository</a>
<span class="issue_date">Issue Date: 2023-05-08</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/665">OpenSource PaLM, 2023</a>
<span class="snippet"><span>Comment</span>150m,410m,1bのモデルがある。Googleの540bには遠く及ばないし、emergent abilityも期待できないパラメータ数だが、どの程度の性能なのだろうか。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NaturalLanguageGeneration.html">#NaturalLanguageGeneration</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/FoundationModel.html">#FoundationModel</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Programming.html">#Programming</a>
<span class="issue_date">Issue Date: 2023-05-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/661">StarCoderBase_StarCoder, 2023</a>
<span class="snippet"><span>Comment</span>・15.5Bパラメータ

<br>

・80種類以上のプログラミング言語で訓練

<br>

・Multi Query Attentionを利用

<br>

・context window size 8192

<br>

・Fill in the middle objectiveを利用

<br>



<br>

Instruction tuningがされておらず、prefixとsuffixの間を埋めるような訓練のされ方をしているので、たとえば関数名をinputして、そのmiddle（関数の中身）を出力させる、といった使い方になる模様。paper: https://drive.google.com/file/d/1cN-b9GnWtHzQRoE7M7gAEyivY0kl4BYs/viewStarCoder:

<br>

https://huggingface.co/bigcode/starcoderStarCoderBaseを35Bのpython tokenでfinetuningしたモデル。

<br>

既存モデルよりも高性能と主張

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/236622130-5e7aa6aa-5f9b-4b0e-9962-ff1beaa03225.jpeg" alt="image" loading="lazy"></span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-05-06</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/659">MPT-7B, 2023</a>
<span class="snippet"><span>Comment</span>新たなオープンソースLLM。

<br>

下記ツイートより引用:

<br>



<br>

・商用利用可能

<br>

・6万5000トークン使用可能

<br>

・7Bと比較的小さいモデルながら高性能

<br>

・日本語を扱え性能が高い

<br>



<br>

とのこと。

<br>



<br>

https://twitter.com/imai_eruel/status/1654629078878793729?s=46&t=nqpG5xvXzdg7yUPU4IfD3AChatGPTのLLMと比較すると、ざっと例を見た感じ質問応答としての能力はそこまで高くなさそうな印象。

<br>

finetuningしない限りはGPT3,GPT4で良さげ。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Pretraining.html">#Pretraining</a>
<a class="button" href="articles/Pocket.html">#Pocket</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<a class="button" href="articles/ReinforcementLearning.html">#ReinforcementLearning</a>
<a class="button" href="articles/Chain-of-Thought.html">#Chain-of-Thought</a>
<a class="button" href="articles/Evaluation.html">#Evaluation</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<a class="button" href="articles/Reasoning.html">#Reasoning</a>
<span class="issue_date">Issue Date: 2023-05-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/626">Towards Complex Reasoning: the Polaris of Large Language Models, Yao Fu, 2023.05</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Assessment.html">#Assessment</a>
<span class="issue_date">Issue Date: 2023-05-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/623">ChatBot Arena, lmsys org, 2023.05</a>
<span class="snippet"><span>Comment</span>クラウドソーシング型のチャットボット評価するシステム。ユーザはシステムにアクセスすると、二つのanonymisedされたLLMと対話し、どちらが優れていたかをvotingする。すべてのシステムとユーザのinteractionはロギングされており、最終的にElo RatingでLLM.をランキング付けする。Arena-Hardと呼ばれるliveアリーナデータを用いたパイプラインを公開。MT-Benchよりも識別力が高く、Chatbot Arenaのランキングとのagreementが高いとのこと。

<br>



<br>

参考:https://x.com/lmsysorg/status/1782179997622649330?s=46&t=Y6UuIHB0Lv0IpmFAjlc2-Q

<br>



<br>

<img src="https://github.com/AkihikoWatanabe/paper_notes/assets/12249301/2faafce4-effd-40b1-8760-d9639d3df6aa" alt="image" loading="lazy">過去のデータについては 876 などもある</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<span class="issue_date">Issue Date: 2023-05-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/618">OpenLLaMA</a>
<span class="snippet"><span>Comment</span>LLaMAと同様の手法を似たデータセットに適用し商用利用可能なLLaMAを構築した模様</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-05-04</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/616">LLM ecosystem graphs</a>
<span class="snippet"><span>Comment</span>様々なfonudation model、それらを利用したアプリケーション、依存関係がまとまったページPercy Liangのグループが運用してるっぽい？</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Assessment.html">#Assessment</a>
<span class="issue_date">Issue Date: 2023-04-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/603">PandaLM</a>
<span class="snippet"><span>Comment</span>異なるLLMを再現性のある形で評価するためのライブラリ

<br>

2つの異なるLLMのoutputを比較し、どちらが優れているか理由付きで説明する。人間が作成して1000サンプルの多様なアノテーションデータセットを使い評価できる。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/ChatGPT.html">#ChatGPT</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2023-04-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/562">HuggingChat, 2023</a>
<span class="snippet"><span>Comment</span>closedな世界で開発されるOpenAIのChatGPTに対して、Openなものが必要ということで、huggingfaceが出してきた例のアレです</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/LongSequence.html">#LongSequence</a>
<span class="issue_date">Issue Date: 2023-04-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/560">Unleashing Infinite-Length Input Capacity for Large-scale Language Models with Self-Controlled Memory System, 2023</a>
<span class="snippet"><span>Comment</span>&gt; Our findings indicate that our system outperforms ChatGPT in handling ultra-long inputs or conversations.

<br>



<br>



<br>



<br>

と書いてあるが、定量評価の結果が全く書いていない模様。全くもって信用できない。読む必要なし。4/27時点だと記述されていなかったと思うが、現時点では定量評価が追加されている模様？</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2023-04-27</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/557">大規模言語モデル間の性能比較まとめ</a>
<span class="snippet"><span>Comment</span>参考になる現状だと研究用であればllama, 商用利用ならtext-davinci-003あるいはFlanT5-xxlあたりになりそうLLM Worksheet：

<br>



<br>

https://docs.google.com/spreadsheets/d/1kT4or6b0Fedd-W_jMwYpb63e1ZR3aePczz3zlbJW-Y4/editgid=0</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/EfficiencyImprovement.html">#EfficiencyImprovement</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<span class="issue_date">Issue Date: 2023-04-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/528">LoRA論文解説, Hayato Tsukagoshi, 2023.04</a>
<span class="snippet"><span>Comment</span>ベースとなる事前学習モデルの一部の線形層の隣に、低ランク行列A,Bを導入し、A,Bのパラメータのみをfinetuningの対象とすることで、チューニングするパラメータ数を激減させた上で同等の予測性能を達成し、推論速度も変わらないようにするfinetuning手法の解説LoRAを使うと、でかすぎるモデルだと、そもそもGPUに載らない問題や、ファインチューニング後のモデルファイルでかすぎワロタ問題が回避できる。

<br>



<br>

前者は事前学習済みモデルのBPのための勾配を保存しておく必要がなくなるため学習時にメモリ節約になる。後者はA,Bのパラメータだけ保存すればいいので、ストレージの節約になる。

<br>



<br>

かつ、学習速度が25%程度早くなる。既存研究であるAdapter（transformerの中に学習可能なMLPを差し込む手法）は推論コストが増加し、prefix tuningは学習が非常に難しく、高い性能を達成するためにprefixとして128 token入れたりしなければならない。huggingfaceがすでにLoRAを実装している

<br>

https://github.com/huggingface/peft</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/InformationRetrieval.html">#InformationRetrieval</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/LLMAgent.html">#LLMAgent</a>
<span class="issue_date">Issue Date: 2023-04-21</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/520">LangChain</a>
<span class="snippet"><span>Comment</span>・LangChain の Googleカスタム検索 連携を試す

<br>



<br>

  ・https://note.com/npaka/n/nd9a4a26a8932・LangChainのGetting StartedをGoogle Colaboratoryでやってみる ④Agents

<br>



<br>

    ・https://zenn.dev/kun432/scraps/8216511783e3da</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Education.html">#Education</a>
<a class="button" href="articles/AES(AutomatedEssayScoring).html">#AES(AutomatedEssayScoring)</a>
<span class="issue_date">Issue Date: 2023-04-01</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/515">Exploring the Potential of Using an AI Language Model for Automated Essay Scoring, Mizumoto+, Research Methods in Applied Linguistics‘23</a>
<span class="snippet"><span>Comment</span>著者によるポスト: https://twitter.com/mizumotoatsushi/status/1641754298496471040?s=46&t=TIr1-wDC_j5MPU3TvCVWMg著者によるブログ:

<br>



<br>

https://mizumot.com/lablog/archives/1805</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Supervised-FineTuning%20(SFT).html">#Supervised-FineTuning (SFT)</a>
<span class="issue_date">Issue Date: 2023-03-30</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/514">Publicly available instruction-tuned models</a>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Library.html">#Library</a>
<span class="issue_date">Issue Date: 2023-03-11</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/510">20B params chatgpt alternative</a>
<span class="snippet"><span>Comment</span>元ツイート

<br>

Apache2.0で公開

<br>



<br>

https://twitter.com/_philschmid/status/1634492396171071488?s=46&t=VvPwEQsB--BeXx0YbYQdxQ</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/TimeSeriesDataProcessing.html">#TimeSeriesDataProcessing</a>
<a class="button" href="articles/MachineLearning.html">#MachineLearning</a>
<a class="button" href="articles/Transformer.html">#Transformer</a>
<span class="issue_date">Issue Date: 2022-12-29</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/504">Are Transformers Effective for Time Series Forecasting?</a>
<span class="snippet"><span>Comment</span>Linear Layerに基づくシンプルな手法がTransformerベースの手法に時系列予測で勝ったという話</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/PEFT(Adaptor/LoRA).html">#PEFT(Adaptor/LoRA)</a>
<span class="issue_date">Issue Date: 2022-08-19</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/473">The Power of Scale for Parameter-Efficient Prompt Tuning, Lester+, Google Research, EMNLP‘21</a>
<span class="snippet"><span>Comment</span>日本語解説: https://qiita.com/kts_plea/items/79ffbef685d362a7b6ce

<br>



<br>

T5のような大規模言語モデルに対してfinetuningをかける際に、大規模言語モデルのパラメータは凍結し、promptをembeddingするパラメータを独立して学習する手法

<br>



<br>

言語モデルのパラメータ数が増加するにつれ、言語モデルそのものをfinetuningした場合（Model Tuning）と同等の性能を示した。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<span class="issue_date">Issue Date: 2021-09-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/404">GPT-3から我々は何を学べば良いのか, 山本, Japio year book 2020</a>
<span class="snippet"><span>Comment</span>GPT-3の概要:

<br>



<br>

GPT-3はWebサイトから数年に渡って収集したCommon Crawlというデータセットから、570GBを抜粋し学習に利用。（英語ウィキペディアの約130倍）

<br>

ある単語列に後続する単語を予測するという方法（自己回帰型言語モデル）で教師なし学習を繰り返し、言語モデルを学習。GPT-3の特徴:

<br>

・モデルが巨大（1750億パラメータ, GPT-2は15億）

<br>

　・扱うトークン数が2048トークン（GPT-2の倍）

<br>

　・Word Embeddingの次元数12288（GPT2の倍

<br>

　・デコード層が98層（GPT2の倍

<br>

・基本的なモデル構造はTransformerと一緒

<br>



<br>

GPT-3の問題点:

<br>

・コーパス中の言語出力を模倣しているだけで、何ら理解をしておらず、常識も持ち合わせていない

<br>

　・e.g. 私の足に目はいくつある？と入力すると、2つと出力する等

<br>

　・整理された知識を獲得しているわけではない

<br>

・偏見や差別、誤った知識も学習する

<br>

・時間的、経済的負荷の大きさ

<br>

　・GPT-3を最大規模で計算するには5億円かかる

<br>

　・1台のGPUで355年必要な計算量

<br>

　→ 個人や小規模業者が実行できる範囲を超えており、大企業でもコストに見合った出力が得られるとは考えにくいGPT-3の産業応用

<br>

・GPT-3は言語モデルであり、言語生成器ではない

<br>

　・人間が書いて欲しいことをおおまかに伝えたらそれを書いてくれるわけではない（代筆）

<br>

　→ GPT-3が小論文や業務レポートを書けると考えるのは早計

<br>

　・入力として英文や英単語を入力するが、生成する文章の分野や話題を提示しただけであり、生成する文章にそれ以上の制御は行っていない

<br>



<br>

・生成内容を強く制御できないことは創作活動にとっては有用

<br>

　・俳句、短歌、詩の生成

<br>

　・キャッチコピーの自動生成

<br>

　・ダミー文章生成（ブログやツイート）

<br>

　・文章添削、校正に使える可能性（要研究;文章を正しく、綺麗に書く能力は高い）GPT-3でどこまでできそうなのか？というざっくりとした肌感が掴めたから良かった</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/RecommenderSystems.html">#RecommenderSystems</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/CIKM.html">#CIKM</a>
<a class="button" href="articles/SequentialRecommendation.html">#SequentialRecommendation</a>
<span class="issue_date">Issue Date: 2021-05-25</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/347">BERT4Rec: Sequential Recommendation with Bidirectional Encoder Representations from Transformer, Sun+, CIKM2019</a>
<span class="snippet"><span>Comment</span>BERTをrecsysのsequential recommendationタスクに転用してSoTA。

<br>

しっかり読んで無いけどモデル構造はほぼBERTと一緒。

<br>

異なる点は、Training時にNext Sentence Predictionは行わずClozeのみ行なっているという点。Clozeとは、実質Masked Language Modelであり、sequenceの一部を[mask]に置き換え、置き換えられたアイテムを左右のコンテキストから予測するタスク。異なる点としては、sequential recommendationタスクでは、次のアイテムを予測したいので、マスクするアイテムの中に、sequenceの最後のアイテムをマスクして予測する事例も混ぜた点。

<br>



<br>

もう一個異なる点として、BERT4Recはend-to-endなモデルで、BERTはpretraining modelだ、みたいなこと言ってるけど、まあ確かに形式的にはそういう違いはあるけど、なんかその違いを主張するのは違和感を覚える…。

<br>

sequential recommendationで使うuser behaviorデータでNext item predictionで学習したいことが、MLMと単に一致していただけ、なのでは…。BERT4Recのモデル構造。next item predictionしたいsessionの末尾に [mask] をconcatし、[MASK]部分のアイテムを予測する構造っぽい？

<br>



<br>

<img src="https://user-images.githubusercontent.com/12249301/138901870-d36fc935-8b61-4434-9d4b-dc1cb968c91e.png" alt="image" loading="lazy">

<br>



<br>

オリジナルはtensorflow実装

<br>



<br>

pytorchの実装はこちら：https://github.com/jaywonchung/BERT4Rec-VAE-Pytorch/tree/master/models</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Tools.html">#Tools</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Dataset.html">#Dataset</a>
<a class="button" href="articles/Library.html">#Library</a>
<a class="button" href="articles/Blog.html">#Blog</a>
<span class="issue_date">Issue Date: 2020-03-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/334">BERT 日本語Pre-trained Model, NICT, 2020</a>
<span class="snippet"><span>Comment</span>NICTが公開。既に公開されているBERTモデルとのベンチマークデータでの性能比較も行なっており、その他の公開済みBERTモデルをoutperformしている。</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/Tutorial.html">#Tutorial</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<span class="issue_date">Issue Date: 2020-01-13</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/332">BERT入門, Ken'ichi Matsui, 2020</a>
<span class="snippet"><span>Comment</span>自然言語処理の王様「BERT」の論文を徹底解説

<br>



<br>

https://qiita.com/omiita/items/72998858efc19a368e50Transformer関連 245 あたりを先に読んでからが読むと良い

<br>



<br>



<br>



<br>

要は

<br>



<br>

・Transformerをたくさん積んだモデル

<br>



<br>

・NSPとMLMで双方向性を持った事前学習タスクを実施することで性能向上

<br>



<br>

・pooler layer（Transformer Encoderの次にくっつくlayer）を切り替えることで、様々なタスクにfine-tuning可能（i.e. pooler layerは転移学習の対象外）

<br>



<br>

・予測する際は、[CLS]トークンに対応する位置の出力を用いて分類問題や複数文間の関係性を問う問題を解いたり、各トークン位置に対応する出力を用いてQAの正解spanを予測したり、色々できる

<br>



<br>

・gMLP 344 あたりの研究が進んでくると使われなくなってくる可能性有こっちの記事もわかりやすい。

<br>



<br>



<br>



<br>

BERTについて勉強したことまとめ (2)モデル構造について

<br>



<br>

https://engineering.mobalab.net/2020/06/12/bert%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E5%8B%89%E5%BC%B7%E3%81%97%E3%81%9F%E3%81%93%E3%81%A8%E3%81%BE%E3%81%A8%E3%82%81-2%E3%83%A2%E3%83%87%E3%83%AB%E6%A7%8B%E9%80%A0%E3%81%AB%E3%81%A4%E3%81%84/</span>
<a class="button" href="articles/Article.html">#Article</a>
<a class="button" href="articles/NeuralNetwork.html">#NeuralNetwork</a>
<a class="button" href="articles/Survey.html">#Survey</a>
<a class="button" href="articles/NLP.html">#NLP</a>
<a class="button" href="articles/Slide.html">#Slide</a>
<a class="button" href="articles/Admin'sPick.html">#Admin'sPick</a>
<span class="issue_date">Issue Date: 2019-11-09</span>
<a href="https://github.com/AkihikoWatanabe/paper_notes/issues/329">事前学習言語モデルの動向 _ Survey of Pretrained Language Models, Kyosuke Nishida, 2019</a>
<span class="snippet"><span>Comment</span>[2019/06まで]

<br>



<br>

・ELMo（双方向2層LSTM言語モデル）

<br>



<br>

・GPT（left-to-rightの12層Transformer自己回帰言語モデル）

<br>



<br>

・BERT（24層のTransformer双方向言語モデル）

<br>



<br>

・MT-DNN（BERTの上にマルチタスク層を追加した研究）

<br>



<br>

・XLM（パラレル翻訳コーパスを用いてクロスリンガルに穴埋めを学習）

<br>



<br>

・TransformerXL（系列長いに制限のあった既存モデルにセグメントレベルの再帰を導入し長い系列を扱えるように）

<br>



<br>

・GPT-2（48層Transformerの自己回帰言語モデル）

<br>



<br>

・ERNIE 1.0（Baidu, エンティティとフレーズの外部知識を使ってマスクに利用）

<br>



<br>

・ERNIE（Tsinghua, 知識グラフの情報をfusionしたLM）

<br>



<br>

・Glover（ドメイン、日付、著者などを条件とした生成を可能としたGPT）

<br>



<br>

・MASS（Encoder-Decoder型の生成モデルのための事前学習）

<br>



<br>

・UniLM（Sequence-to-Sequenceを可能にした言語モデル）

<br>



<br>

・XLNet（自己回帰（単方向）モデルと双方向モデルの両方の利点を得ることを目指す）

<br>



<br>



<br>



<br>

[2019/07~]

<br>



<br>

・SpanBERT（i.i.dではなく範囲でマスクし、同時に範囲の境界も予測する）

<br>



<br>

・ERNIE 2.0（Baidu, マルチタスク事前学習; 単語レベル・構造レベル・意味レベル）

<br>



<br>

・RoBERTa（BERTと同じ構造で工夫を加えることで性能向上）

<br>



<br>

　・より大きなバッチサイズを使う（256から8192）

<br>



<br>

　・より多くのデータを使う（16GBから160GB）

<br>



<br>

　・より長いステップ数の学習をする（BERT換算で16倍）

<br>



<br>

　・次文予測（NSP）は不要

<br>



<br>

　→ GLUEでBERT, XLNetをoutperform

<br>



<br>

・StructBERT (ALICE, NSPに代わる学習の目的関数を工夫)

<br>



<br>

　・マスクした上で単語の順番をシャッフルし元に戻す

<br>



<br>

　・ランダム・正順・逆順の3種類を分類

<br>



<br>

　→ BERTと同サイズ、同データでBERT, RoBERTa超え

<br>



<br>

・DistilBERT（蒸留により、12層BERTを6層に小型化（40%減））

<br>



<br>

　・BERTの出力を教師として、生徒が同じ出力を出すように学習

<br>



<br>

　・幅（隠れ層）サイズを減らすと、層数を経あｒスよりも悪化

<br>



<br>

　→ 推論は60%高速化、精度は95%程度を保持

<br>



<br>

・Q8BERT（精度を落とさずにfine-tuning時にBERTを8bit整数に量子化）

<br>



<br>

　・Embedding, FCは8bit化、softmax, LNorm, GELUは32bitをキープ

<br>



<br>

　→ モデルサイズ1/4, 速度3.7倍

<br>



<br>

・CTRL（条件付き言語モデル）

<br>



<br>

　・条件となる制御テキストを本文の前に与えて学習

<br>



<br>

　・48層/1280次元Transformer（パラメータ数1.6B）

<br>



<br>

・MegatronLM（72層、隠れ状態サイズ3072、長さ1024; BERTの24倍サイズ）

<br>



<br>

・ALBERT（BERTの層のパラメータをすべて共有することで学習を高速化; 2020年あたりのデファクト）

<br>



<br>

　・Largeを超えたモデルは学習が難しいため、表現は落ちるが学習しやすくした

<br>



<br>

　・単語埋め込みを低次元にすることでパラメータ数削減

<br>



<br>

　・次文予測を、文の順序入れ替え判定に変更

<br>



<br>

　→ GLUE, RACE, SQuADでSoTAを更新

<br>



<br>

・T5（NLPタスクをすべてtext-to-textとして扱い、Enc-Dec Transformerを745GBコーパスで事前学習して転移する）

<br>



<br>

　・モデルはEncoder-DecoderのTransformer

<br>



<br>

　・学習タスクをエンコーダ・デコーダに合わせて変更

<br>



<br>

　・エンコーダ側で範囲を欠落させて、デコーダ側で予測

<br>



<br>

　→ GLUE, SuperGLUE, SQuAD1.1, CNN/DMでSoTA更新

<br>



<br>

・BART（Seq2Seqの事前学習として、トークンマスク・削除、範囲マスク、文の入れ替え、文書の回転の複数タスクで学習）

<br>



<br>

　→ CNN/DMでT5超え、WMT'16 RO-ENで逆翻訳を超えてSoTAELMo, GPT, BERT, GPT-2, XLNet, RoBERTa, DistilBERT, ALBERT, T5あたりは良く見るような感各データセットでの各モデルの性能も後半に記載されており興味深い。

<br>



<br>



<br>



<br>

ちなみに、CNN/DailyMail Datasetでは、T5, BARTあたりがSoTA。

<br>



<br>

R2で比較すると

<br>



<br>

　・Pointer-Generator + Coverage Vectorが17,28

<br>



<br>

　・LEAD-3が17.62

<br>



<br>

　・BARTが21.28

<br>



<br>

　・T5が21.55

<br>



<br>

となっている</span>
<button onclick="hideContent(0)" style="display: none;">hide</button>
&lt;/div&gt;
</bos></span></think></span>
</div>


    </div>

</article>
<div class="post-nav">
<a class="previous" href="/paper_notes/articles/LabelBias.html" title="LabelBiasに関する論文・技術記事メモの一覧">LabelBiasに関する論文・技術記事メモの一覧</a><a class="next" href="/paper_notes/articles/LatentReasoning.html" title="LatentReasoningに関する論文・技術記事メモの一覧">LatentReasoningに関する論文・技術記事メモの一覧</a>
</div>
<div class="post-related">
      <div>Related Articles</div>
      <ul>
        <li class="">
          <a class="post-link" href="/paper_notes/articles/Unsupervised.html" title="Unsupervisedに関する論文・技術記事メモの一覧">
            Unsupervisedに関する論文・技術記事メモの一覧<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li>
<li class="">
          <a class="post-link" href="/paper_notes/articles/SoftwareEngineering.html" title="SoftwareEngineeringに関する論文・技術記事メモの一覧">
            SoftwareEngineeringに関する論文・技術記事メモの一覧<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li>
<li class="">
          <a class="post-link" href="/paper_notes/articles/python.html" title="pythonに関する論文・技術記事メモの一覧">
            pythonに関する論文・技術記事メモの一覧<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li>
<li class="">
          <a class="post-link" href="/paper_notes/articles/DataDriven.html" title="DataDrivenに関する論文・技術記事メモの一覧">
            DataDrivenに関する論文・技術記事メモの一覧<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li>
</ul>
    </div>
<div class="post-comments"></div></section>
</div>


  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">TOC</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/paper_notes/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
<div>Copyright © 2023-current AkihikoWATANABE. The header images and any thumbnail images for the posts were generated by ChatGPT's DALL-E3.</div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="https://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/paper_notes/feed.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
